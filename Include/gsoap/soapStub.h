/* soapStub.h
   Generated by gSOAP 2.8.30 for WSVidyoUser.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#define SOAP_NAMESPACE_OF_ns1	"http://portal.vidyo.com/user/v1_1"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20830
# error "GSOAP VERSION 20830 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumeration Types                                                          *
 *                                                                            *
\******************************************************************************/


/* WSVidyoUser.h:768 */
#ifndef SOAP_TYPE_ns1__sortDir
#define SOAP_TYPE_ns1__sortDir (205)
/* ns1:sortDir */
enum ns1__sortDir {
	ns1__sortDir__ASC = 0,
	ns1__sortDir__DESC = 1
};
#endif

/* WSVidyoUser.h:802 */
#ifndef SOAP_TYPE_ns1__AccessOptionName
#define SOAP_TYPE_ns1__AccessOptionName (209)
/* ns1:AccessOptionName */
enum ns1__AccessOptionName {
	ns1__AccessOptionName__roomURL = 0,
	ns1__AccessOptionName__extension = 1,
	ns1__AccessOptionName__PIN = 2,
	ns1__AccessOptionName__dial_in_Number = 3
};
#endif

/* WSVidyoUser.h:835 */
#ifndef SOAP_TYPE__ns1__ClientType
#define SOAP_TYPE__ns1__ClientType (210)
/* ns1:ClientType */
enum _ns1__ClientType {
	_ns1__ClientType__W = 'W',
	_ns1__ClientType__M = 'M',
	_ns1__ClientType__V = 'V',
	_ns1__ClientType__R = 'R',
	_ns1__ClientType__L = 'L',
	_ns1__ClientType__S = 'S',
	_ns1__ClientType__U = 'U',
	_ns1__ClientType__T = 'T',
	_ns1__ClientType__X = 'X',
	_ns1__ClientType__I = 'I',
	_ns1__ClientType__A = 'A',
	_ns1__ClientType__P = 'P',
	_ns1__ClientType__N = 'N',
	_ns1__ClientType__O = 'O',
	_ns1__ClientType__Q = 'Q',
	_ns1__ClientType__Y = 'Y',
	_ns1__ClientType__Z = 'Z',
	_ns1__ClientType__B = 'B',
	_ns1__ClientType__C = 'C',
	_ns1__ClientType__D = 'D'
};
#endif

/* WSVidyoUser.h:865 */
#ifndef SOAP_TYPE__ns1__OK
#define SOAP_TYPE__ns1__OK (211)
/* ns1:OK */
enum _ns1__OK {
	_ns1__OK__OK = 0
};
#endif

/* WSVidyoUser.h:876 */
#ifndef SOAP_TYPE__ns1__Language
#define SOAP_TYPE__ns1__Language (212)
/* ns1:Language */
enum _ns1__Language {
	_ns1__Language__en = 0,
	_ns1__Language__de = 1,
	_ns1__Language__es = 2,
	_ns1__Language__fr = 3,
	_ns1__Language__it = 4,
	_ns1__Language__ja = 5,
	_ns1__Language__ko = 6,
	_ns1__Language__pt = 7,
	_ns1__Language__zh_USCORECN = 8,
	_ns1__Language__fi = 9,
	_ns1__Language__pl = 10,
	_ns1__Language__zh_USCORETW = 11,
	_ns1__Language__th = 12,
	_ns1__Language__ru = 13,
	_ns1__Language__tr = 14
};
#endif

/* WSVidyoUser.h:910 */
#ifndef SOAP_TYPE__ns1__EntityType
#define SOAP_TYPE__ns1__EntityType (213)
/* ns1:EntityType */
enum _ns1__EntityType {
	_ns1__EntityType__Member = 0,
	_ns1__EntityType__Room = 1,
	_ns1__EntityType__Legacy = 2
};
#endif

/* WSVidyoUser.h:924 */
#ifndef SOAP_TYPE__ns1__MemberMode
#define SOAP_TYPE__ns1__MemberMode (214)
/* ns1:MemberMode */
enum _ns1__MemberMode {
	_ns1__MemberMode__Available = 0,
	_ns1__MemberMode__Away = 1,
	_ns1__MemberMode__DoNotDisturb = 2
};
#endif

/* WSVidyoUser.h:947 */
#ifndef SOAP_TYPE__ns1__MemberStatus
#define SOAP_TYPE__ns1__MemberStatus (215)
/* ns1:MemberStatus */
enum _ns1__MemberStatus {
	_ns1__MemberStatus__Offline = 0,
	_ns1__MemberStatus__Online = 1,
	_ns1__MemberStatus__Busy = 2,
	_ns1__MemberStatus__BusyInOwnRoom = 3,
	_ns1__MemberStatus__Ringing = 4,
	_ns1__MemberStatus__RingAccepted = 5,
	_ns1__MemberStatus__RingRejected = 6,
	_ns1__MemberStatus__RingNoAnswer = 7,
	_ns1__MemberStatus__Alerting = 8,
	_ns1__MemberStatus__AlertCancelled = 9
};
#endif

/* WSVidyoUser.h:969 */
#ifndef SOAP_TYPE__ns1__RoomStatus
#define SOAP_TYPE__ns1__RoomStatus (216)
/* ns1:RoomStatus */
enum _ns1__RoomStatus {
	_ns1__RoomStatus__Empty = 0,
	_ns1__RoomStatus__Full = 1,
	_ns1__RoomStatus__Occupied = 2
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class ns1__Recorder;	/* WSVidyoUser.h:142 */
class ns1__RoomProfile;	/* WSVidyoUser.h:145 */
class _ns1__GeneralFault;	/* WSVidyoUser.h:148 */
class _ns1__InvalidArgumentFault;	/* WSVidyoUser.h:151 */
class _ns1__SeatLicenseExpiredFault;	/* WSVidyoUser.h:154 */
class _ns1__WrongPINFault;	/* WSVidyoUser.h:157 */
class _ns1__ConferenceLockedFault;	/* WSVidyoUser.h:160 */
class _ns1__NotLicensedFault;	/* WSVidyoUser.h:163 */
class _ns1__ResourceNotAvailableFault;	/* WSVidyoUser.h:166 */
class _ns1__AccessRestrictedFault;	/* WSVidyoUser.h:169 */
class _ns1__InvalidModeratorPINFormatFault;	/* WSVidyoUser.h:172 */
class _ns1__ControlMeetingFault;	/* WSVidyoUser.h:175 */
class _ns1__ScheduledRoomCreationFault;	/* WSVidyoUser.h:178 */
class _ns1__EndpointNotBoundFault;	/* WSVidyoUser.h:181 */
class _ns1__InPointToPointCallFault;	/* WSVidyoUser.h:184 */
class _ns1__PrefixNotConfiguredException;	/* WSVidyoUser.h:187 */
class _ns1__FeatureNotAvailableFault;	/* WSVidyoUser.h:190 */
class _ns1__VidyoReplayNotAvailableFault;	/* WSVidyoUser.h:193 */
class _ns1__RoomNotFoundFault;	/* WSVidyoUser.h:196 */
class _ns1__RoomMode;	/* WSVidyoUser.h:199 */
class _ns1__Filter;	/* WSVidyoUser.h:202 */
class _ns1__Entity;	/* WSVidyoUser.h:205 */
class _ns1__LectureModeParticipant;	/* WSVidyoUser.h:208 */
class _ns1__LoginAttempt;	/* WSVidyoUser.h:211 */
class _ns1__WelcomeBannerContent;	/* WSVidyoUser.h:214 */
class _ns1__LogInRequest;	/* WSVidyoUser.h:217 */
class _ns1__LogInResponse;	/* WSVidyoUser.h:220 */
class _ns1__LinkEndpointRequest;	/* WSVidyoUser.h:223 */
class _ns1__LinkEndpointResponse;	/* WSVidyoUser.h:226 */
class _ns1__LogOutRequest;	/* WSVidyoUser.h:229 */
class _ns1__LogOutResponse;	/* WSVidyoUser.h:232 */
class _ns1__MyEndpointStatusRequest;	/* WSVidyoUser.h:235 */
class _ns1__MyEndpointStatusResponse;	/* WSVidyoUser.h:238 */
class _ns1__SearchMyContactsRequest;	/* WSVidyoUser.h:241 */
class _ns1__SearchMyContactsResponse;	/* WSVidyoUser.h:244 */
class _ns1__AddToMyContactsRequest;	/* WSVidyoUser.h:247 */
class _ns1__AddToMyContactsResponse;	/* WSVidyoUser.h:250 */
class _ns1__RemoveFromMyContactsRequest;	/* WSVidyoUser.h:253 */
class _ns1__RemoveFromMyContactsResponse;	/* WSVidyoUser.h:256 */
class _ns1__SearchRequest;	/* WSVidyoUser.h:259 */
class _ns1__SearchResponse;	/* WSVidyoUser.h:262 */
class _ns1__SearchByEntityIDRequest;	/* WSVidyoUser.h:265 */
class _ns1__SearchByEntityIDResponse;	/* WSVidyoUser.h:268 */
class _ns1__SearchByEmailRequest;	/* WSVidyoUser.h:271 */
class _ns1__SearchByEmailResponse;	/* WSVidyoUser.h:274 */
class _ns1__GetEntityByEntityIDRequest;	/* WSVidyoUser.h:277 */
class _ns1__GetEntityByEntityIDResponse;	/* WSVidyoUser.h:280 */
union _ns1__union_InviteToConferenceRequest;	/* WSVidyoUser.h:2448 */
class _ns1__InviteToConferenceRequest;	/* WSVidyoUser.h:283 */
class _ns1__InviteToConferenceResponse;	/* WSVidyoUser.h:286 */
class _ns1__CancelOutboundCallRequest;	/* WSVidyoUser.h:289 */
class _ns1__CancelOutboundCallResponse;	/* WSVidyoUser.h:292 */
union _ns1__union_JoinConferenceRequest;	/* WSVidyoUser.h:2559 */
class _ns1__JoinConferenceRequest;	/* WSVidyoUser.h:295 */
class _ns1__JoinConferenceResponse;	/* WSVidyoUser.h:298 */
class _ns1__JoinIPCConferenceRequest;	/* WSVidyoUser.h:301 */
class _ns1__JoinIPCConferenceResponse;	/* WSVidyoUser.h:304 */
union _ns1__union_DirectCallRequest;	/* WSVidyoUser.h:2677 */
class _ns1__DirectCallRequest;	/* WSVidyoUser.h:307 */
class _ns1__DirectCallResponse;	/* WSVidyoUser.h:310 */
class _ns1__GetParticipantsRequest;	/* WSVidyoUser.h:313 */
class _ns1__GetParticipantsResponse;	/* WSVidyoUser.h:316 */
class _ns1__GetLectureModeParticipantsRequest;	/* WSVidyoUser.h:319 */
class _ns1__GetLectureModeParticipantsResponse;	/* WSVidyoUser.h:322 */
class _ns1__LeaveConferenceRequest;	/* WSVidyoUser.h:325 */
class _ns1__LeaveConferenceResponse;	/* WSVidyoUser.h:328 */
class _ns1__MuteAudioRequest;	/* WSVidyoUser.h:331 */
class _ns1__MuteAudioResponse;	/* WSVidyoUser.h:334 */
class _ns1__UnmuteAudioRequest;	/* WSVidyoUser.h:337 */
class _ns1__UnmuteAudioResponse;	/* WSVidyoUser.h:340 */
class _ns1__StartVideoRequest;	/* WSVidyoUser.h:343 */
class _ns1__StartVideoResponse;	/* WSVidyoUser.h:346 */
class _ns1__StopVideoRequest;	/* WSVidyoUser.h:349 */
class _ns1__StopVideoResponse;	/* WSVidyoUser.h:352 */
class _ns1__MyAccountRequest;	/* WSVidyoUser.h:355 */
class _ns1__MyAccountResponse;	/* WSVidyoUser.h:358 */
class _ns1__CreateRoomRequest;	/* WSVidyoUser.h:361 */
class _ns1__CreateRoomResponse;	/* WSVidyoUser.h:364 */
class _ns1__DeleteRoomRequest;	/* WSVidyoUser.h:367 */
class _ns1__DeleteRoomResponse;	/* WSVidyoUser.h:370 */
class _ns1__CreateRoomURLRequest;	/* WSVidyoUser.h:373 */
class _ns1__CreateRoomURLResponse;	/* WSVidyoUser.h:376 */
class _ns1__RemoveRoomURLRequest;	/* WSVidyoUser.h:379 */
class _ns1__RemoveRoomURLResponse;	/* WSVidyoUser.h:382 */
class _ns1__CreateRoomPINRequest;	/* WSVidyoUser.h:385 */
class _ns1__CreateRoomPINResponse;	/* WSVidyoUser.h:388 */
class _ns1__RemoveRoomPINRequest;	/* WSVidyoUser.h:391 */
class _ns1__RemoveRoomPINResponse;	/* WSVidyoUser.h:394 */
class _ns1__UpdatePasswordRequest;	/* WSVidyoUser.h:397 */
class _ns1__UpdatePasswordResponse;	/* WSVidyoUser.h:400 */
class _ns1__UpdateLanguageRequest;	/* WSVidyoUser.h:403 */
class _ns1__UpdateLanguageResponse;	/* WSVidyoUser.h:406 */
class _ns1__LockRoomRequest;	/* WSVidyoUser.h:409 */
class _ns1__LockRoomResponse;	/* WSVidyoUser.h:412 */
class _ns1__UnlockRoomRequest;	/* WSVidyoUser.h:415 */
class _ns1__UnlockRoomResponse;	/* WSVidyoUser.h:418 */
class _ns1__SetMemberModeRequest;	/* WSVidyoUser.h:421 */
class _ns1__SetMemberModeResponse;	/* WSVidyoUser.h:424 */
class _ns1__GetRecordingProfilesRequest;	/* WSVidyoUser.h:427 */
class _ns1__GetRecordingProfilesResponse;	/* WSVidyoUser.h:430 */
class _ns1__StartRecordingRequest;	/* WSVidyoUser.h:433 */
class _ns1__StartRecordingResponse;	/* WSVidyoUser.h:436 */
class _ns1__GetPortalVersionRequest;	/* WSVidyoUser.h:439 */
class _ns1__GetPortalVersionResponse;	/* WSVidyoUser.h:442 */
class _ns1__PauseRecordingRequest;	/* WSVidyoUser.h:445 */
class _ns1__PauseRecordingResponse;	/* WSVidyoUser.h:448 */
class _ns1__ResumeRecordingRequest;	/* WSVidyoUser.h:451 */
class _ns1__ResumeRecordingResponse;	/* WSVidyoUser.h:454 */
class _ns1__StopRecordingRequest;	/* WSVidyoUser.h:457 */
class _ns1__StopRecordingResponse;	/* WSVidyoUser.h:460 */
class _ns1__CreateWebcastURLRequest;	/* WSVidyoUser.h:463 */
class _ns1__CreateWebcastURLResponse;	/* WSVidyoUser.h:466 */
class _ns1__CreateWebcastPINRequest;	/* WSVidyoUser.h:469 */
class _ns1__CreateWebcastPINResponse;	/* WSVidyoUser.h:472 */
class _ns1__RemoveWebcastURLRequest;	/* WSVidyoUser.h:475 */
class _ns1__RemoveWebcastURLResponse;	/* WSVidyoUser.h:478 */
class _ns1__RemoveWebcastPINRequest;	/* WSVidyoUser.h:481 */
class _ns1__RemoveWebcastPINResponse;	/* WSVidyoUser.h:484 */
class _ns1__GetWebcastURLRequest;	/* WSVidyoUser.h:487 */
class _ns1__GetWebcastURLResponse;	/* WSVidyoUser.h:490 */
class _ns1__GetUserNameRequest;	/* WSVidyoUser.h:493 */
class _ns1__GetUserNameResponse;	/* WSVidyoUser.h:496 */
class _ns1__GetEntityByRoomKeyRequest;	/* WSVidyoUser.h:499 */
class _ns1__GetEntityByRoomKeyResponse;	/* WSVidyoUser.h:502 */
class _ns1__GetInviteContentRequest;	/* WSVidyoUser.h:505 */
class _ns1__GetInviteContentResponse;	/* WSVidyoUser.h:508 */
class _ns1__GetRoomProfilesResponse;	/* WSVidyoUser.h:514 */
class _ns1__GetRoomProfileRequest;	/* WSVidyoUser.h:517 */
class _ns1__GetRoomProfileResponse;	/* WSVidyoUser.h:520 */
class _ns1__SetRoomProfileRequest;	/* WSVidyoUser.h:523 */
class _ns1__SetRoomProfileResponse;	/* WSVidyoUser.h:526 */
class _ns1__RemoveRoomProfileRequest;	/* WSVidyoUser.h:529 */
class _ns1__RemoveRoomProfileResponse;	/* WSVidyoUser.h:532 */
class _ns1__CreateModeratorURLRequest;	/* WSVidyoUser.h:535 */
class _ns1__CreateModeratorURLResponse;	/* WSVidyoUser.h:538 */
class _ns1__RemoveModeratorURLRequest;	/* WSVidyoUser.h:541 */
class _ns1__RemoveModeratorURLResponse;	/* WSVidyoUser.h:544 */
class _ns1__GetModeratorURLRequest;	/* WSVidyoUser.h:547 */
class _ns1__GetModeratorURLResponse;	/* WSVidyoUser.h:550 */
class _ns1__GetModeratorURLWithTokenRequest;	/* WSVidyoUser.h:553 */
class _ns1__GetModeratorURLWithTokenResponse;	/* WSVidyoUser.h:556 */
class _ns1__CreateModeratorPINRequest;	/* WSVidyoUser.h:559 */
class _ns1__CreateModeratorPINResponse;	/* WSVidyoUser.h:562 */
class _ns1__RemoveModeratorPINRequest;	/* WSVidyoUser.h:565 */
class _ns1__RemoveModeratorPINResponse;	/* WSVidyoUser.h:568 */
class _ns1__GetConferenceIDRequest;	/* WSVidyoUser.h:571 */
class _ns1__GetConferenceIDResponse;	/* WSVidyoUser.h:574 */
class _ns1__GenerateAuthTokenRequest;	/* WSVidyoUser.h:577 */
class _ns1__GenerateAuthTokenResponse;	/* WSVidyoUser.h:580 */
class _ns1__CreateScheduledRoomRequest;	/* WSVidyoUser.h:583 */
class _ns1__CreateScheduledRoomResponse;	/* WSVidyoUser.h:586 */
class _ns1__DeleteScheduledRoomRequest;	/* WSVidyoUser.h:589 */
class _ns1__DeleteScheduledRoomResponse;	/* WSVidyoUser.h:592 */
class _ns1__PortalFeature;	/* WSVidyoUser.h:595 */
class _ns1__GetPortalFeaturesResponse;	/* WSVidyoUser.h:601 */
class _ns1__EndpointFeature;	/* WSVidyoUser.h:604 */
class _ns1__SetEndpointDetailsRequest;	/* WSVidyoUser.h:607 */
class _ns1__SetEndpointDetailsResponse;	/* WSVidyoUser.h:610 */
class _ns1__GetActiveSessionsResponse;	/* WSVidyoUser.h:616 */
class _ns1__LogoutAllOtherSessionsResponse;	/* WSVidyoUser.h:622 */
class _ns1__disconnectConferenceAllRequest;	/* WSVidyoUser.h:625 */
class _ns1__disconnectConferenceAllResponse;	/* WSVidyoUser.h:628 */
class _ns1__muteAudioServerAllRequest;	/* WSVidyoUser.h:631 */
class _ns1__muteAudioServerAllResponse;	/* WSVidyoUser.h:634 */
class _ns1__muteAudioClientAllRequest;	/* WSVidyoUser.h:637 */
class _ns1__muteAudioClientAllResponse;	/* WSVidyoUser.h:640 */
class _ns1__muteVideoServerAllRequest;	/* WSVidyoUser.h:643 */
class _ns1__muteVideoServerAllResponse;	/* WSVidyoUser.h:646 */
class _ns1__muteVideoClientAllRequest;	/* WSVidyoUser.h:649 */
class _ns1__muteVideoClientAllResponse;	/* WSVidyoUser.h:652 */
class _ns1__OnetimeAccessResponse;	/* WSVidyoUser.h:658 */
class _ns1__RoomAccessOption;	/* WSVidyoUser.h:661 */
class _ns1__RoomAccessOptionsRequest;	/* WSVidyoUser.h:664 */
class _ns1__RoomAccessOptionsResponse;	/* WSVidyoUser.h:667 */
class _ns1__PortalPrefixResponse;	/* WSVidyoUser.h:673 */
class _ns1__PrefixNotConfiguredFault;	/* WSVidyoUser.h:676 */
class _ns1__getLoginAndWelcomeBannerRequest;	/* WSVidyoUser.h:679 */
class _ns1__getLoginAndWelcomeBannerResponse;	/* WSVidyoUser.h:682 */
class _ns1__getUserAccountTypeRequest;	/* WSVidyoUser.h:685 */
class _ns1__getUserAccountTypeResponse;	/* WSVidyoUser.h:688 */
class _ns1__StartLectureModeRequest;	/* WSVidyoUser.h:691 */
class _ns1__StartLectureModeResponse;	/* WSVidyoUser.h:694 */
class _ns1__StopLectureModeRequest;	/* WSVidyoUser.h:697 */
class _ns1__StopLectureModeResponse;	/* WSVidyoUser.h:700 */
class _ns1__RaiseHandResponse;	/* WSVidyoUser.h:706 */
class _ns1__UnraiseHandResponse;	/* WSVidyoUser.h:712 */
class _ns1__DismissRaisedHandRequest;	/* WSVidyoUser.h:715 */
class _ns1__DismissRaisedHandResponse;	/* WSVidyoUser.h:718 */
class _ns1__DismissAllRaisedHandRequest;	/* WSVidyoUser.h:721 */
class _ns1__DismissAllRaisedHandResponse;	/* WSVidyoUser.h:724 */
class _ns1__SetPresenterRequest;	/* WSVidyoUser.h:727 */
class _ns1__SetPresenterResponse;	/* WSVidyoUser.h:730 */
class _ns1__RemovePresenterRequest;	/* WSVidyoUser.h:733 */
class _ns1__RemovePresenterResponse;	/* WSVidyoUser.h:736 */
class _ns1__GetVidyoReplayLibraryRequest;	/* WSVidyoUser.h:739 */
class _ns1__GetVidyoReplayLibraryResponse;	/* WSVidyoUser.h:742 */
class _ns1__WhatIsMyIPAddressRequest;	/* WSVidyoUser.h:745 */
class _ns1__WhatIsMyIPAddressResponse;	/* WSVidyoUser.h:748 */
class _ns1__GetChangePasswordHtmlUrlWithTokenRequest;	/* WSVidyoUser.h:751 */
class _ns1__GetChangePasswordHtmlUrlWithTokenResponse;	/* WSVidyoUser.h:754 */
struct __ns1__logIn;	/* WSVidyoUser.h:6617 */
struct __ns1__linkEndpoint;	/* WSVidyoUser.h:6698 */
struct __ns1__logOut;	/* WSVidyoUser.h:6776 */
struct __ns1__myEndpointStatus;	/* WSVidyoUser.h:6854 */
struct __ns1__searchMyContacts;	/* WSVidyoUser.h:6932 */
struct __ns1__addToMyContacts;	/* WSVidyoUser.h:7010 */
struct __ns1__removeFromMyContacts;	/* WSVidyoUser.h:7088 */
struct __ns1__search;	/* WSVidyoUser.h:7166 */
struct __ns1__searchByEntityID;	/* WSVidyoUser.h:7244 */
struct __ns1__searchByEmail;	/* WSVidyoUser.h:7322 */
struct __ns1__getEntityByEntityID;	/* WSVidyoUser.h:7400 */
struct __ns1__inviteToConference;	/* WSVidyoUser.h:7481 */
struct __ns1__cancelOutboundCall;	/* WSVidyoUser.h:7562 */
struct __ns1__joinConference;	/* WSVidyoUser.h:7646 */
struct __ns1__joinIPCConference;	/* WSVidyoUser.h:7730 */
struct __ns1__directCall;	/* WSVidyoUser.h:7808 */
struct __ns1__getParticipants;	/* WSVidyoUser.h:7889 */
struct __ns1__getLectureModeParticipants;	/* WSVidyoUser.h:7967 */
struct __ns1__leaveConference;	/* WSVidyoUser.h:8048 */
struct __ns1__muteAudio;	/* WSVidyoUser.h:8129 */
struct __ns1__unmuteAudio;	/* WSVidyoUser.h:8210 */
struct __ns1__startVideo;	/* WSVidyoUser.h:8291 */
struct __ns1__stopVideo;	/* WSVidyoUser.h:8372 */
struct __ns1__myAccount;	/* WSVidyoUser.h:8450 */
struct __ns1__createRoomURL;	/* WSVidyoUser.h:8528 */
struct __ns1__removeRoomURL;	/* WSVidyoUser.h:8606 */
struct __ns1__createRoomPIN;	/* WSVidyoUser.h:8684 */
struct __ns1__removeRoomPIN;	/* WSVidyoUser.h:8762 */
struct __ns1__createRoom;	/* WSVidyoUser.h:8840 */
struct __ns1__deleteRoom;	/* WSVidyoUser.h:8918 */
struct __ns1__updatePassword;	/* WSVidyoUser.h:8996 */
struct __ns1__updateLanguage;	/* WSVidyoUser.h:9074 */
struct __ns1__lockRoom;	/* WSVidyoUser.h:9155 */
struct __ns1__unlockRoom;	/* WSVidyoUser.h:9236 */
struct __ns1__setMemberMode;	/* WSVidyoUser.h:9314 */
struct __ns1__getRecordingProfiles;	/* WSVidyoUser.h:9392 */
struct __ns1__startRecording;	/* WSVidyoUser.h:9476 */
struct __ns1__getPortalVersion;	/* WSVidyoUser.h:9554 */
struct __ns1__pauseRecording;	/* WSVidyoUser.h:9635 */
struct __ns1__resumeRecording;	/* WSVidyoUser.h:9716 */
struct __ns1__stopRecording;	/* WSVidyoUser.h:9797 */
struct __ns1__createWebcastURL;	/* WSVidyoUser.h:9875 */
struct __ns1__createWebcastPIN;	/* WSVidyoUser.h:9953 */
struct __ns1__removeWebcastURL;	/* WSVidyoUser.h:10031 */
struct __ns1__removeWebcastPIN;	/* WSVidyoUser.h:10109 */
struct __ns1__getWebcastURL;	/* WSVidyoUser.h:10187 */
struct __ns1__getUserName;	/* WSVidyoUser.h:10262 */
struct __ns1__getEntityByRoomKey;	/* WSVidyoUser.h:10337 */
struct __ns1__getInviteContent;	/* WSVidyoUser.h:10412 */
struct __ns1__getRoomProfiles;	/* WSVidyoUser.h:10487 */
struct __ns1__getRoomProfile;	/* WSVidyoUser.h:10562 */
struct __ns1__setRoomProfile;	/* WSVidyoUser.h:10637 */
struct __ns1__removeRoomProfile;	/* WSVidyoUser.h:10712 */
struct __ns1__createModeratorURL;	/* WSVidyoUser.h:10790 */
struct __ns1__removeModeratorURL;	/* WSVidyoUser.h:10868 */
struct __ns1__getModeratorURL;	/* WSVidyoUser.h:10946 */
struct __ns1__getModeratorURLWithToken;	/* WSVidyoUser.h:11024 */
struct __ns1__createModeratorPIN;	/* WSVidyoUser.h:11105 */
struct __ns1__removeModeratorPIN;	/* WSVidyoUser.h:11183 */
struct __ns1__getConferenceID;	/* WSVidyoUser.h:11258 */
struct __ns1__generateAuthToken;	/* WSVidyoUser.h:11339 */
struct __ns1__createScheduledRoom;	/* WSVidyoUser.h:11420 */
struct __ns1__deleteScheduledRoom;	/* WSVidyoUser.h:11498 */
struct __ns1__getPortalFeatures;	/* WSVidyoUser.h:11570 */
struct __ns1__setEndpointDetails;	/* WSVidyoUser.h:11648 */
struct __ns1__getActiveSessions;	/* WSVidyoUser.h:11720 */
struct __ns1__logoutAllOtherSessions;	/* WSVidyoUser.h:11792 */
struct __ns1__disconnectConferenceAll;	/* WSVidyoUser.h:11870 */
struct __ns1__muteAudioServerAll;	/* WSVidyoUser.h:11948 */
struct __ns1__muteAudioClientAll;	/* WSVidyoUser.h:12026 */
struct __ns1__muteVideoServerAll;	/* WSVidyoUser.h:12104 */
struct __ns1__muteVideoClientAll;	/* WSVidyoUser.h:12182 */
struct __ns1__getOnetimeAccessUrl;	/* WSVidyoUser.h:12257 */
struct __ns1__getRoomAccessOptions;	/* WSVidyoUser.h:12332 */
struct __ns1__getPortalPrefix;	/* WSVidyoUser.h:12407 */
struct __ns1__getLoginAndWelcomeBanner;	/* WSVidyoUser.h:12482 */
struct __ns1__getUserAccountType;	/* WSVidyoUser.h:12554 */
struct __ns1__startLectureMode;	/* WSVidyoUser.h:12632 */
struct __ns1__stopLectureMode;	/* WSVidyoUser.h:12710 */
struct __ns1__raiseHand;	/* WSVidyoUser.h:12785 */
struct __ns1__unraiseHand;	/* WSVidyoUser.h:12860 */
struct __ns1__dismissRaisedHand;	/* WSVidyoUser.h:12938 */
struct __ns1__dismissAllRaisedHand;	/* WSVidyoUser.h:13016 */
struct __ns1__setPresenter;	/* WSVidyoUser.h:13094 */
struct __ns1__removePresenter;	/* WSVidyoUser.h:13172 */
struct __ns1__getVidyoReplayLibrary;	/* WSVidyoUser.h:13247 */
struct __ns1__whatIsMyIPAddress;	/* WSVidyoUser.h:13319 */
struct __ns1__getChangePasswordHtmlUrlWithToken;	/* WSVidyoUser.h:13391 */

/* WSVidyoUser.h:142 */
#ifndef SOAP_TYPE_ns1__Recorder
#define SOAP_TYPE_ns1__Recorder (8)
/* complex XSD type 'ns1:Recorder': */
class SOAP_CMAC ns1__Recorder {
      public:
        /// Required element 'ns1:recorderPrefix' of XSD type 'xsd:string'
        char *recorderPrefix;
        /// Required element 'ns1:description' of XSD type 'xsd:string'
        char *description;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Recorder
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__Recorder; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Recorder, default initialized and not managed by a soap context
        virtual ns1__Recorder *soap_alloc(void) const { return SOAP_NEW(ns1__Recorder); }
      public:
        /// Constructor with initializations
        ns1__Recorder()
        {
          recorderPrefix = (char *)0;
          description = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns1__Recorder() { }
        /// Friend allocator used by soap_new_ns1__Recorder(struct soap*, int)
        friend SOAP_FMAC1 ns1__Recorder * SOAP_FMAC2 soap_instantiate_ns1__Recorder(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:145 */
#ifndef SOAP_TYPE_ns1__RoomProfile
#define SOAP_TYPE_ns1__RoomProfile (9)
/* complex XSD type 'ns1:RoomProfile': */
class SOAP_CMAC ns1__RoomProfile {
      public:
        /// Required element 'ns1:roomProfileName' of XSD type 'xsd:string'
        char *roomProfileName;
        /// Required element 'ns1:description' of XSD type 'xsd:string'
        char *description;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RoomProfile
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__RoomProfile; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RoomProfile, default initialized and not managed by a soap context
        virtual ns1__RoomProfile *soap_alloc(void) const { return SOAP_NEW(ns1__RoomProfile); }
      public:
        /// Constructor with initializations
        ns1__RoomProfile()
        {
          roomProfileName = (char *)0;
          description = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns1__RoomProfile() { }
        /// Friend allocator used by soap_new_ns1__RoomProfile(struct soap*, int)
        friend SOAP_FMAC1 ns1__RoomProfile * SOAP_FMAC2 soap_instantiate_ns1__RoomProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:148 */
#ifndef SOAP_TYPE__ns1__GeneralFault
#define SOAP_TYPE__ns1__GeneralFault (10)
/* complex XSD type 'ns1:GeneralFault': */
class SOAP_CMAC _ns1__GeneralFault {
      public:
        /// Required element 'ns1:ErrorMessage' of XSD type 'xsd:string'
        char *ErrorMessage;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GeneralFault
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GeneralFault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GeneralFault, default initialized and not managed by a soap context
        virtual _ns1__GeneralFault *soap_alloc(void) const { return SOAP_NEW(_ns1__GeneralFault); }
      public:
        /// Constructor with initializations
        _ns1__GeneralFault()
        {
          ErrorMessage = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GeneralFault() { }
        /// Friend allocator used by soap_new__ns1__GeneralFault(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GeneralFault * SOAP_FMAC2 soap_instantiate__ns1__GeneralFault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:151 */
#ifndef SOAP_TYPE__ns1__InvalidArgumentFault
#define SOAP_TYPE__ns1__InvalidArgumentFault (11)
/* complex XSD type 'ns1:InvalidArgumentFault': */
class SOAP_CMAC _ns1__InvalidArgumentFault {
      public:
        /// Required element 'ns1:ErrorMessage' of XSD type 'xsd:string'
        char *ErrorMessage;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InvalidArgumentFault
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InvalidArgumentFault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InvalidArgumentFault, default initialized and not managed by a soap context
        virtual _ns1__InvalidArgumentFault *soap_alloc(void) const { return SOAP_NEW(_ns1__InvalidArgumentFault); }
      public:
        /// Constructor with initializations
        _ns1__InvalidArgumentFault()
        {
          ErrorMessage = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__InvalidArgumentFault() { }
        /// Friend allocator used by soap_new__ns1__InvalidArgumentFault(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InvalidArgumentFault * SOAP_FMAC2 soap_instantiate__ns1__InvalidArgumentFault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:154 */
#ifndef SOAP_TYPE__ns1__SeatLicenseExpiredFault
#define SOAP_TYPE__ns1__SeatLicenseExpiredFault (12)
/* complex XSD type 'ns1:SeatLicenseExpiredFault': */
class SOAP_CMAC _ns1__SeatLicenseExpiredFault {
      public:
        /// Required element 'ns1:ErrorMessage' of XSD type 'xsd:string'
        char *ErrorMessage;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SeatLicenseExpiredFault
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SeatLicenseExpiredFault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SeatLicenseExpiredFault, default initialized and not managed by a soap context
        virtual _ns1__SeatLicenseExpiredFault *soap_alloc(void) const { return SOAP_NEW(_ns1__SeatLicenseExpiredFault); }
      public:
        /// Constructor with initializations
        _ns1__SeatLicenseExpiredFault()
        {
          ErrorMessage = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SeatLicenseExpiredFault() { }
        /// Friend allocator used by soap_new__ns1__SeatLicenseExpiredFault(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SeatLicenseExpiredFault * SOAP_FMAC2 soap_instantiate__ns1__SeatLicenseExpiredFault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:157 */
#ifndef SOAP_TYPE__ns1__WrongPINFault
#define SOAP_TYPE__ns1__WrongPINFault (13)
/* complex XSD type 'ns1:WrongPINFault': */
class SOAP_CMAC _ns1__WrongPINFault {
      public:
        /// Required element 'ns1:ErrorMessage' of XSD type 'xsd:string'
        char *ErrorMessage;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__WrongPINFault
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__WrongPINFault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__WrongPINFault, default initialized and not managed by a soap context
        virtual _ns1__WrongPINFault *soap_alloc(void) const { return SOAP_NEW(_ns1__WrongPINFault); }
      public:
        /// Constructor with initializations
        _ns1__WrongPINFault()
        {
          ErrorMessage = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__WrongPINFault() { }
        /// Friend allocator used by soap_new__ns1__WrongPINFault(struct soap*, int)
        friend SOAP_FMAC1 _ns1__WrongPINFault * SOAP_FMAC2 soap_instantiate__ns1__WrongPINFault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:160 */
#ifndef SOAP_TYPE__ns1__ConferenceLockedFault
#define SOAP_TYPE__ns1__ConferenceLockedFault (14)
/* complex XSD type 'ns1:ConferenceLockedFault': */
class SOAP_CMAC _ns1__ConferenceLockedFault {
      public:
        /// Required element 'ns1:ErrorMessage' of XSD type 'xsd:string'
        char *ErrorMessage;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ConferenceLockedFault
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ConferenceLockedFault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ConferenceLockedFault, default initialized and not managed by a soap context
        virtual _ns1__ConferenceLockedFault *soap_alloc(void) const { return SOAP_NEW(_ns1__ConferenceLockedFault); }
      public:
        /// Constructor with initializations
        _ns1__ConferenceLockedFault()
        {
          ErrorMessage = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__ConferenceLockedFault() { }
        /// Friend allocator used by soap_new__ns1__ConferenceLockedFault(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ConferenceLockedFault * SOAP_FMAC2 soap_instantiate__ns1__ConferenceLockedFault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:163 */
#ifndef SOAP_TYPE__ns1__NotLicensedFault
#define SOAP_TYPE__ns1__NotLicensedFault (15)
/* complex XSD type 'ns1:NotLicensedFault': */
class SOAP_CMAC _ns1__NotLicensedFault {
      public:
        /// Required element 'ns1:ErrorMessage' of XSD type 'xsd:string'
        char *ErrorMessage;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__NotLicensedFault
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__NotLicensedFault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__NotLicensedFault, default initialized and not managed by a soap context
        virtual _ns1__NotLicensedFault *soap_alloc(void) const { return SOAP_NEW(_ns1__NotLicensedFault); }
      public:
        /// Constructor with initializations
        _ns1__NotLicensedFault()
        {
          ErrorMessage = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__NotLicensedFault() { }
        /// Friend allocator used by soap_new__ns1__NotLicensedFault(struct soap*, int)
        friend SOAP_FMAC1 _ns1__NotLicensedFault * SOAP_FMAC2 soap_instantiate__ns1__NotLicensedFault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:166 */
#ifndef SOAP_TYPE__ns1__ResourceNotAvailableFault
#define SOAP_TYPE__ns1__ResourceNotAvailableFault (16)
/* complex XSD type 'ns1:ResourceNotAvailableFault': */
class SOAP_CMAC _ns1__ResourceNotAvailableFault {
      public:
        /// Required element 'ns1:ErrorMessage' of XSD type 'xsd:string'
        char *ErrorMessage;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ResourceNotAvailableFault
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ResourceNotAvailableFault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ResourceNotAvailableFault, default initialized and not managed by a soap context
        virtual _ns1__ResourceNotAvailableFault *soap_alloc(void) const { return SOAP_NEW(_ns1__ResourceNotAvailableFault); }
      public:
        /// Constructor with initializations
        _ns1__ResourceNotAvailableFault()
        {
          ErrorMessage = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__ResourceNotAvailableFault() { }
        /// Friend allocator used by soap_new__ns1__ResourceNotAvailableFault(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ResourceNotAvailableFault * SOAP_FMAC2 soap_instantiate__ns1__ResourceNotAvailableFault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:169 */
#ifndef SOAP_TYPE__ns1__AccessRestrictedFault
#define SOAP_TYPE__ns1__AccessRestrictedFault (17)
/* complex XSD type 'ns1:AccessRestrictedFault': */
class SOAP_CMAC _ns1__AccessRestrictedFault {
      public:
        /// Required element 'ns1:ErrorMessage' of XSD type 'xsd:string'
        char *ErrorMessage;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__AccessRestrictedFault
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__AccessRestrictedFault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__AccessRestrictedFault, default initialized and not managed by a soap context
        virtual _ns1__AccessRestrictedFault *soap_alloc(void) const { return SOAP_NEW(_ns1__AccessRestrictedFault); }
      public:
        /// Constructor with initializations
        _ns1__AccessRestrictedFault()
        {
          ErrorMessage = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__AccessRestrictedFault() { }
        /// Friend allocator used by soap_new__ns1__AccessRestrictedFault(struct soap*, int)
        friend SOAP_FMAC1 _ns1__AccessRestrictedFault * SOAP_FMAC2 soap_instantiate__ns1__AccessRestrictedFault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:172 */
#ifndef SOAP_TYPE__ns1__InvalidModeratorPINFormatFault
#define SOAP_TYPE__ns1__InvalidModeratorPINFormatFault (18)
/* complex XSD type 'ns1:InvalidModeratorPINFormatFault': */
class SOAP_CMAC _ns1__InvalidModeratorPINFormatFault {
      public:
        /// Required element 'ns1:ErrorMessage' of XSD type 'xsd:string'
        char *ErrorMessage;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InvalidModeratorPINFormatFault
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InvalidModeratorPINFormatFault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InvalidModeratorPINFormatFault, default initialized and not managed by a soap context
        virtual _ns1__InvalidModeratorPINFormatFault *soap_alloc(void) const { return SOAP_NEW(_ns1__InvalidModeratorPINFormatFault); }
      public:
        /// Constructor with initializations
        _ns1__InvalidModeratorPINFormatFault()
        {
          ErrorMessage = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__InvalidModeratorPINFormatFault() { }
        /// Friend allocator used by soap_new__ns1__InvalidModeratorPINFormatFault(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InvalidModeratorPINFormatFault * SOAP_FMAC2 soap_instantiate__ns1__InvalidModeratorPINFormatFault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:175 */
#ifndef SOAP_TYPE__ns1__ControlMeetingFault
#define SOAP_TYPE__ns1__ControlMeetingFault (19)
/* complex XSD type 'ns1:ControlMeetingFault': */
class SOAP_CMAC _ns1__ControlMeetingFault {
      public:
        /// Required element 'ns1:ErrorMessage' of XSD type 'xsd:string'
        char *ErrorMessage;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ControlMeetingFault
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ControlMeetingFault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ControlMeetingFault, default initialized and not managed by a soap context
        virtual _ns1__ControlMeetingFault *soap_alloc(void) const { return SOAP_NEW(_ns1__ControlMeetingFault); }
      public:
        /// Constructor with initializations
        _ns1__ControlMeetingFault()
        {
          ErrorMessage = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__ControlMeetingFault() { }
        /// Friend allocator used by soap_new__ns1__ControlMeetingFault(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ControlMeetingFault * SOAP_FMAC2 soap_instantiate__ns1__ControlMeetingFault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:178 */
#ifndef SOAP_TYPE__ns1__ScheduledRoomCreationFault
#define SOAP_TYPE__ns1__ScheduledRoomCreationFault (20)
/* complex XSD type 'ns1:ScheduledRoomCreationFault': */
class SOAP_CMAC _ns1__ScheduledRoomCreationFault {
      public:
        /// Required element 'ns1:ErrorMessage' of XSD type 'xsd:string'
        char *ErrorMessage;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ScheduledRoomCreationFault
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ScheduledRoomCreationFault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ScheduledRoomCreationFault, default initialized and not managed by a soap context
        virtual _ns1__ScheduledRoomCreationFault *soap_alloc(void) const { return SOAP_NEW(_ns1__ScheduledRoomCreationFault); }
      public:
        /// Constructor with initializations
        _ns1__ScheduledRoomCreationFault()
        {
          ErrorMessage = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__ScheduledRoomCreationFault() { }
        /// Friend allocator used by soap_new__ns1__ScheduledRoomCreationFault(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ScheduledRoomCreationFault * SOAP_FMAC2 soap_instantiate__ns1__ScheduledRoomCreationFault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:181 */
#ifndef SOAP_TYPE__ns1__EndpointNotBoundFault
#define SOAP_TYPE__ns1__EndpointNotBoundFault (21)
/* complex XSD type 'ns1:EndpointNotBoundFault': */
class SOAP_CMAC _ns1__EndpointNotBoundFault {
      public:
        /// Required element 'ns1:ErrorMessage' of XSD type 'xsd:string'
        char *ErrorMessage;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__EndpointNotBoundFault
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__EndpointNotBoundFault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__EndpointNotBoundFault, default initialized and not managed by a soap context
        virtual _ns1__EndpointNotBoundFault *soap_alloc(void) const { return SOAP_NEW(_ns1__EndpointNotBoundFault); }
      public:
        /// Constructor with initializations
        _ns1__EndpointNotBoundFault()
        {
          ErrorMessage = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__EndpointNotBoundFault() { }
        /// Friend allocator used by soap_new__ns1__EndpointNotBoundFault(struct soap*, int)
        friend SOAP_FMAC1 _ns1__EndpointNotBoundFault * SOAP_FMAC2 soap_instantiate__ns1__EndpointNotBoundFault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:184 */
#ifndef SOAP_TYPE__ns1__InPointToPointCallFault
#define SOAP_TYPE__ns1__InPointToPointCallFault (22)
/* complex XSD type 'ns1:InPointToPointCallFault': */
class SOAP_CMAC _ns1__InPointToPointCallFault {
      public:
        /// Required element 'ns1:ErrorMessage' of XSD type 'xsd:string'
        char *ErrorMessage;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InPointToPointCallFault
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InPointToPointCallFault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InPointToPointCallFault, default initialized and not managed by a soap context
        virtual _ns1__InPointToPointCallFault *soap_alloc(void) const { return SOAP_NEW(_ns1__InPointToPointCallFault); }
      public:
        /// Constructor with initializations
        _ns1__InPointToPointCallFault()
        {
          ErrorMessage = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__InPointToPointCallFault() { }
        /// Friend allocator used by soap_new__ns1__InPointToPointCallFault(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InPointToPointCallFault * SOAP_FMAC2 soap_instantiate__ns1__InPointToPointCallFault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:187 */
#ifndef SOAP_TYPE__ns1__PrefixNotConfiguredException
#define SOAP_TYPE__ns1__PrefixNotConfiguredException (23)
/* complex XSD type 'ns1:PrefixNotConfiguredException': */
class SOAP_CMAC _ns1__PrefixNotConfiguredException {
      public:
        /// Required element 'ns1:ErrorMessage' of XSD type 'xsd:string'
        char *ErrorMessage;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__PrefixNotConfiguredException
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__PrefixNotConfiguredException; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__PrefixNotConfiguredException, default initialized and not managed by a soap context
        virtual _ns1__PrefixNotConfiguredException *soap_alloc(void) const { return SOAP_NEW(_ns1__PrefixNotConfiguredException); }
      public:
        /// Constructor with initializations
        _ns1__PrefixNotConfiguredException()
        {
          ErrorMessage = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__PrefixNotConfiguredException() { }
        /// Friend allocator used by soap_new__ns1__PrefixNotConfiguredException(struct soap*, int)
        friend SOAP_FMAC1 _ns1__PrefixNotConfiguredException * SOAP_FMAC2 soap_instantiate__ns1__PrefixNotConfiguredException(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:190 */
#ifndef SOAP_TYPE__ns1__FeatureNotAvailableFault
#define SOAP_TYPE__ns1__FeatureNotAvailableFault (24)
/* complex XSD type 'ns1:FeatureNotAvailableFault': */
class SOAP_CMAC _ns1__FeatureNotAvailableFault {
      public:
        /// Required element 'ns1:ErrorMessage' of XSD type 'xsd:string'
        char *ErrorMessage;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__FeatureNotAvailableFault
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__FeatureNotAvailableFault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__FeatureNotAvailableFault, default initialized and not managed by a soap context
        virtual _ns1__FeatureNotAvailableFault *soap_alloc(void) const { return SOAP_NEW(_ns1__FeatureNotAvailableFault); }
      public:
        /// Constructor with initializations
        _ns1__FeatureNotAvailableFault()
        {
          ErrorMessage = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__FeatureNotAvailableFault() { }
        /// Friend allocator used by soap_new__ns1__FeatureNotAvailableFault(struct soap*, int)
        friend SOAP_FMAC1 _ns1__FeatureNotAvailableFault * SOAP_FMAC2 soap_instantiate__ns1__FeatureNotAvailableFault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:193 */
#ifndef SOAP_TYPE__ns1__VidyoReplayNotAvailableFault
#define SOAP_TYPE__ns1__VidyoReplayNotAvailableFault (25)
/* complex XSD type 'ns1:VidyoReplayNotAvailableFault': */
class SOAP_CMAC _ns1__VidyoReplayNotAvailableFault {
      public:
        /// Required element 'ns1:ErrorMessage' of XSD type 'xsd:string'
        char *ErrorMessage;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__VidyoReplayNotAvailableFault
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__VidyoReplayNotAvailableFault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__VidyoReplayNotAvailableFault, default initialized and not managed by a soap context
        virtual _ns1__VidyoReplayNotAvailableFault *soap_alloc(void) const { return SOAP_NEW(_ns1__VidyoReplayNotAvailableFault); }
      public:
        /// Constructor with initializations
        _ns1__VidyoReplayNotAvailableFault()
        {
          ErrorMessage = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__VidyoReplayNotAvailableFault() { }
        /// Friend allocator used by soap_new__ns1__VidyoReplayNotAvailableFault(struct soap*, int)
        friend SOAP_FMAC1 _ns1__VidyoReplayNotAvailableFault * SOAP_FMAC2 soap_instantiate__ns1__VidyoReplayNotAvailableFault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:196 */
#ifndef SOAP_TYPE__ns1__RoomNotFoundFault
#define SOAP_TYPE__ns1__RoomNotFoundFault (26)
/* complex XSD type 'ns1:RoomNotFoundFault': */
class SOAP_CMAC _ns1__RoomNotFoundFault {
      public:
        /// Required element 'ns1:ErrorMessage' of XSD type 'xsd:string'
        char *ErrorMessage;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RoomNotFoundFault
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__RoomNotFoundFault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RoomNotFoundFault, default initialized and not managed by a soap context
        virtual _ns1__RoomNotFoundFault *soap_alloc(void) const { return SOAP_NEW(_ns1__RoomNotFoundFault); }
      public:
        /// Constructor with initializations
        _ns1__RoomNotFoundFault()
        {
          ErrorMessage = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__RoomNotFoundFault() { }
        /// Friend allocator used by soap_new__ns1__RoomNotFoundFault(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RoomNotFoundFault * SOAP_FMAC2 soap_instantiate__ns1__RoomNotFoundFault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:199 */
#ifndef SOAP_TYPE__ns1__RoomMode
#define SOAP_TYPE__ns1__RoomMode (27)
/* complex XSD type 'ns1:RoomMode': */
class SOAP_CMAC _ns1__RoomMode {
      public:
        /// Optional element 'ns1:roomURL' of XSD type 'xsd:string'
        char *roomURL;
        /// Required element 'ns1:isLocked' of XSD type 'xsd:boolean'
        bool isLocked;
        /// Required element 'ns1:hasPIN' of XSD type 'xsd:boolean'
        bool hasPIN;
        /// Optional element 'ns1:roomPIN' of XSD type 'xsd:string'
        char *roomPIN;
        /// Optional element 'ns1:hasModeratorPIN' of XSD type 'xsd:boolean'
        bool *hasModeratorPIN;
        /// Optional element 'ns1:moderatorPIN' of XSD type 'xsd:string'
        char *moderatorPIN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RoomMode
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__RoomMode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RoomMode, default initialized and not managed by a soap context
        virtual _ns1__RoomMode *soap_alloc(void) const { return SOAP_NEW(_ns1__RoomMode); }
      public:
        /// Constructor with initializations
        _ns1__RoomMode()
        {
          roomURL = (char *)0;
          isLocked = (bool)0;
          hasPIN = (bool)0;
          roomPIN = (char *)0;
          hasModeratorPIN = (bool *)0;
          moderatorPIN = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__RoomMode() { }
        /// Friend allocator used by soap_new__ns1__RoomMode(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RoomMode * SOAP_FMAC2 soap_instantiate__ns1__RoomMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:202 */
#ifndef SOAP_TYPE__ns1__Filter
#define SOAP_TYPE__ns1__Filter (28)
/* complex XSD type 'ns1:Filter': */
class SOAP_CMAC _ns1__Filter {
      public:
        /// Optional element 'ns1:start' of XSD type 'xsd:int'
        int *start;
        /// Optional element 'ns1:limit' of XSD type 'xsd:int'
        int *limit;
        /// Optional element 'ns1:sortBy' of XSD type 'xsd:string'
        char *sortBy;
        /// Optional element 'ns1:dir' of XSD type 'ns1:sortDir'
        enum ns1__sortDir *dir;
        /// Optional element 'ns1:EntityType' of XSD type 'ns1:EntityType'
        enum _ns1__EntityType *EntityType;
        /// Optional element 'ns1:query' of XSD type 'xsd:string'
        char *query;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__Filter
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__Filter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__Filter, default initialized and not managed by a soap context
        virtual _ns1__Filter *soap_alloc(void) const { return SOAP_NEW(_ns1__Filter); }
      public:
        /// Constructor with initializations
        _ns1__Filter()
        {
          start = (int *)0;
          limit = (int *)0;
          sortBy = (char *)0;
          dir = (enum ns1__sortDir *)0;
          EntityType = (enum _ns1__EntityType *)0;
          query = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__Filter() { }
        /// Friend allocator used by soap_new__ns1__Filter(struct soap*, int)
        friend SOAP_FMAC1 _ns1__Filter * SOAP_FMAC2 soap_instantiate__ns1__Filter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:205 */
#ifndef SOAP_TYPE__ns1__Entity
#define SOAP_TYPE__ns1__Entity (29)
/* complex XSD type 'ns1:Entity': */
class SOAP_CMAC _ns1__Entity {
      public:
        /// Required element 'ns1:entityID' of XSD type 'ns1:EntityID'
        char *entityID;
        /// Optional element 'ns1:participantID' of XSD type 'ns1:EntityID'
        char *participantID;
        /// Required element 'ns1:EntityType' of XSD type 'ns1:EntityType'
        enum _ns1__EntityType EntityType;
        /// Optional element 'ns1:ownerID' of XSD type 'ns1:EntityID'
        char *ownerID;
        /// Required element 'ns1:displayName' of XSD type 'xsd:string'
        char *displayName;
        /// Required element 'ns1:extension' of XSD type 'xsd:string'
        char *extension;
        /// Optional element 'ns1:emailAddress' of XSD type 'xsd:string'
        char *emailAddress;
        /// Optional element 'ns1:tenant' of XSD type 'xsd:string'
        char *tenant;
        /// Optional element 'ns1:description' of XSD type 'xsd:string'
        char *description;
        /// Optional element 'ns1:Language' of XSD type 'ns1:Language'
        enum _ns1__Language *Language;
        /// Optional element 'ns1:MemberStatus' of XSD type 'ns1:MemberStatus'
        enum _ns1__MemberStatus *MemberStatus;
        /// Optional element 'ns1:MemberMode' of XSD type 'ns1:MemberMode'
        enum _ns1__MemberMode *MemberMode;
        /// Optional element 'ns1:canCallDirect' of XSD type 'xsd:boolean'
        bool *canCallDirect;
        /// Optional element 'ns1:canJoinMeeting' of XSD type 'xsd:boolean'
        bool *canJoinMeeting;
        /// Optional element 'ns1:canRecordMeeting' of XSD type 'xsd:boolean'
        bool *canRecordMeeting;
        /// Optional element 'ns1:isInMyContacts' of XSD type 'xsd:boolean'
        bool *isInMyContacts;
        /// Optional element 'ns1:RoomStatus' of XSD type 'ns1:RoomStatus'
        enum _ns1__RoomStatus *RoomStatus;
        /// Optional element 'ns1:RoomMode' of XSD type 'ns1:RoomMode'
        _ns1__RoomMode *RoomMode;
        /// Optional element 'ns1:canControl' of XSD type 'xsd:boolean'
        bool *canControl;
        /// Optional element 'ns1:audio' of XSD type 'xsd:boolean'
        bool *audio;
        /// Optional element 'ns1:video' of XSD type 'xsd:boolean'
        bool *video;
        /// Optional element 'ns1:appshare' of XSD type 'xsd:boolean'
        bool *appshare;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__Entity
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__Entity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__Entity, default initialized and not managed by a soap context
        virtual _ns1__Entity *soap_alloc(void) const { return SOAP_NEW(_ns1__Entity); }
      public:
        /// Constructor with initializations
        _ns1__Entity()
        {
          entityID = (char *)0;
          participantID = (char *)0;
          EntityType = (enum _ns1__EntityType)0;
          ownerID = (char *)0;
          displayName = (char *)0;
          extension = (char *)0;
          emailAddress = (char *)0;
          tenant = (char *)0;
          description = (char *)0;
          Language = (enum _ns1__Language *)0;
          MemberStatus = (enum _ns1__MemberStatus *)0;
          MemberMode = (enum _ns1__MemberMode *)0;
          canCallDirect = (bool *)0;
          canJoinMeeting = (bool *)0;
          canRecordMeeting = (bool *)0;
          isInMyContacts = (bool *)0;
          RoomStatus = (enum _ns1__RoomStatus *)0;
          RoomMode = (_ns1__RoomMode *)0;
          canControl = (bool *)0;
          audio = (bool *)0;
          video = (bool *)0;
          appshare = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__Entity() { }
        /// Friend allocator used by soap_new__ns1__Entity(struct soap*, int)
        friend SOAP_FMAC1 _ns1__Entity * SOAP_FMAC2 soap_instantiate__ns1__Entity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:208 */
#ifndef SOAP_TYPE__ns1__LectureModeParticipant
#define SOAP_TYPE__ns1__LectureModeParticipant (30)
/* complex XSD type 'ns1:LectureModeParticipant': */
class SOAP_CMAC _ns1__LectureModeParticipant {
      public:
        /// Required element 'ns1:entityID' of XSD type 'ns1:EntityID'
        char *entityID;
        /// Required element 'ns1:participantID' of XSD type 'ns1:EntityID'
        char *participantID;
        /// Required element 'ns1:EntityType' of XSD type 'ns1:EntityType'
        enum _ns1__EntityType EntityType;
        /// Required element 'ns1:displayName' of XSD type 'xsd:string'
        char *displayName;
        /// Required element 'ns1:extension' of XSD type 'xsd:string'
        char *extension;
        /// Optional element 'ns1:audio' of XSD type 'xsd:boolean'
        bool *audio;
        /// Optional element 'ns1:video' of XSD type 'xsd:boolean'
        bool *video;
        /// Optional element 'ns1:appshare' of XSD type 'xsd:boolean'
        bool *appshare;
        /// Optional element 'ns1:handRaised' of XSD type 'xsd:boolean'
        bool *handRaised;
        /// Optional element 'ns1:presenter' of XSD type 'xsd:boolean'
        bool *presenter;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__LectureModeParticipant
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__LectureModeParticipant; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__LectureModeParticipant, default initialized and not managed by a soap context
        virtual _ns1__LectureModeParticipant *soap_alloc(void) const { return SOAP_NEW(_ns1__LectureModeParticipant); }
      public:
        /// Constructor with initializations
        _ns1__LectureModeParticipant()
        {
          entityID = (char *)0;
          participantID = (char *)0;
          EntityType = (enum _ns1__EntityType)0;
          displayName = (char *)0;
          extension = (char *)0;
          audio = (bool *)0;
          video = (bool *)0;
          appshare = (bool *)0;
          handRaised = (bool *)0;
          presenter = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__LectureModeParticipant() { }
        /// Friend allocator used by soap_new__ns1__LectureModeParticipant(struct soap*, int)
        friend SOAP_FMAC1 _ns1__LectureModeParticipant * SOAP_FMAC2 soap_instantiate__ns1__LectureModeParticipant(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:211 */
#ifndef SOAP_TYPE__ns1__LoginAttempt
#define SOAP_TYPE__ns1__LoginAttempt (31)
/* complex XSD type 'ns1:LoginAttempt': */
class SOAP_CMAC _ns1__LoginAttempt {
      public:
        /// Required element 'ns1:result' of XSD type 'xsd:string'
        char *result;
        /// Required element 'ns1:sourceIPAddress' of XSD type 'xsd:string'
        char *sourceIPAddress;
        /// Required element 'ns1:attemptTime' of XSD type 'xsd:dateTime'
        time_t attemptTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__LoginAttempt
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__LoginAttempt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__LoginAttempt, default initialized and not managed by a soap context
        virtual _ns1__LoginAttempt *soap_alloc(void) const { return SOAP_NEW(_ns1__LoginAttempt); }
      public:
        /// Constructor with initializations
        _ns1__LoginAttempt()
        {
          result = (char *)0;
          sourceIPAddress = (char *)0;
          attemptTime = (time_t)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__LoginAttempt() { }
        /// Friend allocator used by soap_new__ns1__LoginAttempt(struct soap*, int)
        friend SOAP_FMAC1 _ns1__LoginAttempt * SOAP_FMAC2 soap_instantiate__ns1__LoginAttempt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:214 */
#ifndef SOAP_TYPE__ns1__WelcomeBannerContent
#define SOAP_TYPE__ns1__WelcomeBannerContent (32)
/* complex XSD type 'ns1:WelcomeBannerContent': */
class SOAP_CMAC _ns1__WelcomeBannerContent {
      public:
        /// Optional element 'ns1:welcomeBannerText' of XSD type 'xsd:string'
        char *welcomeBannerText;
        /// Sequence of elements 'ns1:LoginAttempt' of XSD type 'ns1:LoginAttempt' stored in dynamic array LoginAttempt of length __sizeLoginAttempt
        int __sizeLoginAttempt;
        _ns1__LoginAttempt **LoginAttempt;
        /// Optional element 'ns1:welcomeBannerPasswordExpiryDate' of XSD type 'xsd:dateTime'
        time_t *welcomeBannerPasswordExpiryDate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__WelcomeBannerContent
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__WelcomeBannerContent; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__WelcomeBannerContent, default initialized and not managed by a soap context
        virtual _ns1__WelcomeBannerContent *soap_alloc(void) const { return SOAP_NEW(_ns1__WelcomeBannerContent); }
      public:
        /// Constructor with initializations
        _ns1__WelcomeBannerContent()
        {
          welcomeBannerText = (char *)0;
          __sizeLoginAttempt = 0;
          LoginAttempt = NULL;
          welcomeBannerPasswordExpiryDate = (time_t *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__WelcomeBannerContent() { }
        /// Friend allocator used by soap_new__ns1__WelcomeBannerContent(struct soap*, int)
        friend SOAP_FMAC1 _ns1__WelcomeBannerContent * SOAP_FMAC2 soap_instantiate__ns1__WelcomeBannerContent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:217 */
#ifndef SOAP_TYPE__ns1__LogInRequest
#define SOAP_TYPE__ns1__LogInRequest (33)
/* complex XSD type 'ns1:LogInRequest': */
class SOAP_CMAC _ns1__LogInRequest {
      public:
        /// Optional element 'ns1:ClientType' of XSD type 'ns1:ClientType'
        enum _ns1__ClientType *ClientType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__LogInRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__LogInRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__LogInRequest, default initialized and not managed by a soap context
        virtual _ns1__LogInRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__LogInRequest); }
      public:
        /// Constructor with initializations
        _ns1__LogInRequest()
        {
          ClientType = (enum _ns1__ClientType *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__LogInRequest() { }
        /// Friend allocator used by soap_new__ns1__LogInRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__LogInRequest * SOAP_FMAC2 soap_instantiate__ns1__LogInRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:220 */
#ifndef SOAP_TYPE__ns1__LogInResponse
#define SOAP_TYPE__ns1__LogInResponse (34)
/* complex XSD type 'ns1:LogInResponse': */
class SOAP_CMAC _ns1__LogInResponse {
      public:
        /// Required element 'ns1:pak' of XSD type 'xsd:string'
        char *pak;
        /// Optional element 'ns1:vmaddress' of XSD type 'xsd:string'
        char *vmaddress;
        /// Optional element 'ns1:proxyaddress' of XSD type 'xsd:string'
        char *proxyaddress;
        /// Optional element 'ns1:loctag' of XSD type 'xsd:string'
        char *loctag;
        /// Optional element 'ns1:pak2' of XSD type 'xsd:string'
        char *pak2;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__LogInResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__LogInResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__LogInResponse, default initialized and not managed by a soap context
        virtual _ns1__LogInResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__LogInResponse); }
      public:
        /// Constructor with initializations
        _ns1__LogInResponse()
        {
          pak = (char *)0;
          vmaddress = (char *)0;
          proxyaddress = (char *)0;
          loctag = (char *)0;
          pak2 = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__LogInResponse() { }
        /// Friend allocator used by soap_new__ns1__LogInResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__LogInResponse * SOAP_FMAC2 soap_instantiate__ns1__LogInResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:223 */
#ifndef SOAP_TYPE__ns1__LinkEndpointRequest
#define SOAP_TYPE__ns1__LinkEndpointRequest (35)
/* complex XSD type 'ns1:LinkEndpointRequest': */
class SOAP_CMAC _ns1__LinkEndpointRequest {
      public:
        /// Required element 'ns1:EID' of XSD type 'xsd:string'
        char *EID;
        /// Optional element 'ns1:vrIP' of XSD type 'xsd:string'
        char *vrIP;
        /// Optional element 'ns1:clientType' of XSD type 'xsd:string'
        char *clientType;
        /// Optional element 'ns1:applicationName' of XSD type 'xsd:string'
        char *applicationName;
        /// Optional element 'ns1:applicationVersion' of XSD type 'xsd:string'
        char *applicationVersion;
        /// Optional element 'ns1:applicationOs' of XSD type 'xsd:string'
        char *applicationOs;
        /// Optional element 'ns1:deviceModel' of XSD type 'xsd:string'
        char *deviceModel;
        /// Optional element 'ns1:pak2' of XSD type 'xsd:boolean'
        bool *pak2;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__LinkEndpointRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__LinkEndpointRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__LinkEndpointRequest, default initialized and not managed by a soap context
        virtual _ns1__LinkEndpointRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__LinkEndpointRequest); }
      public:
        /// Constructor with initializations
        _ns1__LinkEndpointRequest()
        {
          EID = (char *)0;
          vrIP = (char *)0;
          clientType = (char *)0;
          applicationName = (char *)0;
          applicationVersion = (char *)0;
          applicationOs = (char *)0;
          deviceModel = (char *)0;
          pak2 = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__LinkEndpointRequest() { }
        /// Friend allocator used by soap_new__ns1__LinkEndpointRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__LinkEndpointRequest * SOAP_FMAC2 soap_instantiate__ns1__LinkEndpointRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:226 */
#ifndef SOAP_TYPE__ns1__LinkEndpointResponse
#define SOAP_TYPE__ns1__LinkEndpointResponse (36)
/* complex XSD type 'ns1:LinkEndpointResponse': */
class SOAP_CMAC _ns1__LinkEndpointResponse {
      public:
        /// Required element 'ns1:Entity' of XSD type 'ns1:Entity'
        _ns1__Entity *Entity;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__LinkEndpointResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__LinkEndpointResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__LinkEndpointResponse, default initialized and not managed by a soap context
        virtual _ns1__LinkEndpointResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__LinkEndpointResponse); }
      public:
        /// Constructor with initializations
        _ns1__LinkEndpointResponse()
        {
          Entity = (_ns1__Entity *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__LinkEndpointResponse() { }
        /// Friend allocator used by soap_new__ns1__LinkEndpointResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__LinkEndpointResponse * SOAP_FMAC2 soap_instantiate__ns1__LinkEndpointResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:229 */
#ifndef SOAP_TYPE__ns1__LogOutRequest
#define SOAP_TYPE__ns1__LogOutRequest (37)
/* complex XSD type 'ns1:LogOutRequest': */
class SOAP_CMAC _ns1__LogOutRequest {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__LogOutRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__LogOutRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__LogOutRequest, default initialized and not managed by a soap context
        virtual _ns1__LogOutRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__LogOutRequest); }
      public:
        /// Constructor with initializations
        _ns1__LogOutRequest()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__LogOutRequest() { }
        /// Friend allocator used by soap_new__ns1__LogOutRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__LogOutRequest * SOAP_FMAC2 soap_instantiate__ns1__LogOutRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:232 */
#ifndef SOAP_TYPE__ns1__LogOutResponse
#define SOAP_TYPE__ns1__LogOutResponse (38)
/* complex XSD type 'ns1:LogOutResponse': */
class SOAP_CMAC _ns1__LogOutResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__LogOutResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__LogOutResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__LogOutResponse, default initialized and not managed by a soap context
        virtual _ns1__LogOutResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__LogOutResponse); }
      public:
        /// Constructor with initializations
        _ns1__LogOutResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__LogOutResponse() { }
        /// Friend allocator used by soap_new__ns1__LogOutResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__LogOutResponse * SOAP_FMAC2 soap_instantiate__ns1__LogOutResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:235 */
#ifndef SOAP_TYPE__ns1__MyEndpointStatusRequest
#define SOAP_TYPE__ns1__MyEndpointStatusRequest (39)
/* complex XSD type 'ns1:MyEndpointStatusRequest': */
class SOAP_CMAC _ns1__MyEndpointStatusRequest {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__MyEndpointStatusRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__MyEndpointStatusRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__MyEndpointStatusRequest, default initialized and not managed by a soap context
        virtual _ns1__MyEndpointStatusRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__MyEndpointStatusRequest); }
      public:
        /// Constructor with initializations
        _ns1__MyEndpointStatusRequest()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__MyEndpointStatusRequest() { }
        /// Friend allocator used by soap_new__ns1__MyEndpointStatusRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__MyEndpointStatusRequest * SOAP_FMAC2 soap_instantiate__ns1__MyEndpointStatusRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:238 */
#ifndef SOAP_TYPE__ns1__MyEndpointStatusResponse
#define SOAP_TYPE__ns1__MyEndpointStatusResponse (40)
/* complex XSD type 'ns1:MyEndpointStatusResponse': */
class SOAP_CMAC _ns1__MyEndpointStatusResponse {
      public:
        /// Required element 'ns1:MemberStatus' of XSD type 'ns1:MemberStatus'
        enum _ns1__MemberStatus MemberStatus;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__MyEndpointStatusResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__MyEndpointStatusResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__MyEndpointStatusResponse, default initialized and not managed by a soap context
        virtual _ns1__MyEndpointStatusResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__MyEndpointStatusResponse); }
      public:
        /// Constructor with initializations
        _ns1__MyEndpointStatusResponse()
        {
          MemberStatus = (enum _ns1__MemberStatus)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__MyEndpointStatusResponse() { }
        /// Friend allocator used by soap_new__ns1__MyEndpointStatusResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__MyEndpointStatusResponse * SOAP_FMAC2 soap_instantiate__ns1__MyEndpointStatusResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:241 */
#ifndef SOAP_TYPE__ns1__SearchMyContactsRequest
#define SOAP_TYPE__ns1__SearchMyContactsRequest (41)
/* complex XSD type 'ns1:SearchMyContactsRequest': */
class SOAP_CMAC _ns1__SearchMyContactsRequest {
      public:
        /// Optional element 'ns1:Filter' of XSD type 'ns1:Filter'
        _ns1__Filter *Filter;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SearchMyContactsRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SearchMyContactsRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SearchMyContactsRequest, default initialized and not managed by a soap context
        virtual _ns1__SearchMyContactsRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__SearchMyContactsRequest); }
      public:
        /// Constructor with initializations
        _ns1__SearchMyContactsRequest()
        {
          Filter = (_ns1__Filter *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SearchMyContactsRequest() { }
        /// Friend allocator used by soap_new__ns1__SearchMyContactsRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SearchMyContactsRequest * SOAP_FMAC2 soap_instantiate__ns1__SearchMyContactsRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:244 */
#ifndef SOAP_TYPE__ns1__SearchMyContactsResponse
#define SOAP_TYPE__ns1__SearchMyContactsResponse (42)
/* complex XSD type 'ns1:SearchMyContactsResponse': */
class SOAP_CMAC _ns1__SearchMyContactsResponse {
      public:
        /// Required element 'ns1:total' of XSD type 'xsd:int'
        int total;
        /// Sequence of elements 'ns1:Entity' of XSD type 'ns1:Entity' stored in dynamic array Entity of length __sizeEntity
        int __sizeEntity;
        _ns1__Entity **Entity;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SearchMyContactsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SearchMyContactsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SearchMyContactsResponse, default initialized and not managed by a soap context
        virtual _ns1__SearchMyContactsResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SearchMyContactsResponse); }
      public:
        /// Constructor with initializations
        _ns1__SearchMyContactsResponse()
        {
          total = (int)0;
          __sizeEntity = 0;
          Entity = NULL;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SearchMyContactsResponse() { }
        /// Friend allocator used by soap_new__ns1__SearchMyContactsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SearchMyContactsResponse * SOAP_FMAC2 soap_instantiate__ns1__SearchMyContactsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:247 */
#ifndef SOAP_TYPE__ns1__AddToMyContactsRequest
#define SOAP_TYPE__ns1__AddToMyContactsRequest (43)
/* complex XSD type 'ns1:AddToMyContactsRequest': */
class SOAP_CMAC _ns1__AddToMyContactsRequest {
      public:
        /// Required element 'ns1:entityID' of XSD type 'ns1:EntityID'
        char *entityID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__AddToMyContactsRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__AddToMyContactsRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__AddToMyContactsRequest, default initialized and not managed by a soap context
        virtual _ns1__AddToMyContactsRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__AddToMyContactsRequest); }
      public:
        /// Constructor with initializations
        _ns1__AddToMyContactsRequest()
        {
          entityID = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__AddToMyContactsRequest() { }
        /// Friend allocator used by soap_new__ns1__AddToMyContactsRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__AddToMyContactsRequest * SOAP_FMAC2 soap_instantiate__ns1__AddToMyContactsRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:250 */
#ifndef SOAP_TYPE__ns1__AddToMyContactsResponse
#define SOAP_TYPE__ns1__AddToMyContactsResponse (44)
/* complex XSD type 'ns1:AddToMyContactsResponse': */
class SOAP_CMAC _ns1__AddToMyContactsResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__AddToMyContactsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__AddToMyContactsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__AddToMyContactsResponse, default initialized and not managed by a soap context
        virtual _ns1__AddToMyContactsResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__AddToMyContactsResponse); }
      public:
        /// Constructor with initializations
        _ns1__AddToMyContactsResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__AddToMyContactsResponse() { }
        /// Friend allocator used by soap_new__ns1__AddToMyContactsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__AddToMyContactsResponse * SOAP_FMAC2 soap_instantiate__ns1__AddToMyContactsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:253 */
#ifndef SOAP_TYPE__ns1__RemoveFromMyContactsRequest
#define SOAP_TYPE__ns1__RemoveFromMyContactsRequest (45)
/* complex XSD type 'ns1:RemoveFromMyContactsRequest': */
class SOAP_CMAC _ns1__RemoveFromMyContactsRequest {
      public:
        /// Required element 'ns1:entityID' of XSD type 'ns1:EntityID'
        char *entityID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RemoveFromMyContactsRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__RemoveFromMyContactsRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RemoveFromMyContactsRequest, default initialized and not managed by a soap context
        virtual _ns1__RemoveFromMyContactsRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__RemoveFromMyContactsRequest); }
      public:
        /// Constructor with initializations
        _ns1__RemoveFromMyContactsRequest()
        {
          entityID = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__RemoveFromMyContactsRequest() { }
        /// Friend allocator used by soap_new__ns1__RemoveFromMyContactsRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RemoveFromMyContactsRequest * SOAP_FMAC2 soap_instantiate__ns1__RemoveFromMyContactsRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:256 */
#ifndef SOAP_TYPE__ns1__RemoveFromMyContactsResponse
#define SOAP_TYPE__ns1__RemoveFromMyContactsResponse (46)
/* complex XSD type 'ns1:RemoveFromMyContactsResponse': */
class SOAP_CMAC _ns1__RemoveFromMyContactsResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RemoveFromMyContactsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__RemoveFromMyContactsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RemoveFromMyContactsResponse, default initialized and not managed by a soap context
        virtual _ns1__RemoveFromMyContactsResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__RemoveFromMyContactsResponse); }
      public:
        /// Constructor with initializations
        _ns1__RemoveFromMyContactsResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__RemoveFromMyContactsResponse() { }
        /// Friend allocator used by soap_new__ns1__RemoveFromMyContactsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RemoveFromMyContactsResponse * SOAP_FMAC2 soap_instantiate__ns1__RemoveFromMyContactsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:259 */
#ifndef SOAP_TYPE__ns1__SearchRequest
#define SOAP_TYPE__ns1__SearchRequest (47)
/* complex XSD type 'ns1:SearchRequest': */
class SOAP_CMAC _ns1__SearchRequest {
      public:
        /// Required element 'ns1:Filter' of XSD type 'ns1:Filter'
        _ns1__Filter *Filter;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SearchRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SearchRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SearchRequest, default initialized and not managed by a soap context
        virtual _ns1__SearchRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__SearchRequest); }
      public:
        /// Constructor with initializations
        _ns1__SearchRequest()
        {
          Filter = (_ns1__Filter *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SearchRequest() { }
        /// Friend allocator used by soap_new__ns1__SearchRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SearchRequest * SOAP_FMAC2 soap_instantiate__ns1__SearchRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:262 */
#ifndef SOAP_TYPE__ns1__SearchResponse
#define SOAP_TYPE__ns1__SearchResponse (48)
/* complex XSD type 'ns1:SearchResponse': */
class SOAP_CMAC _ns1__SearchResponse {
      public:
        /// Required element 'ns1:total' of XSD type 'xsd:int'
        int total;
        /// Sequence of elements 'ns1:Entity' of XSD type 'ns1:Entity' stored in dynamic array Entity of length __sizeEntity
        int __sizeEntity;
        _ns1__Entity **Entity;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SearchResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SearchResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SearchResponse, default initialized and not managed by a soap context
        virtual _ns1__SearchResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SearchResponse); }
      public:
        /// Constructor with initializations
        _ns1__SearchResponse()
        {
          total = (int)0;
          __sizeEntity = 0;
          Entity = NULL;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SearchResponse() { }
        /// Friend allocator used by soap_new__ns1__SearchResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SearchResponse * SOAP_FMAC2 soap_instantiate__ns1__SearchResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:265 */
#ifndef SOAP_TYPE__ns1__SearchByEntityIDRequest
#define SOAP_TYPE__ns1__SearchByEntityIDRequest (49)
/* complex XSD type 'ns1:SearchByEntityIDRequest': */
class SOAP_CMAC _ns1__SearchByEntityIDRequest {
      public:
        /// Required element 'ns1:entityID' of XSD type 'ns1:EntityID'
        char *entityID;
        /// Optional element 'ns1:Filter' of XSD type 'ns1:Filter'
        _ns1__Filter *Filter;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SearchByEntityIDRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SearchByEntityIDRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SearchByEntityIDRequest, default initialized and not managed by a soap context
        virtual _ns1__SearchByEntityIDRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__SearchByEntityIDRequest); }
      public:
        /// Constructor with initializations
        _ns1__SearchByEntityIDRequest()
        {
          entityID = (char *)0;
          Filter = (_ns1__Filter *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SearchByEntityIDRequest() { }
        /// Friend allocator used by soap_new__ns1__SearchByEntityIDRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SearchByEntityIDRequest * SOAP_FMAC2 soap_instantiate__ns1__SearchByEntityIDRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:268 */
#ifndef SOAP_TYPE__ns1__SearchByEntityIDResponse
#define SOAP_TYPE__ns1__SearchByEntityIDResponse (50)
/* complex XSD type 'ns1:SearchByEntityIDResponse': */
class SOAP_CMAC _ns1__SearchByEntityIDResponse {
      public:
        /// Required element 'ns1:total' of XSD type 'xsd:int'
        int total;
        /// Sequence of elements 'ns1:Entity' of XSD type 'ns1:Entity' stored in dynamic array Entity of length __sizeEntity
        int __sizeEntity;
        _ns1__Entity **Entity;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SearchByEntityIDResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SearchByEntityIDResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SearchByEntityIDResponse, default initialized and not managed by a soap context
        virtual _ns1__SearchByEntityIDResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SearchByEntityIDResponse); }
      public:
        /// Constructor with initializations
        _ns1__SearchByEntityIDResponse()
        {
          total = (int)0;
          __sizeEntity = 0;
          Entity = NULL;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SearchByEntityIDResponse() { }
        /// Friend allocator used by soap_new__ns1__SearchByEntityIDResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SearchByEntityIDResponse * SOAP_FMAC2 soap_instantiate__ns1__SearchByEntityIDResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:271 */
#ifndef SOAP_TYPE__ns1__SearchByEmailRequest
#define SOAP_TYPE__ns1__SearchByEmailRequest (51)
/* complex XSD type 'ns1:SearchByEmailRequest': */
class SOAP_CMAC _ns1__SearchByEmailRequest {
      public:
        /// Required element 'ns1:emailAddress' of XSD type 'xsd:string'
        char *emailAddress;
        /// Optional element 'ns1:Filter' of XSD type 'ns1:Filter'
        _ns1__Filter *Filter;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SearchByEmailRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SearchByEmailRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SearchByEmailRequest, default initialized and not managed by a soap context
        virtual _ns1__SearchByEmailRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__SearchByEmailRequest); }
      public:
        /// Constructor with initializations
        _ns1__SearchByEmailRequest()
        {
          emailAddress = (char *)0;
          Filter = (_ns1__Filter *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SearchByEmailRequest() { }
        /// Friend allocator used by soap_new__ns1__SearchByEmailRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SearchByEmailRequest * SOAP_FMAC2 soap_instantiate__ns1__SearchByEmailRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:274 */
#ifndef SOAP_TYPE__ns1__SearchByEmailResponse
#define SOAP_TYPE__ns1__SearchByEmailResponse (52)
/* complex XSD type 'ns1:SearchByEmailResponse': */
class SOAP_CMAC _ns1__SearchByEmailResponse {
      public:
        /// Required element 'ns1:total' of XSD type 'xsd:int'
        int total;
        /// Sequence of elements 'ns1:Entity' of XSD type 'ns1:Entity' stored in dynamic array Entity of length __sizeEntity
        int __sizeEntity;
        _ns1__Entity **Entity;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SearchByEmailResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SearchByEmailResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SearchByEmailResponse, default initialized and not managed by a soap context
        virtual _ns1__SearchByEmailResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SearchByEmailResponse); }
      public:
        /// Constructor with initializations
        _ns1__SearchByEmailResponse()
        {
          total = (int)0;
          __sizeEntity = 0;
          Entity = NULL;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SearchByEmailResponse() { }
        /// Friend allocator used by soap_new__ns1__SearchByEmailResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SearchByEmailResponse * SOAP_FMAC2 soap_instantiate__ns1__SearchByEmailResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:277 */
#ifndef SOAP_TYPE__ns1__GetEntityByEntityIDRequest
#define SOAP_TYPE__ns1__GetEntityByEntityIDRequest (53)
/* complex XSD type 'ns1:GetEntityByEntityIDRequest': */
class SOAP_CMAC _ns1__GetEntityByEntityIDRequest {
      public:
        /// Sequence of 1 to 200 elements 'ns1:entityID' of XSD type 'ns1:EntityID' stored in dynamic array entityID of length __sizeentityID
        int __sizeentityID;
        char **entityID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetEntityByEntityIDRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetEntityByEntityIDRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetEntityByEntityIDRequest, default initialized and not managed by a soap context
        virtual _ns1__GetEntityByEntityIDRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__GetEntityByEntityIDRequest); }
      public:
        /// Constructor with initializations
        _ns1__GetEntityByEntityIDRequest()
        {
          __sizeentityID = 0;
          entityID = NULL;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetEntityByEntityIDRequest() { }
        /// Friend allocator used by soap_new__ns1__GetEntityByEntityIDRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetEntityByEntityIDRequest * SOAP_FMAC2 soap_instantiate__ns1__GetEntityByEntityIDRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:280 */
#ifndef SOAP_TYPE__ns1__GetEntityByEntityIDResponse
#define SOAP_TYPE__ns1__GetEntityByEntityIDResponse (54)
/* complex XSD type 'ns1:GetEntityByEntityIDResponse': */
class SOAP_CMAC _ns1__GetEntityByEntityIDResponse {
      public:
        /// Required element 'ns1:total' of XSD type 'xsd:int'
        int total;
        /// Sequence of elements 'ns1:Entity' of XSD type 'ns1:Entity' stored in dynamic array Entity of length __sizeEntity
        int __sizeEntity;
        _ns1__Entity **Entity;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetEntityByEntityIDResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetEntityByEntityIDResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetEntityByEntityIDResponse, default initialized and not managed by a soap context
        virtual _ns1__GetEntityByEntityIDResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetEntityByEntityIDResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetEntityByEntityIDResponse()
        {
          total = (int)0;
          __sizeEntity = 0;
          Entity = NULL;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetEntityByEntityIDResponse() { }
        /// Friend allocator used by soap_new__ns1__GetEntityByEntityIDResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetEntityByEntityIDResponse * SOAP_FMAC2 soap_instantiate__ns1__GetEntityByEntityIDResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:2448 */
#ifndef SOAP_TYPE__ns1__union_InviteToConferenceRequest
#define SOAP_TYPE__ns1__union_InviteToConferenceRequest (237)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns1__union_InviteToConferenceRequest
{
        #define SOAP_UNION__ns1__union_InviteToConferenceRequest_entityID	(1)	/**< union variant selector value for member entityID */
        char *entityID;
        #define SOAP_UNION__ns1__union_InviteToConferenceRequest_invite	(2)	/**< union variant selector value for member invite */
        char *invite;
};
#endif

/* WSVidyoUser.h:283 */
#ifndef SOAP_TYPE__ns1__InviteToConferenceRequest
#define SOAP_TYPE__ns1__InviteToConferenceRequest (55)
/* complex XSD type 'ns1:InviteToConferenceRequest': */
class SOAP_CMAC _ns1__InviteToConferenceRequest {
      public:
        /// Required element 'ns1:conferenceID' of XSD type 'ns1:EntityID'
        char *conferenceID;
        /// Union with union _ns1__union_InviteToConferenceRequest variant selector __union_InviteToConferenceRequest set to one of: SOAP_UNION__ns1__union_InviteToConferenceRequest_entityID SOAP_UNION__ns1__union_InviteToConferenceRequest_invite
        int __union_InviteToConferenceRequest;
        union _ns1__union_InviteToConferenceRequest union_InviteToConferenceRequest;
        /// Optional element 'ns1:moderatorPIN' of XSD type 'xsd:string'
        char *moderatorPIN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InviteToConferenceRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InviteToConferenceRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InviteToConferenceRequest, default initialized and not managed by a soap context
        virtual _ns1__InviteToConferenceRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__InviteToConferenceRequest); }
      public:
        /// Constructor with initializations
        _ns1__InviteToConferenceRequest()
        {
          conferenceID = (char *)0;
          __union_InviteToConferenceRequest = -1;
          moderatorPIN = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__InviteToConferenceRequest() { }
        /// Friend allocator used by soap_new__ns1__InviteToConferenceRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InviteToConferenceRequest * SOAP_FMAC2 soap_instantiate__ns1__InviteToConferenceRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:286 */
#ifndef SOAP_TYPE__ns1__InviteToConferenceResponse
#define SOAP_TYPE__ns1__InviteToConferenceResponse (56)
/* complex XSD type 'ns1:InviteToConferenceResponse': */
class SOAP_CMAC _ns1__InviteToConferenceResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InviteToConferenceResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InviteToConferenceResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InviteToConferenceResponse, default initialized and not managed by a soap context
        virtual _ns1__InviteToConferenceResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__InviteToConferenceResponse); }
      public:
        /// Constructor with initializations
        _ns1__InviteToConferenceResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__InviteToConferenceResponse() { }
        /// Friend allocator used by soap_new__ns1__InviteToConferenceResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InviteToConferenceResponse * SOAP_FMAC2 soap_instantiate__ns1__InviteToConferenceResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:289 */
#ifndef SOAP_TYPE__ns1__CancelOutboundCallRequest
#define SOAP_TYPE__ns1__CancelOutboundCallRequest (57)
/* complex XSD type 'ns1:CancelOutboundCallRequest': */
class SOAP_CMAC _ns1__CancelOutboundCallRequest {
      public:
        /// Required element 'ns1:conferenceID' of XSD type 'ns1:EntityID'
        char *conferenceID;
        /// Required element 'ns1:entityID' of XSD type 'ns1:EntityID'
        char *entityID;
        /// Optional element 'ns1:moderatorPIN' of XSD type 'xsd:string'
        char *moderatorPIN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CancelOutboundCallRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CancelOutboundCallRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CancelOutboundCallRequest, default initialized and not managed by a soap context
        virtual _ns1__CancelOutboundCallRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__CancelOutboundCallRequest); }
      public:
        /// Constructor with initializations
        _ns1__CancelOutboundCallRequest()
        {
          conferenceID = (char *)0;
          entityID = (char *)0;
          moderatorPIN = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__CancelOutboundCallRequest() { }
        /// Friend allocator used by soap_new__ns1__CancelOutboundCallRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CancelOutboundCallRequest * SOAP_FMAC2 soap_instantiate__ns1__CancelOutboundCallRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:292 */
#ifndef SOAP_TYPE__ns1__CancelOutboundCallResponse
#define SOAP_TYPE__ns1__CancelOutboundCallResponse (58)
/* complex XSD type 'ns1:CancelOutboundCallResponse': */
class SOAP_CMAC _ns1__CancelOutboundCallResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CancelOutboundCallResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CancelOutboundCallResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CancelOutboundCallResponse, default initialized and not managed by a soap context
        virtual _ns1__CancelOutboundCallResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__CancelOutboundCallResponse); }
      public:
        /// Constructor with initializations
        _ns1__CancelOutboundCallResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__CancelOutboundCallResponse() { }
        /// Friend allocator used by soap_new__ns1__CancelOutboundCallResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CancelOutboundCallResponse * SOAP_FMAC2 soap_instantiate__ns1__CancelOutboundCallResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:2559 */
#ifndef SOAP_TYPE__ns1__union_JoinConferenceRequest
#define SOAP_TYPE__ns1__union_JoinConferenceRequest (238)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns1__union_JoinConferenceRequest
{
        #define SOAP_UNION__ns1__union_JoinConferenceRequest_conferenceID	(1)	/**< union variant selector value for member conferenceID */
        char *conferenceID;
        #define SOAP_UNION__ns1__union_JoinConferenceRequest_extension	(2)	/**< union variant selector value for member extension */
        char *extension;
};
#endif

/* WSVidyoUser.h:295 */
#ifndef SOAP_TYPE__ns1__JoinConferenceRequest
#define SOAP_TYPE__ns1__JoinConferenceRequest (59)
/* complex XSD type 'ns1:JoinConferenceRequest': */
class SOAP_CMAC _ns1__JoinConferenceRequest {
      public:
        /// Union with union _ns1__union_JoinConferenceRequest variant selector __union_JoinConferenceRequest set to one of: SOAP_UNION__ns1__union_JoinConferenceRequest_conferenceID SOAP_UNION__ns1__union_JoinConferenceRequest_extension
        int __union_JoinConferenceRequest;
        union _ns1__union_JoinConferenceRequest union_JoinConferenceRequest;
        /// Optional element 'ns1:PIN' of XSD type 'xsd:string'
        char *PIN;
        /// Optional element 'ns1:referenceNumber' of XSD type 'xsd:string'
        char *referenceNumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__JoinConferenceRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__JoinConferenceRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__JoinConferenceRequest, default initialized and not managed by a soap context
        virtual _ns1__JoinConferenceRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__JoinConferenceRequest); }
      public:
        /// Constructor with initializations
        _ns1__JoinConferenceRequest()
        {
          __union_JoinConferenceRequest = -1;
          PIN = (char *)0;
          referenceNumber = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__JoinConferenceRequest() { }
        /// Friend allocator used by soap_new__ns1__JoinConferenceRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__JoinConferenceRequest * SOAP_FMAC2 soap_instantiate__ns1__JoinConferenceRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:298 */
#ifndef SOAP_TYPE__ns1__JoinConferenceResponse
#define SOAP_TYPE__ns1__JoinConferenceResponse (60)
/* complex XSD type 'ns1:JoinConferenceResponse': */
class SOAP_CMAC _ns1__JoinConferenceResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__JoinConferenceResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__JoinConferenceResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__JoinConferenceResponse, default initialized and not managed by a soap context
        virtual _ns1__JoinConferenceResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__JoinConferenceResponse); }
      public:
        /// Constructor with initializations
        _ns1__JoinConferenceResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__JoinConferenceResponse() { }
        /// Friend allocator used by soap_new__ns1__JoinConferenceResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__JoinConferenceResponse * SOAP_FMAC2 soap_instantiate__ns1__JoinConferenceResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:301 */
#ifndef SOAP_TYPE__ns1__JoinIPCConferenceRequest
#define SOAP_TYPE__ns1__JoinIPCConferenceRequest (61)
/* complex XSD type 'ns1:JoinIPCConferenceRequest': */
class SOAP_CMAC _ns1__JoinIPCConferenceRequest {
      public:
        /// Required element 'ns1:local-part' of XSD type 'xsd:string'
        char *local_part;
        /// Required element 'ns1:domain' of XSD type 'xsd:string'
        char *domain;
        /// Optional element 'ns1:PIN' of XSD type 'xsd:string'
        char *PIN;
        /// Optional element 'ns1:referenceNumber' of XSD type 'xsd:string'
        char *referenceNumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__JoinIPCConferenceRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__JoinIPCConferenceRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__JoinIPCConferenceRequest, default initialized and not managed by a soap context
        virtual _ns1__JoinIPCConferenceRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__JoinIPCConferenceRequest); }
      public:
        /// Constructor with initializations
        _ns1__JoinIPCConferenceRequest()
        {
          local_part = (char *)0;
          domain = (char *)0;
          PIN = (char *)0;
          referenceNumber = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__JoinIPCConferenceRequest() { }
        /// Friend allocator used by soap_new__ns1__JoinIPCConferenceRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__JoinIPCConferenceRequest * SOAP_FMAC2 soap_instantiate__ns1__JoinIPCConferenceRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:304 */
#ifndef SOAP_TYPE__ns1__JoinIPCConferenceResponse
#define SOAP_TYPE__ns1__JoinIPCConferenceResponse (62)
/* complex XSD type 'ns1:JoinIPCConferenceResponse': */
class SOAP_CMAC _ns1__JoinIPCConferenceResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__JoinIPCConferenceResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__JoinIPCConferenceResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__JoinIPCConferenceResponse, default initialized and not managed by a soap context
        virtual _ns1__JoinIPCConferenceResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__JoinIPCConferenceResponse); }
      public:
        /// Constructor with initializations
        _ns1__JoinIPCConferenceResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__JoinIPCConferenceResponse() { }
        /// Friend allocator used by soap_new__ns1__JoinIPCConferenceResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__JoinIPCConferenceResponse * SOAP_FMAC2 soap_instantiate__ns1__JoinIPCConferenceResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:2677 */
#ifndef SOAP_TYPE__ns1__union_DirectCallRequest
#define SOAP_TYPE__ns1__union_DirectCallRequest (239)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns1__union_DirectCallRequest
{
        #define SOAP_UNION__ns1__union_DirectCallRequest_entityID	(1)	/**< union variant selector value for member entityID */
        char *entityID;
        #define SOAP_UNION__ns1__union_DirectCallRequest_invite	(2)	/**< union variant selector value for member invite */
        char *invite;
};
#endif

/* WSVidyoUser.h:307 */
#ifndef SOAP_TYPE__ns1__DirectCallRequest
#define SOAP_TYPE__ns1__DirectCallRequest (63)
/* Choice: */
class SOAP_CMAC _ns1__DirectCallRequest {
      public:
        /// Union with union _ns1__union_DirectCallRequest variant selector __union_DirectCallRequest set to one of: SOAP_UNION__ns1__union_DirectCallRequest_entityID SOAP_UNION__ns1__union_DirectCallRequest_invite
        int __union_DirectCallRequest;
        union _ns1__union_DirectCallRequest union_DirectCallRequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DirectCallRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__DirectCallRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DirectCallRequest, default initialized and not managed by a soap context
        virtual _ns1__DirectCallRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__DirectCallRequest); }
      public:
        /// Constructor with initializations
        _ns1__DirectCallRequest()
        {
          __union_DirectCallRequest = -1;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__DirectCallRequest() { }
        /// Friend allocator used by soap_new__ns1__DirectCallRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DirectCallRequest * SOAP_FMAC2 soap_instantiate__ns1__DirectCallRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:310 */
#ifndef SOAP_TYPE__ns1__DirectCallResponse
#define SOAP_TYPE__ns1__DirectCallResponse (64)
/* complex XSD type 'ns1:DirectCallResponse': */
class SOAP_CMAC _ns1__DirectCallResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DirectCallResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__DirectCallResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DirectCallResponse, default initialized and not managed by a soap context
        virtual _ns1__DirectCallResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__DirectCallResponse); }
      public:
        /// Constructor with initializations
        _ns1__DirectCallResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__DirectCallResponse() { }
        /// Friend allocator used by soap_new__ns1__DirectCallResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DirectCallResponse * SOAP_FMAC2 soap_instantiate__ns1__DirectCallResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:313 */
#ifndef SOAP_TYPE__ns1__GetParticipantsRequest
#define SOAP_TYPE__ns1__GetParticipantsRequest (65)
/* complex XSD type 'ns1:GetParticipantsRequest': */
class SOAP_CMAC _ns1__GetParticipantsRequest {
      public:
        /// Required element 'ns1:conferenceID' of XSD type 'ns1:EntityID'
        char *conferenceID;
        /// Optional element 'ns1:Filter' of XSD type 'ns1:Filter'
        _ns1__Filter *Filter;
        /// Optional element 'ns1:moderatorPIN' of XSD type 'xsd:string'
        char *moderatorPIN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetParticipantsRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetParticipantsRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetParticipantsRequest, default initialized and not managed by a soap context
        virtual _ns1__GetParticipantsRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__GetParticipantsRequest); }
      public:
        /// Constructor with initializations
        _ns1__GetParticipantsRequest()
        {
          conferenceID = (char *)0;
          Filter = (_ns1__Filter *)0;
          moderatorPIN = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetParticipantsRequest() { }
        /// Friend allocator used by soap_new__ns1__GetParticipantsRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetParticipantsRequest * SOAP_FMAC2 soap_instantiate__ns1__GetParticipantsRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:316 */
#ifndef SOAP_TYPE__ns1__GetParticipantsResponse
#define SOAP_TYPE__ns1__GetParticipantsResponse (66)
/* complex XSD type 'ns1:GetParticipantsResponse': */
class SOAP_CMAC _ns1__GetParticipantsResponse {
      public:
        /// Required element 'ns1:total' of XSD type 'xsd:int'
        int total;
        /// Optional element 'ns1:recorderID' of XSD type 'xsd:int'
        int *recorderID;
        /// Optional element 'ns1:recorderName' of XSD type 'xsd:string'
        char *recorderName;
        /// Optional element 'ns1:paused' of XSD type 'xsd:boolean'
        bool *paused;
        /// Optional element 'ns1:webcast' of XSD type 'xsd:boolean'
        bool *webcast;
        /// Sequence of elements 'ns1:Entity' of XSD type 'ns1:Entity' stored in dynamic array Entity of length __sizeEntity
        int __sizeEntity;
        _ns1__Entity **Entity;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetParticipantsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetParticipantsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetParticipantsResponse, default initialized and not managed by a soap context
        virtual _ns1__GetParticipantsResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetParticipantsResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetParticipantsResponse()
        {
          total = (int)0;
          recorderID = (int *)0;
          recorderName = (char *)0;
          paused = (bool *)0;
          webcast = (bool *)0;
          __sizeEntity = 0;
          Entity = NULL;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetParticipantsResponse() { }
        /// Friend allocator used by soap_new__ns1__GetParticipantsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetParticipantsResponse * SOAP_FMAC2 soap_instantiate__ns1__GetParticipantsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:319 */
#ifndef SOAP_TYPE__ns1__GetLectureModeParticipantsRequest
#define SOAP_TYPE__ns1__GetLectureModeParticipantsRequest (67)
/* complex XSD type 'ns1:GetLectureModeParticipantsRequest': */
class SOAP_CMAC _ns1__GetLectureModeParticipantsRequest {
      public:
        /// Required element 'ns1:conferenceID' of XSD type 'ns1:EntityID'
        char *conferenceID;
        /// Optional element 'ns1:Filter' of XSD type 'ns1:Filter'
        _ns1__Filter *Filter;
        /// Optional element 'ns1:moderatorPIN' of XSD type 'xsd:string'
        char *moderatorPIN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetLectureModeParticipantsRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetLectureModeParticipantsRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetLectureModeParticipantsRequest, default initialized and not managed by a soap context
        virtual _ns1__GetLectureModeParticipantsRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__GetLectureModeParticipantsRequest); }
      public:
        /// Constructor with initializations
        _ns1__GetLectureModeParticipantsRequest()
        {
          conferenceID = (char *)0;
          Filter = (_ns1__Filter *)0;
          moderatorPIN = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetLectureModeParticipantsRequest() { }
        /// Friend allocator used by soap_new__ns1__GetLectureModeParticipantsRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetLectureModeParticipantsRequest * SOAP_FMAC2 soap_instantiate__ns1__GetLectureModeParticipantsRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:322 */
#ifndef SOAP_TYPE__ns1__GetLectureModeParticipantsResponse
#define SOAP_TYPE__ns1__GetLectureModeParticipantsResponse (68)
/* complex XSD type 'ns1:GetLectureModeParticipantsResponse': */
class SOAP_CMAC _ns1__GetLectureModeParticipantsResponse {
      public:
        /// Required element 'ns1:total' of XSD type 'xsd:int'
        int total;
        /// Optional element 'ns1:recorderID' of XSD type 'xsd:int'
        int *recorderID;
        /// Optional element 'ns1:recorderName' of XSD type 'xsd:string'
        char *recorderName;
        /// Optional element 'ns1:paused' of XSD type 'xsd:boolean'
        bool *paused;
        /// Optional element 'ns1:webcast' of XSD type 'xsd:boolean'
        bool *webcast;
        /// Optional element 'ns1:lectureMode' of XSD type 'xsd:boolean'
        bool *lectureMode;
        /// Sequence of elements 'ns1:LectureModeParticipant' of XSD type 'ns1:LectureModeParticipant' stored in dynamic array LectureModeParticipant of length __sizeLectureModeParticipant
        int __sizeLectureModeParticipant;
        _ns1__LectureModeParticipant **LectureModeParticipant;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetLectureModeParticipantsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetLectureModeParticipantsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetLectureModeParticipantsResponse, default initialized and not managed by a soap context
        virtual _ns1__GetLectureModeParticipantsResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetLectureModeParticipantsResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetLectureModeParticipantsResponse()
        {
          total = (int)0;
          recorderID = (int *)0;
          recorderName = (char *)0;
          paused = (bool *)0;
          webcast = (bool *)0;
          lectureMode = (bool *)0;
          __sizeLectureModeParticipant = 0;
          LectureModeParticipant = NULL;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetLectureModeParticipantsResponse() { }
        /// Friend allocator used by soap_new__ns1__GetLectureModeParticipantsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetLectureModeParticipantsResponse * SOAP_FMAC2 soap_instantiate__ns1__GetLectureModeParticipantsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:325 */
#ifndef SOAP_TYPE__ns1__LeaveConferenceRequest
#define SOAP_TYPE__ns1__LeaveConferenceRequest (69)
/* complex XSD type 'ns1:LeaveConferenceRequest': */
class SOAP_CMAC _ns1__LeaveConferenceRequest {
      public:
        /// Required element 'ns1:conferenceID' of XSD type 'ns1:EntityID'
        char *conferenceID;
        /// Required element 'ns1:participantID' of XSD type 'ns1:EntityID'
        char *participantID;
        /// Optional element 'ns1:moderatorPIN' of XSD type 'xsd:string'
        char *moderatorPIN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__LeaveConferenceRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__LeaveConferenceRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__LeaveConferenceRequest, default initialized and not managed by a soap context
        virtual _ns1__LeaveConferenceRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__LeaveConferenceRequest); }
      public:
        /// Constructor with initializations
        _ns1__LeaveConferenceRequest()
        {
          conferenceID = (char *)0;
          participantID = (char *)0;
          moderatorPIN = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__LeaveConferenceRequest() { }
        /// Friend allocator used by soap_new__ns1__LeaveConferenceRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__LeaveConferenceRequest * SOAP_FMAC2 soap_instantiate__ns1__LeaveConferenceRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:328 */
#ifndef SOAP_TYPE__ns1__LeaveConferenceResponse
#define SOAP_TYPE__ns1__LeaveConferenceResponse (70)
/* complex XSD type 'ns1:LeaveConferenceResponse': */
class SOAP_CMAC _ns1__LeaveConferenceResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__LeaveConferenceResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__LeaveConferenceResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__LeaveConferenceResponse, default initialized and not managed by a soap context
        virtual _ns1__LeaveConferenceResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__LeaveConferenceResponse); }
      public:
        /// Constructor with initializations
        _ns1__LeaveConferenceResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__LeaveConferenceResponse() { }
        /// Friend allocator used by soap_new__ns1__LeaveConferenceResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__LeaveConferenceResponse * SOAP_FMAC2 soap_instantiate__ns1__LeaveConferenceResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:331 */
#ifndef SOAP_TYPE__ns1__MuteAudioRequest
#define SOAP_TYPE__ns1__MuteAudioRequest (71)
/* complex XSD type 'ns1:MuteAudioRequest': */
class SOAP_CMAC _ns1__MuteAudioRequest {
      public:
        /// Required element 'ns1:conferenceID' of XSD type 'ns1:EntityID'
        char *conferenceID;
        /// Required element 'ns1:participantID' of XSD type 'ns1:EntityID'
        char *participantID;
        /// Optional element 'ns1:moderatorPIN' of XSD type 'xsd:string'
        char *moderatorPIN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__MuteAudioRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__MuteAudioRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__MuteAudioRequest, default initialized and not managed by a soap context
        virtual _ns1__MuteAudioRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__MuteAudioRequest); }
      public:
        /// Constructor with initializations
        _ns1__MuteAudioRequest()
        {
          conferenceID = (char *)0;
          participantID = (char *)0;
          moderatorPIN = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__MuteAudioRequest() { }
        /// Friend allocator used by soap_new__ns1__MuteAudioRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__MuteAudioRequest * SOAP_FMAC2 soap_instantiate__ns1__MuteAudioRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:334 */
#ifndef SOAP_TYPE__ns1__MuteAudioResponse
#define SOAP_TYPE__ns1__MuteAudioResponse (72)
/* complex XSD type 'ns1:MuteAudioResponse': */
class SOAP_CMAC _ns1__MuteAudioResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__MuteAudioResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__MuteAudioResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__MuteAudioResponse, default initialized and not managed by a soap context
        virtual _ns1__MuteAudioResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__MuteAudioResponse); }
      public:
        /// Constructor with initializations
        _ns1__MuteAudioResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__MuteAudioResponse() { }
        /// Friend allocator used by soap_new__ns1__MuteAudioResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__MuteAudioResponse * SOAP_FMAC2 soap_instantiate__ns1__MuteAudioResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:337 */
#ifndef SOAP_TYPE__ns1__UnmuteAudioRequest
#define SOAP_TYPE__ns1__UnmuteAudioRequest (73)
/* complex XSD type 'ns1:UnmuteAudioRequest': */
class SOAP_CMAC _ns1__UnmuteAudioRequest {
      public:
        /// Required element 'ns1:conferenceID' of XSD type 'ns1:EntityID'
        char *conferenceID;
        /// Required element 'ns1:participantID' of XSD type 'ns1:EntityID'
        char *participantID;
        /// Optional element 'ns1:moderatorPIN' of XSD type 'xsd:string'
        char *moderatorPIN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__UnmuteAudioRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__UnmuteAudioRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__UnmuteAudioRequest, default initialized and not managed by a soap context
        virtual _ns1__UnmuteAudioRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__UnmuteAudioRequest); }
      public:
        /// Constructor with initializations
        _ns1__UnmuteAudioRequest()
        {
          conferenceID = (char *)0;
          participantID = (char *)0;
          moderatorPIN = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__UnmuteAudioRequest() { }
        /// Friend allocator used by soap_new__ns1__UnmuteAudioRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__UnmuteAudioRequest * SOAP_FMAC2 soap_instantiate__ns1__UnmuteAudioRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:340 */
#ifndef SOAP_TYPE__ns1__UnmuteAudioResponse
#define SOAP_TYPE__ns1__UnmuteAudioResponse (74)
/* complex XSD type 'ns1:UnmuteAudioResponse': */
class SOAP_CMAC _ns1__UnmuteAudioResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__UnmuteAudioResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__UnmuteAudioResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__UnmuteAudioResponse, default initialized and not managed by a soap context
        virtual _ns1__UnmuteAudioResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__UnmuteAudioResponse); }
      public:
        /// Constructor with initializations
        _ns1__UnmuteAudioResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__UnmuteAudioResponse() { }
        /// Friend allocator used by soap_new__ns1__UnmuteAudioResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__UnmuteAudioResponse * SOAP_FMAC2 soap_instantiate__ns1__UnmuteAudioResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:343 */
#ifndef SOAP_TYPE__ns1__StartVideoRequest
#define SOAP_TYPE__ns1__StartVideoRequest (75)
/* complex XSD type 'ns1:StartVideoRequest': */
class SOAP_CMAC _ns1__StartVideoRequest {
      public:
        /// Required element 'ns1:conferenceID' of XSD type 'ns1:EntityID'
        char *conferenceID;
        /// Required element 'ns1:participantID' of XSD type 'ns1:EntityID'
        char *participantID;
        /// Optional element 'ns1:moderatorPIN' of XSD type 'xsd:string'
        char *moderatorPIN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__StartVideoRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__StartVideoRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__StartVideoRequest, default initialized and not managed by a soap context
        virtual _ns1__StartVideoRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__StartVideoRequest); }
      public:
        /// Constructor with initializations
        _ns1__StartVideoRequest()
        {
          conferenceID = (char *)0;
          participantID = (char *)0;
          moderatorPIN = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__StartVideoRequest() { }
        /// Friend allocator used by soap_new__ns1__StartVideoRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__StartVideoRequest * SOAP_FMAC2 soap_instantiate__ns1__StartVideoRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:346 */
#ifndef SOAP_TYPE__ns1__StartVideoResponse
#define SOAP_TYPE__ns1__StartVideoResponse (76)
/* complex XSD type 'ns1:StartVideoResponse': */
class SOAP_CMAC _ns1__StartVideoResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__StartVideoResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__StartVideoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__StartVideoResponse, default initialized and not managed by a soap context
        virtual _ns1__StartVideoResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__StartVideoResponse); }
      public:
        /// Constructor with initializations
        _ns1__StartVideoResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__StartVideoResponse() { }
        /// Friend allocator used by soap_new__ns1__StartVideoResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__StartVideoResponse * SOAP_FMAC2 soap_instantiate__ns1__StartVideoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:349 */
#ifndef SOAP_TYPE__ns1__StopVideoRequest
#define SOAP_TYPE__ns1__StopVideoRequest (77)
/* complex XSD type 'ns1:StopVideoRequest': */
class SOAP_CMAC _ns1__StopVideoRequest {
      public:
        /// Required element 'ns1:conferenceID' of XSD type 'ns1:EntityID'
        char *conferenceID;
        /// Required element 'ns1:participantID' of XSD type 'ns1:EntityID'
        char *participantID;
        /// Optional element 'ns1:moderatorPIN' of XSD type 'xsd:string'
        char *moderatorPIN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__StopVideoRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__StopVideoRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__StopVideoRequest, default initialized and not managed by a soap context
        virtual _ns1__StopVideoRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__StopVideoRequest); }
      public:
        /// Constructor with initializations
        _ns1__StopVideoRequest()
        {
          conferenceID = (char *)0;
          participantID = (char *)0;
          moderatorPIN = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__StopVideoRequest() { }
        /// Friend allocator used by soap_new__ns1__StopVideoRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__StopVideoRequest * SOAP_FMAC2 soap_instantiate__ns1__StopVideoRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:352 */
#ifndef SOAP_TYPE__ns1__StopVideoResponse
#define SOAP_TYPE__ns1__StopVideoResponse (78)
/* complex XSD type 'ns1:StopVideoResponse': */
class SOAP_CMAC _ns1__StopVideoResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__StopVideoResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__StopVideoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__StopVideoResponse, default initialized and not managed by a soap context
        virtual _ns1__StopVideoResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__StopVideoResponse); }
      public:
        /// Constructor with initializations
        _ns1__StopVideoResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__StopVideoResponse() { }
        /// Friend allocator used by soap_new__ns1__StopVideoResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__StopVideoResponse * SOAP_FMAC2 soap_instantiate__ns1__StopVideoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:355 */
#ifndef SOAP_TYPE__ns1__MyAccountRequest
#define SOAP_TYPE__ns1__MyAccountRequest (79)
/* complex XSD type 'ns1:MyAccountRequest': */
class SOAP_CMAC _ns1__MyAccountRequest {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__MyAccountRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__MyAccountRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__MyAccountRequest, default initialized and not managed by a soap context
        virtual _ns1__MyAccountRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__MyAccountRequest); }
      public:
        /// Constructor with initializations
        _ns1__MyAccountRequest()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__MyAccountRequest() { }
        /// Friend allocator used by soap_new__ns1__MyAccountRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__MyAccountRequest * SOAP_FMAC2 soap_instantiate__ns1__MyAccountRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:358 */
#ifndef SOAP_TYPE__ns1__MyAccountResponse
#define SOAP_TYPE__ns1__MyAccountResponse (80)
/* complex XSD type 'ns1:MyAccountResponse': */
class SOAP_CMAC _ns1__MyAccountResponse {
      public:
        /// Required element 'ns1:Entity' of XSD type 'ns1:Entity'
        _ns1__Entity *Entity;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__MyAccountResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__MyAccountResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__MyAccountResponse, default initialized and not managed by a soap context
        virtual _ns1__MyAccountResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__MyAccountResponse); }
      public:
        /// Constructor with initializations
        _ns1__MyAccountResponse()
        {
          Entity = (_ns1__Entity *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__MyAccountResponse() { }
        /// Friend allocator used by soap_new__ns1__MyAccountResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__MyAccountResponse * SOAP_FMAC2 soap_instantiate__ns1__MyAccountResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:361 */
#ifndef SOAP_TYPE__ns1__CreateRoomRequest
#define SOAP_TYPE__ns1__CreateRoomRequest (81)
/* complex XSD type 'ns1:CreateRoomRequest': */
class SOAP_CMAC _ns1__CreateRoomRequest {
      public:
        /// Required element 'ns1:name' of XSD type 'xsd:string'
        char *name;
        /// Required element 'ns1:extension' of XSD type 'xsd:string'
        char *extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CreateRoomRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CreateRoomRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CreateRoomRequest, default initialized and not managed by a soap context
        virtual _ns1__CreateRoomRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__CreateRoomRequest); }
      public:
        /// Constructor with initializations
        _ns1__CreateRoomRequest()
        {
          name = (char *)0;
          extension = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__CreateRoomRequest() { }
        /// Friend allocator used by soap_new__ns1__CreateRoomRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CreateRoomRequest * SOAP_FMAC2 soap_instantiate__ns1__CreateRoomRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:364 */
#ifndef SOAP_TYPE__ns1__CreateRoomResponse
#define SOAP_TYPE__ns1__CreateRoomResponse (82)
/* complex XSD type 'ns1:CreateRoomResponse': */
class SOAP_CMAC _ns1__CreateRoomResponse {
      public:
        /// Required element 'ns1:Entity' of XSD type 'ns1:Entity'
        _ns1__Entity *Entity;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CreateRoomResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CreateRoomResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CreateRoomResponse, default initialized and not managed by a soap context
        virtual _ns1__CreateRoomResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__CreateRoomResponse); }
      public:
        /// Constructor with initializations
        _ns1__CreateRoomResponse()
        {
          Entity = (_ns1__Entity *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__CreateRoomResponse() { }
        /// Friend allocator used by soap_new__ns1__CreateRoomResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CreateRoomResponse * SOAP_FMAC2 soap_instantiate__ns1__CreateRoomResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:367 */
#ifndef SOAP_TYPE__ns1__DeleteRoomRequest
#define SOAP_TYPE__ns1__DeleteRoomRequest (83)
/* complex XSD type 'ns1:DeleteRoomRequest': */
class SOAP_CMAC _ns1__DeleteRoomRequest {
      public:
        /// Required element 'ns1:roomID' of XSD type 'ns1:EntityID'
        char *roomID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DeleteRoomRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__DeleteRoomRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DeleteRoomRequest, default initialized and not managed by a soap context
        virtual _ns1__DeleteRoomRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__DeleteRoomRequest); }
      public:
        /// Constructor with initializations
        _ns1__DeleteRoomRequest()
        {
          roomID = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__DeleteRoomRequest() { }
        /// Friend allocator used by soap_new__ns1__DeleteRoomRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DeleteRoomRequest * SOAP_FMAC2 soap_instantiate__ns1__DeleteRoomRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:370 */
#ifndef SOAP_TYPE__ns1__DeleteRoomResponse
#define SOAP_TYPE__ns1__DeleteRoomResponse (84)
/* complex XSD type 'ns1:DeleteRoomResponse': */
class SOAP_CMAC _ns1__DeleteRoomResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DeleteRoomResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__DeleteRoomResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DeleteRoomResponse, default initialized and not managed by a soap context
        virtual _ns1__DeleteRoomResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__DeleteRoomResponse); }
      public:
        /// Constructor with initializations
        _ns1__DeleteRoomResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__DeleteRoomResponse() { }
        /// Friend allocator used by soap_new__ns1__DeleteRoomResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DeleteRoomResponse * SOAP_FMAC2 soap_instantiate__ns1__DeleteRoomResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:373 */
#ifndef SOAP_TYPE__ns1__CreateRoomURLRequest
#define SOAP_TYPE__ns1__CreateRoomURLRequest (85)
/* complex XSD type 'ns1:CreateRoomURLRequest': */
class SOAP_CMAC _ns1__CreateRoomURLRequest {
      public:
        /// Required element 'ns1:roomID' of XSD type 'ns1:EntityID'
        char *roomID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CreateRoomURLRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CreateRoomURLRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CreateRoomURLRequest, default initialized and not managed by a soap context
        virtual _ns1__CreateRoomURLRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__CreateRoomURLRequest); }
      public:
        /// Constructor with initializations
        _ns1__CreateRoomURLRequest()
        {
          roomID = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__CreateRoomURLRequest() { }
        /// Friend allocator used by soap_new__ns1__CreateRoomURLRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CreateRoomURLRequest * SOAP_FMAC2 soap_instantiate__ns1__CreateRoomURLRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:376 */
#ifndef SOAP_TYPE__ns1__CreateRoomURLResponse
#define SOAP_TYPE__ns1__CreateRoomURLResponse (86)
/* complex XSD type 'ns1:CreateRoomURLResponse': */
class SOAP_CMAC _ns1__CreateRoomURLResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CreateRoomURLResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CreateRoomURLResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CreateRoomURLResponse, default initialized and not managed by a soap context
        virtual _ns1__CreateRoomURLResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__CreateRoomURLResponse); }
      public:
        /// Constructor with initializations
        _ns1__CreateRoomURLResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__CreateRoomURLResponse() { }
        /// Friend allocator used by soap_new__ns1__CreateRoomURLResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CreateRoomURLResponse * SOAP_FMAC2 soap_instantiate__ns1__CreateRoomURLResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:379 */
#ifndef SOAP_TYPE__ns1__RemoveRoomURLRequest
#define SOAP_TYPE__ns1__RemoveRoomURLRequest (87)
/* complex XSD type 'ns1:RemoveRoomURLRequest': */
class SOAP_CMAC _ns1__RemoveRoomURLRequest {
      public:
        /// Required element 'ns1:roomID' of XSD type 'ns1:EntityID'
        char *roomID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RemoveRoomURLRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__RemoveRoomURLRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RemoveRoomURLRequest, default initialized and not managed by a soap context
        virtual _ns1__RemoveRoomURLRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__RemoveRoomURLRequest); }
      public:
        /// Constructor with initializations
        _ns1__RemoveRoomURLRequest()
        {
          roomID = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__RemoveRoomURLRequest() { }
        /// Friend allocator used by soap_new__ns1__RemoveRoomURLRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RemoveRoomURLRequest * SOAP_FMAC2 soap_instantiate__ns1__RemoveRoomURLRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:382 */
#ifndef SOAP_TYPE__ns1__RemoveRoomURLResponse
#define SOAP_TYPE__ns1__RemoveRoomURLResponse (88)
/* complex XSD type 'ns1:RemoveRoomURLResponse': */
class SOAP_CMAC _ns1__RemoveRoomURLResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RemoveRoomURLResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__RemoveRoomURLResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RemoveRoomURLResponse, default initialized and not managed by a soap context
        virtual _ns1__RemoveRoomURLResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__RemoveRoomURLResponse); }
      public:
        /// Constructor with initializations
        _ns1__RemoveRoomURLResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__RemoveRoomURLResponse() { }
        /// Friend allocator used by soap_new__ns1__RemoveRoomURLResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RemoveRoomURLResponse * SOAP_FMAC2 soap_instantiate__ns1__RemoveRoomURLResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:385 */
#ifndef SOAP_TYPE__ns1__CreateRoomPINRequest
#define SOAP_TYPE__ns1__CreateRoomPINRequest (89)
/* complex XSD type 'ns1:CreateRoomPINRequest': */
class SOAP_CMAC _ns1__CreateRoomPINRequest {
      public:
        /// Required element 'ns1:roomID' of XSD type 'ns1:EntityID'
        char *roomID;
        /// Required element 'ns1:PIN' of XSD type 'xsd:string'
        char *PIN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CreateRoomPINRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CreateRoomPINRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CreateRoomPINRequest, default initialized and not managed by a soap context
        virtual _ns1__CreateRoomPINRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__CreateRoomPINRequest); }
      public:
        /// Constructor with initializations
        _ns1__CreateRoomPINRequest()
        {
          roomID = (char *)0;
          PIN = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__CreateRoomPINRequest() { }
        /// Friend allocator used by soap_new__ns1__CreateRoomPINRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CreateRoomPINRequest * SOAP_FMAC2 soap_instantiate__ns1__CreateRoomPINRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:388 */
#ifndef SOAP_TYPE__ns1__CreateRoomPINResponse
#define SOAP_TYPE__ns1__CreateRoomPINResponse (90)
/* complex XSD type 'ns1:CreateRoomPINResponse': */
class SOAP_CMAC _ns1__CreateRoomPINResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CreateRoomPINResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CreateRoomPINResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CreateRoomPINResponse, default initialized and not managed by a soap context
        virtual _ns1__CreateRoomPINResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__CreateRoomPINResponse); }
      public:
        /// Constructor with initializations
        _ns1__CreateRoomPINResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__CreateRoomPINResponse() { }
        /// Friend allocator used by soap_new__ns1__CreateRoomPINResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CreateRoomPINResponse * SOAP_FMAC2 soap_instantiate__ns1__CreateRoomPINResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:391 */
#ifndef SOAP_TYPE__ns1__RemoveRoomPINRequest
#define SOAP_TYPE__ns1__RemoveRoomPINRequest (91)
/* complex XSD type 'ns1:RemoveRoomPINRequest': */
class SOAP_CMAC _ns1__RemoveRoomPINRequest {
      public:
        /// Required element 'ns1:roomID' of XSD type 'ns1:EntityID'
        char *roomID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RemoveRoomPINRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__RemoveRoomPINRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RemoveRoomPINRequest, default initialized and not managed by a soap context
        virtual _ns1__RemoveRoomPINRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__RemoveRoomPINRequest); }
      public:
        /// Constructor with initializations
        _ns1__RemoveRoomPINRequest()
        {
          roomID = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__RemoveRoomPINRequest() { }
        /// Friend allocator used by soap_new__ns1__RemoveRoomPINRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RemoveRoomPINRequest * SOAP_FMAC2 soap_instantiate__ns1__RemoveRoomPINRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:394 */
#ifndef SOAP_TYPE__ns1__RemoveRoomPINResponse
#define SOAP_TYPE__ns1__RemoveRoomPINResponse (92)
/* complex XSD type 'ns1:RemoveRoomPINResponse': */
class SOAP_CMAC _ns1__RemoveRoomPINResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RemoveRoomPINResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__RemoveRoomPINResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RemoveRoomPINResponse, default initialized and not managed by a soap context
        virtual _ns1__RemoveRoomPINResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__RemoveRoomPINResponse); }
      public:
        /// Constructor with initializations
        _ns1__RemoveRoomPINResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__RemoveRoomPINResponse() { }
        /// Friend allocator used by soap_new__ns1__RemoveRoomPINResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RemoveRoomPINResponse * SOAP_FMAC2 soap_instantiate__ns1__RemoveRoomPINResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:397 */
#ifndef SOAP_TYPE__ns1__UpdatePasswordRequest
#define SOAP_TYPE__ns1__UpdatePasswordRequest (93)
/* complex XSD type 'ns1:UpdatePasswordRequest': */
class SOAP_CMAC _ns1__UpdatePasswordRequest {
      public:
        /// Required element 'ns1:password' of XSD type 'xsd:string'
        char *password;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__UpdatePasswordRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__UpdatePasswordRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__UpdatePasswordRequest, default initialized and not managed by a soap context
        virtual _ns1__UpdatePasswordRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__UpdatePasswordRequest); }
      public:
        /// Constructor with initializations
        _ns1__UpdatePasswordRequest()
        {
          password = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__UpdatePasswordRequest() { }
        /// Friend allocator used by soap_new__ns1__UpdatePasswordRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__UpdatePasswordRequest * SOAP_FMAC2 soap_instantiate__ns1__UpdatePasswordRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:400 */
#ifndef SOAP_TYPE__ns1__UpdatePasswordResponse
#define SOAP_TYPE__ns1__UpdatePasswordResponse (94)
/* complex XSD type 'ns1:UpdatePasswordResponse': */
class SOAP_CMAC _ns1__UpdatePasswordResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__UpdatePasswordResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__UpdatePasswordResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__UpdatePasswordResponse, default initialized and not managed by a soap context
        virtual _ns1__UpdatePasswordResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__UpdatePasswordResponse); }
      public:
        /// Constructor with initializations
        _ns1__UpdatePasswordResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__UpdatePasswordResponse() { }
        /// Friend allocator used by soap_new__ns1__UpdatePasswordResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__UpdatePasswordResponse * SOAP_FMAC2 soap_instantiate__ns1__UpdatePasswordResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:403 */
#ifndef SOAP_TYPE__ns1__UpdateLanguageRequest
#define SOAP_TYPE__ns1__UpdateLanguageRequest (95)
/* complex XSD type 'ns1:UpdateLanguageRequest': */
class SOAP_CMAC _ns1__UpdateLanguageRequest {
      public:
        /// Required element 'ns1:Language' of XSD type 'ns1:Language'
        enum _ns1__Language Language;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__UpdateLanguageRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__UpdateLanguageRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__UpdateLanguageRequest, default initialized and not managed by a soap context
        virtual _ns1__UpdateLanguageRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__UpdateLanguageRequest); }
      public:
        /// Constructor with initializations
        _ns1__UpdateLanguageRequest()
        {
          Language = (enum _ns1__Language)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__UpdateLanguageRequest() { }
        /// Friend allocator used by soap_new__ns1__UpdateLanguageRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__UpdateLanguageRequest * SOAP_FMAC2 soap_instantiate__ns1__UpdateLanguageRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:406 */
#ifndef SOAP_TYPE__ns1__UpdateLanguageResponse
#define SOAP_TYPE__ns1__UpdateLanguageResponse (96)
/* complex XSD type 'ns1:UpdateLanguageResponse': */
class SOAP_CMAC _ns1__UpdateLanguageResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__UpdateLanguageResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__UpdateLanguageResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__UpdateLanguageResponse, default initialized and not managed by a soap context
        virtual _ns1__UpdateLanguageResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__UpdateLanguageResponse); }
      public:
        /// Constructor with initializations
        _ns1__UpdateLanguageResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__UpdateLanguageResponse() { }
        /// Friend allocator used by soap_new__ns1__UpdateLanguageResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__UpdateLanguageResponse * SOAP_FMAC2 soap_instantiate__ns1__UpdateLanguageResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:409 */
#ifndef SOAP_TYPE__ns1__LockRoomRequest
#define SOAP_TYPE__ns1__LockRoomRequest (97)
/* complex XSD type 'ns1:LockRoomRequest': */
class SOAP_CMAC _ns1__LockRoomRequest {
      public:
        /// Required element 'ns1:roomID' of XSD type 'ns1:EntityID'
        char *roomID;
        /// Optional element 'ns1:moderatorPIN' of XSD type 'xsd:string'
        char *moderatorPIN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__LockRoomRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__LockRoomRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__LockRoomRequest, default initialized and not managed by a soap context
        virtual _ns1__LockRoomRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__LockRoomRequest); }
      public:
        /// Constructor with initializations
        _ns1__LockRoomRequest()
        {
          roomID = (char *)0;
          moderatorPIN = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__LockRoomRequest() { }
        /// Friend allocator used by soap_new__ns1__LockRoomRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__LockRoomRequest * SOAP_FMAC2 soap_instantiate__ns1__LockRoomRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:412 */
#ifndef SOAP_TYPE__ns1__LockRoomResponse
#define SOAP_TYPE__ns1__LockRoomResponse (98)
/* complex XSD type 'ns1:LockRoomResponse': */
class SOAP_CMAC _ns1__LockRoomResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__LockRoomResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__LockRoomResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__LockRoomResponse, default initialized and not managed by a soap context
        virtual _ns1__LockRoomResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__LockRoomResponse); }
      public:
        /// Constructor with initializations
        _ns1__LockRoomResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__LockRoomResponse() { }
        /// Friend allocator used by soap_new__ns1__LockRoomResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__LockRoomResponse * SOAP_FMAC2 soap_instantiate__ns1__LockRoomResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:415 */
#ifndef SOAP_TYPE__ns1__UnlockRoomRequest
#define SOAP_TYPE__ns1__UnlockRoomRequest (99)
/* complex XSD type 'ns1:UnlockRoomRequest': */
class SOAP_CMAC _ns1__UnlockRoomRequest {
      public:
        /// Required element 'ns1:roomID' of XSD type 'ns1:EntityID'
        char *roomID;
        /// Optional element 'ns1:moderatorPIN' of XSD type 'xsd:string'
        char *moderatorPIN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__UnlockRoomRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__UnlockRoomRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__UnlockRoomRequest, default initialized and not managed by a soap context
        virtual _ns1__UnlockRoomRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__UnlockRoomRequest); }
      public:
        /// Constructor with initializations
        _ns1__UnlockRoomRequest()
        {
          roomID = (char *)0;
          moderatorPIN = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__UnlockRoomRequest() { }
        /// Friend allocator used by soap_new__ns1__UnlockRoomRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__UnlockRoomRequest * SOAP_FMAC2 soap_instantiate__ns1__UnlockRoomRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:418 */
#ifndef SOAP_TYPE__ns1__UnlockRoomResponse
#define SOAP_TYPE__ns1__UnlockRoomResponse (100)
/* complex XSD type 'ns1:UnlockRoomResponse': */
class SOAP_CMAC _ns1__UnlockRoomResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__UnlockRoomResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__UnlockRoomResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__UnlockRoomResponse, default initialized and not managed by a soap context
        virtual _ns1__UnlockRoomResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__UnlockRoomResponse); }
      public:
        /// Constructor with initializations
        _ns1__UnlockRoomResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__UnlockRoomResponse() { }
        /// Friend allocator used by soap_new__ns1__UnlockRoomResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__UnlockRoomResponse * SOAP_FMAC2 soap_instantiate__ns1__UnlockRoomResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:421 */
#ifndef SOAP_TYPE__ns1__SetMemberModeRequest
#define SOAP_TYPE__ns1__SetMemberModeRequest (101)
/* complex XSD type 'ns1:SetMemberModeRequest': */
class SOAP_CMAC _ns1__SetMemberModeRequest {
      public:
        /// Required element 'ns1:MemberMode' of XSD type 'ns1:MemberMode'
        enum _ns1__MemberMode MemberMode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetMemberModeRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetMemberModeRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetMemberModeRequest, default initialized and not managed by a soap context
        virtual _ns1__SetMemberModeRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__SetMemberModeRequest); }
      public:
        /// Constructor with initializations
        _ns1__SetMemberModeRequest()
        {
          MemberMode = (enum _ns1__MemberMode)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetMemberModeRequest() { }
        /// Friend allocator used by soap_new__ns1__SetMemberModeRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetMemberModeRequest * SOAP_FMAC2 soap_instantiate__ns1__SetMemberModeRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:424 */
#ifndef SOAP_TYPE__ns1__SetMemberModeResponse
#define SOAP_TYPE__ns1__SetMemberModeResponse (102)
/* complex XSD type 'ns1:SetMemberModeResponse': */
class SOAP_CMAC _ns1__SetMemberModeResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetMemberModeResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetMemberModeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetMemberModeResponse, default initialized and not managed by a soap context
        virtual _ns1__SetMemberModeResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SetMemberModeResponse); }
      public:
        /// Constructor with initializations
        _ns1__SetMemberModeResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetMemberModeResponse() { }
        /// Friend allocator used by soap_new__ns1__SetMemberModeResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetMemberModeResponse * SOAP_FMAC2 soap_instantiate__ns1__SetMemberModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:427 */
#ifndef SOAP_TYPE__ns1__GetRecordingProfilesRequest
#define SOAP_TYPE__ns1__GetRecordingProfilesRequest (103)
/* complex XSD type 'ns1:GetRecordingProfilesRequest': */
class SOAP_CMAC _ns1__GetRecordingProfilesRequest {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetRecordingProfilesRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetRecordingProfilesRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetRecordingProfilesRequest, default initialized and not managed by a soap context
        virtual _ns1__GetRecordingProfilesRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__GetRecordingProfilesRequest); }
      public:
        /// Constructor with initializations
        _ns1__GetRecordingProfilesRequest()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetRecordingProfilesRequest() { }
        /// Friend allocator used by soap_new__ns1__GetRecordingProfilesRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetRecordingProfilesRequest * SOAP_FMAC2 soap_instantiate__ns1__GetRecordingProfilesRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:430 */
#ifndef SOAP_TYPE__ns1__GetRecordingProfilesResponse
#define SOAP_TYPE__ns1__GetRecordingProfilesResponse (104)
/* complex XSD type 'ns1:GetRecordingProfilesResponse': */
class SOAP_CMAC _ns1__GetRecordingProfilesResponse {
      public:
        /// Required element 'ns1:total' of XSD type 'xsd:int'
        int total;
        /// Sequence of elements 'ns1:recorder' of XSD type 'ns1:Recorder' stored in dynamic array recorder of length __sizerecorder
        int __sizerecorder;
        ns1__Recorder **recorder;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetRecordingProfilesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetRecordingProfilesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetRecordingProfilesResponse, default initialized and not managed by a soap context
        virtual _ns1__GetRecordingProfilesResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetRecordingProfilesResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetRecordingProfilesResponse()
        {
          total = (int)0;
          __sizerecorder = 0;
          recorder = NULL;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetRecordingProfilesResponse() { }
        /// Friend allocator used by soap_new__ns1__GetRecordingProfilesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetRecordingProfilesResponse * SOAP_FMAC2 soap_instantiate__ns1__GetRecordingProfilesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:433 */
#ifndef SOAP_TYPE__ns1__StartRecordingRequest
#define SOAP_TYPE__ns1__StartRecordingRequest (105)
/* complex XSD type 'ns1:StartRecordingRequest': */
class SOAP_CMAC _ns1__StartRecordingRequest {
      public:
        /// Required element 'ns1:conferenceID' of XSD type 'ns1:EntityID'
        char *conferenceID;
        /// Required element 'ns1:recorderPrefix' of XSD type 'xsd:string'
        char *recorderPrefix;
        /// Required element 'ns1:webcast' of XSD type 'xsd:boolean'
        bool webcast;
        /// Optional element 'ns1:moderatorPIN' of XSD type 'xsd:string'
        char *moderatorPIN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__StartRecordingRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__StartRecordingRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__StartRecordingRequest, default initialized and not managed by a soap context
        virtual _ns1__StartRecordingRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__StartRecordingRequest); }
      public:
        /// Constructor with initializations
        _ns1__StartRecordingRequest()
        {
          conferenceID = (char *)0;
          recorderPrefix = (char *)0;
          webcast = (bool)0;
          moderatorPIN = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__StartRecordingRequest() { }
        /// Friend allocator used by soap_new__ns1__StartRecordingRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__StartRecordingRequest * SOAP_FMAC2 soap_instantiate__ns1__StartRecordingRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:436 */
#ifndef SOAP_TYPE__ns1__StartRecordingResponse
#define SOAP_TYPE__ns1__StartRecordingResponse (106)
/* complex XSD type 'ns1:StartRecordingResponse': */
class SOAP_CMAC _ns1__StartRecordingResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__StartRecordingResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__StartRecordingResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__StartRecordingResponse, default initialized and not managed by a soap context
        virtual _ns1__StartRecordingResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__StartRecordingResponse); }
      public:
        /// Constructor with initializations
        _ns1__StartRecordingResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__StartRecordingResponse() { }
        /// Friend allocator used by soap_new__ns1__StartRecordingResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__StartRecordingResponse * SOAP_FMAC2 soap_instantiate__ns1__StartRecordingResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:439 */
#ifndef SOAP_TYPE__ns1__GetPortalVersionRequest
#define SOAP_TYPE__ns1__GetPortalVersionRequest (107)
/* complex XSD type 'ns1:GetPortalVersionRequest': */
class SOAP_CMAC _ns1__GetPortalVersionRequest {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetPortalVersionRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetPortalVersionRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetPortalVersionRequest, default initialized and not managed by a soap context
        virtual _ns1__GetPortalVersionRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__GetPortalVersionRequest); }
      public:
        /// Constructor with initializations
        _ns1__GetPortalVersionRequest()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetPortalVersionRequest() { }
        /// Friend allocator used by soap_new__ns1__GetPortalVersionRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetPortalVersionRequest * SOAP_FMAC2 soap_instantiate__ns1__GetPortalVersionRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:442 */
#ifndef SOAP_TYPE__ns1__GetPortalVersionResponse
#define SOAP_TYPE__ns1__GetPortalVersionResponse (108)
/* complex XSD type 'ns1:GetPortalVersionResponse': */
class SOAP_CMAC _ns1__GetPortalVersionResponse {
      public:
        /// Required element 'ns1:portalVersion' of XSD type 'xsd:string'
        char *portalVersion;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetPortalVersionResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetPortalVersionResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetPortalVersionResponse, default initialized and not managed by a soap context
        virtual _ns1__GetPortalVersionResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetPortalVersionResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetPortalVersionResponse()
        {
          portalVersion = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetPortalVersionResponse() { }
        /// Friend allocator used by soap_new__ns1__GetPortalVersionResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetPortalVersionResponse * SOAP_FMAC2 soap_instantiate__ns1__GetPortalVersionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:445 */
#ifndef SOAP_TYPE__ns1__PauseRecordingRequest
#define SOAP_TYPE__ns1__PauseRecordingRequest (109)
/* complex XSD type 'ns1:PauseRecordingRequest': */
class SOAP_CMAC _ns1__PauseRecordingRequest {
      public:
        /// Required element 'ns1:conferenceID' of XSD type 'ns1:EntityID'
        char *conferenceID;
        /// Required element 'ns1:recorderID' of XSD type 'xsd:int'
        int recorderID;
        /// Optional element 'ns1:moderatorPIN' of XSD type 'xsd:string'
        char *moderatorPIN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__PauseRecordingRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__PauseRecordingRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__PauseRecordingRequest, default initialized and not managed by a soap context
        virtual _ns1__PauseRecordingRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__PauseRecordingRequest); }
      public:
        /// Constructor with initializations
        _ns1__PauseRecordingRequest()
        {
          conferenceID = (char *)0;
          recorderID = (int)0;
          moderatorPIN = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__PauseRecordingRequest() { }
        /// Friend allocator used by soap_new__ns1__PauseRecordingRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__PauseRecordingRequest * SOAP_FMAC2 soap_instantiate__ns1__PauseRecordingRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:448 */
#ifndef SOAP_TYPE__ns1__PauseRecordingResponse
#define SOAP_TYPE__ns1__PauseRecordingResponse (110)
/* complex XSD type 'ns1:PauseRecordingResponse': */
class SOAP_CMAC _ns1__PauseRecordingResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__PauseRecordingResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__PauseRecordingResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__PauseRecordingResponse, default initialized and not managed by a soap context
        virtual _ns1__PauseRecordingResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__PauseRecordingResponse); }
      public:
        /// Constructor with initializations
        _ns1__PauseRecordingResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__PauseRecordingResponse() { }
        /// Friend allocator used by soap_new__ns1__PauseRecordingResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__PauseRecordingResponse * SOAP_FMAC2 soap_instantiate__ns1__PauseRecordingResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:451 */
#ifndef SOAP_TYPE__ns1__ResumeRecordingRequest
#define SOAP_TYPE__ns1__ResumeRecordingRequest (111)
/* complex XSD type 'ns1:ResumeRecordingRequest': */
class SOAP_CMAC _ns1__ResumeRecordingRequest {
      public:
        /// Required element 'ns1:conferenceID' of XSD type 'ns1:EntityID'
        char *conferenceID;
        /// Required element 'ns1:recorderID' of XSD type 'xsd:int'
        int recorderID;
        /// Optional element 'ns1:moderatorPIN' of XSD type 'xsd:string'
        char *moderatorPIN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ResumeRecordingRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ResumeRecordingRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ResumeRecordingRequest, default initialized and not managed by a soap context
        virtual _ns1__ResumeRecordingRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__ResumeRecordingRequest); }
      public:
        /// Constructor with initializations
        _ns1__ResumeRecordingRequest()
        {
          conferenceID = (char *)0;
          recorderID = (int)0;
          moderatorPIN = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__ResumeRecordingRequest() { }
        /// Friend allocator used by soap_new__ns1__ResumeRecordingRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ResumeRecordingRequest * SOAP_FMAC2 soap_instantiate__ns1__ResumeRecordingRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:454 */
#ifndef SOAP_TYPE__ns1__ResumeRecordingResponse
#define SOAP_TYPE__ns1__ResumeRecordingResponse (112)
/* complex XSD type 'ns1:ResumeRecordingResponse': */
class SOAP_CMAC _ns1__ResumeRecordingResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ResumeRecordingResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ResumeRecordingResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ResumeRecordingResponse, default initialized and not managed by a soap context
        virtual _ns1__ResumeRecordingResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__ResumeRecordingResponse); }
      public:
        /// Constructor with initializations
        _ns1__ResumeRecordingResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__ResumeRecordingResponse() { }
        /// Friend allocator used by soap_new__ns1__ResumeRecordingResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ResumeRecordingResponse * SOAP_FMAC2 soap_instantiate__ns1__ResumeRecordingResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:457 */
#ifndef SOAP_TYPE__ns1__StopRecordingRequest
#define SOAP_TYPE__ns1__StopRecordingRequest (113)
/* complex XSD type 'ns1:StopRecordingRequest': */
class SOAP_CMAC _ns1__StopRecordingRequest {
      public:
        /// Required element 'ns1:conferenceID' of XSD type 'ns1:EntityID'
        char *conferenceID;
        /// Required element 'ns1:recorderID' of XSD type 'xsd:int'
        int recorderID;
        /// Optional element 'ns1:moderatorPIN' of XSD type 'xsd:string'
        char *moderatorPIN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__StopRecordingRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__StopRecordingRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__StopRecordingRequest, default initialized and not managed by a soap context
        virtual _ns1__StopRecordingRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__StopRecordingRequest); }
      public:
        /// Constructor with initializations
        _ns1__StopRecordingRequest()
        {
          conferenceID = (char *)0;
          recorderID = (int)0;
          moderatorPIN = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__StopRecordingRequest() { }
        /// Friend allocator used by soap_new__ns1__StopRecordingRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__StopRecordingRequest * SOAP_FMAC2 soap_instantiate__ns1__StopRecordingRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:460 */
#ifndef SOAP_TYPE__ns1__StopRecordingResponse
#define SOAP_TYPE__ns1__StopRecordingResponse (114)
/* complex XSD type 'ns1:StopRecordingResponse': */
class SOAP_CMAC _ns1__StopRecordingResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__StopRecordingResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__StopRecordingResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__StopRecordingResponse, default initialized and not managed by a soap context
        virtual _ns1__StopRecordingResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__StopRecordingResponse); }
      public:
        /// Constructor with initializations
        _ns1__StopRecordingResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__StopRecordingResponse() { }
        /// Friend allocator used by soap_new__ns1__StopRecordingResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__StopRecordingResponse * SOAP_FMAC2 soap_instantiate__ns1__StopRecordingResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:463 */
#ifndef SOAP_TYPE__ns1__CreateWebcastURLRequest
#define SOAP_TYPE__ns1__CreateWebcastURLRequest (115)
/* complex XSD type 'ns1:CreateWebcastURLRequest': */
class SOAP_CMAC _ns1__CreateWebcastURLRequest {
      public:
        /// Required element 'ns1:roomID' of XSD type 'ns1:EntityID'
        char *roomID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CreateWebcastURLRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CreateWebcastURLRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CreateWebcastURLRequest, default initialized and not managed by a soap context
        virtual _ns1__CreateWebcastURLRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__CreateWebcastURLRequest); }
      public:
        /// Constructor with initializations
        _ns1__CreateWebcastURLRequest()
        {
          roomID = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__CreateWebcastURLRequest() { }
        /// Friend allocator used by soap_new__ns1__CreateWebcastURLRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CreateWebcastURLRequest * SOAP_FMAC2 soap_instantiate__ns1__CreateWebcastURLRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:466 */
#ifndef SOAP_TYPE__ns1__CreateWebcastURLResponse
#define SOAP_TYPE__ns1__CreateWebcastURLResponse (116)
/* complex XSD type 'ns1:CreateWebcastURLResponse': */
class SOAP_CMAC _ns1__CreateWebcastURLResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CreateWebcastURLResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CreateWebcastURLResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CreateWebcastURLResponse, default initialized and not managed by a soap context
        virtual _ns1__CreateWebcastURLResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__CreateWebcastURLResponse); }
      public:
        /// Constructor with initializations
        _ns1__CreateWebcastURLResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__CreateWebcastURLResponse() { }
        /// Friend allocator used by soap_new__ns1__CreateWebcastURLResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CreateWebcastURLResponse * SOAP_FMAC2 soap_instantiate__ns1__CreateWebcastURLResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:469 */
#ifndef SOAP_TYPE__ns1__CreateWebcastPINRequest
#define SOAP_TYPE__ns1__CreateWebcastPINRequest (117)
/* complex XSD type 'ns1:CreateWebcastPINRequest': */
class SOAP_CMAC _ns1__CreateWebcastPINRequest {
      public:
        /// Required element 'ns1:roomID' of XSD type 'ns1:EntityID'
        char *roomID;
        /// Required element 'ns1:PIN' of XSD type 'xsd:string'
        char *PIN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CreateWebcastPINRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CreateWebcastPINRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CreateWebcastPINRequest, default initialized and not managed by a soap context
        virtual _ns1__CreateWebcastPINRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__CreateWebcastPINRequest); }
      public:
        /// Constructor with initializations
        _ns1__CreateWebcastPINRequest()
        {
          roomID = (char *)0;
          PIN = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__CreateWebcastPINRequest() { }
        /// Friend allocator used by soap_new__ns1__CreateWebcastPINRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CreateWebcastPINRequest * SOAP_FMAC2 soap_instantiate__ns1__CreateWebcastPINRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:472 */
#ifndef SOAP_TYPE__ns1__CreateWebcastPINResponse
#define SOAP_TYPE__ns1__CreateWebcastPINResponse (118)
/* complex XSD type 'ns1:CreateWebcastPINResponse': */
class SOAP_CMAC _ns1__CreateWebcastPINResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CreateWebcastPINResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CreateWebcastPINResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CreateWebcastPINResponse, default initialized and not managed by a soap context
        virtual _ns1__CreateWebcastPINResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__CreateWebcastPINResponse); }
      public:
        /// Constructor with initializations
        _ns1__CreateWebcastPINResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__CreateWebcastPINResponse() { }
        /// Friend allocator used by soap_new__ns1__CreateWebcastPINResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CreateWebcastPINResponse * SOAP_FMAC2 soap_instantiate__ns1__CreateWebcastPINResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:475 */
#ifndef SOAP_TYPE__ns1__RemoveWebcastURLRequest
#define SOAP_TYPE__ns1__RemoveWebcastURLRequest (119)
/* complex XSD type 'ns1:RemoveWebcastURLRequest': */
class SOAP_CMAC _ns1__RemoveWebcastURLRequest {
      public:
        /// Required element 'ns1:roomID' of XSD type 'ns1:EntityID'
        char *roomID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RemoveWebcastURLRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__RemoveWebcastURLRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RemoveWebcastURLRequest, default initialized and not managed by a soap context
        virtual _ns1__RemoveWebcastURLRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__RemoveWebcastURLRequest); }
      public:
        /// Constructor with initializations
        _ns1__RemoveWebcastURLRequest()
        {
          roomID = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__RemoveWebcastURLRequest() { }
        /// Friend allocator used by soap_new__ns1__RemoveWebcastURLRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RemoveWebcastURLRequest * SOAP_FMAC2 soap_instantiate__ns1__RemoveWebcastURLRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:478 */
#ifndef SOAP_TYPE__ns1__RemoveWebcastURLResponse
#define SOAP_TYPE__ns1__RemoveWebcastURLResponse (120)
/* complex XSD type 'ns1:RemoveWebcastURLResponse': */
class SOAP_CMAC _ns1__RemoveWebcastURLResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RemoveWebcastURLResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__RemoveWebcastURLResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RemoveWebcastURLResponse, default initialized and not managed by a soap context
        virtual _ns1__RemoveWebcastURLResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__RemoveWebcastURLResponse); }
      public:
        /// Constructor with initializations
        _ns1__RemoveWebcastURLResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__RemoveWebcastURLResponse() { }
        /// Friend allocator used by soap_new__ns1__RemoveWebcastURLResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RemoveWebcastURLResponse * SOAP_FMAC2 soap_instantiate__ns1__RemoveWebcastURLResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:481 */
#ifndef SOAP_TYPE__ns1__RemoveWebcastPINRequest
#define SOAP_TYPE__ns1__RemoveWebcastPINRequest (121)
/* complex XSD type 'ns1:RemoveWebcastPINRequest': */
class SOAP_CMAC _ns1__RemoveWebcastPINRequest {
      public:
        /// Required element 'ns1:roomID' of XSD type 'ns1:EntityID'
        char *roomID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RemoveWebcastPINRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__RemoveWebcastPINRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RemoveWebcastPINRequest, default initialized and not managed by a soap context
        virtual _ns1__RemoveWebcastPINRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__RemoveWebcastPINRequest); }
      public:
        /// Constructor with initializations
        _ns1__RemoveWebcastPINRequest()
        {
          roomID = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__RemoveWebcastPINRequest() { }
        /// Friend allocator used by soap_new__ns1__RemoveWebcastPINRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RemoveWebcastPINRequest * SOAP_FMAC2 soap_instantiate__ns1__RemoveWebcastPINRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:484 */
#ifndef SOAP_TYPE__ns1__RemoveWebcastPINResponse
#define SOAP_TYPE__ns1__RemoveWebcastPINResponse (122)
/* complex XSD type 'ns1:RemoveWebcastPINResponse': */
class SOAP_CMAC _ns1__RemoveWebcastPINResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RemoveWebcastPINResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__RemoveWebcastPINResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RemoveWebcastPINResponse, default initialized and not managed by a soap context
        virtual _ns1__RemoveWebcastPINResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__RemoveWebcastPINResponse); }
      public:
        /// Constructor with initializations
        _ns1__RemoveWebcastPINResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__RemoveWebcastPINResponse() { }
        /// Friend allocator used by soap_new__ns1__RemoveWebcastPINResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RemoveWebcastPINResponse * SOAP_FMAC2 soap_instantiate__ns1__RemoveWebcastPINResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:487 */
#ifndef SOAP_TYPE__ns1__GetWebcastURLRequest
#define SOAP_TYPE__ns1__GetWebcastURLRequest (123)
/* complex XSD type 'ns1:GetWebcastURLRequest': */
class SOAP_CMAC _ns1__GetWebcastURLRequest {
      public:
        /// Required element 'ns1:roomID' of XSD type 'ns1:EntityID'
        char *roomID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetWebcastURLRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetWebcastURLRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetWebcastURLRequest, default initialized and not managed by a soap context
        virtual _ns1__GetWebcastURLRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__GetWebcastURLRequest); }
      public:
        /// Constructor with initializations
        _ns1__GetWebcastURLRequest()
        {
          roomID = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetWebcastURLRequest() { }
        /// Friend allocator used by soap_new__ns1__GetWebcastURLRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetWebcastURLRequest * SOAP_FMAC2 soap_instantiate__ns1__GetWebcastURLRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:490 */
#ifndef SOAP_TYPE__ns1__GetWebcastURLResponse
#define SOAP_TYPE__ns1__GetWebcastURLResponse (124)
/* complex XSD type 'ns1:GetWebcastURLResponse': */
class SOAP_CMAC _ns1__GetWebcastURLResponse {
      public:
        /// Optional element 'ns1:webCastURL' of XSD type 'xsd:string'
        char *webCastURL;
        /// Optional element 'ns1:hasWebCastPIN' of XSD type 'xsd:boolean'
        bool *hasWebCastPIN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetWebcastURLResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetWebcastURLResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetWebcastURLResponse, default initialized and not managed by a soap context
        virtual _ns1__GetWebcastURLResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetWebcastURLResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetWebcastURLResponse()
        {
          webCastURL = (char *)0;
          hasWebCastPIN = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetWebcastURLResponse() { }
        /// Friend allocator used by soap_new__ns1__GetWebcastURLResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetWebcastURLResponse * SOAP_FMAC2 soap_instantiate__ns1__GetWebcastURLResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:493 */
#ifndef SOAP_TYPE__ns1__GetUserNameRequest
#define SOAP_TYPE__ns1__GetUserNameRequest (125)
/* complex XSD type 'ns1:GetUserNameRequest': */
class SOAP_CMAC _ns1__GetUserNameRequest {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetUserNameRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetUserNameRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetUserNameRequest, default initialized and not managed by a soap context
        virtual _ns1__GetUserNameRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__GetUserNameRequest); }
      public:
        /// Constructor with initializations
        _ns1__GetUserNameRequest()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetUserNameRequest() { }
        /// Friend allocator used by soap_new__ns1__GetUserNameRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetUserNameRequest * SOAP_FMAC2 soap_instantiate__ns1__GetUserNameRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:496 */
#ifndef SOAP_TYPE__ns1__GetUserNameResponse
#define SOAP_TYPE__ns1__GetUserNameResponse (126)
/* complex XSD type 'ns1:GetUserNameResponse': */
class SOAP_CMAC _ns1__GetUserNameResponse {
      public:
        /// Required element 'ns1:realUserName' of XSD type 'xsd:string'
        char *realUserName;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetUserNameResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetUserNameResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetUserNameResponse, default initialized and not managed by a soap context
        virtual _ns1__GetUserNameResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetUserNameResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetUserNameResponse()
        {
          realUserName = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetUserNameResponse() { }
        /// Friend allocator used by soap_new__ns1__GetUserNameResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetUserNameResponse * SOAP_FMAC2 soap_instantiate__ns1__GetUserNameResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:499 */
#ifndef SOAP_TYPE__ns1__GetEntityByRoomKeyRequest
#define SOAP_TYPE__ns1__GetEntityByRoomKeyRequest (127)
/* complex XSD type 'ns1:GetEntityByRoomKeyRequest': */
class SOAP_CMAC _ns1__GetEntityByRoomKeyRequest {
      public:
        /// Required element 'ns1:roomKey' of XSD type 'xsd:string'
        char *roomKey;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetEntityByRoomKeyRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetEntityByRoomKeyRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetEntityByRoomKeyRequest, default initialized and not managed by a soap context
        virtual _ns1__GetEntityByRoomKeyRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__GetEntityByRoomKeyRequest); }
      public:
        /// Constructor with initializations
        _ns1__GetEntityByRoomKeyRequest()
        {
          roomKey = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetEntityByRoomKeyRequest() { }
        /// Friend allocator used by soap_new__ns1__GetEntityByRoomKeyRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetEntityByRoomKeyRequest * SOAP_FMAC2 soap_instantiate__ns1__GetEntityByRoomKeyRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:502 */
#ifndef SOAP_TYPE__ns1__GetEntityByRoomKeyResponse
#define SOAP_TYPE__ns1__GetEntityByRoomKeyResponse (128)
/* complex XSD type 'ns1:GetEntityByRoomKeyResponse': */
class SOAP_CMAC _ns1__GetEntityByRoomKeyResponse {
      public:
        /// Required element 'ns1:Entity' of XSD type 'ns1:Entity'
        _ns1__Entity *Entity;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetEntityByRoomKeyResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetEntityByRoomKeyResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetEntityByRoomKeyResponse, default initialized and not managed by a soap context
        virtual _ns1__GetEntityByRoomKeyResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetEntityByRoomKeyResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetEntityByRoomKeyResponse()
        {
          Entity = (_ns1__Entity *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetEntityByRoomKeyResponse() { }
        /// Friend allocator used by soap_new__ns1__GetEntityByRoomKeyResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetEntityByRoomKeyResponse * SOAP_FMAC2 soap_instantiate__ns1__GetEntityByRoomKeyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:505 */
#ifndef SOAP_TYPE__ns1__GetInviteContentRequest
#define SOAP_TYPE__ns1__GetInviteContentRequest (129)
/* complex XSD type 'ns1:GetInviteContentRequest': */
class SOAP_CMAC _ns1__GetInviteContentRequest {
      public:
        /// Optional element 'ns1:roomID' of XSD type 'ns1:EntityID'
        char *roomID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetInviteContentRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetInviteContentRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetInviteContentRequest, default initialized and not managed by a soap context
        virtual _ns1__GetInviteContentRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__GetInviteContentRequest); }
      public:
        /// Constructor with initializations
        _ns1__GetInviteContentRequest()
        {
          roomID = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetInviteContentRequest() { }
        /// Friend allocator used by soap_new__ns1__GetInviteContentRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetInviteContentRequest * SOAP_FMAC2 soap_instantiate__ns1__GetInviteContentRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:508 */
#ifndef SOAP_TYPE__ns1__GetInviteContentResponse
#define SOAP_TYPE__ns1__GetInviteContentResponse (130)
/* complex XSD type 'ns1:GetInviteContentResponse': */
class SOAP_CMAC _ns1__GetInviteContentResponse {
      public:
        /// Required element 'ns1:content' of XSD type 'xsd:string'
        char *content;
        /// Optional element 'ns1:subject' of XSD type 'xsd:string'
        char *subject;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetInviteContentResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetInviteContentResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetInviteContentResponse, default initialized and not managed by a soap context
        virtual _ns1__GetInviteContentResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetInviteContentResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetInviteContentResponse()
        {
          content = (char *)0;
          subject = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetInviteContentResponse() { }
        /// Friend allocator used by soap_new__ns1__GetInviteContentResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetInviteContentResponse * SOAP_FMAC2 soap_instantiate__ns1__GetInviteContentResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:514 */
#ifndef SOAP_TYPE__ns1__GetRoomProfilesResponse
#define SOAP_TYPE__ns1__GetRoomProfilesResponse (131)
/* complex XSD type 'ns1:GetRoomProfilesResponse': */
class SOAP_CMAC _ns1__GetRoomProfilesResponse {
      public:
        /// Required element 'ns1:total' of XSD type 'xsd:int'
        int total;
        /// Sequence of elements 'ns1:roomProfile' of XSD type 'ns1:RoomProfile' stored in dynamic array roomProfile of length __sizeroomProfile
        int __sizeroomProfile;
        ns1__RoomProfile **roomProfile;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetRoomProfilesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetRoomProfilesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetRoomProfilesResponse, default initialized and not managed by a soap context
        virtual _ns1__GetRoomProfilesResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetRoomProfilesResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetRoomProfilesResponse()
        {
          total = (int)0;
          __sizeroomProfile = 0;
          roomProfile = NULL;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetRoomProfilesResponse() { }
        /// Friend allocator used by soap_new__ns1__GetRoomProfilesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetRoomProfilesResponse * SOAP_FMAC2 soap_instantiate__ns1__GetRoomProfilesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:517 */
#ifndef SOAP_TYPE__ns1__GetRoomProfileRequest
#define SOAP_TYPE__ns1__GetRoomProfileRequest (132)
/* complex XSD type 'ns1:GetRoomProfileRequest': */
class SOAP_CMAC _ns1__GetRoomProfileRequest {
      public:
        /// Required element 'ns1:roomID' of XSD type 'ns1:EntityID'
        char *roomID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetRoomProfileRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetRoomProfileRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetRoomProfileRequest, default initialized and not managed by a soap context
        virtual _ns1__GetRoomProfileRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__GetRoomProfileRequest); }
      public:
        /// Constructor with initializations
        _ns1__GetRoomProfileRequest()
        {
          roomID = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetRoomProfileRequest() { }
        /// Friend allocator used by soap_new__ns1__GetRoomProfileRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetRoomProfileRequest * SOAP_FMAC2 soap_instantiate__ns1__GetRoomProfileRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:520 */
#ifndef SOAP_TYPE__ns1__GetRoomProfileResponse
#define SOAP_TYPE__ns1__GetRoomProfileResponse (133)
/* complex XSD type 'ns1:GetRoomProfileResponse': */
class SOAP_CMAC _ns1__GetRoomProfileResponse {
      public:
        /// Required element 'ns1:roomProfile' of XSD type 'ns1:RoomProfile'
        ns1__RoomProfile *roomProfile;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetRoomProfileResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetRoomProfileResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetRoomProfileResponse, default initialized and not managed by a soap context
        virtual _ns1__GetRoomProfileResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetRoomProfileResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetRoomProfileResponse()
        {
          roomProfile = (ns1__RoomProfile *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetRoomProfileResponse() { }
        /// Friend allocator used by soap_new__ns1__GetRoomProfileResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetRoomProfileResponse * SOAP_FMAC2 soap_instantiate__ns1__GetRoomProfileResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:523 */
#ifndef SOAP_TYPE__ns1__SetRoomProfileRequest
#define SOAP_TYPE__ns1__SetRoomProfileRequest (134)
/* complex XSD type 'ns1:SetRoomProfileRequest': */
class SOAP_CMAC _ns1__SetRoomProfileRequest {
      public:
        /// Required element 'ns1:roomID' of XSD type 'ns1:EntityID'
        char *roomID;
        /// Required element 'ns1:roomProfileName' of XSD type 'xsd:string'
        char *roomProfileName;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetRoomProfileRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetRoomProfileRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetRoomProfileRequest, default initialized and not managed by a soap context
        virtual _ns1__SetRoomProfileRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__SetRoomProfileRequest); }
      public:
        /// Constructor with initializations
        _ns1__SetRoomProfileRequest()
        {
          roomID = (char *)0;
          roomProfileName = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetRoomProfileRequest() { }
        /// Friend allocator used by soap_new__ns1__SetRoomProfileRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetRoomProfileRequest * SOAP_FMAC2 soap_instantiate__ns1__SetRoomProfileRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:526 */
#ifndef SOAP_TYPE__ns1__SetRoomProfileResponse
#define SOAP_TYPE__ns1__SetRoomProfileResponse (135)
/* complex XSD type 'ns1:SetRoomProfileResponse': */
class SOAP_CMAC _ns1__SetRoomProfileResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetRoomProfileResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetRoomProfileResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetRoomProfileResponse, default initialized and not managed by a soap context
        virtual _ns1__SetRoomProfileResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SetRoomProfileResponse); }
      public:
        /// Constructor with initializations
        _ns1__SetRoomProfileResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetRoomProfileResponse() { }
        /// Friend allocator used by soap_new__ns1__SetRoomProfileResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetRoomProfileResponse * SOAP_FMAC2 soap_instantiate__ns1__SetRoomProfileResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:529 */
#ifndef SOAP_TYPE__ns1__RemoveRoomProfileRequest
#define SOAP_TYPE__ns1__RemoveRoomProfileRequest (136)
/* complex XSD type 'ns1:RemoveRoomProfileRequest': */
class SOAP_CMAC _ns1__RemoveRoomProfileRequest {
      public:
        /// Required element 'ns1:roomID' of XSD type 'ns1:EntityID'
        char *roomID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RemoveRoomProfileRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__RemoveRoomProfileRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RemoveRoomProfileRequest, default initialized and not managed by a soap context
        virtual _ns1__RemoveRoomProfileRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__RemoveRoomProfileRequest); }
      public:
        /// Constructor with initializations
        _ns1__RemoveRoomProfileRequest()
        {
          roomID = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__RemoveRoomProfileRequest() { }
        /// Friend allocator used by soap_new__ns1__RemoveRoomProfileRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RemoveRoomProfileRequest * SOAP_FMAC2 soap_instantiate__ns1__RemoveRoomProfileRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:532 */
#ifndef SOAP_TYPE__ns1__RemoveRoomProfileResponse
#define SOAP_TYPE__ns1__RemoveRoomProfileResponse (137)
/* complex XSD type 'ns1:RemoveRoomProfileResponse': */
class SOAP_CMAC _ns1__RemoveRoomProfileResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RemoveRoomProfileResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__RemoveRoomProfileResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RemoveRoomProfileResponse, default initialized and not managed by a soap context
        virtual _ns1__RemoveRoomProfileResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__RemoveRoomProfileResponse); }
      public:
        /// Constructor with initializations
        _ns1__RemoveRoomProfileResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__RemoveRoomProfileResponse() { }
        /// Friend allocator used by soap_new__ns1__RemoveRoomProfileResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RemoveRoomProfileResponse * SOAP_FMAC2 soap_instantiate__ns1__RemoveRoomProfileResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:535 */
#ifndef SOAP_TYPE__ns1__CreateModeratorURLRequest
#define SOAP_TYPE__ns1__CreateModeratorURLRequest (138)
/* complex XSD type 'ns1:CreateModeratorURLRequest': */
class SOAP_CMAC _ns1__CreateModeratorURLRequest {
      public:
        /// Required element 'ns1:roomID' of XSD type 'ns1:EntityID'
        char *roomID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CreateModeratorURLRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CreateModeratorURLRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CreateModeratorURLRequest, default initialized and not managed by a soap context
        virtual _ns1__CreateModeratorURLRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__CreateModeratorURLRequest); }
      public:
        /// Constructor with initializations
        _ns1__CreateModeratorURLRequest()
        {
          roomID = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__CreateModeratorURLRequest() { }
        /// Friend allocator used by soap_new__ns1__CreateModeratorURLRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CreateModeratorURLRequest * SOAP_FMAC2 soap_instantiate__ns1__CreateModeratorURLRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:538 */
#ifndef SOAP_TYPE__ns1__CreateModeratorURLResponse
#define SOAP_TYPE__ns1__CreateModeratorURLResponse (139)
/* complex XSD type 'ns1:CreateModeratorURLResponse': */
class SOAP_CMAC _ns1__CreateModeratorURLResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CreateModeratorURLResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CreateModeratorURLResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CreateModeratorURLResponse, default initialized and not managed by a soap context
        virtual _ns1__CreateModeratorURLResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__CreateModeratorURLResponse); }
      public:
        /// Constructor with initializations
        _ns1__CreateModeratorURLResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__CreateModeratorURLResponse() { }
        /// Friend allocator used by soap_new__ns1__CreateModeratorURLResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CreateModeratorURLResponse * SOAP_FMAC2 soap_instantiate__ns1__CreateModeratorURLResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:541 */
#ifndef SOAP_TYPE__ns1__RemoveModeratorURLRequest
#define SOAP_TYPE__ns1__RemoveModeratorURLRequest (140)
/* complex XSD type 'ns1:RemoveModeratorURLRequest': */
class SOAP_CMAC _ns1__RemoveModeratorURLRequest {
      public:
        /// Required element 'ns1:roomID' of XSD type 'ns1:EntityID'
        char *roomID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RemoveModeratorURLRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__RemoveModeratorURLRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RemoveModeratorURLRequest, default initialized and not managed by a soap context
        virtual _ns1__RemoveModeratorURLRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__RemoveModeratorURLRequest); }
      public:
        /// Constructor with initializations
        _ns1__RemoveModeratorURLRequest()
        {
          roomID = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__RemoveModeratorURLRequest() { }
        /// Friend allocator used by soap_new__ns1__RemoveModeratorURLRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RemoveModeratorURLRequest * SOAP_FMAC2 soap_instantiate__ns1__RemoveModeratorURLRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:544 */
#ifndef SOAP_TYPE__ns1__RemoveModeratorURLResponse
#define SOAP_TYPE__ns1__RemoveModeratorURLResponse (141)
/* complex XSD type 'ns1:RemoveModeratorURLResponse': */
class SOAP_CMAC _ns1__RemoveModeratorURLResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RemoveModeratorURLResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__RemoveModeratorURLResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RemoveModeratorURLResponse, default initialized and not managed by a soap context
        virtual _ns1__RemoveModeratorURLResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__RemoveModeratorURLResponse); }
      public:
        /// Constructor with initializations
        _ns1__RemoveModeratorURLResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__RemoveModeratorURLResponse() { }
        /// Friend allocator used by soap_new__ns1__RemoveModeratorURLResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RemoveModeratorURLResponse * SOAP_FMAC2 soap_instantiate__ns1__RemoveModeratorURLResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:547 */
#ifndef SOAP_TYPE__ns1__GetModeratorURLRequest
#define SOAP_TYPE__ns1__GetModeratorURLRequest (142)
/* complex XSD type 'ns1:GetModeratorURLRequest': */
class SOAP_CMAC _ns1__GetModeratorURLRequest {
      public:
        /// Required element 'ns1:roomID' of XSD type 'ns1:EntityID'
        char *roomID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetModeratorURLRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetModeratorURLRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetModeratorURLRequest, default initialized and not managed by a soap context
        virtual _ns1__GetModeratorURLRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__GetModeratorURLRequest); }
      public:
        /// Constructor with initializations
        _ns1__GetModeratorURLRequest()
        {
          roomID = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetModeratorURLRequest() { }
        /// Friend allocator used by soap_new__ns1__GetModeratorURLRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetModeratorURLRequest * SOAP_FMAC2 soap_instantiate__ns1__GetModeratorURLRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:550 */
#ifndef SOAP_TYPE__ns1__GetModeratorURLResponse
#define SOAP_TYPE__ns1__GetModeratorURLResponse (143)
/* complex XSD type 'ns1:GetModeratorURLResponse': */
class SOAP_CMAC _ns1__GetModeratorURLResponse {
      public:
        /// Optional element 'ns1:moderatorURL' of XSD type 'xsd:string'
        char *moderatorURL;
        /// Optional element 'ns1:hasModeratorPIN' of XSD type 'xsd:boolean'
        bool *hasModeratorPIN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetModeratorURLResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetModeratorURLResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetModeratorURLResponse, default initialized and not managed by a soap context
        virtual _ns1__GetModeratorURLResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetModeratorURLResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetModeratorURLResponse()
        {
          moderatorURL = (char *)0;
          hasModeratorPIN = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetModeratorURLResponse() { }
        /// Friend allocator used by soap_new__ns1__GetModeratorURLResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetModeratorURLResponse * SOAP_FMAC2 soap_instantiate__ns1__GetModeratorURLResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:553 */
#ifndef SOAP_TYPE__ns1__GetModeratorURLWithTokenRequest
#define SOAP_TYPE__ns1__GetModeratorURLWithTokenRequest (144)
/* complex XSD type 'ns1:GetModeratorURLWithTokenRequest': */
class SOAP_CMAC _ns1__GetModeratorURLWithTokenRequest {
      public:
        /// Required element 'ns1:roomID' of XSD type 'ns1:EntityID'
        char *roomID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetModeratorURLWithTokenRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetModeratorURLWithTokenRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetModeratorURLWithTokenRequest, default initialized and not managed by a soap context
        virtual _ns1__GetModeratorURLWithTokenRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__GetModeratorURLWithTokenRequest); }
      public:
        /// Constructor with initializations
        _ns1__GetModeratorURLWithTokenRequest()
        {
          roomID = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetModeratorURLWithTokenRequest() { }
        /// Friend allocator used by soap_new__ns1__GetModeratorURLWithTokenRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetModeratorURLWithTokenRequest * SOAP_FMAC2 soap_instantiate__ns1__GetModeratorURLWithTokenRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:556 */
#ifndef SOAP_TYPE__ns1__GetModeratorURLWithTokenResponse
#define SOAP_TYPE__ns1__GetModeratorURLWithTokenResponse (145)
/* complex XSD type 'ns1:GetModeratorURLWithTokenResponse': */
class SOAP_CMAC _ns1__GetModeratorURLWithTokenResponse {
      public:
        /// Required element 'ns1:moderatorURL' of XSD type 'xsd:string'
        char *moderatorURL;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetModeratorURLWithTokenResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetModeratorURLWithTokenResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetModeratorURLWithTokenResponse, default initialized and not managed by a soap context
        virtual _ns1__GetModeratorURLWithTokenResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetModeratorURLWithTokenResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetModeratorURLWithTokenResponse()
        {
          moderatorURL = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetModeratorURLWithTokenResponse() { }
        /// Friend allocator used by soap_new__ns1__GetModeratorURLWithTokenResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetModeratorURLWithTokenResponse * SOAP_FMAC2 soap_instantiate__ns1__GetModeratorURLWithTokenResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:559 */
#ifndef SOAP_TYPE__ns1__CreateModeratorPINRequest
#define SOAP_TYPE__ns1__CreateModeratorPINRequest (146)
/* complex XSD type 'ns1:CreateModeratorPINRequest': */
class SOAP_CMAC _ns1__CreateModeratorPINRequest {
      public:
        /// Required element 'ns1:roomID' of XSD type 'ns1:EntityID'
        char *roomID;
        /// Required element 'ns1:PIN' of XSD type 'xsd:string'
        char *PIN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CreateModeratorPINRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CreateModeratorPINRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CreateModeratorPINRequest, default initialized and not managed by a soap context
        virtual _ns1__CreateModeratorPINRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__CreateModeratorPINRequest); }
      public:
        /// Constructor with initializations
        _ns1__CreateModeratorPINRequest()
        {
          roomID = (char *)0;
          PIN = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__CreateModeratorPINRequest() { }
        /// Friend allocator used by soap_new__ns1__CreateModeratorPINRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CreateModeratorPINRequest * SOAP_FMAC2 soap_instantiate__ns1__CreateModeratorPINRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:562 */
#ifndef SOAP_TYPE__ns1__CreateModeratorPINResponse
#define SOAP_TYPE__ns1__CreateModeratorPINResponse (147)
/* complex XSD type 'ns1:CreateModeratorPINResponse': */
class SOAP_CMAC _ns1__CreateModeratorPINResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CreateModeratorPINResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CreateModeratorPINResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CreateModeratorPINResponse, default initialized and not managed by a soap context
        virtual _ns1__CreateModeratorPINResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__CreateModeratorPINResponse); }
      public:
        /// Constructor with initializations
        _ns1__CreateModeratorPINResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__CreateModeratorPINResponse() { }
        /// Friend allocator used by soap_new__ns1__CreateModeratorPINResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CreateModeratorPINResponse * SOAP_FMAC2 soap_instantiate__ns1__CreateModeratorPINResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:565 */
#ifndef SOAP_TYPE__ns1__RemoveModeratorPINRequest
#define SOAP_TYPE__ns1__RemoveModeratorPINRequest (148)
/* complex XSD type 'ns1:RemoveModeratorPINRequest': */
class SOAP_CMAC _ns1__RemoveModeratorPINRequest {
      public:
        /// Required element 'ns1:roomID' of XSD type 'ns1:EntityID'
        char *roomID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RemoveModeratorPINRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__RemoveModeratorPINRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RemoveModeratorPINRequest, default initialized and not managed by a soap context
        virtual _ns1__RemoveModeratorPINRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__RemoveModeratorPINRequest); }
      public:
        /// Constructor with initializations
        _ns1__RemoveModeratorPINRequest()
        {
          roomID = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__RemoveModeratorPINRequest() { }
        /// Friend allocator used by soap_new__ns1__RemoveModeratorPINRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RemoveModeratorPINRequest * SOAP_FMAC2 soap_instantiate__ns1__RemoveModeratorPINRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:568 */
#ifndef SOAP_TYPE__ns1__RemoveModeratorPINResponse
#define SOAP_TYPE__ns1__RemoveModeratorPINResponse (149)
/* complex XSD type 'ns1:RemoveModeratorPINResponse': */
class SOAP_CMAC _ns1__RemoveModeratorPINResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RemoveModeratorPINResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__RemoveModeratorPINResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RemoveModeratorPINResponse, default initialized and not managed by a soap context
        virtual _ns1__RemoveModeratorPINResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__RemoveModeratorPINResponse); }
      public:
        /// Constructor with initializations
        _ns1__RemoveModeratorPINResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__RemoveModeratorPINResponse() { }
        /// Friend allocator used by soap_new__ns1__RemoveModeratorPINResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RemoveModeratorPINResponse * SOAP_FMAC2 soap_instantiate__ns1__RemoveModeratorPINResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:571 */
#ifndef SOAP_TYPE__ns1__GetConferenceIDRequest
#define SOAP_TYPE__ns1__GetConferenceIDRequest (150)
/* complex XSD type 'ns1:GetConferenceIDRequest': */
class SOAP_CMAC _ns1__GetConferenceIDRequest {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetConferenceIDRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetConferenceIDRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetConferenceIDRequest, default initialized and not managed by a soap context
        virtual _ns1__GetConferenceIDRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__GetConferenceIDRequest); }
      public:
        /// Constructor with initializations
        _ns1__GetConferenceIDRequest()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetConferenceIDRequest() { }
        /// Friend allocator used by soap_new__ns1__GetConferenceIDRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetConferenceIDRequest * SOAP_FMAC2 soap_instantiate__ns1__GetConferenceIDRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:574 */
#ifndef SOAP_TYPE__ns1__GetConferenceIDResponse
#define SOAP_TYPE__ns1__GetConferenceIDResponse (151)
/* complex XSD type 'ns1:GetConferenceIDResponse': */
class SOAP_CMAC _ns1__GetConferenceIDResponse {
      public:
        /// Optional element 'ns1:conferenceID' of XSD type 'ns1:EntityID'
        char *conferenceID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetConferenceIDResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetConferenceIDResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetConferenceIDResponse, default initialized and not managed by a soap context
        virtual _ns1__GetConferenceIDResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetConferenceIDResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetConferenceIDResponse()
        {
          conferenceID = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetConferenceIDResponse() { }
        /// Friend allocator used by soap_new__ns1__GetConferenceIDResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetConferenceIDResponse * SOAP_FMAC2 soap_instantiate__ns1__GetConferenceIDResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:577 */
#ifndef SOAP_TYPE__ns1__GenerateAuthTokenRequest
#define SOAP_TYPE__ns1__GenerateAuthTokenRequest (152)
/* complex XSD type 'ns1:GenerateAuthTokenRequest': */
class SOAP_CMAC _ns1__GenerateAuthTokenRequest {
      public:
        /// Required element 'ns1:validityTime' of XSD type 'xsd:int'
        int validityTime;
        /// Required element 'ns1:endpointId' of XSD type 'xsd:string'
        char *endpointId;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GenerateAuthTokenRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GenerateAuthTokenRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GenerateAuthTokenRequest, default initialized and not managed by a soap context
        virtual _ns1__GenerateAuthTokenRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__GenerateAuthTokenRequest); }
      public:
        /// Constructor with initializations
        _ns1__GenerateAuthTokenRequest()
        {
          validityTime = (int)0;
          endpointId = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GenerateAuthTokenRequest() { }
        /// Friend allocator used by soap_new__ns1__GenerateAuthTokenRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GenerateAuthTokenRequest * SOAP_FMAC2 soap_instantiate__ns1__GenerateAuthTokenRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:580 */
#ifndef SOAP_TYPE__ns1__GenerateAuthTokenResponse
#define SOAP_TYPE__ns1__GenerateAuthTokenResponse (153)
/* complex XSD type 'ns1:GenerateAuthTokenResponse': */
class SOAP_CMAC _ns1__GenerateAuthTokenResponse {
      public:
        /// Required element 'ns1:authToken' of XSD type 'xsd:string'
        char *authToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GenerateAuthTokenResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GenerateAuthTokenResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GenerateAuthTokenResponse, default initialized and not managed by a soap context
        virtual _ns1__GenerateAuthTokenResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GenerateAuthTokenResponse); }
      public:
        /// Constructor with initializations
        _ns1__GenerateAuthTokenResponse()
        {
          authToken = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GenerateAuthTokenResponse() { }
        /// Friend allocator used by soap_new__ns1__GenerateAuthTokenResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GenerateAuthTokenResponse * SOAP_FMAC2 soap_instantiate__ns1__GenerateAuthTokenResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:583 */
#ifndef SOAP_TYPE__ns1__CreateScheduledRoomRequest
#define SOAP_TYPE__ns1__CreateScheduledRoomRequest (154)
/* complex XSD type 'ns1:CreateScheduledRoomRequest': */
class SOAP_CMAC _ns1__CreateScheduledRoomRequest {
      public:
        /// Optional element 'ns1:recurring' of XSD type 'xsd:int'
        int *recurring;
        /// Optional element 'ns1:setPIN' of XSD type 'xsd:boolean'
        bool *setPIN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CreateScheduledRoomRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CreateScheduledRoomRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CreateScheduledRoomRequest, default initialized and not managed by a soap context
        virtual _ns1__CreateScheduledRoomRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__CreateScheduledRoomRequest); }
      public:
        /// Constructor with initializations
        _ns1__CreateScheduledRoomRequest()
        {
          recurring = (int *)0;
          setPIN = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__CreateScheduledRoomRequest() { }
        /// Friend allocator used by soap_new__ns1__CreateScheduledRoomRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CreateScheduledRoomRequest * SOAP_FMAC2 soap_instantiate__ns1__CreateScheduledRoomRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:586 */
#ifndef SOAP_TYPE__ns1__CreateScheduledRoomResponse
#define SOAP_TYPE__ns1__CreateScheduledRoomResponse (155)
/* complex XSD type 'ns1:CreateScheduledRoomResponse': */
class SOAP_CMAC _ns1__CreateScheduledRoomResponse {
      public:
        /// Required element 'ns1:extension' of XSD type 'xsd:string'
        char *extension;
        /// Optional element 'ns1:pin' of XSD type 'xsd:string'
        char **pin;
        /// Required element 'ns1:inviteContent' of XSD type 'xsd:string'
        char *inviteContent;
        /// Required element 'ns1:roomURL' of XSD type 'xsd:anyURI'
        char *roomURL;
        /// Optional element 'ns1:inviteSubject' of XSD type 'xsd:string'
        char *inviteSubject;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CreateScheduledRoomResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CreateScheduledRoomResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CreateScheduledRoomResponse, default initialized and not managed by a soap context
        virtual _ns1__CreateScheduledRoomResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__CreateScheduledRoomResponse); }
      public:
        /// Constructor with initializations
        _ns1__CreateScheduledRoomResponse()
        {
          extension = (char *)0;
          pin = (char **)0;
          inviteContent = (char *)0;
          roomURL = (char *)0;
          inviteSubject = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__CreateScheduledRoomResponse() { }
        /// Friend allocator used by soap_new__ns1__CreateScheduledRoomResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CreateScheduledRoomResponse * SOAP_FMAC2 soap_instantiate__ns1__CreateScheduledRoomResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:589 */
#ifndef SOAP_TYPE__ns1__DeleteScheduledRoomRequest
#define SOAP_TYPE__ns1__DeleteScheduledRoomRequest (156)
/* complex XSD type 'ns1:DeleteScheduledRoomRequest': */
class SOAP_CMAC _ns1__DeleteScheduledRoomRequest {
      public:
        /// Required element 'ns1:extension' of XSD type 'xsd:string'
        char *extension;
        /// Optional element 'ns1:pin' of XSD type 'xsd:string'
        char **pin;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DeleteScheduledRoomRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__DeleteScheduledRoomRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DeleteScheduledRoomRequest, default initialized and not managed by a soap context
        virtual _ns1__DeleteScheduledRoomRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__DeleteScheduledRoomRequest); }
      public:
        /// Constructor with initializations
        _ns1__DeleteScheduledRoomRequest()
        {
          extension = (char *)0;
          pin = (char **)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__DeleteScheduledRoomRequest() { }
        /// Friend allocator used by soap_new__ns1__DeleteScheduledRoomRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DeleteScheduledRoomRequest * SOAP_FMAC2 soap_instantiate__ns1__DeleteScheduledRoomRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:592 */
#ifndef SOAP_TYPE__ns1__DeleteScheduledRoomResponse
#define SOAP_TYPE__ns1__DeleteScheduledRoomResponse (157)
/* complex XSD type 'ns1:DeleteScheduledRoomResponse': */
class SOAP_CMAC _ns1__DeleteScheduledRoomResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DeleteScheduledRoomResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__DeleteScheduledRoomResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DeleteScheduledRoomResponse, default initialized and not managed by a soap context
        virtual _ns1__DeleteScheduledRoomResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__DeleteScheduledRoomResponse); }
      public:
        /// Constructor with initializations
        _ns1__DeleteScheduledRoomResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__DeleteScheduledRoomResponse() { }
        /// Friend allocator used by soap_new__ns1__DeleteScheduledRoomResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DeleteScheduledRoomResponse * SOAP_FMAC2 soap_instantiate__ns1__DeleteScheduledRoomResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:595 */
#ifndef SOAP_TYPE__ns1__PortalFeature
#define SOAP_TYPE__ns1__PortalFeature (158)
/* complex XSD type 'ns1:PortalFeature': */
class SOAP_CMAC _ns1__PortalFeature {
      public:
        /// Required element 'ns1:feature' of XSD type 'ns1:PortalFeatureName'
        char *feature;
        /// Required element 'ns1:enable' of XSD type 'xsd:boolean'
        bool enable;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__PortalFeature
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__PortalFeature; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__PortalFeature, default initialized and not managed by a soap context
        virtual _ns1__PortalFeature *soap_alloc(void) const { return SOAP_NEW(_ns1__PortalFeature); }
      public:
        /// Constructor with initializations
        _ns1__PortalFeature()
        {
          feature = (char *)0;
          enable = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__PortalFeature() { }
        /// Friend allocator used by soap_new__ns1__PortalFeature(struct soap*, int)
        friend SOAP_FMAC1 _ns1__PortalFeature * SOAP_FMAC2 soap_instantiate__ns1__PortalFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:601 */
#ifndef SOAP_TYPE__ns1__GetPortalFeaturesResponse
#define SOAP_TYPE__ns1__GetPortalFeaturesResponse (159)
/* complex XSD type 'ns1:GetPortalFeaturesResponse': */
class SOAP_CMAC _ns1__GetPortalFeaturesResponse {
      public:
        /// Sequence of at least 1 elements 'ns1:PortalFeature' of XSD type 'ns1:PortalFeature' stored in dynamic array PortalFeature of length __sizePortalFeature
        int __sizePortalFeature;
        _ns1__PortalFeature **PortalFeature;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetPortalFeaturesResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetPortalFeaturesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetPortalFeaturesResponse, default initialized and not managed by a soap context
        virtual _ns1__GetPortalFeaturesResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetPortalFeaturesResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetPortalFeaturesResponse()
        {
          __sizePortalFeature = 0;
          PortalFeature = NULL;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetPortalFeaturesResponse() { }
        /// Friend allocator used by soap_new__ns1__GetPortalFeaturesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetPortalFeaturesResponse * SOAP_FMAC2 soap_instantiate__ns1__GetPortalFeaturesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:604 */
#ifndef SOAP_TYPE__ns1__EndpointFeature
#define SOAP_TYPE__ns1__EndpointFeature (160)
/* complex XSD type 'ns1:EndpointFeature': */
class SOAP_CMAC _ns1__EndpointFeature {
      public:
        /// Required element 'ns1:feature' of XSD type 'ns1:EndpointFeatureName'
        char *feature;
        /// Required element 'ns1:enable' of XSD type 'xsd:boolean'
        bool enable;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__EndpointFeature
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__EndpointFeature; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__EndpointFeature, default initialized and not managed by a soap context
        virtual _ns1__EndpointFeature *soap_alloc(void) const { return SOAP_NEW(_ns1__EndpointFeature); }
      public:
        /// Constructor with initializations
        _ns1__EndpointFeature()
        {
          feature = (char *)0;
          enable = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__EndpointFeature() { }
        /// Friend allocator used by soap_new__ns1__EndpointFeature(struct soap*, int)
        friend SOAP_FMAC1 _ns1__EndpointFeature * SOAP_FMAC2 soap_instantiate__ns1__EndpointFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:607 */
#ifndef SOAP_TYPE__ns1__SetEndpointDetailsRequest
#define SOAP_TYPE__ns1__SetEndpointDetailsRequest (161)
/* complex XSD type 'ns1:SetEndpointDetailsRequest': */
class SOAP_CMAC _ns1__SetEndpointDetailsRequest {
      public:
        /// Required element 'ns1:EID' of XSD type 'xsd:string'
        char *EID;
        /// Sequence of at least 1 elements 'ns1:EndpointFeature' of XSD type 'ns1:EndpointFeature' stored in dynamic array EndpointFeature of length __sizeEndpointFeature
        int __sizeEndpointFeature;
        _ns1__EndpointFeature **EndpointFeature;
        /// Optional element 'ns1:applicationName' of XSD type 'xsd:string'
        char *applicationName;
        /// Optional element 'ns1:applicationVersion' of XSD type 'xsd:string'
        char *applicationVersion;
        /// Optional element 'ns1:applicationOs' of XSD type 'xsd:string'
        char *applicationOs;
        /// Optional element 'ns1:deviceModel' of XSD type 'xsd:string'
        char *deviceModel;
        /// Sequence of elements '-any' of XSD type 'xsd:anyType' stored in dynamic array __any of length __size
        int __size;
        char *__any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetEndpointDetailsRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetEndpointDetailsRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetEndpointDetailsRequest, default initialized and not managed by a soap context
        virtual _ns1__SetEndpointDetailsRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__SetEndpointDetailsRequest); }
      public:
        /// Constructor with initializations
        _ns1__SetEndpointDetailsRequest()
        {
          EID = (char *)0;
          __sizeEndpointFeature = 0;
          EndpointFeature = NULL;
          applicationName = (char *)0;
          applicationVersion = (char *)0;
          applicationOs = (char *)0;
          deviceModel = (char *)0;
          __size = 0;
          __any = NULL;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetEndpointDetailsRequest() { }
        /// Friend allocator used by soap_new__ns1__SetEndpointDetailsRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetEndpointDetailsRequest * SOAP_FMAC2 soap_instantiate__ns1__SetEndpointDetailsRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:610 */
#ifndef SOAP_TYPE__ns1__SetEndpointDetailsResponse
#define SOAP_TYPE__ns1__SetEndpointDetailsResponse (162)
/* complex XSD type 'ns1:SetEndpointDetailsResponse': */
class SOAP_CMAC _ns1__SetEndpointDetailsResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetEndpointDetailsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetEndpointDetailsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetEndpointDetailsResponse, default initialized and not managed by a soap context
        virtual _ns1__SetEndpointDetailsResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SetEndpointDetailsResponse); }
      public:
        /// Constructor with initializations
        _ns1__SetEndpointDetailsResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetEndpointDetailsResponse() { }
        /// Friend allocator used by soap_new__ns1__SetEndpointDetailsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetEndpointDetailsResponse * SOAP_FMAC2 soap_instantiate__ns1__SetEndpointDetailsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:616 */
#ifndef SOAP_TYPE__ns1__GetActiveSessionsResponse
#define SOAP_TYPE__ns1__GetActiveSessionsResponse (163)
/* complex XSD type 'ns1:GetActiveSessionsResponse': */
class SOAP_CMAC _ns1__GetActiveSessionsResponse {
      public:
        /// Required element 'ns1:count' of XSD type 'xsd:int'
        int count;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetActiveSessionsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetActiveSessionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetActiveSessionsResponse, default initialized and not managed by a soap context
        virtual _ns1__GetActiveSessionsResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetActiveSessionsResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetActiveSessionsResponse()
        {
          count = (int)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetActiveSessionsResponse() { }
        /// Friend allocator used by soap_new__ns1__GetActiveSessionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetActiveSessionsResponse * SOAP_FMAC2 soap_instantiate__ns1__GetActiveSessionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:622 */
#ifndef SOAP_TYPE__ns1__LogoutAllOtherSessionsResponse
#define SOAP_TYPE__ns1__LogoutAllOtherSessionsResponse (164)
/* complex XSD type 'ns1:LogoutAllOtherSessionsResponse': */
class SOAP_CMAC _ns1__LogoutAllOtherSessionsResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__LogoutAllOtherSessionsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__LogoutAllOtherSessionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__LogoutAllOtherSessionsResponse, default initialized and not managed by a soap context
        virtual _ns1__LogoutAllOtherSessionsResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__LogoutAllOtherSessionsResponse); }
      public:
        /// Constructor with initializations
        _ns1__LogoutAllOtherSessionsResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__LogoutAllOtherSessionsResponse() { }
        /// Friend allocator used by soap_new__ns1__LogoutAllOtherSessionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__LogoutAllOtherSessionsResponse * SOAP_FMAC2 soap_instantiate__ns1__LogoutAllOtherSessionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:625 */
#ifndef SOAP_TYPE__ns1__disconnectConferenceAllRequest
#define SOAP_TYPE__ns1__disconnectConferenceAllRequest (165)
/* complex XSD type 'ns1:disconnectConferenceAllRequest': */
class SOAP_CMAC _ns1__disconnectConferenceAllRequest {
      public:
        /// Required element 'ns1:conferenceID' of XSD type 'ns1:EntityID'
        char *conferenceID;
        /// Optional element 'ns1:moderatorPIN' of XSD type 'xsd:string'
        char *moderatorPIN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__disconnectConferenceAllRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__disconnectConferenceAllRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__disconnectConferenceAllRequest, default initialized and not managed by a soap context
        virtual _ns1__disconnectConferenceAllRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__disconnectConferenceAllRequest); }
      public:
        /// Constructor with initializations
        _ns1__disconnectConferenceAllRequest()
        {
          conferenceID = (char *)0;
          moderatorPIN = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__disconnectConferenceAllRequest() { }
        /// Friend allocator used by soap_new__ns1__disconnectConferenceAllRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__disconnectConferenceAllRequest * SOAP_FMAC2 soap_instantiate__ns1__disconnectConferenceAllRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:628 */
#ifndef SOAP_TYPE__ns1__disconnectConferenceAllResponse
#define SOAP_TYPE__ns1__disconnectConferenceAllResponse (166)
/* complex XSD type 'ns1:disconnectConferenceAllResponse': */
class SOAP_CMAC _ns1__disconnectConferenceAllResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__disconnectConferenceAllResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__disconnectConferenceAllResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__disconnectConferenceAllResponse, default initialized and not managed by a soap context
        virtual _ns1__disconnectConferenceAllResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__disconnectConferenceAllResponse); }
      public:
        /// Constructor with initializations
        _ns1__disconnectConferenceAllResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__disconnectConferenceAllResponse() { }
        /// Friend allocator used by soap_new__ns1__disconnectConferenceAllResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__disconnectConferenceAllResponse * SOAP_FMAC2 soap_instantiate__ns1__disconnectConferenceAllResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:631 */
#ifndef SOAP_TYPE__ns1__muteAudioServerAllRequest
#define SOAP_TYPE__ns1__muteAudioServerAllRequest (167)
/* complex XSD type 'ns1:muteAudioServerAllRequest': */
class SOAP_CMAC _ns1__muteAudioServerAllRequest {
      public:
        /// Required element 'ns1:conferenceID' of XSD type 'ns1:EntityID'
        char *conferenceID;
        /// Required element 'ns1:muteState' of XSD type 'xsd:boolean'
        bool muteState;
        /// Optional element 'ns1:moderatorPIN' of XSD type 'xsd:string'
        char *moderatorPIN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__muteAudioServerAllRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__muteAudioServerAllRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__muteAudioServerAllRequest, default initialized and not managed by a soap context
        virtual _ns1__muteAudioServerAllRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__muteAudioServerAllRequest); }
      public:
        /// Constructor with initializations
        _ns1__muteAudioServerAllRequest()
        {
          conferenceID = (char *)0;
          muteState = (bool)0;
          moderatorPIN = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__muteAudioServerAllRequest() { }
        /// Friend allocator used by soap_new__ns1__muteAudioServerAllRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__muteAudioServerAllRequest * SOAP_FMAC2 soap_instantiate__ns1__muteAudioServerAllRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:634 */
#ifndef SOAP_TYPE__ns1__muteAudioServerAllResponse
#define SOAP_TYPE__ns1__muteAudioServerAllResponse (168)
/* complex XSD type 'ns1:muteAudioServerAllResponse': */
class SOAP_CMAC _ns1__muteAudioServerAllResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__muteAudioServerAllResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__muteAudioServerAllResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__muteAudioServerAllResponse, default initialized and not managed by a soap context
        virtual _ns1__muteAudioServerAllResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__muteAudioServerAllResponse); }
      public:
        /// Constructor with initializations
        _ns1__muteAudioServerAllResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__muteAudioServerAllResponse() { }
        /// Friend allocator used by soap_new__ns1__muteAudioServerAllResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__muteAudioServerAllResponse * SOAP_FMAC2 soap_instantiate__ns1__muteAudioServerAllResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:637 */
#ifndef SOAP_TYPE__ns1__muteAudioClientAllRequest
#define SOAP_TYPE__ns1__muteAudioClientAllRequest (169)
/* complex XSD type 'ns1:muteAudioClientAllRequest': */
class SOAP_CMAC _ns1__muteAudioClientAllRequest {
      public:
        /// Required element 'ns1:conferenceID' of XSD type 'ns1:EntityID'
        char *conferenceID;
        /// Optional element 'ns1:moderatorPIN' of XSD type 'xsd:string'
        char *moderatorPIN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__muteAudioClientAllRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__muteAudioClientAllRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__muteAudioClientAllRequest, default initialized and not managed by a soap context
        virtual _ns1__muteAudioClientAllRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__muteAudioClientAllRequest); }
      public:
        /// Constructor with initializations
        _ns1__muteAudioClientAllRequest()
        {
          conferenceID = (char *)0;
          moderatorPIN = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__muteAudioClientAllRequest() { }
        /// Friend allocator used by soap_new__ns1__muteAudioClientAllRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__muteAudioClientAllRequest * SOAP_FMAC2 soap_instantiate__ns1__muteAudioClientAllRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:640 */
#ifndef SOAP_TYPE__ns1__muteAudioClientAllResponse
#define SOAP_TYPE__ns1__muteAudioClientAllResponse (170)
/* complex XSD type 'ns1:muteAudioClientAllResponse': */
class SOAP_CMAC _ns1__muteAudioClientAllResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__muteAudioClientAllResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__muteAudioClientAllResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__muteAudioClientAllResponse, default initialized and not managed by a soap context
        virtual _ns1__muteAudioClientAllResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__muteAudioClientAllResponse); }
      public:
        /// Constructor with initializations
        _ns1__muteAudioClientAllResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__muteAudioClientAllResponse() { }
        /// Friend allocator used by soap_new__ns1__muteAudioClientAllResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__muteAudioClientAllResponse * SOAP_FMAC2 soap_instantiate__ns1__muteAudioClientAllResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:643 */
#ifndef SOAP_TYPE__ns1__muteVideoServerAllRequest
#define SOAP_TYPE__ns1__muteVideoServerAllRequest (171)
/* complex XSD type 'ns1:muteVideoServerAllRequest': */
class SOAP_CMAC _ns1__muteVideoServerAllRequest {
      public:
        /// Required element 'ns1:conferenceID' of XSD type 'ns1:EntityID'
        char *conferenceID;
        /// Required element 'ns1:muteState' of XSD type 'xsd:boolean'
        bool muteState;
        /// Optional element 'ns1:moderatorPIN' of XSD type 'xsd:string'
        char *moderatorPIN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__muteVideoServerAllRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__muteVideoServerAllRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__muteVideoServerAllRequest, default initialized and not managed by a soap context
        virtual _ns1__muteVideoServerAllRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__muteVideoServerAllRequest); }
      public:
        /// Constructor with initializations
        _ns1__muteVideoServerAllRequest()
        {
          conferenceID = (char *)0;
          muteState = (bool)0;
          moderatorPIN = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__muteVideoServerAllRequest() { }
        /// Friend allocator used by soap_new__ns1__muteVideoServerAllRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__muteVideoServerAllRequest * SOAP_FMAC2 soap_instantiate__ns1__muteVideoServerAllRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:646 */
#ifndef SOAP_TYPE__ns1__muteVideoServerAllResponse
#define SOAP_TYPE__ns1__muteVideoServerAllResponse (172)
/* complex XSD type 'ns1:muteVideoServerAllResponse': */
class SOAP_CMAC _ns1__muteVideoServerAllResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__muteVideoServerAllResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__muteVideoServerAllResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__muteVideoServerAllResponse, default initialized and not managed by a soap context
        virtual _ns1__muteVideoServerAllResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__muteVideoServerAllResponse); }
      public:
        /// Constructor with initializations
        _ns1__muteVideoServerAllResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__muteVideoServerAllResponse() { }
        /// Friend allocator used by soap_new__ns1__muteVideoServerAllResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__muteVideoServerAllResponse * SOAP_FMAC2 soap_instantiate__ns1__muteVideoServerAllResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:649 */
#ifndef SOAP_TYPE__ns1__muteVideoClientAllRequest
#define SOAP_TYPE__ns1__muteVideoClientAllRequest (173)
/* complex XSD type 'ns1:muteVideoClientAllRequest': */
class SOAP_CMAC _ns1__muteVideoClientAllRequest {
      public:
        /// Required element 'ns1:conferenceID' of XSD type 'ns1:EntityID'
        char *conferenceID;
        /// Optional element 'ns1:moderatorPIN' of XSD type 'xsd:string'
        char *moderatorPIN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__muteVideoClientAllRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__muteVideoClientAllRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__muteVideoClientAllRequest, default initialized and not managed by a soap context
        virtual _ns1__muteVideoClientAllRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__muteVideoClientAllRequest); }
      public:
        /// Constructor with initializations
        _ns1__muteVideoClientAllRequest()
        {
          conferenceID = (char *)0;
          moderatorPIN = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__muteVideoClientAllRequest() { }
        /// Friend allocator used by soap_new__ns1__muteVideoClientAllRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__muteVideoClientAllRequest * SOAP_FMAC2 soap_instantiate__ns1__muteVideoClientAllRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:652 */
#ifndef SOAP_TYPE__ns1__muteVideoClientAllResponse
#define SOAP_TYPE__ns1__muteVideoClientAllResponse (174)
/* complex XSD type 'ns1:muteVideoClientAllResponse': */
class SOAP_CMAC _ns1__muteVideoClientAllResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__muteVideoClientAllResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__muteVideoClientAllResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__muteVideoClientAllResponse, default initialized and not managed by a soap context
        virtual _ns1__muteVideoClientAllResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__muteVideoClientAllResponse); }
      public:
        /// Constructor with initializations
        _ns1__muteVideoClientAllResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__muteVideoClientAllResponse() { }
        /// Friend allocator used by soap_new__ns1__muteVideoClientAllResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__muteVideoClientAllResponse * SOAP_FMAC2 soap_instantiate__ns1__muteVideoClientAllResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:658 */
#ifndef SOAP_TYPE__ns1__OnetimeAccessResponse
#define SOAP_TYPE__ns1__OnetimeAccessResponse (175)
/* complex XSD type 'ns1:OnetimeAccessResponse': */
class SOAP_CMAC _ns1__OnetimeAccessResponse {
      public:
        /// Required element 'ns1:url' of XSD type 'xsd:anyURI'
        char *url;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__OnetimeAccessResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__OnetimeAccessResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__OnetimeAccessResponse, default initialized and not managed by a soap context
        virtual _ns1__OnetimeAccessResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__OnetimeAccessResponse); }
      public:
        /// Constructor with initializations
        _ns1__OnetimeAccessResponse()
        {
          url = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__OnetimeAccessResponse() { }
        /// Friend allocator used by soap_new__ns1__OnetimeAccessResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__OnetimeAccessResponse * SOAP_FMAC2 soap_instantiate__ns1__OnetimeAccessResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:661 */
#ifndef SOAP_TYPE__ns1__RoomAccessOption
#define SOAP_TYPE__ns1__RoomAccessOption (176)
/* complex XSD type 'ns1:RoomAccessOption': */
class SOAP_CMAC _ns1__RoomAccessOption {
      public:
        /// Required element 'ns1:accessOption' of XSD type 'ns1:AccessOptionName'
        enum ns1__AccessOptionName accessOption;
        /// Required element 'ns1:value' of XSD type 'xsd:string'
        char *value;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RoomAccessOption
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__RoomAccessOption; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RoomAccessOption, default initialized and not managed by a soap context
        virtual _ns1__RoomAccessOption *soap_alloc(void) const { return SOAP_NEW(_ns1__RoomAccessOption); }
      public:
        /// Constructor with initializations
        _ns1__RoomAccessOption()
        {
          accessOption = (enum ns1__AccessOptionName)0;
          value = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__RoomAccessOption() { }
        /// Friend allocator used by soap_new__ns1__RoomAccessOption(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RoomAccessOption * SOAP_FMAC2 soap_instantiate__ns1__RoomAccessOption(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:664 */
#ifndef SOAP_TYPE__ns1__RoomAccessOptionsRequest
#define SOAP_TYPE__ns1__RoomAccessOptionsRequest (177)
/* complex XSD type 'ns1:RoomAccessOptionsRequest': */
class SOAP_CMAC _ns1__RoomAccessOptionsRequest {
      public:
        /// Required element 'ns1:roomID' of XSD type 'ns1:EntityID'
        char *roomID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RoomAccessOptionsRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__RoomAccessOptionsRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RoomAccessOptionsRequest, default initialized and not managed by a soap context
        virtual _ns1__RoomAccessOptionsRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__RoomAccessOptionsRequest); }
      public:
        /// Constructor with initializations
        _ns1__RoomAccessOptionsRequest()
        {
          roomID = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__RoomAccessOptionsRequest() { }
        /// Friend allocator used by soap_new__ns1__RoomAccessOptionsRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RoomAccessOptionsRequest * SOAP_FMAC2 soap_instantiate__ns1__RoomAccessOptionsRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:667 */
#ifndef SOAP_TYPE__ns1__RoomAccessOptionsResponse
#define SOAP_TYPE__ns1__RoomAccessOptionsResponse (178)
/* complex XSD type 'ns1:RoomAccessOptionsResponse': */
class SOAP_CMAC _ns1__RoomAccessOptionsResponse {
      public:
        /// Sequence of at least 1 elements 'ns1:RoomAccessOption' of XSD type 'ns1:RoomAccessOption' stored in dynamic array RoomAccessOption of length __sizeRoomAccessOption
        int __sizeRoomAccessOption;
        _ns1__RoomAccessOption **RoomAccessOption;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RoomAccessOptionsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__RoomAccessOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RoomAccessOptionsResponse, default initialized and not managed by a soap context
        virtual _ns1__RoomAccessOptionsResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__RoomAccessOptionsResponse); }
      public:
        /// Constructor with initializations
        _ns1__RoomAccessOptionsResponse()
        {
          __sizeRoomAccessOption = 0;
          RoomAccessOption = NULL;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__RoomAccessOptionsResponse() { }
        /// Friend allocator used by soap_new__ns1__RoomAccessOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RoomAccessOptionsResponse * SOAP_FMAC2 soap_instantiate__ns1__RoomAccessOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:673 */
#ifndef SOAP_TYPE__ns1__PortalPrefixResponse
#define SOAP_TYPE__ns1__PortalPrefixResponse (179)
/* complex XSD type 'ns1:PortalPrefixResponse': */
class SOAP_CMAC _ns1__PortalPrefixResponse {
      public:
        /// Required element 'ns1:portalPrefix' of XSD type 'xsd:string'
        char *portalPrefix;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__PortalPrefixResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__PortalPrefixResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__PortalPrefixResponse, default initialized and not managed by a soap context
        virtual _ns1__PortalPrefixResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__PortalPrefixResponse); }
      public:
        /// Constructor with initializations
        _ns1__PortalPrefixResponse()
        {
          portalPrefix = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__PortalPrefixResponse() { }
        /// Friend allocator used by soap_new__ns1__PortalPrefixResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__PortalPrefixResponse * SOAP_FMAC2 soap_instantiate__ns1__PortalPrefixResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:676 */
#ifndef SOAP_TYPE__ns1__PrefixNotConfiguredFault
#define SOAP_TYPE__ns1__PrefixNotConfiguredFault (180)
/* complex XSD type 'ns1:PrefixNotConfiguredFault': */
class SOAP_CMAC _ns1__PrefixNotConfiguredFault {
      public:
        /// Required element 'ns1:ErrorMessage' of XSD type 'xsd:string'
        char *ErrorMessage;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__PrefixNotConfiguredFault
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__PrefixNotConfiguredFault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__PrefixNotConfiguredFault, default initialized and not managed by a soap context
        virtual _ns1__PrefixNotConfiguredFault *soap_alloc(void) const { return SOAP_NEW(_ns1__PrefixNotConfiguredFault); }
      public:
        /// Constructor with initializations
        _ns1__PrefixNotConfiguredFault()
        {
          ErrorMessage = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__PrefixNotConfiguredFault() { }
        /// Friend allocator used by soap_new__ns1__PrefixNotConfiguredFault(struct soap*, int)
        friend SOAP_FMAC1 _ns1__PrefixNotConfiguredFault * SOAP_FMAC2 soap_instantiate__ns1__PrefixNotConfiguredFault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:679 */
#ifndef SOAP_TYPE__ns1__getLoginAndWelcomeBannerRequest
#define SOAP_TYPE__ns1__getLoginAndWelcomeBannerRequest (181)
/* complex XSD type 'ns1:getLoginAndWelcomeBannerRequest': */
class SOAP_CMAC _ns1__getLoginAndWelcomeBannerRequest {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getLoginAndWelcomeBannerRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getLoginAndWelcomeBannerRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getLoginAndWelcomeBannerRequest, default initialized and not managed by a soap context
        virtual _ns1__getLoginAndWelcomeBannerRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__getLoginAndWelcomeBannerRequest); }
      public:
        /// Constructor with initializations
        _ns1__getLoginAndWelcomeBannerRequest()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__getLoginAndWelcomeBannerRequest() { }
        /// Friend allocator used by soap_new__ns1__getLoginAndWelcomeBannerRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getLoginAndWelcomeBannerRequest * SOAP_FMAC2 soap_instantiate__ns1__getLoginAndWelcomeBannerRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:682 */
#ifndef SOAP_TYPE__ns1__getLoginAndWelcomeBannerResponse
#define SOAP_TYPE__ns1__getLoginAndWelcomeBannerResponse (182)
/* complex XSD type 'ns1:getLoginAndWelcomeBannerResponse': */
class SOAP_CMAC _ns1__getLoginAndWelcomeBannerResponse {
      public:
        /// Optional element 'ns1:loginBannerText' of XSD type 'xsd:string'
        char *loginBannerText;
        /// Optional element 'ns1:WelcomeBannerContent' of XSD type 'ns1:WelcomeBannerContent'
        _ns1__WelcomeBannerContent *WelcomeBannerContent;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getLoginAndWelcomeBannerResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getLoginAndWelcomeBannerResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getLoginAndWelcomeBannerResponse, default initialized and not managed by a soap context
        virtual _ns1__getLoginAndWelcomeBannerResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__getLoginAndWelcomeBannerResponse); }
      public:
        /// Constructor with initializations
        _ns1__getLoginAndWelcomeBannerResponse()
        {
          loginBannerText = (char *)0;
          WelcomeBannerContent = (_ns1__WelcomeBannerContent *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__getLoginAndWelcomeBannerResponse() { }
        /// Friend allocator used by soap_new__ns1__getLoginAndWelcomeBannerResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getLoginAndWelcomeBannerResponse * SOAP_FMAC2 soap_instantiate__ns1__getLoginAndWelcomeBannerResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:685 */
#ifndef SOAP_TYPE__ns1__getUserAccountTypeRequest
#define SOAP_TYPE__ns1__getUserAccountTypeRequest (183)
/* complex XSD type 'ns1:getUserAccountTypeRequest': */
class SOAP_CMAC _ns1__getUserAccountTypeRequest {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getUserAccountTypeRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getUserAccountTypeRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getUserAccountTypeRequest, default initialized and not managed by a soap context
        virtual _ns1__getUserAccountTypeRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__getUserAccountTypeRequest); }
      public:
        /// Constructor with initializations
        _ns1__getUserAccountTypeRequest()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__getUserAccountTypeRequest() { }
        /// Friend allocator used by soap_new__ns1__getUserAccountTypeRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getUserAccountTypeRequest * SOAP_FMAC2 soap_instantiate__ns1__getUserAccountTypeRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:688 */
#ifndef SOAP_TYPE__ns1__getUserAccountTypeResponse
#define SOAP_TYPE__ns1__getUserAccountTypeResponse (184)
/* complex XSD type 'ns1:getUserAccountTypeResponse': */
class SOAP_CMAC _ns1__getUserAccountTypeResponse {
      public:
        /// Required element 'ns1:userAccountType' of XSD type 'xsd:string'
        char *userAccountType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getUserAccountTypeResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getUserAccountTypeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getUserAccountTypeResponse, default initialized and not managed by a soap context
        virtual _ns1__getUserAccountTypeResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__getUserAccountTypeResponse); }
      public:
        /// Constructor with initializations
        _ns1__getUserAccountTypeResponse()
        {
          userAccountType = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__getUserAccountTypeResponse() { }
        /// Friend allocator used by soap_new__ns1__getUserAccountTypeResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getUserAccountTypeResponse * SOAP_FMAC2 soap_instantiate__ns1__getUserAccountTypeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:691 */
#ifndef SOAP_TYPE__ns1__StartLectureModeRequest
#define SOAP_TYPE__ns1__StartLectureModeRequest (185)
/* complex XSD type 'ns1:StartLectureModeRequest': */
class SOAP_CMAC _ns1__StartLectureModeRequest {
      public:
        /// Required element 'ns1:conferenceID' of XSD type 'ns1:EntityID'
        char *conferenceID;
        /// Optional element 'ns1:moderatorPIN' of XSD type 'xsd:string'
        char *moderatorPIN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__StartLectureModeRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__StartLectureModeRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__StartLectureModeRequest, default initialized and not managed by a soap context
        virtual _ns1__StartLectureModeRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__StartLectureModeRequest); }
      public:
        /// Constructor with initializations
        _ns1__StartLectureModeRequest()
        {
          conferenceID = (char *)0;
          moderatorPIN = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__StartLectureModeRequest() { }
        /// Friend allocator used by soap_new__ns1__StartLectureModeRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__StartLectureModeRequest * SOAP_FMAC2 soap_instantiate__ns1__StartLectureModeRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:694 */
#ifndef SOAP_TYPE__ns1__StartLectureModeResponse
#define SOAP_TYPE__ns1__StartLectureModeResponse (186)
/* complex XSD type 'ns1:StartLectureModeResponse': */
class SOAP_CMAC _ns1__StartLectureModeResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__StartLectureModeResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__StartLectureModeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__StartLectureModeResponse, default initialized and not managed by a soap context
        virtual _ns1__StartLectureModeResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__StartLectureModeResponse); }
      public:
        /// Constructor with initializations
        _ns1__StartLectureModeResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__StartLectureModeResponse() { }
        /// Friend allocator used by soap_new__ns1__StartLectureModeResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__StartLectureModeResponse * SOAP_FMAC2 soap_instantiate__ns1__StartLectureModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:697 */
#ifndef SOAP_TYPE__ns1__StopLectureModeRequest
#define SOAP_TYPE__ns1__StopLectureModeRequest (187)
/* complex XSD type 'ns1:StopLectureModeRequest': */
class SOAP_CMAC _ns1__StopLectureModeRequest {
      public:
        /// Required element 'ns1:conferenceID' of XSD type 'ns1:EntityID'
        char *conferenceID;
        /// Optional element 'ns1:moderatorPIN' of XSD type 'xsd:string'
        char *moderatorPIN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__StopLectureModeRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__StopLectureModeRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__StopLectureModeRequest, default initialized and not managed by a soap context
        virtual _ns1__StopLectureModeRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__StopLectureModeRequest); }
      public:
        /// Constructor with initializations
        _ns1__StopLectureModeRequest()
        {
          conferenceID = (char *)0;
          moderatorPIN = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__StopLectureModeRequest() { }
        /// Friend allocator used by soap_new__ns1__StopLectureModeRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__StopLectureModeRequest * SOAP_FMAC2 soap_instantiate__ns1__StopLectureModeRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:700 */
#ifndef SOAP_TYPE__ns1__StopLectureModeResponse
#define SOAP_TYPE__ns1__StopLectureModeResponse (188)
/* complex XSD type 'ns1:StopLectureModeResponse': */
class SOAP_CMAC _ns1__StopLectureModeResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__StopLectureModeResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__StopLectureModeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__StopLectureModeResponse, default initialized and not managed by a soap context
        virtual _ns1__StopLectureModeResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__StopLectureModeResponse); }
      public:
        /// Constructor with initializations
        _ns1__StopLectureModeResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__StopLectureModeResponse() { }
        /// Friend allocator used by soap_new__ns1__StopLectureModeResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__StopLectureModeResponse * SOAP_FMAC2 soap_instantiate__ns1__StopLectureModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:706 */
#ifndef SOAP_TYPE__ns1__RaiseHandResponse
#define SOAP_TYPE__ns1__RaiseHandResponse (189)
/* complex XSD type 'ns1:RaiseHandResponse': */
class SOAP_CMAC _ns1__RaiseHandResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RaiseHandResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__RaiseHandResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RaiseHandResponse, default initialized and not managed by a soap context
        virtual _ns1__RaiseHandResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__RaiseHandResponse); }
      public:
        /// Constructor with initializations
        _ns1__RaiseHandResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__RaiseHandResponse() { }
        /// Friend allocator used by soap_new__ns1__RaiseHandResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RaiseHandResponse * SOAP_FMAC2 soap_instantiate__ns1__RaiseHandResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:712 */
#ifndef SOAP_TYPE__ns1__UnraiseHandResponse
#define SOAP_TYPE__ns1__UnraiseHandResponse (190)
/* complex XSD type 'ns1:UnraiseHandResponse': */
class SOAP_CMAC _ns1__UnraiseHandResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__UnraiseHandResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__UnraiseHandResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__UnraiseHandResponse, default initialized and not managed by a soap context
        virtual _ns1__UnraiseHandResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__UnraiseHandResponse); }
      public:
        /// Constructor with initializations
        _ns1__UnraiseHandResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__UnraiseHandResponse() { }
        /// Friend allocator used by soap_new__ns1__UnraiseHandResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__UnraiseHandResponse * SOAP_FMAC2 soap_instantiate__ns1__UnraiseHandResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:715 */
#ifndef SOAP_TYPE__ns1__DismissRaisedHandRequest
#define SOAP_TYPE__ns1__DismissRaisedHandRequest (191)
/* complex XSD type 'ns1:DismissRaisedHandRequest': */
class SOAP_CMAC _ns1__DismissRaisedHandRequest {
      public:
        /// Required element 'ns1:conferenceID' of XSD type 'ns1:EntityID'
        char *conferenceID;
        /// Required element 'ns1:participantID' of XSD type 'ns1:EntityID'
        char *participantID;
        /// Optional element 'ns1:moderatorPIN' of XSD type 'xsd:string'
        char *moderatorPIN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DismissRaisedHandRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__DismissRaisedHandRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DismissRaisedHandRequest, default initialized and not managed by a soap context
        virtual _ns1__DismissRaisedHandRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__DismissRaisedHandRequest); }
      public:
        /// Constructor with initializations
        _ns1__DismissRaisedHandRequest()
        {
          conferenceID = (char *)0;
          participantID = (char *)0;
          moderatorPIN = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__DismissRaisedHandRequest() { }
        /// Friend allocator used by soap_new__ns1__DismissRaisedHandRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DismissRaisedHandRequest * SOAP_FMAC2 soap_instantiate__ns1__DismissRaisedHandRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:718 */
#ifndef SOAP_TYPE__ns1__DismissRaisedHandResponse
#define SOAP_TYPE__ns1__DismissRaisedHandResponse (192)
/* complex XSD type 'ns1:DismissRaisedHandResponse': */
class SOAP_CMAC _ns1__DismissRaisedHandResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DismissRaisedHandResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__DismissRaisedHandResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DismissRaisedHandResponse, default initialized and not managed by a soap context
        virtual _ns1__DismissRaisedHandResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__DismissRaisedHandResponse); }
      public:
        /// Constructor with initializations
        _ns1__DismissRaisedHandResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__DismissRaisedHandResponse() { }
        /// Friend allocator used by soap_new__ns1__DismissRaisedHandResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DismissRaisedHandResponse * SOAP_FMAC2 soap_instantiate__ns1__DismissRaisedHandResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:721 */
#ifndef SOAP_TYPE__ns1__DismissAllRaisedHandRequest
#define SOAP_TYPE__ns1__DismissAllRaisedHandRequest (193)
/* complex XSD type 'ns1:DismissAllRaisedHandRequest': */
class SOAP_CMAC _ns1__DismissAllRaisedHandRequest {
      public:
        /// Required element 'ns1:conferenceID' of XSD type 'ns1:EntityID'
        char *conferenceID;
        /// Optional element 'ns1:moderatorPIN' of XSD type 'xsd:string'
        char *moderatorPIN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DismissAllRaisedHandRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__DismissAllRaisedHandRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DismissAllRaisedHandRequest, default initialized and not managed by a soap context
        virtual _ns1__DismissAllRaisedHandRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__DismissAllRaisedHandRequest); }
      public:
        /// Constructor with initializations
        _ns1__DismissAllRaisedHandRequest()
        {
          conferenceID = (char *)0;
          moderatorPIN = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__DismissAllRaisedHandRequest() { }
        /// Friend allocator used by soap_new__ns1__DismissAllRaisedHandRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DismissAllRaisedHandRequest * SOAP_FMAC2 soap_instantiate__ns1__DismissAllRaisedHandRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:724 */
#ifndef SOAP_TYPE__ns1__DismissAllRaisedHandResponse
#define SOAP_TYPE__ns1__DismissAllRaisedHandResponse (194)
/* complex XSD type 'ns1:DismissAllRaisedHandResponse': */
class SOAP_CMAC _ns1__DismissAllRaisedHandResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DismissAllRaisedHandResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__DismissAllRaisedHandResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DismissAllRaisedHandResponse, default initialized and not managed by a soap context
        virtual _ns1__DismissAllRaisedHandResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__DismissAllRaisedHandResponse); }
      public:
        /// Constructor with initializations
        _ns1__DismissAllRaisedHandResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__DismissAllRaisedHandResponse() { }
        /// Friend allocator used by soap_new__ns1__DismissAllRaisedHandResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DismissAllRaisedHandResponse * SOAP_FMAC2 soap_instantiate__ns1__DismissAllRaisedHandResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:727 */
#ifndef SOAP_TYPE__ns1__SetPresenterRequest
#define SOAP_TYPE__ns1__SetPresenterRequest (195)
/* complex XSD type 'ns1:SetPresenterRequest': */
class SOAP_CMAC _ns1__SetPresenterRequest {
      public:
        /// Required element 'ns1:conferenceID' of XSD type 'ns1:EntityID'
        char *conferenceID;
        /// Required element 'ns1:participantID' of XSD type 'ns1:EntityID'
        char *participantID;
        /// Optional element 'ns1:moderatorPIN' of XSD type 'xsd:string'
        char *moderatorPIN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetPresenterRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetPresenterRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetPresenterRequest, default initialized and not managed by a soap context
        virtual _ns1__SetPresenterRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__SetPresenterRequest); }
      public:
        /// Constructor with initializations
        _ns1__SetPresenterRequest()
        {
          conferenceID = (char *)0;
          participantID = (char *)0;
          moderatorPIN = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetPresenterRequest() { }
        /// Friend allocator used by soap_new__ns1__SetPresenterRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetPresenterRequest * SOAP_FMAC2 soap_instantiate__ns1__SetPresenterRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:730 */
#ifndef SOAP_TYPE__ns1__SetPresenterResponse
#define SOAP_TYPE__ns1__SetPresenterResponse (196)
/* complex XSD type 'ns1:SetPresenterResponse': */
class SOAP_CMAC _ns1__SetPresenterResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetPresenterResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SetPresenterResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetPresenterResponse, default initialized and not managed by a soap context
        virtual _ns1__SetPresenterResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SetPresenterResponse); }
      public:
        /// Constructor with initializations
        _ns1__SetPresenterResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SetPresenterResponse() { }
        /// Friend allocator used by soap_new__ns1__SetPresenterResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetPresenterResponse * SOAP_FMAC2 soap_instantiate__ns1__SetPresenterResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:733 */
#ifndef SOAP_TYPE__ns1__RemovePresenterRequest
#define SOAP_TYPE__ns1__RemovePresenterRequest (197)
/* complex XSD type 'ns1:RemovePresenterRequest': */
class SOAP_CMAC _ns1__RemovePresenterRequest {
      public:
        /// Required element 'ns1:conferenceID' of XSD type 'ns1:EntityID'
        char *conferenceID;
        /// Required element 'ns1:participantID' of XSD type 'ns1:EntityID'
        char *participantID;
        /// Optional element 'ns1:moderatorPIN' of XSD type 'xsd:string'
        char *moderatorPIN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RemovePresenterRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__RemovePresenterRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RemovePresenterRequest, default initialized and not managed by a soap context
        virtual _ns1__RemovePresenterRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__RemovePresenterRequest); }
      public:
        /// Constructor with initializations
        _ns1__RemovePresenterRequest()
        {
          conferenceID = (char *)0;
          participantID = (char *)0;
          moderatorPIN = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__RemovePresenterRequest() { }
        /// Friend allocator used by soap_new__ns1__RemovePresenterRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RemovePresenterRequest * SOAP_FMAC2 soap_instantiate__ns1__RemovePresenterRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:736 */
#ifndef SOAP_TYPE__ns1__RemovePresenterResponse
#define SOAP_TYPE__ns1__RemovePresenterResponse (198)
/* complex XSD type 'ns1:RemovePresenterResponse': */
class SOAP_CMAC _ns1__RemovePresenterResponse {
      public:
        /// Required element 'ns1:OK' of XSD type 'ns1:OK'
        enum _ns1__OK OK;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RemovePresenterResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__RemovePresenterResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RemovePresenterResponse, default initialized and not managed by a soap context
        virtual _ns1__RemovePresenterResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__RemovePresenterResponse); }
      public:
        /// Constructor with initializations
        _ns1__RemovePresenterResponse()
        {
          OK = (enum _ns1__OK)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__RemovePresenterResponse() { }
        /// Friend allocator used by soap_new__ns1__RemovePresenterResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RemovePresenterResponse * SOAP_FMAC2 soap_instantiate__ns1__RemovePresenterResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:739 */
#ifndef SOAP_TYPE__ns1__GetVidyoReplayLibraryRequest
#define SOAP_TYPE__ns1__GetVidyoReplayLibraryRequest (199)
/* complex XSD type 'ns1:GetVidyoReplayLibraryRequest': */
class SOAP_CMAC _ns1__GetVidyoReplayLibraryRequest {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetVidyoReplayLibraryRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetVidyoReplayLibraryRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetVidyoReplayLibraryRequest, default initialized and not managed by a soap context
        virtual _ns1__GetVidyoReplayLibraryRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__GetVidyoReplayLibraryRequest); }
      public:
        /// Constructor with initializations
        _ns1__GetVidyoReplayLibraryRequest()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetVidyoReplayLibraryRequest() { }
        /// Friend allocator used by soap_new__ns1__GetVidyoReplayLibraryRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetVidyoReplayLibraryRequest * SOAP_FMAC2 soap_instantiate__ns1__GetVidyoReplayLibraryRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:742 */
#ifndef SOAP_TYPE__ns1__GetVidyoReplayLibraryResponse
#define SOAP_TYPE__ns1__GetVidyoReplayLibraryResponse (200)
/* complex XSD type 'ns1:GetVidyoReplayLibraryResponse': */
class SOAP_CMAC _ns1__GetVidyoReplayLibraryResponse {
      public:
        /// Required element 'ns1:authToken' of XSD type 'xsd:string'
        char *authToken;
        /// Required element 'ns1:vidyoReplayLibraryUrl' of XSD type 'xsd:string'
        char *vidyoReplayLibraryUrl;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetVidyoReplayLibraryResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetVidyoReplayLibraryResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetVidyoReplayLibraryResponse, default initialized and not managed by a soap context
        virtual _ns1__GetVidyoReplayLibraryResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetVidyoReplayLibraryResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetVidyoReplayLibraryResponse()
        {
          authToken = (char *)0;
          vidyoReplayLibraryUrl = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetVidyoReplayLibraryResponse() { }
        /// Friend allocator used by soap_new__ns1__GetVidyoReplayLibraryResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetVidyoReplayLibraryResponse * SOAP_FMAC2 soap_instantiate__ns1__GetVidyoReplayLibraryResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:745 */
#ifndef SOAP_TYPE__ns1__WhatIsMyIPAddressRequest
#define SOAP_TYPE__ns1__WhatIsMyIPAddressRequest (201)
/* complex XSD type 'ns1:WhatIsMyIPAddressRequest': */
class SOAP_CMAC _ns1__WhatIsMyIPAddressRequest {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__WhatIsMyIPAddressRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__WhatIsMyIPAddressRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__WhatIsMyIPAddressRequest, default initialized and not managed by a soap context
        virtual _ns1__WhatIsMyIPAddressRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__WhatIsMyIPAddressRequest); }
      public:
        /// Constructor with initializations
        _ns1__WhatIsMyIPAddressRequest()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__WhatIsMyIPAddressRequest() { }
        /// Friend allocator used by soap_new__ns1__WhatIsMyIPAddressRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__WhatIsMyIPAddressRequest * SOAP_FMAC2 soap_instantiate__ns1__WhatIsMyIPAddressRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:748 */
#ifndef SOAP_TYPE__ns1__WhatIsMyIPAddressResponse
#define SOAP_TYPE__ns1__WhatIsMyIPAddressResponse (202)
/* complex XSD type 'ns1:WhatIsMyIPAddressResponse': */
class SOAP_CMAC _ns1__WhatIsMyIPAddressResponse {
      public:
        /// Required element 'ns1:endpointExternalIPAddress' of XSD type 'xsd:string'
        char *endpointExternalIPAddress;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__WhatIsMyIPAddressResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__WhatIsMyIPAddressResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__WhatIsMyIPAddressResponse, default initialized and not managed by a soap context
        virtual _ns1__WhatIsMyIPAddressResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__WhatIsMyIPAddressResponse); }
      public:
        /// Constructor with initializations
        _ns1__WhatIsMyIPAddressResponse()
        {
          endpointExternalIPAddress = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__WhatIsMyIPAddressResponse() { }
        /// Friend allocator used by soap_new__ns1__WhatIsMyIPAddressResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__WhatIsMyIPAddressResponse * SOAP_FMAC2 soap_instantiate__ns1__WhatIsMyIPAddressResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:751 */
#ifndef SOAP_TYPE__ns1__GetChangePasswordHtmlUrlWithTokenRequest
#define SOAP_TYPE__ns1__GetChangePasswordHtmlUrlWithTokenRequest (203)
/* complex XSD type 'ns1:GetChangePasswordHtmlUrlWithTokenRequest': */
class SOAP_CMAC _ns1__GetChangePasswordHtmlUrlWithTokenRequest {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetChangePasswordHtmlUrlWithTokenRequest
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetChangePasswordHtmlUrlWithTokenRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetChangePasswordHtmlUrlWithTokenRequest, default initialized and not managed by a soap context
        virtual _ns1__GetChangePasswordHtmlUrlWithTokenRequest *soap_alloc(void) const { return SOAP_NEW(_ns1__GetChangePasswordHtmlUrlWithTokenRequest); }
      public:
        /// Constructor with initializations
        _ns1__GetChangePasswordHtmlUrlWithTokenRequest()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetChangePasswordHtmlUrlWithTokenRequest() { }
        /// Friend allocator used by soap_new__ns1__GetChangePasswordHtmlUrlWithTokenRequest(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetChangePasswordHtmlUrlWithTokenRequest * SOAP_FMAC2 soap_instantiate__ns1__GetChangePasswordHtmlUrlWithTokenRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:754 */
#ifndef SOAP_TYPE__ns1__GetChangePasswordHtmlUrlWithTokenResponse
#define SOAP_TYPE__ns1__GetChangePasswordHtmlUrlWithTokenResponse (204)
/* complex XSD type 'ns1:GetChangePasswordHtmlUrlWithTokenResponse': */
class SOAP_CMAC _ns1__GetChangePasswordHtmlUrlWithTokenResponse {
      public:
        /// Required element 'ns1:changePasswordHtmlUrlWithToken' of XSD type 'xsd:string'
        char *changePasswordHtmlUrlWithToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetChangePasswordHtmlUrlWithTokenResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetChangePasswordHtmlUrlWithTokenResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetChangePasswordHtmlUrlWithTokenResponse, default initialized and not managed by a soap context
        virtual _ns1__GetChangePasswordHtmlUrlWithTokenResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetChangePasswordHtmlUrlWithTokenResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetChangePasswordHtmlUrlWithTokenResponse()
        {
          changePasswordHtmlUrlWithToken = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetChangePasswordHtmlUrlWithTokenResponse() { }
        /// Friend allocator used by soap_new__ns1__GetChangePasswordHtmlUrlWithTokenResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetChangePasswordHtmlUrlWithTokenResponse * SOAP_FMAC2 soap_instantiate__ns1__GetChangePasswordHtmlUrlWithTokenResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:6491 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (254)
/* SOAP_ENV__Detail: */
struct SOAP_ENV__Detail {
      public:
        /** Optional element 'ns1:AccessRestrictedFault' of XSD type 'ns1:AccessRestrictedFault' */
        _ns1__AccessRestrictedFault *ns1__AccessRestrictedFault;
        /** Optional element 'ns1:ConferenceLockedFault' of XSD type 'ns1:ConferenceLockedFault' */
        _ns1__ConferenceLockedFault *ns1__ConferenceLockedFault;
        /** Optional element 'ns1:ControlMeetingFault' of XSD type 'ns1:ControlMeetingFault' */
        _ns1__ControlMeetingFault *ns1__ControlMeetingFault;
        /** Optional element 'ns1:EndpointNotBoundFault' of XSD type 'ns1:EndpointNotBoundFault' */
        _ns1__EndpointNotBoundFault *ns1__EndpointNotBoundFault;
        /** Optional element 'ns1:FeatureNotAvailableFault' of XSD type 'ns1:FeatureNotAvailableFault' */
        _ns1__FeatureNotAvailableFault *ns1__FeatureNotAvailableFault;
        /** Optional element 'ns1:GeneralFault' of XSD type 'ns1:GeneralFault' */
        _ns1__GeneralFault *ns1__GeneralFault;
        /** Optional element 'ns1:InPointToPointCallFault' of XSD type 'ns1:InPointToPointCallFault' */
        _ns1__InPointToPointCallFault *ns1__InPointToPointCallFault;
        /** Optional element 'ns1:InvalidArgumentFault' of XSD type 'ns1:InvalidArgumentFault' */
        _ns1__InvalidArgumentFault *ns1__InvalidArgumentFault;
        /** Optional element 'ns1:InvalidModeratorPINFormatFault' of XSD type 'ns1:InvalidModeratorPINFormatFault' */
        _ns1__InvalidModeratorPINFormatFault *ns1__InvalidModeratorPINFormatFault;
        /** Optional element 'ns1:NotLicensedFault' of XSD type 'ns1:NotLicensedFault' */
        _ns1__NotLicensedFault *ns1__NotLicensedFault;
        /** Optional element 'ns1:PrefixNotConfiguredFault' of XSD type 'ns1:PrefixNotConfiguredFault' */
        _ns1__PrefixNotConfiguredFault *ns1__PrefixNotConfiguredFault;
        /** Optional element 'ns1:ResourceNotAvailableFault' of XSD type 'ns1:ResourceNotAvailableFault' */
        _ns1__ResourceNotAvailableFault *ns1__ResourceNotAvailableFault;
        /** Optional element 'ns1:RoomNotFoundFault' of XSD type 'ns1:RoomNotFoundFault' */
        _ns1__RoomNotFoundFault *ns1__RoomNotFoundFault;
        /** Optional element 'ns1:ScheduledRoomCreationFault' of XSD type 'ns1:ScheduledRoomCreationFault' */
        _ns1__ScheduledRoomCreationFault *ns1__ScheduledRoomCreationFault;
        /** Optional element 'ns1:SeatLicenseExpiredFault' of XSD type 'ns1:SeatLicenseExpiredFault' */
        _ns1__SeatLicenseExpiredFault *ns1__SeatLicenseExpiredFault;
        /** Optional element 'ns1:VidyoReplayNotAvailableFault' of XSD type 'ns1:VidyoReplayNotAvailableFault' */
        _ns1__VidyoReplayNotAvailableFault *ns1__VidyoReplayNotAvailableFault;
        /** Optional element 'ns1:WrongPINFault' of XSD type 'ns1:WrongPINFault' */
        _ns1__WrongPINFault *ns1__WrongPINFault;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_T assigned to __type */
        /** Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
        char *__any;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail()
        {
          ns1__AccessRestrictedFault = (_ns1__AccessRestrictedFault *)0;
          ns1__ConferenceLockedFault = (_ns1__ConferenceLockedFault *)0;
          ns1__ControlMeetingFault = (_ns1__ControlMeetingFault *)0;
          ns1__EndpointNotBoundFault = (_ns1__EndpointNotBoundFault *)0;
          ns1__FeatureNotAvailableFault = (_ns1__FeatureNotAvailableFault *)0;
          ns1__GeneralFault = (_ns1__GeneralFault *)0;
          ns1__InPointToPointCallFault = (_ns1__InPointToPointCallFault *)0;
          ns1__InvalidArgumentFault = (_ns1__InvalidArgumentFault *)0;
          ns1__InvalidModeratorPINFormatFault = (_ns1__InvalidModeratorPINFormatFault *)0;
          ns1__NotLicensedFault = (_ns1__NotLicensedFault *)0;
          ns1__PrefixNotConfiguredFault = (_ns1__PrefixNotConfiguredFault *)0;
          ns1__ResourceNotAvailableFault = (_ns1__ResourceNotAvailableFault *)0;
          ns1__RoomNotFoundFault = (_ns1__RoomNotFoundFault *)0;
          ns1__ScheduledRoomCreationFault = (_ns1__ScheduledRoomCreationFault *)0;
          ns1__SeatLicenseExpiredFault = (_ns1__SeatLicenseExpiredFault *)0;
          ns1__VidyoReplayNotAvailableFault = (_ns1__VidyoReplayNotAvailableFault *)0;
          ns1__WrongPINFault = (_ns1__WrongPINFault *)0;
          __type = 0;
          fault = NULL;
          __any = (char *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Detail(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* WSVidyoUser.h:6617 */
#ifndef SOAP_TYPE___ns1__logIn
#define SOAP_TYPE___ns1__logIn (277)
/* Wrapper: */
struct __ns1__logIn {
      public:
        /** Optional element 'ns1:LogInRequest' of XSD type 'ns1:LogInRequest' */
        _ns1__LogInRequest *ns1__LogInRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__logIn */
        int soap_type() const { return SOAP_TYPE___ns1__logIn; }
        /** Constructor with member initializations */
        __ns1__logIn()
        {
          ns1__LogInRequest = (_ns1__LogInRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__logIn(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__logIn * SOAP_FMAC2 soap_instantiate___ns1__logIn(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:6698 */
#ifndef SOAP_TYPE___ns1__linkEndpoint
#define SOAP_TYPE___ns1__linkEndpoint (281)
/* Wrapper: */
struct __ns1__linkEndpoint {
      public:
        /** Optional element 'ns1:LinkEndpointRequest' of XSD type 'ns1:LinkEndpointRequest' */
        _ns1__LinkEndpointRequest *ns1__LinkEndpointRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__linkEndpoint */
        int soap_type() const { return SOAP_TYPE___ns1__linkEndpoint; }
        /** Constructor with member initializations */
        __ns1__linkEndpoint()
        {
          ns1__LinkEndpointRequest = (_ns1__LinkEndpointRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__linkEndpoint(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__linkEndpoint * SOAP_FMAC2 soap_instantiate___ns1__linkEndpoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:6776 */
#ifndef SOAP_TYPE___ns1__logOut
#define SOAP_TYPE___ns1__logOut (285)
/* Wrapper: */
struct __ns1__logOut {
      public:
        /** Optional element 'ns1:LogOutRequest' of XSD type 'ns1:LogOutRequest' */
        _ns1__LogOutRequest *ns1__LogOutRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__logOut */
        int soap_type() const { return SOAP_TYPE___ns1__logOut; }
        /** Constructor with member initializations */
        __ns1__logOut()
        {
          ns1__LogOutRequest = (_ns1__LogOutRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__logOut(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__logOut * SOAP_FMAC2 soap_instantiate___ns1__logOut(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:6854 */
#ifndef SOAP_TYPE___ns1__myEndpointStatus
#define SOAP_TYPE___ns1__myEndpointStatus (289)
/* Wrapper: */
struct __ns1__myEndpointStatus {
      public:
        /** Optional element 'ns1:MyEndpointStatusRequest' of XSD type 'ns1:MyEndpointStatusRequest' */
        _ns1__MyEndpointStatusRequest *ns1__MyEndpointStatusRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__myEndpointStatus */
        int soap_type() const { return SOAP_TYPE___ns1__myEndpointStatus; }
        /** Constructor with member initializations */
        __ns1__myEndpointStatus()
        {
          ns1__MyEndpointStatusRequest = (_ns1__MyEndpointStatusRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__myEndpointStatus(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__myEndpointStatus * SOAP_FMAC2 soap_instantiate___ns1__myEndpointStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:6932 */
#ifndef SOAP_TYPE___ns1__searchMyContacts
#define SOAP_TYPE___ns1__searchMyContacts (293)
/* Wrapper: */
struct __ns1__searchMyContacts {
      public:
        /** Optional element 'ns1:SearchMyContactsRequest' of XSD type 'ns1:SearchMyContactsRequest' */
        _ns1__SearchMyContactsRequest *ns1__SearchMyContactsRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__searchMyContacts */
        int soap_type() const { return SOAP_TYPE___ns1__searchMyContacts; }
        /** Constructor with member initializations */
        __ns1__searchMyContacts()
        {
          ns1__SearchMyContactsRequest = (_ns1__SearchMyContactsRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__searchMyContacts(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__searchMyContacts * SOAP_FMAC2 soap_instantiate___ns1__searchMyContacts(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:7010 */
#ifndef SOAP_TYPE___ns1__addToMyContacts
#define SOAP_TYPE___ns1__addToMyContacts (297)
/* Wrapper: */
struct __ns1__addToMyContacts {
      public:
        /** Optional element 'ns1:AddToMyContactsRequest' of XSD type 'ns1:AddToMyContactsRequest' */
        _ns1__AddToMyContactsRequest *ns1__AddToMyContactsRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__addToMyContacts */
        int soap_type() const { return SOAP_TYPE___ns1__addToMyContacts; }
        /** Constructor with member initializations */
        __ns1__addToMyContacts()
        {
          ns1__AddToMyContactsRequest = (_ns1__AddToMyContactsRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__addToMyContacts(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__addToMyContacts * SOAP_FMAC2 soap_instantiate___ns1__addToMyContacts(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:7088 */
#ifndef SOAP_TYPE___ns1__removeFromMyContacts
#define SOAP_TYPE___ns1__removeFromMyContacts (301)
/* Wrapper: */
struct __ns1__removeFromMyContacts {
      public:
        /** Optional element 'ns1:RemoveFromMyContactsRequest' of XSD type 'ns1:RemoveFromMyContactsRequest' */
        _ns1__RemoveFromMyContactsRequest *ns1__RemoveFromMyContactsRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__removeFromMyContacts */
        int soap_type() const { return SOAP_TYPE___ns1__removeFromMyContacts; }
        /** Constructor with member initializations */
        __ns1__removeFromMyContacts()
        {
          ns1__RemoveFromMyContactsRequest = (_ns1__RemoveFromMyContactsRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__removeFromMyContacts(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__removeFromMyContacts * SOAP_FMAC2 soap_instantiate___ns1__removeFromMyContacts(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:7166 */
#ifndef SOAP_TYPE___ns1__search
#define SOAP_TYPE___ns1__search (305)
/* Wrapper: */
struct __ns1__search {
      public:
        /** Optional element 'ns1:SearchRequest' of XSD type 'ns1:SearchRequest' */
        _ns1__SearchRequest *ns1__SearchRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__search */
        int soap_type() const { return SOAP_TYPE___ns1__search; }
        /** Constructor with member initializations */
        __ns1__search()
        {
          ns1__SearchRequest = (_ns1__SearchRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__search(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__search * SOAP_FMAC2 soap_instantiate___ns1__search(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:7244 */
#ifndef SOAP_TYPE___ns1__searchByEntityID
#define SOAP_TYPE___ns1__searchByEntityID (309)
/* Wrapper: */
struct __ns1__searchByEntityID {
      public:
        /** Optional element 'ns1:SearchByEntityIDRequest' of XSD type 'ns1:SearchByEntityIDRequest' */
        _ns1__SearchByEntityIDRequest *ns1__SearchByEntityIDRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__searchByEntityID */
        int soap_type() const { return SOAP_TYPE___ns1__searchByEntityID; }
        /** Constructor with member initializations */
        __ns1__searchByEntityID()
        {
          ns1__SearchByEntityIDRequest = (_ns1__SearchByEntityIDRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__searchByEntityID(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__searchByEntityID * SOAP_FMAC2 soap_instantiate___ns1__searchByEntityID(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:7322 */
#ifndef SOAP_TYPE___ns1__searchByEmail
#define SOAP_TYPE___ns1__searchByEmail (313)
/* Wrapper: */
struct __ns1__searchByEmail {
      public:
        /** Optional element 'ns1:SearchByEmailRequest' of XSD type 'ns1:SearchByEmailRequest' */
        _ns1__SearchByEmailRequest *ns1__SearchByEmailRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__searchByEmail */
        int soap_type() const { return SOAP_TYPE___ns1__searchByEmail; }
        /** Constructor with member initializations */
        __ns1__searchByEmail()
        {
          ns1__SearchByEmailRequest = (_ns1__SearchByEmailRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__searchByEmail(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__searchByEmail * SOAP_FMAC2 soap_instantiate___ns1__searchByEmail(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:7400 */
#ifndef SOAP_TYPE___ns1__getEntityByEntityID
#define SOAP_TYPE___ns1__getEntityByEntityID (317)
/* Wrapper: */
struct __ns1__getEntityByEntityID {
      public:
        /** Optional element 'ns1:GetEntityByEntityIDRequest' of XSD type 'ns1:GetEntityByEntityIDRequest' */
        _ns1__GetEntityByEntityIDRequest *ns1__GetEntityByEntityIDRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getEntityByEntityID */
        int soap_type() const { return SOAP_TYPE___ns1__getEntityByEntityID; }
        /** Constructor with member initializations */
        __ns1__getEntityByEntityID()
        {
          ns1__GetEntityByEntityIDRequest = (_ns1__GetEntityByEntityIDRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__getEntityByEntityID(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__getEntityByEntityID * SOAP_FMAC2 soap_instantiate___ns1__getEntityByEntityID(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:7481 */
#ifndef SOAP_TYPE___ns1__inviteToConference
#define SOAP_TYPE___ns1__inviteToConference (321)
/* Wrapper: */
struct __ns1__inviteToConference {
      public:
        /** Optional element 'ns1:InviteToConferenceRequest' of XSD type 'ns1:InviteToConferenceRequest' */
        _ns1__InviteToConferenceRequest *ns1__InviteToConferenceRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__inviteToConference */
        int soap_type() const { return SOAP_TYPE___ns1__inviteToConference; }
        /** Constructor with member initializations */
        __ns1__inviteToConference()
        {
          ns1__InviteToConferenceRequest = (_ns1__InviteToConferenceRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__inviteToConference(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__inviteToConference * SOAP_FMAC2 soap_instantiate___ns1__inviteToConference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:7562 */
#ifndef SOAP_TYPE___ns1__cancelOutboundCall
#define SOAP_TYPE___ns1__cancelOutboundCall (325)
/* Wrapper: */
struct __ns1__cancelOutboundCall {
      public:
        /** Optional element 'ns1:CancelOutboundCallRequest' of XSD type 'ns1:CancelOutboundCallRequest' */
        _ns1__CancelOutboundCallRequest *ns1__CancelOutboundCallRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__cancelOutboundCall */
        int soap_type() const { return SOAP_TYPE___ns1__cancelOutboundCall; }
        /** Constructor with member initializations */
        __ns1__cancelOutboundCall()
        {
          ns1__CancelOutboundCallRequest = (_ns1__CancelOutboundCallRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__cancelOutboundCall(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__cancelOutboundCall * SOAP_FMAC2 soap_instantiate___ns1__cancelOutboundCall(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:7646 */
#ifndef SOAP_TYPE___ns1__joinConference
#define SOAP_TYPE___ns1__joinConference (329)
/* Wrapper: */
struct __ns1__joinConference {
      public:
        /** Optional element 'ns1:JoinConferenceRequest' of XSD type 'ns1:JoinConferenceRequest' */
        _ns1__JoinConferenceRequest *ns1__JoinConferenceRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__joinConference */
        int soap_type() const { return SOAP_TYPE___ns1__joinConference; }
        /** Constructor with member initializations */
        __ns1__joinConference()
        {
          ns1__JoinConferenceRequest = (_ns1__JoinConferenceRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__joinConference(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__joinConference * SOAP_FMAC2 soap_instantiate___ns1__joinConference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:7730 */
#ifndef SOAP_TYPE___ns1__joinIPCConference
#define SOAP_TYPE___ns1__joinIPCConference (333)
/* Wrapper: */
struct __ns1__joinIPCConference {
      public:
        /** Optional element 'ns1:JoinIPCConferenceRequest' of XSD type 'ns1:JoinIPCConferenceRequest' */
        _ns1__JoinIPCConferenceRequest *ns1__JoinIPCConferenceRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__joinIPCConference */
        int soap_type() const { return SOAP_TYPE___ns1__joinIPCConference; }
        /** Constructor with member initializations */
        __ns1__joinIPCConference()
        {
          ns1__JoinIPCConferenceRequest = (_ns1__JoinIPCConferenceRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__joinIPCConference(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__joinIPCConference * SOAP_FMAC2 soap_instantiate___ns1__joinIPCConference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:7808 */
#ifndef SOAP_TYPE___ns1__directCall
#define SOAP_TYPE___ns1__directCall (337)
/* Wrapper: */
struct __ns1__directCall {
      public:
        /** Optional element 'ns1:DirectCallRequest' of XSD type 'ns1:DirectCallRequest' */
        _ns1__DirectCallRequest *ns1__DirectCallRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__directCall */
        int soap_type() const { return SOAP_TYPE___ns1__directCall; }
        /** Constructor with member initializations */
        __ns1__directCall()
        {
          ns1__DirectCallRequest = (_ns1__DirectCallRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__directCall(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__directCall * SOAP_FMAC2 soap_instantiate___ns1__directCall(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:7889 */
#ifndef SOAP_TYPE___ns1__getParticipants
#define SOAP_TYPE___ns1__getParticipants (341)
/* Wrapper: */
struct __ns1__getParticipants {
      public:
        /** Optional element 'ns1:GetParticipantsRequest' of XSD type 'ns1:GetParticipantsRequest' */
        _ns1__GetParticipantsRequest *ns1__GetParticipantsRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getParticipants */
        int soap_type() const { return SOAP_TYPE___ns1__getParticipants; }
        /** Constructor with member initializations */
        __ns1__getParticipants()
        {
          ns1__GetParticipantsRequest = (_ns1__GetParticipantsRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__getParticipants(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__getParticipants * SOAP_FMAC2 soap_instantiate___ns1__getParticipants(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:7967 */
#ifndef SOAP_TYPE___ns1__getLectureModeParticipants
#define SOAP_TYPE___ns1__getLectureModeParticipants (345)
/* Wrapper: */
struct __ns1__getLectureModeParticipants {
      public:
        /** Optional element 'ns1:GetLectureModeParticipantsRequest' of XSD type 'ns1:GetLectureModeParticipantsRequest' */
        _ns1__GetLectureModeParticipantsRequest *ns1__GetLectureModeParticipantsRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getLectureModeParticipants */
        int soap_type() const { return SOAP_TYPE___ns1__getLectureModeParticipants; }
        /** Constructor with member initializations */
        __ns1__getLectureModeParticipants()
        {
          ns1__GetLectureModeParticipantsRequest = (_ns1__GetLectureModeParticipantsRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__getLectureModeParticipants(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__getLectureModeParticipants * SOAP_FMAC2 soap_instantiate___ns1__getLectureModeParticipants(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:8048 */
#ifndef SOAP_TYPE___ns1__leaveConference
#define SOAP_TYPE___ns1__leaveConference (349)
/* Wrapper: */
struct __ns1__leaveConference {
      public:
        /** Optional element 'ns1:LeaveConferenceRequest' of XSD type 'ns1:LeaveConferenceRequest' */
        _ns1__LeaveConferenceRequest *ns1__LeaveConferenceRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__leaveConference */
        int soap_type() const { return SOAP_TYPE___ns1__leaveConference; }
        /** Constructor with member initializations */
        __ns1__leaveConference()
        {
          ns1__LeaveConferenceRequest = (_ns1__LeaveConferenceRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__leaveConference(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__leaveConference * SOAP_FMAC2 soap_instantiate___ns1__leaveConference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:8129 */
#ifndef SOAP_TYPE___ns1__muteAudio
#define SOAP_TYPE___ns1__muteAudio (353)
/* Wrapper: */
struct __ns1__muteAudio {
      public:
        /** Optional element 'ns1:MuteAudioRequest' of XSD type 'ns1:MuteAudioRequest' */
        _ns1__MuteAudioRequest *ns1__MuteAudioRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__muteAudio */
        int soap_type() const { return SOAP_TYPE___ns1__muteAudio; }
        /** Constructor with member initializations */
        __ns1__muteAudio()
        {
          ns1__MuteAudioRequest = (_ns1__MuteAudioRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__muteAudio(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__muteAudio * SOAP_FMAC2 soap_instantiate___ns1__muteAudio(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:8210 */
#ifndef SOAP_TYPE___ns1__unmuteAudio
#define SOAP_TYPE___ns1__unmuteAudio (357)
/* Wrapper: */
struct __ns1__unmuteAudio {
      public:
        /** Optional element 'ns1:UnmuteAudioRequest' of XSD type 'ns1:UnmuteAudioRequest' */
        _ns1__UnmuteAudioRequest *ns1__UnmuteAudioRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__unmuteAudio */
        int soap_type() const { return SOAP_TYPE___ns1__unmuteAudio; }
        /** Constructor with member initializations */
        __ns1__unmuteAudio()
        {
          ns1__UnmuteAudioRequest = (_ns1__UnmuteAudioRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__unmuteAudio(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__unmuteAudio * SOAP_FMAC2 soap_instantiate___ns1__unmuteAudio(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:8291 */
#ifndef SOAP_TYPE___ns1__startVideo
#define SOAP_TYPE___ns1__startVideo (361)
/* Wrapper: */
struct __ns1__startVideo {
      public:
        /** Optional element 'ns1:StartVideoRequest' of XSD type 'ns1:StartVideoRequest' */
        _ns1__StartVideoRequest *ns1__StartVideoRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__startVideo */
        int soap_type() const { return SOAP_TYPE___ns1__startVideo; }
        /** Constructor with member initializations */
        __ns1__startVideo()
        {
          ns1__StartVideoRequest = (_ns1__StartVideoRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__startVideo(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__startVideo * SOAP_FMAC2 soap_instantiate___ns1__startVideo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:8372 */
#ifndef SOAP_TYPE___ns1__stopVideo
#define SOAP_TYPE___ns1__stopVideo (365)
/* Wrapper: */
struct __ns1__stopVideo {
      public:
        /** Optional element 'ns1:StopVideoRequest' of XSD type 'ns1:StopVideoRequest' */
        _ns1__StopVideoRequest *ns1__StopVideoRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__stopVideo */
        int soap_type() const { return SOAP_TYPE___ns1__stopVideo; }
        /** Constructor with member initializations */
        __ns1__stopVideo()
        {
          ns1__StopVideoRequest = (_ns1__StopVideoRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__stopVideo(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__stopVideo * SOAP_FMAC2 soap_instantiate___ns1__stopVideo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:8450 */
#ifndef SOAP_TYPE___ns1__myAccount
#define SOAP_TYPE___ns1__myAccount (369)
/* Wrapper: */
struct __ns1__myAccount {
      public:
        /** Optional element 'ns1:MyAccountRequest' of XSD type 'ns1:MyAccountRequest' */
        _ns1__MyAccountRequest *ns1__MyAccountRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__myAccount */
        int soap_type() const { return SOAP_TYPE___ns1__myAccount; }
        /** Constructor with member initializations */
        __ns1__myAccount()
        {
          ns1__MyAccountRequest = (_ns1__MyAccountRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__myAccount(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__myAccount * SOAP_FMAC2 soap_instantiate___ns1__myAccount(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:8528 */
#ifndef SOAP_TYPE___ns1__createRoomURL
#define SOAP_TYPE___ns1__createRoomURL (373)
/* Wrapper: */
struct __ns1__createRoomURL {
      public:
        /** Optional element 'ns1:CreateRoomURLRequest' of XSD type 'ns1:CreateRoomURLRequest' */
        _ns1__CreateRoomURLRequest *ns1__CreateRoomURLRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__createRoomURL */
        int soap_type() const { return SOAP_TYPE___ns1__createRoomURL; }
        /** Constructor with member initializations */
        __ns1__createRoomURL()
        {
          ns1__CreateRoomURLRequest = (_ns1__CreateRoomURLRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__createRoomURL(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__createRoomURL * SOAP_FMAC2 soap_instantiate___ns1__createRoomURL(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:8606 */
#ifndef SOAP_TYPE___ns1__removeRoomURL
#define SOAP_TYPE___ns1__removeRoomURL (377)
/* Wrapper: */
struct __ns1__removeRoomURL {
      public:
        /** Optional element 'ns1:RemoveRoomURLRequest' of XSD type 'ns1:RemoveRoomURLRequest' */
        _ns1__RemoveRoomURLRequest *ns1__RemoveRoomURLRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__removeRoomURL */
        int soap_type() const { return SOAP_TYPE___ns1__removeRoomURL; }
        /** Constructor with member initializations */
        __ns1__removeRoomURL()
        {
          ns1__RemoveRoomURLRequest = (_ns1__RemoveRoomURLRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__removeRoomURL(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__removeRoomURL * SOAP_FMAC2 soap_instantiate___ns1__removeRoomURL(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:8684 */
#ifndef SOAP_TYPE___ns1__createRoomPIN
#define SOAP_TYPE___ns1__createRoomPIN (381)
/* Wrapper: */
struct __ns1__createRoomPIN {
      public:
        /** Optional element 'ns1:CreateRoomPINRequest' of XSD type 'ns1:CreateRoomPINRequest' */
        _ns1__CreateRoomPINRequest *ns1__CreateRoomPINRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__createRoomPIN */
        int soap_type() const { return SOAP_TYPE___ns1__createRoomPIN; }
        /** Constructor with member initializations */
        __ns1__createRoomPIN()
        {
          ns1__CreateRoomPINRequest = (_ns1__CreateRoomPINRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__createRoomPIN(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__createRoomPIN * SOAP_FMAC2 soap_instantiate___ns1__createRoomPIN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:8762 */
#ifndef SOAP_TYPE___ns1__removeRoomPIN
#define SOAP_TYPE___ns1__removeRoomPIN (385)
/* Wrapper: */
struct __ns1__removeRoomPIN {
      public:
        /** Optional element 'ns1:RemoveRoomPINRequest' of XSD type 'ns1:RemoveRoomPINRequest' */
        _ns1__RemoveRoomPINRequest *ns1__RemoveRoomPINRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__removeRoomPIN */
        int soap_type() const { return SOAP_TYPE___ns1__removeRoomPIN; }
        /** Constructor with member initializations */
        __ns1__removeRoomPIN()
        {
          ns1__RemoveRoomPINRequest = (_ns1__RemoveRoomPINRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__removeRoomPIN(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__removeRoomPIN * SOAP_FMAC2 soap_instantiate___ns1__removeRoomPIN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:8840 */
#ifndef SOAP_TYPE___ns1__createRoom
#define SOAP_TYPE___ns1__createRoom (389)
/* Wrapper: */
struct __ns1__createRoom {
      public:
        /** Optional element 'ns1:CreateRoomRequest' of XSD type 'ns1:CreateRoomRequest' */
        _ns1__CreateRoomRequest *ns1__CreateRoomRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__createRoom */
        int soap_type() const { return SOAP_TYPE___ns1__createRoom; }
        /** Constructor with member initializations */
        __ns1__createRoom()
        {
          ns1__CreateRoomRequest = (_ns1__CreateRoomRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__createRoom(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__createRoom * SOAP_FMAC2 soap_instantiate___ns1__createRoom(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:8918 */
#ifndef SOAP_TYPE___ns1__deleteRoom
#define SOAP_TYPE___ns1__deleteRoom (393)
/* Wrapper: */
struct __ns1__deleteRoom {
      public:
        /** Optional element 'ns1:DeleteRoomRequest' of XSD type 'ns1:DeleteRoomRequest' */
        _ns1__DeleteRoomRequest *ns1__DeleteRoomRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__deleteRoom */
        int soap_type() const { return SOAP_TYPE___ns1__deleteRoom; }
        /** Constructor with member initializations */
        __ns1__deleteRoom()
        {
          ns1__DeleteRoomRequest = (_ns1__DeleteRoomRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__deleteRoom(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__deleteRoom * SOAP_FMAC2 soap_instantiate___ns1__deleteRoom(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:8996 */
#ifndef SOAP_TYPE___ns1__updatePassword
#define SOAP_TYPE___ns1__updatePassword (397)
/* Wrapper: */
struct __ns1__updatePassword {
      public:
        /** Optional element 'ns1:UpdatePasswordRequest' of XSD type 'ns1:UpdatePasswordRequest' */
        _ns1__UpdatePasswordRequest *ns1__UpdatePasswordRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__updatePassword */
        int soap_type() const { return SOAP_TYPE___ns1__updatePassword; }
        /** Constructor with member initializations */
        __ns1__updatePassword()
        {
          ns1__UpdatePasswordRequest = (_ns1__UpdatePasswordRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__updatePassword(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__updatePassword * SOAP_FMAC2 soap_instantiate___ns1__updatePassword(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:9074 */
#ifndef SOAP_TYPE___ns1__updateLanguage
#define SOAP_TYPE___ns1__updateLanguage (401)
/* Wrapper: */
struct __ns1__updateLanguage {
      public:
        /** Optional element 'ns1:UpdateLanguageRequest' of XSD type 'ns1:UpdateLanguageRequest' */
        _ns1__UpdateLanguageRequest *ns1__UpdateLanguageRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__updateLanguage */
        int soap_type() const { return SOAP_TYPE___ns1__updateLanguage; }
        /** Constructor with member initializations */
        __ns1__updateLanguage()
        {
          ns1__UpdateLanguageRequest = (_ns1__UpdateLanguageRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__updateLanguage(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__updateLanguage * SOAP_FMAC2 soap_instantiate___ns1__updateLanguage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:9155 */
#ifndef SOAP_TYPE___ns1__lockRoom
#define SOAP_TYPE___ns1__lockRoom (405)
/* Wrapper: */
struct __ns1__lockRoom {
      public:
        /** Optional element 'ns1:LockRoomRequest' of XSD type 'ns1:LockRoomRequest' */
        _ns1__LockRoomRequest *ns1__LockRoomRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__lockRoom */
        int soap_type() const { return SOAP_TYPE___ns1__lockRoom; }
        /** Constructor with member initializations */
        __ns1__lockRoom()
        {
          ns1__LockRoomRequest = (_ns1__LockRoomRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__lockRoom(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__lockRoom * SOAP_FMAC2 soap_instantiate___ns1__lockRoom(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:9236 */
#ifndef SOAP_TYPE___ns1__unlockRoom
#define SOAP_TYPE___ns1__unlockRoom (409)
/* Wrapper: */
struct __ns1__unlockRoom {
      public:
        /** Optional element 'ns1:UnlockRoomRequest' of XSD type 'ns1:UnlockRoomRequest' */
        _ns1__UnlockRoomRequest *ns1__UnlockRoomRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__unlockRoom */
        int soap_type() const { return SOAP_TYPE___ns1__unlockRoom; }
        /** Constructor with member initializations */
        __ns1__unlockRoom()
        {
          ns1__UnlockRoomRequest = (_ns1__UnlockRoomRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__unlockRoom(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__unlockRoom * SOAP_FMAC2 soap_instantiate___ns1__unlockRoom(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:9314 */
#ifndef SOAP_TYPE___ns1__setMemberMode
#define SOAP_TYPE___ns1__setMemberMode (413)
/* Wrapper: */
struct __ns1__setMemberMode {
      public:
        /** Optional element 'ns1:SetMemberModeRequest' of XSD type 'ns1:SetMemberModeRequest' */
        _ns1__SetMemberModeRequest *ns1__SetMemberModeRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__setMemberMode */
        int soap_type() const { return SOAP_TYPE___ns1__setMemberMode; }
        /** Constructor with member initializations */
        __ns1__setMemberMode()
        {
          ns1__SetMemberModeRequest = (_ns1__SetMemberModeRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__setMemberMode(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__setMemberMode * SOAP_FMAC2 soap_instantiate___ns1__setMemberMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:9392 */
#ifndef SOAP_TYPE___ns1__getRecordingProfiles
#define SOAP_TYPE___ns1__getRecordingProfiles (417)
/* Wrapper: */
struct __ns1__getRecordingProfiles {
      public:
        /** Optional element 'ns1:GetRecordingProfilesRequest' of XSD type 'ns1:GetRecordingProfilesRequest' */
        _ns1__GetRecordingProfilesRequest *ns1__GetRecordingProfilesRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getRecordingProfiles */
        int soap_type() const { return SOAP_TYPE___ns1__getRecordingProfiles; }
        /** Constructor with member initializations */
        __ns1__getRecordingProfiles()
        {
          ns1__GetRecordingProfilesRequest = (_ns1__GetRecordingProfilesRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__getRecordingProfiles(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__getRecordingProfiles * SOAP_FMAC2 soap_instantiate___ns1__getRecordingProfiles(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:9476 */
#ifndef SOAP_TYPE___ns1__startRecording
#define SOAP_TYPE___ns1__startRecording (421)
/* Wrapper: */
struct __ns1__startRecording {
      public:
        /** Optional element 'ns1:StartRecordingRequest' of XSD type 'ns1:StartRecordingRequest' */
        _ns1__StartRecordingRequest *ns1__StartRecordingRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__startRecording */
        int soap_type() const { return SOAP_TYPE___ns1__startRecording; }
        /** Constructor with member initializations */
        __ns1__startRecording()
        {
          ns1__StartRecordingRequest = (_ns1__StartRecordingRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__startRecording(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__startRecording * SOAP_FMAC2 soap_instantiate___ns1__startRecording(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:9554 */
#ifndef SOAP_TYPE___ns1__getPortalVersion
#define SOAP_TYPE___ns1__getPortalVersion (425)
/* Wrapper: */
struct __ns1__getPortalVersion {
      public:
        /** Optional element 'ns1:GetPortalVersionRequest' of XSD type 'ns1:GetPortalVersionRequest' */
        _ns1__GetPortalVersionRequest *ns1__GetPortalVersionRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getPortalVersion */
        int soap_type() const { return SOAP_TYPE___ns1__getPortalVersion; }
        /** Constructor with member initializations */
        __ns1__getPortalVersion()
        {
          ns1__GetPortalVersionRequest = (_ns1__GetPortalVersionRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__getPortalVersion(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__getPortalVersion * SOAP_FMAC2 soap_instantiate___ns1__getPortalVersion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:9635 */
#ifndef SOAP_TYPE___ns1__pauseRecording
#define SOAP_TYPE___ns1__pauseRecording (429)
/* Wrapper: */
struct __ns1__pauseRecording {
      public:
        /** Optional element 'ns1:PauseRecordingRequest' of XSD type 'ns1:PauseRecordingRequest' */
        _ns1__PauseRecordingRequest *ns1__PauseRecordingRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__pauseRecording */
        int soap_type() const { return SOAP_TYPE___ns1__pauseRecording; }
        /** Constructor with member initializations */
        __ns1__pauseRecording()
        {
          ns1__PauseRecordingRequest = (_ns1__PauseRecordingRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__pauseRecording(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__pauseRecording * SOAP_FMAC2 soap_instantiate___ns1__pauseRecording(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:9716 */
#ifndef SOAP_TYPE___ns1__resumeRecording
#define SOAP_TYPE___ns1__resumeRecording (433)
/* Wrapper: */
struct __ns1__resumeRecording {
      public:
        /** Optional element 'ns1:ResumeRecordingRequest' of XSD type 'ns1:ResumeRecordingRequest' */
        _ns1__ResumeRecordingRequest *ns1__ResumeRecordingRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__resumeRecording */
        int soap_type() const { return SOAP_TYPE___ns1__resumeRecording; }
        /** Constructor with member initializations */
        __ns1__resumeRecording()
        {
          ns1__ResumeRecordingRequest = (_ns1__ResumeRecordingRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__resumeRecording(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__resumeRecording * SOAP_FMAC2 soap_instantiate___ns1__resumeRecording(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:9797 */
#ifndef SOAP_TYPE___ns1__stopRecording
#define SOAP_TYPE___ns1__stopRecording (437)
/* Wrapper: */
struct __ns1__stopRecording {
      public:
        /** Optional element 'ns1:StopRecordingRequest' of XSD type 'ns1:StopRecordingRequest' */
        _ns1__StopRecordingRequest *ns1__StopRecordingRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__stopRecording */
        int soap_type() const { return SOAP_TYPE___ns1__stopRecording; }
        /** Constructor with member initializations */
        __ns1__stopRecording()
        {
          ns1__StopRecordingRequest = (_ns1__StopRecordingRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__stopRecording(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__stopRecording * SOAP_FMAC2 soap_instantiate___ns1__stopRecording(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:9875 */
#ifndef SOAP_TYPE___ns1__createWebcastURL
#define SOAP_TYPE___ns1__createWebcastURL (441)
/* Wrapper: */
struct __ns1__createWebcastURL {
      public:
        /** Optional element 'ns1:CreateWebcastURLRequest' of XSD type 'ns1:CreateWebcastURLRequest' */
        _ns1__CreateWebcastURLRequest *ns1__CreateWebcastURLRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__createWebcastURL */
        int soap_type() const { return SOAP_TYPE___ns1__createWebcastURL; }
        /** Constructor with member initializations */
        __ns1__createWebcastURL()
        {
          ns1__CreateWebcastURLRequest = (_ns1__CreateWebcastURLRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__createWebcastURL(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__createWebcastURL * SOAP_FMAC2 soap_instantiate___ns1__createWebcastURL(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:9953 */
#ifndef SOAP_TYPE___ns1__createWebcastPIN
#define SOAP_TYPE___ns1__createWebcastPIN (445)
/* Wrapper: */
struct __ns1__createWebcastPIN {
      public:
        /** Optional element 'ns1:CreateWebcastPINRequest' of XSD type 'ns1:CreateWebcastPINRequest' */
        _ns1__CreateWebcastPINRequest *ns1__CreateWebcastPINRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__createWebcastPIN */
        int soap_type() const { return SOAP_TYPE___ns1__createWebcastPIN; }
        /** Constructor with member initializations */
        __ns1__createWebcastPIN()
        {
          ns1__CreateWebcastPINRequest = (_ns1__CreateWebcastPINRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__createWebcastPIN(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__createWebcastPIN * SOAP_FMAC2 soap_instantiate___ns1__createWebcastPIN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:10031 */
#ifndef SOAP_TYPE___ns1__removeWebcastURL
#define SOAP_TYPE___ns1__removeWebcastURL (449)
/* Wrapper: */
struct __ns1__removeWebcastURL {
      public:
        /** Optional element 'ns1:RemoveWebcastURLRequest' of XSD type 'ns1:RemoveWebcastURLRequest' */
        _ns1__RemoveWebcastURLRequest *ns1__RemoveWebcastURLRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__removeWebcastURL */
        int soap_type() const { return SOAP_TYPE___ns1__removeWebcastURL; }
        /** Constructor with member initializations */
        __ns1__removeWebcastURL()
        {
          ns1__RemoveWebcastURLRequest = (_ns1__RemoveWebcastURLRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__removeWebcastURL(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__removeWebcastURL * SOAP_FMAC2 soap_instantiate___ns1__removeWebcastURL(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:10109 */
#ifndef SOAP_TYPE___ns1__removeWebcastPIN
#define SOAP_TYPE___ns1__removeWebcastPIN (453)
/* Wrapper: */
struct __ns1__removeWebcastPIN {
      public:
        /** Optional element 'ns1:RemoveWebcastPINRequest' of XSD type 'ns1:RemoveWebcastPINRequest' */
        _ns1__RemoveWebcastPINRequest *ns1__RemoveWebcastPINRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__removeWebcastPIN */
        int soap_type() const { return SOAP_TYPE___ns1__removeWebcastPIN; }
        /** Constructor with member initializations */
        __ns1__removeWebcastPIN()
        {
          ns1__RemoveWebcastPINRequest = (_ns1__RemoveWebcastPINRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__removeWebcastPIN(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__removeWebcastPIN * SOAP_FMAC2 soap_instantiate___ns1__removeWebcastPIN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:10187 */
#ifndef SOAP_TYPE___ns1__getWebcastURL
#define SOAP_TYPE___ns1__getWebcastURL (457)
/* Wrapper: */
struct __ns1__getWebcastURL {
      public:
        /** Optional element 'ns1:GetWebcastURLRequest' of XSD type 'ns1:GetWebcastURLRequest' */
        _ns1__GetWebcastURLRequest *ns1__GetWebcastURLRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getWebcastURL */
        int soap_type() const { return SOAP_TYPE___ns1__getWebcastURL; }
        /** Constructor with member initializations */
        __ns1__getWebcastURL()
        {
          ns1__GetWebcastURLRequest = (_ns1__GetWebcastURLRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__getWebcastURL(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__getWebcastURL * SOAP_FMAC2 soap_instantiate___ns1__getWebcastURL(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:10262 */
#ifndef SOAP_TYPE___ns1__getUserName
#define SOAP_TYPE___ns1__getUserName (461)
/* Wrapper: */
struct __ns1__getUserName {
      public:
        /** Optional element 'ns1:GetUserNameRequest' of XSD type 'ns1:GetUserNameRequest' */
        _ns1__GetUserNameRequest *ns1__GetUserNameRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getUserName */
        int soap_type() const { return SOAP_TYPE___ns1__getUserName; }
        /** Constructor with member initializations */
        __ns1__getUserName()
        {
          ns1__GetUserNameRequest = (_ns1__GetUserNameRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__getUserName(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__getUserName * SOAP_FMAC2 soap_instantiate___ns1__getUserName(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:10337 */
#ifndef SOAP_TYPE___ns1__getEntityByRoomKey
#define SOAP_TYPE___ns1__getEntityByRoomKey (465)
/* Wrapper: */
struct __ns1__getEntityByRoomKey {
      public:
        /** Optional element 'ns1:GetEntityByRoomKeyRequest' of XSD type 'ns1:GetEntityByRoomKeyRequest' */
        _ns1__GetEntityByRoomKeyRequest *ns1__GetEntityByRoomKeyRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getEntityByRoomKey */
        int soap_type() const { return SOAP_TYPE___ns1__getEntityByRoomKey; }
        /** Constructor with member initializations */
        __ns1__getEntityByRoomKey()
        {
          ns1__GetEntityByRoomKeyRequest = (_ns1__GetEntityByRoomKeyRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__getEntityByRoomKey(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__getEntityByRoomKey * SOAP_FMAC2 soap_instantiate___ns1__getEntityByRoomKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:10412 */
#ifndef SOAP_TYPE___ns1__getInviteContent
#define SOAP_TYPE___ns1__getInviteContent (469)
/* Wrapper: */
struct __ns1__getInviteContent {
      public:
        /** Optional element 'ns1:GetInviteContentRequest' of XSD type 'ns1:GetInviteContentRequest' */
        _ns1__GetInviteContentRequest *ns1__GetInviteContentRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getInviteContent */
        int soap_type() const { return SOAP_TYPE___ns1__getInviteContent; }
        /** Constructor with member initializations */
        __ns1__getInviteContent()
        {
          ns1__GetInviteContentRequest = (_ns1__GetInviteContentRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__getInviteContent(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__getInviteContent * SOAP_FMAC2 soap_instantiate___ns1__getInviteContent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:10487 */
#ifndef SOAP_TYPE___ns1__getRoomProfiles
#define SOAP_TYPE___ns1__getRoomProfiles (472)
/* Wrapper: */
struct __ns1__getRoomProfiles {
      public:
        /** Optional element 'ns1:GetRoomProfilesRequest' of XSD type 'xsd:anyType' */
        char *ns1__GetRoomProfilesRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getRoomProfiles */
        int soap_type() const { return SOAP_TYPE___ns1__getRoomProfiles; }
        /** Constructor with member initializations */
        __ns1__getRoomProfiles()
        {
          ns1__GetRoomProfilesRequest = (char *)0;
        }
        /** Friend allocator used by soap_new___ns1__getRoomProfiles(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__getRoomProfiles * SOAP_FMAC2 soap_instantiate___ns1__getRoomProfiles(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:10562 */
#ifndef SOAP_TYPE___ns1__getRoomProfile
#define SOAP_TYPE___ns1__getRoomProfile (476)
/* Wrapper: */
struct __ns1__getRoomProfile {
      public:
        /** Optional element 'ns1:GetRoomProfileRequest' of XSD type 'ns1:GetRoomProfileRequest' */
        _ns1__GetRoomProfileRequest *ns1__GetRoomProfileRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getRoomProfile */
        int soap_type() const { return SOAP_TYPE___ns1__getRoomProfile; }
        /** Constructor with member initializations */
        __ns1__getRoomProfile()
        {
          ns1__GetRoomProfileRequest = (_ns1__GetRoomProfileRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__getRoomProfile(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__getRoomProfile * SOAP_FMAC2 soap_instantiate___ns1__getRoomProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:10637 */
#ifndef SOAP_TYPE___ns1__setRoomProfile
#define SOAP_TYPE___ns1__setRoomProfile (480)
/* Wrapper: */
struct __ns1__setRoomProfile {
      public:
        /** Optional element 'ns1:SetRoomProfileRequest' of XSD type 'ns1:SetRoomProfileRequest' */
        _ns1__SetRoomProfileRequest *ns1__SetRoomProfileRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__setRoomProfile */
        int soap_type() const { return SOAP_TYPE___ns1__setRoomProfile; }
        /** Constructor with member initializations */
        __ns1__setRoomProfile()
        {
          ns1__SetRoomProfileRequest = (_ns1__SetRoomProfileRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__setRoomProfile(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__setRoomProfile * SOAP_FMAC2 soap_instantiate___ns1__setRoomProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:10712 */
#ifndef SOAP_TYPE___ns1__removeRoomProfile
#define SOAP_TYPE___ns1__removeRoomProfile (484)
/* Wrapper: */
struct __ns1__removeRoomProfile {
      public:
        /** Optional element 'ns1:RemoveRoomProfileRequest' of XSD type 'ns1:RemoveRoomProfileRequest' */
        _ns1__RemoveRoomProfileRequest *ns1__RemoveRoomProfileRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__removeRoomProfile */
        int soap_type() const { return SOAP_TYPE___ns1__removeRoomProfile; }
        /** Constructor with member initializations */
        __ns1__removeRoomProfile()
        {
          ns1__RemoveRoomProfileRequest = (_ns1__RemoveRoomProfileRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__removeRoomProfile(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__removeRoomProfile * SOAP_FMAC2 soap_instantiate___ns1__removeRoomProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:10790 */
#ifndef SOAP_TYPE___ns1__createModeratorURL
#define SOAP_TYPE___ns1__createModeratorURL (488)
/* Wrapper: */
struct __ns1__createModeratorURL {
      public:
        /** Optional element 'ns1:CreateModeratorURLRequest' of XSD type 'ns1:CreateModeratorURLRequest' */
        _ns1__CreateModeratorURLRequest *ns1__CreateModeratorURLRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__createModeratorURL */
        int soap_type() const { return SOAP_TYPE___ns1__createModeratorURL; }
        /** Constructor with member initializations */
        __ns1__createModeratorURL()
        {
          ns1__CreateModeratorURLRequest = (_ns1__CreateModeratorURLRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__createModeratorURL(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__createModeratorURL * SOAP_FMAC2 soap_instantiate___ns1__createModeratorURL(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:10868 */
#ifndef SOAP_TYPE___ns1__removeModeratorURL
#define SOAP_TYPE___ns1__removeModeratorURL (492)
/* Wrapper: */
struct __ns1__removeModeratorURL {
      public:
        /** Optional element 'ns1:RemoveModeratorURLRequest' of XSD type 'ns1:RemoveModeratorURLRequest' */
        _ns1__RemoveModeratorURLRequest *ns1__RemoveModeratorURLRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__removeModeratorURL */
        int soap_type() const { return SOAP_TYPE___ns1__removeModeratorURL; }
        /** Constructor with member initializations */
        __ns1__removeModeratorURL()
        {
          ns1__RemoveModeratorURLRequest = (_ns1__RemoveModeratorURLRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__removeModeratorURL(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__removeModeratorURL * SOAP_FMAC2 soap_instantiate___ns1__removeModeratorURL(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:10946 */
#ifndef SOAP_TYPE___ns1__getModeratorURL
#define SOAP_TYPE___ns1__getModeratorURL (496)
/* Wrapper: */
struct __ns1__getModeratorURL {
      public:
        /** Optional element 'ns1:GetModeratorURLRequest' of XSD type 'ns1:GetModeratorURLRequest' */
        _ns1__GetModeratorURLRequest *ns1__GetModeratorURLRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getModeratorURL */
        int soap_type() const { return SOAP_TYPE___ns1__getModeratorURL; }
        /** Constructor with member initializations */
        __ns1__getModeratorURL()
        {
          ns1__GetModeratorURLRequest = (_ns1__GetModeratorURLRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__getModeratorURL(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__getModeratorURL * SOAP_FMAC2 soap_instantiate___ns1__getModeratorURL(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:11024 */
#ifndef SOAP_TYPE___ns1__getModeratorURLWithToken
#define SOAP_TYPE___ns1__getModeratorURLWithToken (500)
/* Wrapper: */
struct __ns1__getModeratorURLWithToken {
      public:
        /** Optional element 'ns1:GetModeratorURLWithTokenRequest' of XSD type 'ns1:GetModeratorURLWithTokenRequest' */
        _ns1__GetModeratorURLWithTokenRequest *ns1__GetModeratorURLWithTokenRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getModeratorURLWithToken */
        int soap_type() const { return SOAP_TYPE___ns1__getModeratorURLWithToken; }
        /** Constructor with member initializations */
        __ns1__getModeratorURLWithToken()
        {
          ns1__GetModeratorURLWithTokenRequest = (_ns1__GetModeratorURLWithTokenRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__getModeratorURLWithToken(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__getModeratorURLWithToken * SOAP_FMAC2 soap_instantiate___ns1__getModeratorURLWithToken(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:11105 */
#ifndef SOAP_TYPE___ns1__createModeratorPIN
#define SOAP_TYPE___ns1__createModeratorPIN (504)
/* Wrapper: */
struct __ns1__createModeratorPIN {
      public:
        /** Optional element 'ns1:CreateModeratorPINRequest' of XSD type 'ns1:CreateModeratorPINRequest' */
        _ns1__CreateModeratorPINRequest *ns1__CreateModeratorPINRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__createModeratorPIN */
        int soap_type() const { return SOAP_TYPE___ns1__createModeratorPIN; }
        /** Constructor with member initializations */
        __ns1__createModeratorPIN()
        {
          ns1__CreateModeratorPINRequest = (_ns1__CreateModeratorPINRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__createModeratorPIN(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__createModeratorPIN * SOAP_FMAC2 soap_instantiate___ns1__createModeratorPIN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:11183 */
#ifndef SOAP_TYPE___ns1__removeModeratorPIN
#define SOAP_TYPE___ns1__removeModeratorPIN (508)
/* Wrapper: */
struct __ns1__removeModeratorPIN {
      public:
        /** Optional element 'ns1:RemoveModeratorPINRequest' of XSD type 'ns1:RemoveModeratorPINRequest' */
        _ns1__RemoveModeratorPINRequest *ns1__RemoveModeratorPINRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__removeModeratorPIN */
        int soap_type() const { return SOAP_TYPE___ns1__removeModeratorPIN; }
        /** Constructor with member initializations */
        __ns1__removeModeratorPIN()
        {
          ns1__RemoveModeratorPINRequest = (_ns1__RemoveModeratorPINRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__removeModeratorPIN(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__removeModeratorPIN * SOAP_FMAC2 soap_instantiate___ns1__removeModeratorPIN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:11258 */
#ifndef SOAP_TYPE___ns1__getConferenceID
#define SOAP_TYPE___ns1__getConferenceID (512)
/* Wrapper: */
struct __ns1__getConferenceID {
      public:
        /** Optional element 'ns1:GetConferenceIDRequest' of XSD type 'ns1:GetConferenceIDRequest' */
        _ns1__GetConferenceIDRequest *ns1__GetConferenceIDRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getConferenceID */
        int soap_type() const { return SOAP_TYPE___ns1__getConferenceID; }
        /** Constructor with member initializations */
        __ns1__getConferenceID()
        {
          ns1__GetConferenceIDRequest = (_ns1__GetConferenceIDRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__getConferenceID(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__getConferenceID * SOAP_FMAC2 soap_instantiate___ns1__getConferenceID(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:11339 */
#ifndef SOAP_TYPE___ns1__generateAuthToken
#define SOAP_TYPE___ns1__generateAuthToken (516)
/* Wrapper: */
struct __ns1__generateAuthToken {
      public:
        /** Optional element 'ns1:GenerateAuthTokenRequest' of XSD type 'ns1:GenerateAuthTokenRequest' */
        _ns1__GenerateAuthTokenRequest *ns1__GenerateAuthTokenRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__generateAuthToken */
        int soap_type() const { return SOAP_TYPE___ns1__generateAuthToken; }
        /** Constructor with member initializations */
        __ns1__generateAuthToken()
        {
          ns1__GenerateAuthTokenRequest = (_ns1__GenerateAuthTokenRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__generateAuthToken(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__generateAuthToken * SOAP_FMAC2 soap_instantiate___ns1__generateAuthToken(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:11420 */
#ifndef SOAP_TYPE___ns1__createScheduledRoom
#define SOAP_TYPE___ns1__createScheduledRoom (520)
/* Wrapper: */
struct __ns1__createScheduledRoom {
      public:
        /** Optional element 'ns1:CreateScheduledRoomRequest' of XSD type 'ns1:CreateScheduledRoomRequest' */
        _ns1__CreateScheduledRoomRequest *ns1__CreateScheduledRoomRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__createScheduledRoom */
        int soap_type() const { return SOAP_TYPE___ns1__createScheduledRoom; }
        /** Constructor with member initializations */
        __ns1__createScheduledRoom()
        {
          ns1__CreateScheduledRoomRequest = (_ns1__CreateScheduledRoomRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__createScheduledRoom(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__createScheduledRoom * SOAP_FMAC2 soap_instantiate___ns1__createScheduledRoom(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:11498 */
#ifndef SOAP_TYPE___ns1__deleteScheduledRoom
#define SOAP_TYPE___ns1__deleteScheduledRoom (524)
/* Wrapper: */
struct __ns1__deleteScheduledRoom {
      public:
        /** Optional element 'ns1:DeleteScheduledRoomRequest' of XSD type 'ns1:DeleteScheduledRoomRequest' */
        _ns1__DeleteScheduledRoomRequest *ns1__DeleteScheduledRoomRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__deleteScheduledRoom */
        int soap_type() const { return SOAP_TYPE___ns1__deleteScheduledRoom; }
        /** Constructor with member initializations */
        __ns1__deleteScheduledRoom()
        {
          ns1__DeleteScheduledRoomRequest = (_ns1__DeleteScheduledRoomRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__deleteScheduledRoom(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__deleteScheduledRoom * SOAP_FMAC2 soap_instantiate___ns1__deleteScheduledRoom(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:11570 */
#ifndef SOAP_TYPE___ns1__getPortalFeatures
#define SOAP_TYPE___ns1__getPortalFeatures (527)
/* Wrapper: */
struct __ns1__getPortalFeatures {
      public:
        /** Optional element 'ns1:GetPortalFeaturesRequest' of XSD type 'xsd:anyType' */
        char *ns1__GetPortalFeaturesRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getPortalFeatures */
        int soap_type() const { return SOAP_TYPE___ns1__getPortalFeatures; }
        /** Constructor with member initializations */
        __ns1__getPortalFeatures()
        {
          ns1__GetPortalFeaturesRequest = (char *)0;
        }
        /** Friend allocator used by soap_new___ns1__getPortalFeatures(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__getPortalFeatures * SOAP_FMAC2 soap_instantiate___ns1__getPortalFeatures(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:11648 */
#ifndef SOAP_TYPE___ns1__setEndpointDetails
#define SOAP_TYPE___ns1__setEndpointDetails (531)
/* Wrapper: */
struct __ns1__setEndpointDetails {
      public:
        /** Optional element 'ns1:SetEndpointDetailsRequest' of XSD type 'ns1:SetEndpointDetailsRequest' */
        _ns1__SetEndpointDetailsRequest *ns1__SetEndpointDetailsRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__setEndpointDetails */
        int soap_type() const { return SOAP_TYPE___ns1__setEndpointDetails; }
        /** Constructor with member initializations */
        __ns1__setEndpointDetails()
        {
          ns1__SetEndpointDetailsRequest = (_ns1__SetEndpointDetailsRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__setEndpointDetails(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__setEndpointDetails * SOAP_FMAC2 soap_instantiate___ns1__setEndpointDetails(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:11720 */
#ifndef SOAP_TYPE___ns1__getActiveSessions
#define SOAP_TYPE___ns1__getActiveSessions (534)
/* Wrapper: */
struct __ns1__getActiveSessions {
      public:
        /** Optional element 'ns1:GetActiveSessionsRequest' of XSD type 'xsd:anyType' */
        char *ns1__GetActiveSessionsRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getActiveSessions */
        int soap_type() const { return SOAP_TYPE___ns1__getActiveSessions; }
        /** Constructor with member initializations */
        __ns1__getActiveSessions()
        {
          ns1__GetActiveSessionsRequest = (char *)0;
        }
        /** Friend allocator used by soap_new___ns1__getActiveSessions(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__getActiveSessions * SOAP_FMAC2 soap_instantiate___ns1__getActiveSessions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:11792 */
#ifndef SOAP_TYPE___ns1__logoutAllOtherSessions
#define SOAP_TYPE___ns1__logoutAllOtherSessions (537)
/* Wrapper: */
struct __ns1__logoutAllOtherSessions {
      public:
        /** Optional element 'ns1:LogoutAllOtherSessionsRequest' of XSD type 'xsd:anyType' */
        char *ns1__LogoutAllOtherSessionsRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__logoutAllOtherSessions */
        int soap_type() const { return SOAP_TYPE___ns1__logoutAllOtherSessions; }
        /** Constructor with member initializations */
        __ns1__logoutAllOtherSessions()
        {
          ns1__LogoutAllOtherSessionsRequest = (char *)0;
        }
        /** Friend allocator used by soap_new___ns1__logoutAllOtherSessions(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__logoutAllOtherSessions * SOAP_FMAC2 soap_instantiate___ns1__logoutAllOtherSessions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:11870 */
#ifndef SOAP_TYPE___ns1__disconnectConferenceAll
#define SOAP_TYPE___ns1__disconnectConferenceAll (541)
/* Wrapper: */
struct __ns1__disconnectConferenceAll {
      public:
        /** Optional element 'ns1:disconnectConferenceAllRequest' of XSD type 'ns1:disconnectConferenceAllRequest' */
        _ns1__disconnectConferenceAllRequest *ns1__disconnectConferenceAllRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__disconnectConferenceAll */
        int soap_type() const { return SOAP_TYPE___ns1__disconnectConferenceAll; }
        /** Constructor with member initializations */
        __ns1__disconnectConferenceAll()
        {
          ns1__disconnectConferenceAllRequest = (_ns1__disconnectConferenceAllRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__disconnectConferenceAll(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__disconnectConferenceAll * SOAP_FMAC2 soap_instantiate___ns1__disconnectConferenceAll(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:11948 */
#ifndef SOAP_TYPE___ns1__muteAudioServerAll
#define SOAP_TYPE___ns1__muteAudioServerAll (545)
/* Wrapper: */
struct __ns1__muteAudioServerAll {
      public:
        /** Optional element 'ns1:muteAudioServerAllRequest' of XSD type 'ns1:muteAudioServerAllRequest' */
        _ns1__muteAudioServerAllRequest *ns1__muteAudioServerAllRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__muteAudioServerAll */
        int soap_type() const { return SOAP_TYPE___ns1__muteAudioServerAll; }
        /** Constructor with member initializations */
        __ns1__muteAudioServerAll()
        {
          ns1__muteAudioServerAllRequest = (_ns1__muteAudioServerAllRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__muteAudioServerAll(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__muteAudioServerAll * SOAP_FMAC2 soap_instantiate___ns1__muteAudioServerAll(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:12026 */
#ifndef SOAP_TYPE___ns1__muteAudioClientAll
#define SOAP_TYPE___ns1__muteAudioClientAll (549)
/* Wrapper: */
struct __ns1__muteAudioClientAll {
      public:
        /** Optional element 'ns1:muteAudioClientAllRequest' of XSD type 'ns1:muteAudioClientAllRequest' */
        _ns1__muteAudioClientAllRequest *ns1__muteAudioClientAllRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__muteAudioClientAll */
        int soap_type() const { return SOAP_TYPE___ns1__muteAudioClientAll; }
        /** Constructor with member initializations */
        __ns1__muteAudioClientAll()
        {
          ns1__muteAudioClientAllRequest = (_ns1__muteAudioClientAllRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__muteAudioClientAll(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__muteAudioClientAll * SOAP_FMAC2 soap_instantiate___ns1__muteAudioClientAll(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:12104 */
#ifndef SOAP_TYPE___ns1__muteVideoServerAll
#define SOAP_TYPE___ns1__muteVideoServerAll (553)
/* Wrapper: */
struct __ns1__muteVideoServerAll {
      public:
        /** Optional element 'ns1:muteVideoServerAllRequest' of XSD type 'ns1:muteVideoServerAllRequest' */
        _ns1__muteVideoServerAllRequest *ns1__muteVideoServerAllRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__muteVideoServerAll */
        int soap_type() const { return SOAP_TYPE___ns1__muteVideoServerAll; }
        /** Constructor with member initializations */
        __ns1__muteVideoServerAll()
        {
          ns1__muteVideoServerAllRequest = (_ns1__muteVideoServerAllRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__muteVideoServerAll(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__muteVideoServerAll * SOAP_FMAC2 soap_instantiate___ns1__muteVideoServerAll(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:12182 */
#ifndef SOAP_TYPE___ns1__muteVideoClientAll
#define SOAP_TYPE___ns1__muteVideoClientAll (557)
/* Wrapper: */
struct __ns1__muteVideoClientAll {
      public:
        /** Optional element 'ns1:muteVideoClientAllRequest' of XSD type 'ns1:muteVideoClientAllRequest' */
        _ns1__muteVideoClientAllRequest *ns1__muteVideoClientAllRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__muteVideoClientAll */
        int soap_type() const { return SOAP_TYPE___ns1__muteVideoClientAll; }
        /** Constructor with member initializations */
        __ns1__muteVideoClientAll()
        {
          ns1__muteVideoClientAllRequest = (_ns1__muteVideoClientAllRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__muteVideoClientAll(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__muteVideoClientAll * SOAP_FMAC2 soap_instantiate___ns1__muteVideoClientAll(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:12257 */
#ifndef SOAP_TYPE___ns1__getOnetimeAccessUrl
#define SOAP_TYPE___ns1__getOnetimeAccessUrl (560)
/* Wrapper: */
struct __ns1__getOnetimeAccessUrl {
      public:
        /** Optional element 'ns1:OnetimeAccessRequest' of XSD type 'xsd:anyType' */
        char *ns1__OnetimeAccessRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getOnetimeAccessUrl */
        int soap_type() const { return SOAP_TYPE___ns1__getOnetimeAccessUrl; }
        /** Constructor with member initializations */
        __ns1__getOnetimeAccessUrl()
        {
          ns1__OnetimeAccessRequest = (char *)0;
        }
        /** Friend allocator used by soap_new___ns1__getOnetimeAccessUrl(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__getOnetimeAccessUrl * SOAP_FMAC2 soap_instantiate___ns1__getOnetimeAccessUrl(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:12332 */
#ifndef SOAP_TYPE___ns1__getRoomAccessOptions
#define SOAP_TYPE___ns1__getRoomAccessOptions (564)
/* Wrapper: */
struct __ns1__getRoomAccessOptions {
      public:
        /** Optional element 'ns1:RoomAccessOptionsRequest' of XSD type 'ns1:RoomAccessOptionsRequest' */
        _ns1__RoomAccessOptionsRequest *ns1__RoomAccessOptionsRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getRoomAccessOptions */
        int soap_type() const { return SOAP_TYPE___ns1__getRoomAccessOptions; }
        /** Constructor with member initializations */
        __ns1__getRoomAccessOptions()
        {
          ns1__RoomAccessOptionsRequest = (_ns1__RoomAccessOptionsRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__getRoomAccessOptions(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__getRoomAccessOptions * SOAP_FMAC2 soap_instantiate___ns1__getRoomAccessOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:12407 */
#ifndef SOAP_TYPE___ns1__getPortalPrefix
#define SOAP_TYPE___ns1__getPortalPrefix (567)
/* Wrapper: */
struct __ns1__getPortalPrefix {
      public:
        /** Optional element 'ns1:PortalPrefixRequest' of XSD type 'xsd:anyType' */
        char *ns1__PortalPrefixRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getPortalPrefix */
        int soap_type() const { return SOAP_TYPE___ns1__getPortalPrefix; }
        /** Constructor with member initializations */
        __ns1__getPortalPrefix()
        {
          ns1__PortalPrefixRequest = (char *)0;
        }
        /** Friend allocator used by soap_new___ns1__getPortalPrefix(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__getPortalPrefix * SOAP_FMAC2 soap_instantiate___ns1__getPortalPrefix(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:12482 */
#ifndef SOAP_TYPE___ns1__getLoginAndWelcomeBanner
#define SOAP_TYPE___ns1__getLoginAndWelcomeBanner (571)
/* Wrapper: */
struct __ns1__getLoginAndWelcomeBanner {
      public:
        /** Optional element 'ns1:getLoginAndWelcomeBannerRequest' of XSD type 'ns1:getLoginAndWelcomeBannerRequest' */
        _ns1__getLoginAndWelcomeBannerRequest *ns1__getLoginAndWelcomeBannerRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getLoginAndWelcomeBanner */
        int soap_type() const { return SOAP_TYPE___ns1__getLoginAndWelcomeBanner; }
        /** Constructor with member initializations */
        __ns1__getLoginAndWelcomeBanner()
        {
          ns1__getLoginAndWelcomeBannerRequest = (_ns1__getLoginAndWelcomeBannerRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__getLoginAndWelcomeBanner(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__getLoginAndWelcomeBanner * SOAP_FMAC2 soap_instantiate___ns1__getLoginAndWelcomeBanner(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:12554 */
#ifndef SOAP_TYPE___ns1__getUserAccountType
#define SOAP_TYPE___ns1__getUserAccountType (575)
/* Wrapper: */
struct __ns1__getUserAccountType {
      public:
        /** Optional element 'ns1:getUserAccountTypeRequest' of XSD type 'ns1:getUserAccountTypeRequest' */
        _ns1__getUserAccountTypeRequest *ns1__getUserAccountTypeRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getUserAccountType */
        int soap_type() const { return SOAP_TYPE___ns1__getUserAccountType; }
        /** Constructor with member initializations */
        __ns1__getUserAccountType()
        {
          ns1__getUserAccountTypeRequest = (_ns1__getUserAccountTypeRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__getUserAccountType(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__getUserAccountType * SOAP_FMAC2 soap_instantiate___ns1__getUserAccountType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:12632 */
#ifndef SOAP_TYPE___ns1__startLectureMode
#define SOAP_TYPE___ns1__startLectureMode (579)
/* Wrapper: */
struct __ns1__startLectureMode {
      public:
        /** Optional element 'ns1:StartLectureModeRequest' of XSD type 'ns1:StartLectureModeRequest' */
        _ns1__StartLectureModeRequest *ns1__StartLectureModeRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__startLectureMode */
        int soap_type() const { return SOAP_TYPE___ns1__startLectureMode; }
        /** Constructor with member initializations */
        __ns1__startLectureMode()
        {
          ns1__StartLectureModeRequest = (_ns1__StartLectureModeRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__startLectureMode(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__startLectureMode * SOAP_FMAC2 soap_instantiate___ns1__startLectureMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:12710 */
#ifndef SOAP_TYPE___ns1__stopLectureMode
#define SOAP_TYPE___ns1__stopLectureMode (583)
/* Wrapper: */
struct __ns1__stopLectureMode {
      public:
        /** Optional element 'ns1:StopLectureModeRequest' of XSD type 'ns1:StopLectureModeRequest' */
        _ns1__StopLectureModeRequest *ns1__StopLectureModeRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__stopLectureMode */
        int soap_type() const { return SOAP_TYPE___ns1__stopLectureMode; }
        /** Constructor with member initializations */
        __ns1__stopLectureMode()
        {
          ns1__StopLectureModeRequest = (_ns1__StopLectureModeRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__stopLectureMode(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__stopLectureMode * SOAP_FMAC2 soap_instantiate___ns1__stopLectureMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:12785 */
#ifndef SOAP_TYPE___ns1__raiseHand
#define SOAP_TYPE___ns1__raiseHand (586)
/* Wrapper: */
struct __ns1__raiseHand {
      public:
        /** Optional element 'ns1:RaiseHandRequest' of XSD type 'xsd:anyType' */
        char *ns1__RaiseHandRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__raiseHand */
        int soap_type() const { return SOAP_TYPE___ns1__raiseHand; }
        /** Constructor with member initializations */
        __ns1__raiseHand()
        {
          ns1__RaiseHandRequest = (char *)0;
        }
        /** Friend allocator used by soap_new___ns1__raiseHand(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__raiseHand * SOAP_FMAC2 soap_instantiate___ns1__raiseHand(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:12860 */
#ifndef SOAP_TYPE___ns1__unraiseHand
#define SOAP_TYPE___ns1__unraiseHand (589)
/* Wrapper: */
struct __ns1__unraiseHand {
      public:
        /** Optional element 'ns1:UnraiseHandRequest' of XSD type 'xsd:anyType' */
        char *ns1__UnraiseHandRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__unraiseHand */
        int soap_type() const { return SOAP_TYPE___ns1__unraiseHand; }
        /** Constructor with member initializations */
        __ns1__unraiseHand()
        {
          ns1__UnraiseHandRequest = (char *)0;
        }
        /** Friend allocator used by soap_new___ns1__unraiseHand(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__unraiseHand * SOAP_FMAC2 soap_instantiate___ns1__unraiseHand(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:12938 */
#ifndef SOAP_TYPE___ns1__dismissRaisedHand
#define SOAP_TYPE___ns1__dismissRaisedHand (593)
/* Wrapper: */
struct __ns1__dismissRaisedHand {
      public:
        /** Optional element 'ns1:DismissRaisedHandRequest' of XSD type 'ns1:DismissRaisedHandRequest' */
        _ns1__DismissRaisedHandRequest *ns1__DismissRaisedHandRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__dismissRaisedHand */
        int soap_type() const { return SOAP_TYPE___ns1__dismissRaisedHand; }
        /** Constructor with member initializations */
        __ns1__dismissRaisedHand()
        {
          ns1__DismissRaisedHandRequest = (_ns1__DismissRaisedHandRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__dismissRaisedHand(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__dismissRaisedHand * SOAP_FMAC2 soap_instantiate___ns1__dismissRaisedHand(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:13016 */
#ifndef SOAP_TYPE___ns1__dismissAllRaisedHand
#define SOAP_TYPE___ns1__dismissAllRaisedHand (597)
/* Wrapper: */
struct __ns1__dismissAllRaisedHand {
      public:
        /** Optional element 'ns1:DismissAllRaisedHandRequest' of XSD type 'ns1:DismissAllRaisedHandRequest' */
        _ns1__DismissAllRaisedHandRequest *ns1__DismissAllRaisedHandRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__dismissAllRaisedHand */
        int soap_type() const { return SOAP_TYPE___ns1__dismissAllRaisedHand; }
        /** Constructor with member initializations */
        __ns1__dismissAllRaisedHand()
        {
          ns1__DismissAllRaisedHandRequest = (_ns1__DismissAllRaisedHandRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__dismissAllRaisedHand(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__dismissAllRaisedHand * SOAP_FMAC2 soap_instantiate___ns1__dismissAllRaisedHand(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:13094 */
#ifndef SOAP_TYPE___ns1__setPresenter
#define SOAP_TYPE___ns1__setPresenter (601)
/* Wrapper: */
struct __ns1__setPresenter {
      public:
        /** Optional element 'ns1:SetPresenterRequest' of XSD type 'ns1:SetPresenterRequest' */
        _ns1__SetPresenterRequest *ns1__SetPresenterRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__setPresenter */
        int soap_type() const { return SOAP_TYPE___ns1__setPresenter; }
        /** Constructor with member initializations */
        __ns1__setPresenter()
        {
          ns1__SetPresenterRequest = (_ns1__SetPresenterRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__setPresenter(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__setPresenter * SOAP_FMAC2 soap_instantiate___ns1__setPresenter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:13172 */
#ifndef SOAP_TYPE___ns1__removePresenter
#define SOAP_TYPE___ns1__removePresenter (605)
/* Wrapper: */
struct __ns1__removePresenter {
      public:
        /** Optional element 'ns1:RemovePresenterRequest' of XSD type 'ns1:RemovePresenterRequest' */
        _ns1__RemovePresenterRequest *ns1__RemovePresenterRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__removePresenter */
        int soap_type() const { return SOAP_TYPE___ns1__removePresenter; }
        /** Constructor with member initializations */
        __ns1__removePresenter()
        {
          ns1__RemovePresenterRequest = (_ns1__RemovePresenterRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__removePresenter(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__removePresenter * SOAP_FMAC2 soap_instantiate___ns1__removePresenter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:13247 */
#ifndef SOAP_TYPE___ns1__getVidyoReplayLibrary
#define SOAP_TYPE___ns1__getVidyoReplayLibrary (609)
/* Wrapper: */
struct __ns1__getVidyoReplayLibrary {
      public:
        /** Optional element 'ns1:GetVidyoReplayLibraryRequest' of XSD type 'ns1:GetVidyoReplayLibraryRequest' */
        _ns1__GetVidyoReplayLibraryRequest *ns1__GetVidyoReplayLibraryRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getVidyoReplayLibrary */
        int soap_type() const { return SOAP_TYPE___ns1__getVidyoReplayLibrary; }
        /** Constructor with member initializations */
        __ns1__getVidyoReplayLibrary()
        {
          ns1__GetVidyoReplayLibraryRequest = (_ns1__GetVidyoReplayLibraryRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__getVidyoReplayLibrary(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__getVidyoReplayLibrary * SOAP_FMAC2 soap_instantiate___ns1__getVidyoReplayLibrary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:13319 */
#ifndef SOAP_TYPE___ns1__whatIsMyIPAddress
#define SOAP_TYPE___ns1__whatIsMyIPAddress (613)
/* Wrapper: */
struct __ns1__whatIsMyIPAddress {
      public:
        /** Optional element 'ns1:WhatIsMyIPAddressRequest' of XSD type 'ns1:WhatIsMyIPAddressRequest' */
        _ns1__WhatIsMyIPAddressRequest *ns1__WhatIsMyIPAddressRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__whatIsMyIPAddress */
        int soap_type() const { return SOAP_TYPE___ns1__whatIsMyIPAddress; }
        /** Constructor with member initializations */
        __ns1__whatIsMyIPAddress()
        {
          ns1__WhatIsMyIPAddressRequest = (_ns1__WhatIsMyIPAddressRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__whatIsMyIPAddress(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__whatIsMyIPAddress * SOAP_FMAC2 soap_instantiate___ns1__whatIsMyIPAddress(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:13391 */
#ifndef SOAP_TYPE___ns1__getChangePasswordHtmlUrlWithToken
#define SOAP_TYPE___ns1__getChangePasswordHtmlUrlWithToken (617)
/* Wrapper: */
struct __ns1__getChangePasswordHtmlUrlWithToken {
      public:
        /** Optional element 'ns1:GetChangePasswordHtmlUrlWithTokenRequest' of XSD type 'ns1:GetChangePasswordHtmlUrlWithTokenRequest' */
        _ns1__GetChangePasswordHtmlUrlWithTokenRequest *ns1__GetChangePasswordHtmlUrlWithTokenRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getChangePasswordHtmlUrlWithToken */
        int soap_type() const { return SOAP_TYPE___ns1__getChangePasswordHtmlUrlWithToken; }
        /** Constructor with member initializations */
        __ns1__getChangePasswordHtmlUrlWithToken()
        {
          ns1__GetChangePasswordHtmlUrlWithTokenRequest = (_ns1__GetChangePasswordHtmlUrlWithTokenRequest *)0;
        }
        /** Friend allocator used by soap_new___ns1__getChangePasswordHtmlUrlWithToken(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__getChangePasswordHtmlUrlWithToken * SOAP_FMAC2 soap_instantiate___ns1__getChangePasswordHtmlUrlWithToken(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* WSVidyoUser.h:15134 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (618)
/* SOAP_ENV__Header: */
struct SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header()
        {
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Header(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* WSVidyoUser.h:15134 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (619)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XSD type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code()
        {
          SOAP_ENV__Value = (char *)0;
          SOAP_ENV__Subcode = (struct SOAP_ENV__Code *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Code(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* WSVidyoUser.h:15134 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (621)
/* SOAP_ENV__Reason: */
struct SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XSD type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason()
        {
          SOAP_ENV__Text = (char *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Reason(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* WSVidyoUser.h:15134 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (622)
/* SOAP_ENV__Fault: */
struct SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XSD type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XSD type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XSD type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XSD type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XSD type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XSD type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault()
        {
          faultcode = (char *)0;
          faultstring = (char *)0;
          faultactor = (char *)0;
          detail = (struct SOAP_ENV__Detail *)0;
          SOAP_ENV__Code = (struct SOAP_ENV__Code *)0;
          SOAP_ENV__Reason = (struct SOAP_ENV__Reason *)0;
          SOAP_ENV__Node = (char *)0;
          SOAP_ENV__Role = (char *)0;
          SOAP_ENV__Detail = (struct SOAP_ENV__Detail *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Fault(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* WSVidyoUser.h:121 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

/* WSVidyoUser.h:121 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

/* WSVidyoUser.h:131 */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (7)
typedef char *xsd__anyURI;
#endif

/* WSVidyoUser.h:779 */
#ifndef SOAP_TYPE_ns1__EntityID
#define SOAP_TYPE_ns1__EntityID (206)
typedef char *ns1__EntityID;
#endif

/* WSVidyoUser.h:786 */
#ifndef SOAP_TYPE_ns1__PortalFeatureName
#define SOAP_TYPE_ns1__PortalFeatureName (207)
typedef char *ns1__PortalFeatureName;
#endif

/* WSVidyoUser.h:793 */
#ifndef SOAP_TYPE_ns1__EndpointFeatureName
#define SOAP_TYPE_ns1__EndpointFeatureName (208)
typedef char *ns1__EndpointFeatureName;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* time_t has binding name 'dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_dateTime
#define SOAP_TYPE_dateTime (228)
#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_bool
#define SOAP_TYPE_bool (218)
#endif

/* enum _ns1__RoomStatus has binding name '_ns1__RoomStatus' for type 'ns1:RoomStatus' */
#ifndef SOAP_TYPE__ns1__RoomStatus
#define SOAP_TYPE__ns1__RoomStatus (216)
#endif

/* enum _ns1__MemberStatus has binding name '_ns1__MemberStatus' for type 'ns1:MemberStatus' */
#ifndef SOAP_TYPE__ns1__MemberStatus
#define SOAP_TYPE__ns1__MemberStatus (215)
#endif

/* enum _ns1__MemberMode has binding name '_ns1__MemberMode' for type 'ns1:MemberMode' */
#ifndef SOAP_TYPE__ns1__MemberMode
#define SOAP_TYPE__ns1__MemberMode (214)
#endif

/* enum _ns1__EntityType has binding name '_ns1__EntityType' for type 'ns1:EntityType' */
#ifndef SOAP_TYPE__ns1__EntityType
#define SOAP_TYPE__ns1__EntityType (213)
#endif

/* enum _ns1__Language has binding name '_ns1__Language' for type 'ns1:Language' */
#ifndef SOAP_TYPE__ns1__Language
#define SOAP_TYPE__ns1__Language (212)
#endif

/* enum _ns1__OK has binding name '_ns1__OK' for type 'ns1:OK' */
#ifndef SOAP_TYPE__ns1__OK
#define SOAP_TYPE__ns1__OK (211)
#endif

/* enum _ns1__ClientType has binding name '_ns1__ClientType' for type 'ns1:ClientType' */
#ifndef SOAP_TYPE__ns1__ClientType
#define SOAP_TYPE__ns1__ClientType (210)
#endif

/* enum ns1__AccessOptionName has binding name 'ns1__AccessOptionName' for type 'ns1:AccessOptionName' */
#ifndef SOAP_TYPE_ns1__AccessOptionName
#define SOAP_TYPE_ns1__AccessOptionName (209)
#endif

/* enum ns1__sortDir has binding name 'ns1__sortDir' for type 'ns1:sortDir' */
#ifndef SOAP_TYPE_ns1__sortDir
#define SOAP_TYPE_ns1__sortDir (205)
#endif

/* _ns1__GetChangePasswordHtmlUrlWithTokenResponse has binding name '_ns1__GetChangePasswordHtmlUrlWithTokenResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetChangePasswordHtmlUrlWithTokenResponse
#define SOAP_TYPE__ns1__GetChangePasswordHtmlUrlWithTokenResponse (204)
#endif

/* _ns1__GetChangePasswordHtmlUrlWithTokenRequest has binding name '_ns1__GetChangePasswordHtmlUrlWithTokenRequest' for type '' */
#ifndef SOAP_TYPE__ns1__GetChangePasswordHtmlUrlWithTokenRequest
#define SOAP_TYPE__ns1__GetChangePasswordHtmlUrlWithTokenRequest (203)
#endif

/* _ns1__WhatIsMyIPAddressResponse has binding name '_ns1__WhatIsMyIPAddressResponse' for type '' */
#ifndef SOAP_TYPE__ns1__WhatIsMyIPAddressResponse
#define SOAP_TYPE__ns1__WhatIsMyIPAddressResponse (202)
#endif

/* _ns1__WhatIsMyIPAddressRequest has binding name '_ns1__WhatIsMyIPAddressRequest' for type '' */
#ifndef SOAP_TYPE__ns1__WhatIsMyIPAddressRequest
#define SOAP_TYPE__ns1__WhatIsMyIPAddressRequest (201)
#endif

/* _ns1__GetVidyoReplayLibraryResponse has binding name '_ns1__GetVidyoReplayLibraryResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetVidyoReplayLibraryResponse
#define SOAP_TYPE__ns1__GetVidyoReplayLibraryResponse (200)
#endif

/* _ns1__GetVidyoReplayLibraryRequest has binding name '_ns1__GetVidyoReplayLibraryRequest' for type '' */
#ifndef SOAP_TYPE__ns1__GetVidyoReplayLibraryRequest
#define SOAP_TYPE__ns1__GetVidyoReplayLibraryRequest (199)
#endif

/* _ns1__RemovePresenterResponse has binding name '_ns1__RemovePresenterResponse' for type '' */
#ifndef SOAP_TYPE__ns1__RemovePresenterResponse
#define SOAP_TYPE__ns1__RemovePresenterResponse (198)
#endif

/* _ns1__RemovePresenterRequest has binding name '_ns1__RemovePresenterRequest' for type '' */
#ifndef SOAP_TYPE__ns1__RemovePresenterRequest
#define SOAP_TYPE__ns1__RemovePresenterRequest (197)
#endif

/* _ns1__SetPresenterResponse has binding name '_ns1__SetPresenterResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SetPresenterResponse
#define SOAP_TYPE__ns1__SetPresenterResponse (196)
#endif

/* _ns1__SetPresenterRequest has binding name '_ns1__SetPresenterRequest' for type '' */
#ifndef SOAP_TYPE__ns1__SetPresenterRequest
#define SOAP_TYPE__ns1__SetPresenterRequest (195)
#endif

/* _ns1__DismissAllRaisedHandResponse has binding name '_ns1__DismissAllRaisedHandResponse' for type '' */
#ifndef SOAP_TYPE__ns1__DismissAllRaisedHandResponse
#define SOAP_TYPE__ns1__DismissAllRaisedHandResponse (194)
#endif

/* _ns1__DismissAllRaisedHandRequest has binding name '_ns1__DismissAllRaisedHandRequest' for type '' */
#ifndef SOAP_TYPE__ns1__DismissAllRaisedHandRequest
#define SOAP_TYPE__ns1__DismissAllRaisedHandRequest (193)
#endif

/* _ns1__DismissRaisedHandResponse has binding name '_ns1__DismissRaisedHandResponse' for type '' */
#ifndef SOAP_TYPE__ns1__DismissRaisedHandResponse
#define SOAP_TYPE__ns1__DismissRaisedHandResponse (192)
#endif

/* _ns1__DismissRaisedHandRequest has binding name '_ns1__DismissRaisedHandRequest' for type '' */
#ifndef SOAP_TYPE__ns1__DismissRaisedHandRequest
#define SOAP_TYPE__ns1__DismissRaisedHandRequest (191)
#endif

/* _ns1__UnraiseHandResponse has binding name '_ns1__UnraiseHandResponse' for type '' */
#ifndef SOAP_TYPE__ns1__UnraiseHandResponse
#define SOAP_TYPE__ns1__UnraiseHandResponse (190)
#endif

/* _ns1__RaiseHandResponse has binding name '_ns1__RaiseHandResponse' for type '' */
#ifndef SOAP_TYPE__ns1__RaiseHandResponse
#define SOAP_TYPE__ns1__RaiseHandResponse (189)
#endif

/* _ns1__StopLectureModeResponse has binding name '_ns1__StopLectureModeResponse' for type '' */
#ifndef SOAP_TYPE__ns1__StopLectureModeResponse
#define SOAP_TYPE__ns1__StopLectureModeResponse (188)
#endif

/* _ns1__StopLectureModeRequest has binding name '_ns1__StopLectureModeRequest' for type '' */
#ifndef SOAP_TYPE__ns1__StopLectureModeRequest
#define SOAP_TYPE__ns1__StopLectureModeRequest (187)
#endif

/* _ns1__StartLectureModeResponse has binding name '_ns1__StartLectureModeResponse' for type '' */
#ifndef SOAP_TYPE__ns1__StartLectureModeResponse
#define SOAP_TYPE__ns1__StartLectureModeResponse (186)
#endif

/* _ns1__StartLectureModeRequest has binding name '_ns1__StartLectureModeRequest' for type '' */
#ifndef SOAP_TYPE__ns1__StartLectureModeRequest
#define SOAP_TYPE__ns1__StartLectureModeRequest (185)
#endif

/* _ns1__getUserAccountTypeResponse has binding name '_ns1__getUserAccountTypeResponse' for type '' */
#ifndef SOAP_TYPE__ns1__getUserAccountTypeResponse
#define SOAP_TYPE__ns1__getUserAccountTypeResponse (184)
#endif

/* _ns1__getUserAccountTypeRequest has binding name '_ns1__getUserAccountTypeRequest' for type '' */
#ifndef SOAP_TYPE__ns1__getUserAccountTypeRequest
#define SOAP_TYPE__ns1__getUserAccountTypeRequest (183)
#endif

/* _ns1__getLoginAndWelcomeBannerResponse has binding name '_ns1__getLoginAndWelcomeBannerResponse' for type '' */
#ifndef SOAP_TYPE__ns1__getLoginAndWelcomeBannerResponse
#define SOAP_TYPE__ns1__getLoginAndWelcomeBannerResponse (182)
#endif

/* _ns1__getLoginAndWelcomeBannerRequest has binding name '_ns1__getLoginAndWelcomeBannerRequest' for type '' */
#ifndef SOAP_TYPE__ns1__getLoginAndWelcomeBannerRequest
#define SOAP_TYPE__ns1__getLoginAndWelcomeBannerRequest (181)
#endif

/* _ns1__PrefixNotConfiguredFault has binding name '_ns1__PrefixNotConfiguredFault' for type '' */
#ifndef SOAP_TYPE__ns1__PrefixNotConfiguredFault
#define SOAP_TYPE__ns1__PrefixNotConfiguredFault (180)
#endif

/* _ns1__PortalPrefixResponse has binding name '_ns1__PortalPrefixResponse' for type '' */
#ifndef SOAP_TYPE__ns1__PortalPrefixResponse
#define SOAP_TYPE__ns1__PortalPrefixResponse (179)
#endif

/* _ns1__RoomAccessOptionsResponse has binding name '_ns1__RoomAccessOptionsResponse' for type '' */
#ifndef SOAP_TYPE__ns1__RoomAccessOptionsResponse
#define SOAP_TYPE__ns1__RoomAccessOptionsResponse (178)
#endif

/* _ns1__RoomAccessOptionsRequest has binding name '_ns1__RoomAccessOptionsRequest' for type '' */
#ifndef SOAP_TYPE__ns1__RoomAccessOptionsRequest
#define SOAP_TYPE__ns1__RoomAccessOptionsRequest (177)
#endif

/* _ns1__RoomAccessOption has binding name '_ns1__RoomAccessOption' for type '' */
#ifndef SOAP_TYPE__ns1__RoomAccessOption
#define SOAP_TYPE__ns1__RoomAccessOption (176)
#endif

/* _ns1__OnetimeAccessResponse has binding name '_ns1__OnetimeAccessResponse' for type '' */
#ifndef SOAP_TYPE__ns1__OnetimeAccessResponse
#define SOAP_TYPE__ns1__OnetimeAccessResponse (175)
#endif

/* _ns1__muteVideoClientAllResponse has binding name '_ns1__muteVideoClientAllResponse' for type '' */
#ifndef SOAP_TYPE__ns1__muteVideoClientAllResponse
#define SOAP_TYPE__ns1__muteVideoClientAllResponse (174)
#endif

/* _ns1__muteVideoClientAllRequest has binding name '_ns1__muteVideoClientAllRequest' for type '' */
#ifndef SOAP_TYPE__ns1__muteVideoClientAllRequest
#define SOAP_TYPE__ns1__muteVideoClientAllRequest (173)
#endif

/* _ns1__muteVideoServerAllResponse has binding name '_ns1__muteVideoServerAllResponse' for type '' */
#ifndef SOAP_TYPE__ns1__muteVideoServerAllResponse
#define SOAP_TYPE__ns1__muteVideoServerAllResponse (172)
#endif

/* _ns1__muteVideoServerAllRequest has binding name '_ns1__muteVideoServerAllRequest' for type '' */
#ifndef SOAP_TYPE__ns1__muteVideoServerAllRequest
#define SOAP_TYPE__ns1__muteVideoServerAllRequest (171)
#endif

/* _ns1__muteAudioClientAllResponse has binding name '_ns1__muteAudioClientAllResponse' for type '' */
#ifndef SOAP_TYPE__ns1__muteAudioClientAllResponse
#define SOAP_TYPE__ns1__muteAudioClientAllResponse (170)
#endif

/* _ns1__muteAudioClientAllRequest has binding name '_ns1__muteAudioClientAllRequest' for type '' */
#ifndef SOAP_TYPE__ns1__muteAudioClientAllRequest
#define SOAP_TYPE__ns1__muteAudioClientAllRequest (169)
#endif

/* _ns1__muteAudioServerAllResponse has binding name '_ns1__muteAudioServerAllResponse' for type '' */
#ifndef SOAP_TYPE__ns1__muteAudioServerAllResponse
#define SOAP_TYPE__ns1__muteAudioServerAllResponse (168)
#endif

/* _ns1__muteAudioServerAllRequest has binding name '_ns1__muteAudioServerAllRequest' for type '' */
#ifndef SOAP_TYPE__ns1__muteAudioServerAllRequest
#define SOAP_TYPE__ns1__muteAudioServerAllRequest (167)
#endif

/* _ns1__disconnectConferenceAllResponse has binding name '_ns1__disconnectConferenceAllResponse' for type '' */
#ifndef SOAP_TYPE__ns1__disconnectConferenceAllResponse
#define SOAP_TYPE__ns1__disconnectConferenceAllResponse (166)
#endif

/* _ns1__disconnectConferenceAllRequest has binding name '_ns1__disconnectConferenceAllRequest' for type '' */
#ifndef SOAP_TYPE__ns1__disconnectConferenceAllRequest
#define SOAP_TYPE__ns1__disconnectConferenceAllRequest (165)
#endif

/* _ns1__LogoutAllOtherSessionsResponse has binding name '_ns1__LogoutAllOtherSessionsResponse' for type '' */
#ifndef SOAP_TYPE__ns1__LogoutAllOtherSessionsResponse
#define SOAP_TYPE__ns1__LogoutAllOtherSessionsResponse (164)
#endif

/* _ns1__GetActiveSessionsResponse has binding name '_ns1__GetActiveSessionsResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetActiveSessionsResponse
#define SOAP_TYPE__ns1__GetActiveSessionsResponse (163)
#endif

/* _ns1__SetEndpointDetailsResponse has binding name '_ns1__SetEndpointDetailsResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SetEndpointDetailsResponse
#define SOAP_TYPE__ns1__SetEndpointDetailsResponse (162)
#endif

/* _ns1__SetEndpointDetailsRequest has binding name '_ns1__SetEndpointDetailsRequest' for type '' */
#ifndef SOAP_TYPE__ns1__SetEndpointDetailsRequest
#define SOAP_TYPE__ns1__SetEndpointDetailsRequest (161)
#endif

/* _ns1__EndpointFeature has binding name '_ns1__EndpointFeature' for type '' */
#ifndef SOAP_TYPE__ns1__EndpointFeature
#define SOAP_TYPE__ns1__EndpointFeature (160)
#endif

/* _ns1__GetPortalFeaturesResponse has binding name '_ns1__GetPortalFeaturesResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetPortalFeaturesResponse
#define SOAP_TYPE__ns1__GetPortalFeaturesResponse (159)
#endif

/* _ns1__PortalFeature has binding name '_ns1__PortalFeature' for type '' */
#ifndef SOAP_TYPE__ns1__PortalFeature
#define SOAP_TYPE__ns1__PortalFeature (158)
#endif

/* _ns1__DeleteScheduledRoomResponse has binding name '_ns1__DeleteScheduledRoomResponse' for type '' */
#ifndef SOAP_TYPE__ns1__DeleteScheduledRoomResponse
#define SOAP_TYPE__ns1__DeleteScheduledRoomResponse (157)
#endif

/* _ns1__DeleteScheduledRoomRequest has binding name '_ns1__DeleteScheduledRoomRequest' for type '' */
#ifndef SOAP_TYPE__ns1__DeleteScheduledRoomRequest
#define SOAP_TYPE__ns1__DeleteScheduledRoomRequest (156)
#endif

/* _ns1__CreateScheduledRoomResponse has binding name '_ns1__CreateScheduledRoomResponse' for type '' */
#ifndef SOAP_TYPE__ns1__CreateScheduledRoomResponse
#define SOAP_TYPE__ns1__CreateScheduledRoomResponse (155)
#endif

/* _ns1__CreateScheduledRoomRequest has binding name '_ns1__CreateScheduledRoomRequest' for type '' */
#ifndef SOAP_TYPE__ns1__CreateScheduledRoomRequest
#define SOAP_TYPE__ns1__CreateScheduledRoomRequest (154)
#endif

/* _ns1__GenerateAuthTokenResponse has binding name '_ns1__GenerateAuthTokenResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GenerateAuthTokenResponse
#define SOAP_TYPE__ns1__GenerateAuthTokenResponse (153)
#endif

/* _ns1__GenerateAuthTokenRequest has binding name '_ns1__GenerateAuthTokenRequest' for type '' */
#ifndef SOAP_TYPE__ns1__GenerateAuthTokenRequest
#define SOAP_TYPE__ns1__GenerateAuthTokenRequest (152)
#endif

/* _ns1__GetConferenceIDResponse has binding name '_ns1__GetConferenceIDResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetConferenceIDResponse
#define SOAP_TYPE__ns1__GetConferenceIDResponse (151)
#endif

/* _ns1__GetConferenceIDRequest has binding name '_ns1__GetConferenceIDRequest' for type '' */
#ifndef SOAP_TYPE__ns1__GetConferenceIDRequest
#define SOAP_TYPE__ns1__GetConferenceIDRequest (150)
#endif

/* _ns1__RemoveModeratorPINResponse has binding name '_ns1__RemoveModeratorPINResponse' for type '' */
#ifndef SOAP_TYPE__ns1__RemoveModeratorPINResponse
#define SOAP_TYPE__ns1__RemoveModeratorPINResponse (149)
#endif

/* _ns1__RemoveModeratorPINRequest has binding name '_ns1__RemoveModeratorPINRequest' for type '' */
#ifndef SOAP_TYPE__ns1__RemoveModeratorPINRequest
#define SOAP_TYPE__ns1__RemoveModeratorPINRequest (148)
#endif

/* _ns1__CreateModeratorPINResponse has binding name '_ns1__CreateModeratorPINResponse' for type '' */
#ifndef SOAP_TYPE__ns1__CreateModeratorPINResponse
#define SOAP_TYPE__ns1__CreateModeratorPINResponse (147)
#endif

/* _ns1__CreateModeratorPINRequest has binding name '_ns1__CreateModeratorPINRequest' for type '' */
#ifndef SOAP_TYPE__ns1__CreateModeratorPINRequest
#define SOAP_TYPE__ns1__CreateModeratorPINRequest (146)
#endif

/* _ns1__GetModeratorURLWithTokenResponse has binding name '_ns1__GetModeratorURLWithTokenResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetModeratorURLWithTokenResponse
#define SOAP_TYPE__ns1__GetModeratorURLWithTokenResponse (145)
#endif

/* _ns1__GetModeratorURLWithTokenRequest has binding name '_ns1__GetModeratorURLWithTokenRequest' for type '' */
#ifndef SOAP_TYPE__ns1__GetModeratorURLWithTokenRequest
#define SOAP_TYPE__ns1__GetModeratorURLWithTokenRequest (144)
#endif

/* _ns1__GetModeratorURLResponse has binding name '_ns1__GetModeratorURLResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetModeratorURLResponse
#define SOAP_TYPE__ns1__GetModeratorURLResponse (143)
#endif

/* _ns1__GetModeratorURLRequest has binding name '_ns1__GetModeratorURLRequest' for type '' */
#ifndef SOAP_TYPE__ns1__GetModeratorURLRequest
#define SOAP_TYPE__ns1__GetModeratorURLRequest (142)
#endif

/* _ns1__RemoveModeratorURLResponse has binding name '_ns1__RemoveModeratorURLResponse' for type '' */
#ifndef SOAP_TYPE__ns1__RemoveModeratorURLResponse
#define SOAP_TYPE__ns1__RemoveModeratorURLResponse (141)
#endif

/* _ns1__RemoveModeratorURLRequest has binding name '_ns1__RemoveModeratorURLRequest' for type '' */
#ifndef SOAP_TYPE__ns1__RemoveModeratorURLRequest
#define SOAP_TYPE__ns1__RemoveModeratorURLRequest (140)
#endif

/* _ns1__CreateModeratorURLResponse has binding name '_ns1__CreateModeratorURLResponse' for type '' */
#ifndef SOAP_TYPE__ns1__CreateModeratorURLResponse
#define SOAP_TYPE__ns1__CreateModeratorURLResponse (139)
#endif

/* _ns1__CreateModeratorURLRequest has binding name '_ns1__CreateModeratorURLRequest' for type '' */
#ifndef SOAP_TYPE__ns1__CreateModeratorURLRequest
#define SOAP_TYPE__ns1__CreateModeratorURLRequest (138)
#endif

/* _ns1__RemoveRoomProfileResponse has binding name '_ns1__RemoveRoomProfileResponse' for type '' */
#ifndef SOAP_TYPE__ns1__RemoveRoomProfileResponse
#define SOAP_TYPE__ns1__RemoveRoomProfileResponse (137)
#endif

/* _ns1__RemoveRoomProfileRequest has binding name '_ns1__RemoveRoomProfileRequest' for type '' */
#ifndef SOAP_TYPE__ns1__RemoveRoomProfileRequest
#define SOAP_TYPE__ns1__RemoveRoomProfileRequest (136)
#endif

/* _ns1__SetRoomProfileResponse has binding name '_ns1__SetRoomProfileResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SetRoomProfileResponse
#define SOAP_TYPE__ns1__SetRoomProfileResponse (135)
#endif

/* _ns1__SetRoomProfileRequest has binding name '_ns1__SetRoomProfileRequest' for type '' */
#ifndef SOAP_TYPE__ns1__SetRoomProfileRequest
#define SOAP_TYPE__ns1__SetRoomProfileRequest (134)
#endif

/* _ns1__GetRoomProfileResponse has binding name '_ns1__GetRoomProfileResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetRoomProfileResponse
#define SOAP_TYPE__ns1__GetRoomProfileResponse (133)
#endif

/* _ns1__GetRoomProfileRequest has binding name '_ns1__GetRoomProfileRequest' for type '' */
#ifndef SOAP_TYPE__ns1__GetRoomProfileRequest
#define SOAP_TYPE__ns1__GetRoomProfileRequest (132)
#endif

/* _ns1__GetRoomProfilesResponse has binding name '_ns1__GetRoomProfilesResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetRoomProfilesResponse
#define SOAP_TYPE__ns1__GetRoomProfilesResponse (131)
#endif

/* _ns1__GetInviteContentResponse has binding name '_ns1__GetInviteContentResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetInviteContentResponse
#define SOAP_TYPE__ns1__GetInviteContentResponse (130)
#endif

/* _ns1__GetInviteContentRequest has binding name '_ns1__GetInviteContentRequest' for type '' */
#ifndef SOAP_TYPE__ns1__GetInviteContentRequest
#define SOAP_TYPE__ns1__GetInviteContentRequest (129)
#endif

/* _ns1__GetEntityByRoomKeyResponse has binding name '_ns1__GetEntityByRoomKeyResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetEntityByRoomKeyResponse
#define SOAP_TYPE__ns1__GetEntityByRoomKeyResponse (128)
#endif

/* _ns1__GetEntityByRoomKeyRequest has binding name '_ns1__GetEntityByRoomKeyRequest' for type '' */
#ifndef SOAP_TYPE__ns1__GetEntityByRoomKeyRequest
#define SOAP_TYPE__ns1__GetEntityByRoomKeyRequest (127)
#endif

/* _ns1__GetUserNameResponse has binding name '_ns1__GetUserNameResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetUserNameResponse
#define SOAP_TYPE__ns1__GetUserNameResponse (126)
#endif

/* _ns1__GetUserNameRequest has binding name '_ns1__GetUserNameRequest' for type '' */
#ifndef SOAP_TYPE__ns1__GetUserNameRequest
#define SOAP_TYPE__ns1__GetUserNameRequest (125)
#endif

/* _ns1__GetWebcastURLResponse has binding name '_ns1__GetWebcastURLResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetWebcastURLResponse
#define SOAP_TYPE__ns1__GetWebcastURLResponse (124)
#endif

/* _ns1__GetWebcastURLRequest has binding name '_ns1__GetWebcastURLRequest' for type '' */
#ifndef SOAP_TYPE__ns1__GetWebcastURLRequest
#define SOAP_TYPE__ns1__GetWebcastURLRequest (123)
#endif

/* _ns1__RemoveWebcastPINResponse has binding name '_ns1__RemoveWebcastPINResponse' for type '' */
#ifndef SOAP_TYPE__ns1__RemoveWebcastPINResponse
#define SOAP_TYPE__ns1__RemoveWebcastPINResponse (122)
#endif

/* _ns1__RemoveWebcastPINRequest has binding name '_ns1__RemoveWebcastPINRequest' for type '' */
#ifndef SOAP_TYPE__ns1__RemoveWebcastPINRequest
#define SOAP_TYPE__ns1__RemoveWebcastPINRequest (121)
#endif

/* _ns1__RemoveWebcastURLResponse has binding name '_ns1__RemoveWebcastURLResponse' for type '' */
#ifndef SOAP_TYPE__ns1__RemoveWebcastURLResponse
#define SOAP_TYPE__ns1__RemoveWebcastURLResponse (120)
#endif

/* _ns1__RemoveWebcastURLRequest has binding name '_ns1__RemoveWebcastURLRequest' for type '' */
#ifndef SOAP_TYPE__ns1__RemoveWebcastURLRequest
#define SOAP_TYPE__ns1__RemoveWebcastURLRequest (119)
#endif

/* _ns1__CreateWebcastPINResponse has binding name '_ns1__CreateWebcastPINResponse' for type '' */
#ifndef SOAP_TYPE__ns1__CreateWebcastPINResponse
#define SOAP_TYPE__ns1__CreateWebcastPINResponse (118)
#endif

/* _ns1__CreateWebcastPINRequest has binding name '_ns1__CreateWebcastPINRequest' for type '' */
#ifndef SOAP_TYPE__ns1__CreateWebcastPINRequest
#define SOAP_TYPE__ns1__CreateWebcastPINRequest (117)
#endif

/* _ns1__CreateWebcastURLResponse has binding name '_ns1__CreateWebcastURLResponse' for type '' */
#ifndef SOAP_TYPE__ns1__CreateWebcastURLResponse
#define SOAP_TYPE__ns1__CreateWebcastURLResponse (116)
#endif

/* _ns1__CreateWebcastURLRequest has binding name '_ns1__CreateWebcastURLRequest' for type '' */
#ifndef SOAP_TYPE__ns1__CreateWebcastURLRequest
#define SOAP_TYPE__ns1__CreateWebcastURLRequest (115)
#endif

/* _ns1__StopRecordingResponse has binding name '_ns1__StopRecordingResponse' for type '' */
#ifndef SOAP_TYPE__ns1__StopRecordingResponse
#define SOAP_TYPE__ns1__StopRecordingResponse (114)
#endif

/* _ns1__StopRecordingRequest has binding name '_ns1__StopRecordingRequest' for type '' */
#ifndef SOAP_TYPE__ns1__StopRecordingRequest
#define SOAP_TYPE__ns1__StopRecordingRequest (113)
#endif

/* _ns1__ResumeRecordingResponse has binding name '_ns1__ResumeRecordingResponse' for type '' */
#ifndef SOAP_TYPE__ns1__ResumeRecordingResponse
#define SOAP_TYPE__ns1__ResumeRecordingResponse (112)
#endif

/* _ns1__ResumeRecordingRequest has binding name '_ns1__ResumeRecordingRequest' for type '' */
#ifndef SOAP_TYPE__ns1__ResumeRecordingRequest
#define SOAP_TYPE__ns1__ResumeRecordingRequest (111)
#endif

/* _ns1__PauseRecordingResponse has binding name '_ns1__PauseRecordingResponse' for type '' */
#ifndef SOAP_TYPE__ns1__PauseRecordingResponse
#define SOAP_TYPE__ns1__PauseRecordingResponse (110)
#endif

/* _ns1__PauseRecordingRequest has binding name '_ns1__PauseRecordingRequest' for type '' */
#ifndef SOAP_TYPE__ns1__PauseRecordingRequest
#define SOAP_TYPE__ns1__PauseRecordingRequest (109)
#endif

/* _ns1__GetPortalVersionResponse has binding name '_ns1__GetPortalVersionResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetPortalVersionResponse
#define SOAP_TYPE__ns1__GetPortalVersionResponse (108)
#endif

/* _ns1__GetPortalVersionRequest has binding name '_ns1__GetPortalVersionRequest' for type '' */
#ifndef SOAP_TYPE__ns1__GetPortalVersionRequest
#define SOAP_TYPE__ns1__GetPortalVersionRequest (107)
#endif

/* _ns1__StartRecordingResponse has binding name '_ns1__StartRecordingResponse' for type '' */
#ifndef SOAP_TYPE__ns1__StartRecordingResponse
#define SOAP_TYPE__ns1__StartRecordingResponse (106)
#endif

/* _ns1__StartRecordingRequest has binding name '_ns1__StartRecordingRequest' for type '' */
#ifndef SOAP_TYPE__ns1__StartRecordingRequest
#define SOAP_TYPE__ns1__StartRecordingRequest (105)
#endif

/* _ns1__GetRecordingProfilesResponse has binding name '_ns1__GetRecordingProfilesResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetRecordingProfilesResponse
#define SOAP_TYPE__ns1__GetRecordingProfilesResponse (104)
#endif

/* _ns1__GetRecordingProfilesRequest has binding name '_ns1__GetRecordingProfilesRequest' for type '' */
#ifndef SOAP_TYPE__ns1__GetRecordingProfilesRequest
#define SOAP_TYPE__ns1__GetRecordingProfilesRequest (103)
#endif

/* _ns1__SetMemberModeResponse has binding name '_ns1__SetMemberModeResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SetMemberModeResponse
#define SOAP_TYPE__ns1__SetMemberModeResponse (102)
#endif

/* _ns1__SetMemberModeRequest has binding name '_ns1__SetMemberModeRequest' for type '' */
#ifndef SOAP_TYPE__ns1__SetMemberModeRequest
#define SOAP_TYPE__ns1__SetMemberModeRequest (101)
#endif

/* _ns1__UnlockRoomResponse has binding name '_ns1__UnlockRoomResponse' for type '' */
#ifndef SOAP_TYPE__ns1__UnlockRoomResponse
#define SOAP_TYPE__ns1__UnlockRoomResponse (100)
#endif

/* _ns1__UnlockRoomRequest has binding name '_ns1__UnlockRoomRequest' for type '' */
#ifndef SOAP_TYPE__ns1__UnlockRoomRequest
#define SOAP_TYPE__ns1__UnlockRoomRequest (99)
#endif

/* _ns1__LockRoomResponse has binding name '_ns1__LockRoomResponse' for type '' */
#ifndef SOAP_TYPE__ns1__LockRoomResponse
#define SOAP_TYPE__ns1__LockRoomResponse (98)
#endif

/* _ns1__LockRoomRequest has binding name '_ns1__LockRoomRequest' for type '' */
#ifndef SOAP_TYPE__ns1__LockRoomRequest
#define SOAP_TYPE__ns1__LockRoomRequest (97)
#endif

/* _ns1__UpdateLanguageResponse has binding name '_ns1__UpdateLanguageResponse' for type '' */
#ifndef SOAP_TYPE__ns1__UpdateLanguageResponse
#define SOAP_TYPE__ns1__UpdateLanguageResponse (96)
#endif

/* _ns1__UpdateLanguageRequest has binding name '_ns1__UpdateLanguageRequest' for type '' */
#ifndef SOAP_TYPE__ns1__UpdateLanguageRequest
#define SOAP_TYPE__ns1__UpdateLanguageRequest (95)
#endif

/* _ns1__UpdatePasswordResponse has binding name '_ns1__UpdatePasswordResponse' for type '' */
#ifndef SOAP_TYPE__ns1__UpdatePasswordResponse
#define SOAP_TYPE__ns1__UpdatePasswordResponse (94)
#endif

/* _ns1__UpdatePasswordRequest has binding name '_ns1__UpdatePasswordRequest' for type '' */
#ifndef SOAP_TYPE__ns1__UpdatePasswordRequest
#define SOAP_TYPE__ns1__UpdatePasswordRequest (93)
#endif

/* _ns1__RemoveRoomPINResponse has binding name '_ns1__RemoveRoomPINResponse' for type '' */
#ifndef SOAP_TYPE__ns1__RemoveRoomPINResponse
#define SOAP_TYPE__ns1__RemoveRoomPINResponse (92)
#endif

/* _ns1__RemoveRoomPINRequest has binding name '_ns1__RemoveRoomPINRequest' for type '' */
#ifndef SOAP_TYPE__ns1__RemoveRoomPINRequest
#define SOAP_TYPE__ns1__RemoveRoomPINRequest (91)
#endif

/* _ns1__CreateRoomPINResponse has binding name '_ns1__CreateRoomPINResponse' for type '' */
#ifndef SOAP_TYPE__ns1__CreateRoomPINResponse
#define SOAP_TYPE__ns1__CreateRoomPINResponse (90)
#endif

/* _ns1__CreateRoomPINRequest has binding name '_ns1__CreateRoomPINRequest' for type '' */
#ifndef SOAP_TYPE__ns1__CreateRoomPINRequest
#define SOAP_TYPE__ns1__CreateRoomPINRequest (89)
#endif

/* _ns1__RemoveRoomURLResponse has binding name '_ns1__RemoveRoomURLResponse' for type '' */
#ifndef SOAP_TYPE__ns1__RemoveRoomURLResponse
#define SOAP_TYPE__ns1__RemoveRoomURLResponse (88)
#endif

/* _ns1__RemoveRoomURLRequest has binding name '_ns1__RemoveRoomURLRequest' for type '' */
#ifndef SOAP_TYPE__ns1__RemoveRoomURLRequest
#define SOAP_TYPE__ns1__RemoveRoomURLRequest (87)
#endif

/* _ns1__CreateRoomURLResponse has binding name '_ns1__CreateRoomURLResponse' for type '' */
#ifndef SOAP_TYPE__ns1__CreateRoomURLResponse
#define SOAP_TYPE__ns1__CreateRoomURLResponse (86)
#endif

/* _ns1__CreateRoomURLRequest has binding name '_ns1__CreateRoomURLRequest' for type '' */
#ifndef SOAP_TYPE__ns1__CreateRoomURLRequest
#define SOAP_TYPE__ns1__CreateRoomURLRequest (85)
#endif

/* _ns1__DeleteRoomResponse has binding name '_ns1__DeleteRoomResponse' for type '' */
#ifndef SOAP_TYPE__ns1__DeleteRoomResponse
#define SOAP_TYPE__ns1__DeleteRoomResponse (84)
#endif

/* _ns1__DeleteRoomRequest has binding name '_ns1__DeleteRoomRequest' for type '' */
#ifndef SOAP_TYPE__ns1__DeleteRoomRequest
#define SOAP_TYPE__ns1__DeleteRoomRequest (83)
#endif

/* _ns1__CreateRoomResponse has binding name '_ns1__CreateRoomResponse' for type '' */
#ifndef SOAP_TYPE__ns1__CreateRoomResponse
#define SOAP_TYPE__ns1__CreateRoomResponse (82)
#endif

/* _ns1__CreateRoomRequest has binding name '_ns1__CreateRoomRequest' for type '' */
#ifndef SOAP_TYPE__ns1__CreateRoomRequest
#define SOAP_TYPE__ns1__CreateRoomRequest (81)
#endif

/* _ns1__MyAccountResponse has binding name '_ns1__MyAccountResponse' for type '' */
#ifndef SOAP_TYPE__ns1__MyAccountResponse
#define SOAP_TYPE__ns1__MyAccountResponse (80)
#endif

/* _ns1__MyAccountRequest has binding name '_ns1__MyAccountRequest' for type '' */
#ifndef SOAP_TYPE__ns1__MyAccountRequest
#define SOAP_TYPE__ns1__MyAccountRequest (79)
#endif

/* _ns1__StopVideoResponse has binding name '_ns1__StopVideoResponse' for type '' */
#ifndef SOAP_TYPE__ns1__StopVideoResponse
#define SOAP_TYPE__ns1__StopVideoResponse (78)
#endif

/* _ns1__StopVideoRequest has binding name '_ns1__StopVideoRequest' for type '' */
#ifndef SOAP_TYPE__ns1__StopVideoRequest
#define SOAP_TYPE__ns1__StopVideoRequest (77)
#endif

/* _ns1__StartVideoResponse has binding name '_ns1__StartVideoResponse' for type '' */
#ifndef SOAP_TYPE__ns1__StartVideoResponse
#define SOAP_TYPE__ns1__StartVideoResponse (76)
#endif

/* _ns1__StartVideoRequest has binding name '_ns1__StartVideoRequest' for type '' */
#ifndef SOAP_TYPE__ns1__StartVideoRequest
#define SOAP_TYPE__ns1__StartVideoRequest (75)
#endif

/* _ns1__UnmuteAudioResponse has binding name '_ns1__UnmuteAudioResponse' for type '' */
#ifndef SOAP_TYPE__ns1__UnmuteAudioResponse
#define SOAP_TYPE__ns1__UnmuteAudioResponse (74)
#endif

/* _ns1__UnmuteAudioRequest has binding name '_ns1__UnmuteAudioRequest' for type '' */
#ifndef SOAP_TYPE__ns1__UnmuteAudioRequest
#define SOAP_TYPE__ns1__UnmuteAudioRequest (73)
#endif

/* _ns1__MuteAudioResponse has binding name '_ns1__MuteAudioResponse' for type '' */
#ifndef SOAP_TYPE__ns1__MuteAudioResponse
#define SOAP_TYPE__ns1__MuteAudioResponse (72)
#endif

/* _ns1__MuteAudioRequest has binding name '_ns1__MuteAudioRequest' for type '' */
#ifndef SOAP_TYPE__ns1__MuteAudioRequest
#define SOAP_TYPE__ns1__MuteAudioRequest (71)
#endif

/* _ns1__LeaveConferenceResponse has binding name '_ns1__LeaveConferenceResponse' for type '' */
#ifndef SOAP_TYPE__ns1__LeaveConferenceResponse
#define SOAP_TYPE__ns1__LeaveConferenceResponse (70)
#endif

/* _ns1__LeaveConferenceRequest has binding name '_ns1__LeaveConferenceRequest' for type '' */
#ifndef SOAP_TYPE__ns1__LeaveConferenceRequest
#define SOAP_TYPE__ns1__LeaveConferenceRequest (69)
#endif

/* _ns1__GetLectureModeParticipantsResponse has binding name '_ns1__GetLectureModeParticipantsResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetLectureModeParticipantsResponse
#define SOAP_TYPE__ns1__GetLectureModeParticipantsResponse (68)
#endif

/* _ns1__GetLectureModeParticipantsRequest has binding name '_ns1__GetLectureModeParticipantsRequest' for type '' */
#ifndef SOAP_TYPE__ns1__GetLectureModeParticipantsRequest
#define SOAP_TYPE__ns1__GetLectureModeParticipantsRequest (67)
#endif

/* _ns1__GetParticipantsResponse has binding name '_ns1__GetParticipantsResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetParticipantsResponse
#define SOAP_TYPE__ns1__GetParticipantsResponse (66)
#endif

/* _ns1__GetParticipantsRequest has binding name '_ns1__GetParticipantsRequest' for type '' */
#ifndef SOAP_TYPE__ns1__GetParticipantsRequest
#define SOAP_TYPE__ns1__GetParticipantsRequest (65)
#endif

/* _ns1__DirectCallResponse has binding name '_ns1__DirectCallResponse' for type '' */
#ifndef SOAP_TYPE__ns1__DirectCallResponse
#define SOAP_TYPE__ns1__DirectCallResponse (64)
#endif

/* _ns1__DirectCallRequest has binding name '_ns1__DirectCallRequest' for type '' */
#ifndef SOAP_TYPE__ns1__DirectCallRequest
#define SOAP_TYPE__ns1__DirectCallRequest (63)
#endif

/* _ns1__JoinIPCConferenceResponse has binding name '_ns1__JoinIPCConferenceResponse' for type '' */
#ifndef SOAP_TYPE__ns1__JoinIPCConferenceResponse
#define SOAP_TYPE__ns1__JoinIPCConferenceResponse (62)
#endif

/* _ns1__JoinIPCConferenceRequest has binding name '_ns1__JoinIPCConferenceRequest' for type '' */
#ifndef SOAP_TYPE__ns1__JoinIPCConferenceRequest
#define SOAP_TYPE__ns1__JoinIPCConferenceRequest (61)
#endif

/* _ns1__JoinConferenceResponse has binding name '_ns1__JoinConferenceResponse' for type '' */
#ifndef SOAP_TYPE__ns1__JoinConferenceResponse
#define SOAP_TYPE__ns1__JoinConferenceResponse (60)
#endif

/* _ns1__JoinConferenceRequest has binding name '_ns1__JoinConferenceRequest' for type '' */
#ifndef SOAP_TYPE__ns1__JoinConferenceRequest
#define SOAP_TYPE__ns1__JoinConferenceRequest (59)
#endif

/* _ns1__CancelOutboundCallResponse has binding name '_ns1__CancelOutboundCallResponse' for type '' */
#ifndef SOAP_TYPE__ns1__CancelOutboundCallResponse
#define SOAP_TYPE__ns1__CancelOutboundCallResponse (58)
#endif

/* _ns1__CancelOutboundCallRequest has binding name '_ns1__CancelOutboundCallRequest' for type '' */
#ifndef SOAP_TYPE__ns1__CancelOutboundCallRequest
#define SOAP_TYPE__ns1__CancelOutboundCallRequest (57)
#endif

/* _ns1__InviteToConferenceResponse has binding name '_ns1__InviteToConferenceResponse' for type '' */
#ifndef SOAP_TYPE__ns1__InviteToConferenceResponse
#define SOAP_TYPE__ns1__InviteToConferenceResponse (56)
#endif

/* _ns1__InviteToConferenceRequest has binding name '_ns1__InviteToConferenceRequest' for type '' */
#ifndef SOAP_TYPE__ns1__InviteToConferenceRequest
#define SOAP_TYPE__ns1__InviteToConferenceRequest (55)
#endif

/* _ns1__GetEntityByEntityIDResponse has binding name '_ns1__GetEntityByEntityIDResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetEntityByEntityIDResponse
#define SOAP_TYPE__ns1__GetEntityByEntityIDResponse (54)
#endif

/* _ns1__GetEntityByEntityIDRequest has binding name '_ns1__GetEntityByEntityIDRequest' for type '' */
#ifndef SOAP_TYPE__ns1__GetEntityByEntityIDRequest
#define SOAP_TYPE__ns1__GetEntityByEntityIDRequest (53)
#endif

/* _ns1__SearchByEmailResponse has binding name '_ns1__SearchByEmailResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SearchByEmailResponse
#define SOAP_TYPE__ns1__SearchByEmailResponse (52)
#endif

/* _ns1__SearchByEmailRequest has binding name '_ns1__SearchByEmailRequest' for type '' */
#ifndef SOAP_TYPE__ns1__SearchByEmailRequest
#define SOAP_TYPE__ns1__SearchByEmailRequest (51)
#endif

/* _ns1__SearchByEntityIDResponse has binding name '_ns1__SearchByEntityIDResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SearchByEntityIDResponse
#define SOAP_TYPE__ns1__SearchByEntityIDResponse (50)
#endif

/* _ns1__SearchByEntityIDRequest has binding name '_ns1__SearchByEntityIDRequest' for type '' */
#ifndef SOAP_TYPE__ns1__SearchByEntityIDRequest
#define SOAP_TYPE__ns1__SearchByEntityIDRequest (49)
#endif

/* _ns1__SearchResponse has binding name '_ns1__SearchResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SearchResponse
#define SOAP_TYPE__ns1__SearchResponse (48)
#endif

/* _ns1__SearchRequest has binding name '_ns1__SearchRequest' for type '' */
#ifndef SOAP_TYPE__ns1__SearchRequest
#define SOAP_TYPE__ns1__SearchRequest (47)
#endif

/* _ns1__RemoveFromMyContactsResponse has binding name '_ns1__RemoveFromMyContactsResponse' for type '' */
#ifndef SOAP_TYPE__ns1__RemoveFromMyContactsResponse
#define SOAP_TYPE__ns1__RemoveFromMyContactsResponse (46)
#endif

/* _ns1__RemoveFromMyContactsRequest has binding name '_ns1__RemoveFromMyContactsRequest' for type '' */
#ifndef SOAP_TYPE__ns1__RemoveFromMyContactsRequest
#define SOAP_TYPE__ns1__RemoveFromMyContactsRequest (45)
#endif

/* _ns1__AddToMyContactsResponse has binding name '_ns1__AddToMyContactsResponse' for type '' */
#ifndef SOAP_TYPE__ns1__AddToMyContactsResponse
#define SOAP_TYPE__ns1__AddToMyContactsResponse (44)
#endif

/* _ns1__AddToMyContactsRequest has binding name '_ns1__AddToMyContactsRequest' for type '' */
#ifndef SOAP_TYPE__ns1__AddToMyContactsRequest
#define SOAP_TYPE__ns1__AddToMyContactsRequest (43)
#endif

/* _ns1__SearchMyContactsResponse has binding name '_ns1__SearchMyContactsResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SearchMyContactsResponse
#define SOAP_TYPE__ns1__SearchMyContactsResponse (42)
#endif

/* _ns1__SearchMyContactsRequest has binding name '_ns1__SearchMyContactsRequest' for type '' */
#ifndef SOAP_TYPE__ns1__SearchMyContactsRequest
#define SOAP_TYPE__ns1__SearchMyContactsRequest (41)
#endif

/* _ns1__MyEndpointStatusResponse has binding name '_ns1__MyEndpointStatusResponse' for type '' */
#ifndef SOAP_TYPE__ns1__MyEndpointStatusResponse
#define SOAP_TYPE__ns1__MyEndpointStatusResponse (40)
#endif

/* _ns1__MyEndpointStatusRequest has binding name '_ns1__MyEndpointStatusRequest' for type '' */
#ifndef SOAP_TYPE__ns1__MyEndpointStatusRequest
#define SOAP_TYPE__ns1__MyEndpointStatusRequest (39)
#endif

/* _ns1__LogOutResponse has binding name '_ns1__LogOutResponse' for type '' */
#ifndef SOAP_TYPE__ns1__LogOutResponse
#define SOAP_TYPE__ns1__LogOutResponse (38)
#endif

/* _ns1__LogOutRequest has binding name '_ns1__LogOutRequest' for type '' */
#ifndef SOAP_TYPE__ns1__LogOutRequest
#define SOAP_TYPE__ns1__LogOutRequest (37)
#endif

/* _ns1__LinkEndpointResponse has binding name '_ns1__LinkEndpointResponse' for type '' */
#ifndef SOAP_TYPE__ns1__LinkEndpointResponse
#define SOAP_TYPE__ns1__LinkEndpointResponse (36)
#endif

/* _ns1__LinkEndpointRequest has binding name '_ns1__LinkEndpointRequest' for type '' */
#ifndef SOAP_TYPE__ns1__LinkEndpointRequest
#define SOAP_TYPE__ns1__LinkEndpointRequest (35)
#endif

/* _ns1__LogInResponse has binding name '_ns1__LogInResponse' for type '' */
#ifndef SOAP_TYPE__ns1__LogInResponse
#define SOAP_TYPE__ns1__LogInResponse (34)
#endif

/* _ns1__LogInRequest has binding name '_ns1__LogInRequest' for type '' */
#ifndef SOAP_TYPE__ns1__LogInRequest
#define SOAP_TYPE__ns1__LogInRequest (33)
#endif

/* _ns1__WelcomeBannerContent has binding name '_ns1__WelcomeBannerContent' for type '' */
#ifndef SOAP_TYPE__ns1__WelcomeBannerContent
#define SOAP_TYPE__ns1__WelcomeBannerContent (32)
#endif

/* _ns1__LoginAttempt has binding name '_ns1__LoginAttempt' for type '' */
#ifndef SOAP_TYPE__ns1__LoginAttempt
#define SOAP_TYPE__ns1__LoginAttempt (31)
#endif

/* _ns1__LectureModeParticipant has binding name '_ns1__LectureModeParticipant' for type '' */
#ifndef SOAP_TYPE__ns1__LectureModeParticipant
#define SOAP_TYPE__ns1__LectureModeParticipant (30)
#endif

/* _ns1__Entity has binding name '_ns1__Entity' for type '' */
#ifndef SOAP_TYPE__ns1__Entity
#define SOAP_TYPE__ns1__Entity (29)
#endif

/* _ns1__Filter has binding name '_ns1__Filter' for type '' */
#ifndef SOAP_TYPE__ns1__Filter
#define SOAP_TYPE__ns1__Filter (28)
#endif

/* _ns1__RoomMode has binding name '_ns1__RoomMode' for type '' */
#ifndef SOAP_TYPE__ns1__RoomMode
#define SOAP_TYPE__ns1__RoomMode (27)
#endif

/* _ns1__RoomNotFoundFault has binding name '_ns1__RoomNotFoundFault' for type '' */
#ifndef SOAP_TYPE__ns1__RoomNotFoundFault
#define SOAP_TYPE__ns1__RoomNotFoundFault (26)
#endif

/* _ns1__VidyoReplayNotAvailableFault has binding name '_ns1__VidyoReplayNotAvailableFault' for type '' */
#ifndef SOAP_TYPE__ns1__VidyoReplayNotAvailableFault
#define SOAP_TYPE__ns1__VidyoReplayNotAvailableFault (25)
#endif

/* _ns1__FeatureNotAvailableFault has binding name '_ns1__FeatureNotAvailableFault' for type '' */
#ifndef SOAP_TYPE__ns1__FeatureNotAvailableFault
#define SOAP_TYPE__ns1__FeatureNotAvailableFault (24)
#endif

/* _ns1__PrefixNotConfiguredException has binding name '_ns1__PrefixNotConfiguredException' for type '' */
#ifndef SOAP_TYPE__ns1__PrefixNotConfiguredException
#define SOAP_TYPE__ns1__PrefixNotConfiguredException (23)
#endif

/* _ns1__InPointToPointCallFault has binding name '_ns1__InPointToPointCallFault' for type '' */
#ifndef SOAP_TYPE__ns1__InPointToPointCallFault
#define SOAP_TYPE__ns1__InPointToPointCallFault (22)
#endif

/* _ns1__EndpointNotBoundFault has binding name '_ns1__EndpointNotBoundFault' for type '' */
#ifndef SOAP_TYPE__ns1__EndpointNotBoundFault
#define SOAP_TYPE__ns1__EndpointNotBoundFault (21)
#endif

/* _ns1__ScheduledRoomCreationFault has binding name '_ns1__ScheduledRoomCreationFault' for type '' */
#ifndef SOAP_TYPE__ns1__ScheduledRoomCreationFault
#define SOAP_TYPE__ns1__ScheduledRoomCreationFault (20)
#endif

/* _ns1__ControlMeetingFault has binding name '_ns1__ControlMeetingFault' for type '' */
#ifndef SOAP_TYPE__ns1__ControlMeetingFault
#define SOAP_TYPE__ns1__ControlMeetingFault (19)
#endif

/* _ns1__InvalidModeratorPINFormatFault has binding name '_ns1__InvalidModeratorPINFormatFault' for type '' */
#ifndef SOAP_TYPE__ns1__InvalidModeratorPINFormatFault
#define SOAP_TYPE__ns1__InvalidModeratorPINFormatFault (18)
#endif

/* _ns1__AccessRestrictedFault has binding name '_ns1__AccessRestrictedFault' for type '' */
#ifndef SOAP_TYPE__ns1__AccessRestrictedFault
#define SOAP_TYPE__ns1__AccessRestrictedFault (17)
#endif

/* _ns1__ResourceNotAvailableFault has binding name '_ns1__ResourceNotAvailableFault' for type '' */
#ifndef SOAP_TYPE__ns1__ResourceNotAvailableFault
#define SOAP_TYPE__ns1__ResourceNotAvailableFault (16)
#endif

/* _ns1__NotLicensedFault has binding name '_ns1__NotLicensedFault' for type '' */
#ifndef SOAP_TYPE__ns1__NotLicensedFault
#define SOAP_TYPE__ns1__NotLicensedFault (15)
#endif

/* _ns1__ConferenceLockedFault has binding name '_ns1__ConferenceLockedFault' for type '' */
#ifndef SOAP_TYPE__ns1__ConferenceLockedFault
#define SOAP_TYPE__ns1__ConferenceLockedFault (14)
#endif

/* _ns1__WrongPINFault has binding name '_ns1__WrongPINFault' for type '' */
#ifndef SOAP_TYPE__ns1__WrongPINFault
#define SOAP_TYPE__ns1__WrongPINFault (13)
#endif

/* _ns1__SeatLicenseExpiredFault has binding name '_ns1__SeatLicenseExpiredFault' for type '' */
#ifndef SOAP_TYPE__ns1__SeatLicenseExpiredFault
#define SOAP_TYPE__ns1__SeatLicenseExpiredFault (12)
#endif

/* _ns1__InvalidArgumentFault has binding name '_ns1__InvalidArgumentFault' for type '' */
#ifndef SOAP_TYPE__ns1__InvalidArgumentFault
#define SOAP_TYPE__ns1__InvalidArgumentFault (11)
#endif

/* _ns1__GeneralFault has binding name '_ns1__GeneralFault' for type '' */
#ifndef SOAP_TYPE__ns1__GeneralFault
#define SOAP_TYPE__ns1__GeneralFault (10)
#endif

/* ns1__RoomProfile has binding name 'ns1__RoomProfile' for type 'ns1:RoomProfile' */
#ifndef SOAP_TYPE_ns1__RoomProfile
#define SOAP_TYPE_ns1__RoomProfile (9)
#endif

/* ns1__Recorder has binding name 'ns1__Recorder' for type 'ns1:Recorder' */
#ifndef SOAP_TYPE_ns1__Recorder
#define SOAP_TYPE_ns1__Recorder (8)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (622)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (621)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (619)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (618)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (254)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (624)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (623)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (620)
#endif

/* _ns1__GetChangePasswordHtmlUrlWithTokenRequest * has binding name 'PointerTo_ns1__GetChangePasswordHtmlUrlWithTokenRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetChangePasswordHtmlUrlWithTokenRequest
#define SOAP_TYPE_PointerTo_ns1__GetChangePasswordHtmlUrlWithTokenRequest (614)
#endif

/* _ns1__WhatIsMyIPAddressRequest * has binding name 'PointerTo_ns1__WhatIsMyIPAddressRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__WhatIsMyIPAddressRequest
#define SOAP_TYPE_PointerTo_ns1__WhatIsMyIPAddressRequest (610)
#endif

/* _ns1__GetVidyoReplayLibraryRequest * has binding name 'PointerTo_ns1__GetVidyoReplayLibraryRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetVidyoReplayLibraryRequest
#define SOAP_TYPE_PointerTo_ns1__GetVidyoReplayLibraryRequest (606)
#endif

/* _ns1__RemovePresenterRequest * has binding name 'PointerTo_ns1__RemovePresenterRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__RemovePresenterRequest
#define SOAP_TYPE_PointerTo_ns1__RemovePresenterRequest (602)
#endif

/* _ns1__SetPresenterRequest * has binding name 'PointerTo_ns1__SetPresenterRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetPresenterRequest
#define SOAP_TYPE_PointerTo_ns1__SetPresenterRequest (598)
#endif

/* _ns1__DismissAllRaisedHandRequest * has binding name 'PointerTo_ns1__DismissAllRaisedHandRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__DismissAllRaisedHandRequest
#define SOAP_TYPE_PointerTo_ns1__DismissAllRaisedHandRequest (594)
#endif

/* _ns1__DismissRaisedHandRequest * has binding name 'PointerTo_ns1__DismissRaisedHandRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__DismissRaisedHandRequest
#define SOAP_TYPE_PointerTo_ns1__DismissRaisedHandRequest (590)
#endif

/* _ns1__StopLectureModeRequest * has binding name 'PointerTo_ns1__StopLectureModeRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__StopLectureModeRequest
#define SOAP_TYPE_PointerTo_ns1__StopLectureModeRequest (580)
#endif

/* _ns1__StartLectureModeRequest * has binding name 'PointerTo_ns1__StartLectureModeRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__StartLectureModeRequest
#define SOAP_TYPE_PointerTo_ns1__StartLectureModeRequest (576)
#endif

/* _ns1__getUserAccountTypeRequest * has binding name 'PointerTo_ns1__getUserAccountTypeRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getUserAccountTypeRequest
#define SOAP_TYPE_PointerTo_ns1__getUserAccountTypeRequest (572)
#endif

/* _ns1__getLoginAndWelcomeBannerRequest * has binding name 'PointerTo_ns1__getLoginAndWelcomeBannerRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getLoginAndWelcomeBannerRequest
#define SOAP_TYPE_PointerTo_ns1__getLoginAndWelcomeBannerRequest (568)
#endif

/* _ns1__RoomAccessOptionsRequest * has binding name 'PointerTo_ns1__RoomAccessOptionsRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__RoomAccessOptionsRequest
#define SOAP_TYPE_PointerTo_ns1__RoomAccessOptionsRequest (561)
#endif

/* _ns1__muteVideoClientAllRequest * has binding name 'PointerTo_ns1__muteVideoClientAllRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__muteVideoClientAllRequest
#define SOAP_TYPE_PointerTo_ns1__muteVideoClientAllRequest (554)
#endif

/* _ns1__muteVideoServerAllRequest * has binding name 'PointerTo_ns1__muteVideoServerAllRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__muteVideoServerAllRequest
#define SOAP_TYPE_PointerTo_ns1__muteVideoServerAllRequest (550)
#endif

/* _ns1__muteAudioClientAllRequest * has binding name 'PointerTo_ns1__muteAudioClientAllRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__muteAudioClientAllRequest
#define SOAP_TYPE_PointerTo_ns1__muteAudioClientAllRequest (546)
#endif

/* _ns1__muteAudioServerAllRequest * has binding name 'PointerTo_ns1__muteAudioServerAllRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__muteAudioServerAllRequest
#define SOAP_TYPE_PointerTo_ns1__muteAudioServerAllRequest (542)
#endif

/* _ns1__disconnectConferenceAllRequest * has binding name 'PointerTo_ns1__disconnectConferenceAllRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__disconnectConferenceAllRequest
#define SOAP_TYPE_PointerTo_ns1__disconnectConferenceAllRequest (538)
#endif

/* _ns1__SetEndpointDetailsRequest * has binding name 'PointerTo_ns1__SetEndpointDetailsRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetEndpointDetailsRequest
#define SOAP_TYPE_PointerTo_ns1__SetEndpointDetailsRequest (528)
#endif

/* _ns1__DeleteScheduledRoomRequest * has binding name 'PointerTo_ns1__DeleteScheduledRoomRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__DeleteScheduledRoomRequest
#define SOAP_TYPE_PointerTo_ns1__DeleteScheduledRoomRequest (521)
#endif

/* _ns1__CreateScheduledRoomRequest * has binding name 'PointerTo_ns1__CreateScheduledRoomRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__CreateScheduledRoomRequest
#define SOAP_TYPE_PointerTo_ns1__CreateScheduledRoomRequest (517)
#endif

/* _ns1__GenerateAuthTokenRequest * has binding name 'PointerTo_ns1__GenerateAuthTokenRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GenerateAuthTokenRequest
#define SOAP_TYPE_PointerTo_ns1__GenerateAuthTokenRequest (513)
#endif

/* _ns1__GetConferenceIDRequest * has binding name 'PointerTo_ns1__GetConferenceIDRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetConferenceIDRequest
#define SOAP_TYPE_PointerTo_ns1__GetConferenceIDRequest (509)
#endif

/* _ns1__RemoveModeratorPINRequest * has binding name 'PointerTo_ns1__RemoveModeratorPINRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__RemoveModeratorPINRequest
#define SOAP_TYPE_PointerTo_ns1__RemoveModeratorPINRequest (505)
#endif

/* _ns1__CreateModeratorPINRequest * has binding name 'PointerTo_ns1__CreateModeratorPINRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__CreateModeratorPINRequest
#define SOAP_TYPE_PointerTo_ns1__CreateModeratorPINRequest (501)
#endif

/* _ns1__GetModeratorURLWithTokenRequest * has binding name 'PointerTo_ns1__GetModeratorURLWithTokenRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetModeratorURLWithTokenRequest
#define SOAP_TYPE_PointerTo_ns1__GetModeratorURLWithTokenRequest (497)
#endif

/* _ns1__GetModeratorURLRequest * has binding name 'PointerTo_ns1__GetModeratorURLRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetModeratorURLRequest
#define SOAP_TYPE_PointerTo_ns1__GetModeratorURLRequest (493)
#endif

/* _ns1__RemoveModeratorURLRequest * has binding name 'PointerTo_ns1__RemoveModeratorURLRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__RemoveModeratorURLRequest
#define SOAP_TYPE_PointerTo_ns1__RemoveModeratorURLRequest (489)
#endif

/* _ns1__CreateModeratorURLRequest * has binding name 'PointerTo_ns1__CreateModeratorURLRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__CreateModeratorURLRequest
#define SOAP_TYPE_PointerTo_ns1__CreateModeratorURLRequest (485)
#endif

/* _ns1__RemoveRoomProfileRequest * has binding name 'PointerTo_ns1__RemoveRoomProfileRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__RemoveRoomProfileRequest
#define SOAP_TYPE_PointerTo_ns1__RemoveRoomProfileRequest (481)
#endif

/* _ns1__SetRoomProfileRequest * has binding name 'PointerTo_ns1__SetRoomProfileRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetRoomProfileRequest
#define SOAP_TYPE_PointerTo_ns1__SetRoomProfileRequest (477)
#endif

/* _ns1__GetRoomProfileRequest * has binding name 'PointerTo_ns1__GetRoomProfileRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetRoomProfileRequest
#define SOAP_TYPE_PointerTo_ns1__GetRoomProfileRequest (473)
#endif

/* _ns1__GetInviteContentRequest * has binding name 'PointerTo_ns1__GetInviteContentRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetInviteContentRequest
#define SOAP_TYPE_PointerTo_ns1__GetInviteContentRequest (466)
#endif

/* _ns1__GetEntityByRoomKeyRequest * has binding name 'PointerTo_ns1__GetEntityByRoomKeyRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetEntityByRoomKeyRequest
#define SOAP_TYPE_PointerTo_ns1__GetEntityByRoomKeyRequest (462)
#endif

/* _ns1__GetUserNameRequest * has binding name 'PointerTo_ns1__GetUserNameRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetUserNameRequest
#define SOAP_TYPE_PointerTo_ns1__GetUserNameRequest (458)
#endif

/* _ns1__GetWebcastURLRequest * has binding name 'PointerTo_ns1__GetWebcastURLRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetWebcastURLRequest
#define SOAP_TYPE_PointerTo_ns1__GetWebcastURLRequest (454)
#endif

/* _ns1__RemoveWebcastPINRequest * has binding name 'PointerTo_ns1__RemoveWebcastPINRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__RemoveWebcastPINRequest
#define SOAP_TYPE_PointerTo_ns1__RemoveWebcastPINRequest (450)
#endif

/* _ns1__RemoveWebcastURLRequest * has binding name 'PointerTo_ns1__RemoveWebcastURLRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__RemoveWebcastURLRequest
#define SOAP_TYPE_PointerTo_ns1__RemoveWebcastURLRequest (446)
#endif

/* _ns1__CreateWebcastPINRequest * has binding name 'PointerTo_ns1__CreateWebcastPINRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__CreateWebcastPINRequest
#define SOAP_TYPE_PointerTo_ns1__CreateWebcastPINRequest (442)
#endif

/* _ns1__CreateWebcastURLRequest * has binding name 'PointerTo_ns1__CreateWebcastURLRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__CreateWebcastURLRequest
#define SOAP_TYPE_PointerTo_ns1__CreateWebcastURLRequest (438)
#endif

/* _ns1__StopRecordingRequest * has binding name 'PointerTo_ns1__StopRecordingRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__StopRecordingRequest
#define SOAP_TYPE_PointerTo_ns1__StopRecordingRequest (434)
#endif

/* _ns1__ResumeRecordingRequest * has binding name 'PointerTo_ns1__ResumeRecordingRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__ResumeRecordingRequest
#define SOAP_TYPE_PointerTo_ns1__ResumeRecordingRequest (430)
#endif

/* _ns1__PauseRecordingRequest * has binding name 'PointerTo_ns1__PauseRecordingRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__PauseRecordingRequest
#define SOAP_TYPE_PointerTo_ns1__PauseRecordingRequest (426)
#endif

/* _ns1__GetPortalVersionRequest * has binding name 'PointerTo_ns1__GetPortalVersionRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetPortalVersionRequest
#define SOAP_TYPE_PointerTo_ns1__GetPortalVersionRequest (422)
#endif

/* _ns1__StartRecordingRequest * has binding name 'PointerTo_ns1__StartRecordingRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__StartRecordingRequest
#define SOAP_TYPE_PointerTo_ns1__StartRecordingRequest (418)
#endif

/* _ns1__GetRecordingProfilesRequest * has binding name 'PointerTo_ns1__GetRecordingProfilesRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetRecordingProfilesRequest
#define SOAP_TYPE_PointerTo_ns1__GetRecordingProfilesRequest (414)
#endif

/* _ns1__SetMemberModeRequest * has binding name 'PointerTo_ns1__SetMemberModeRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetMemberModeRequest
#define SOAP_TYPE_PointerTo_ns1__SetMemberModeRequest (410)
#endif

/* _ns1__UnlockRoomRequest * has binding name 'PointerTo_ns1__UnlockRoomRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__UnlockRoomRequest
#define SOAP_TYPE_PointerTo_ns1__UnlockRoomRequest (406)
#endif

/* _ns1__LockRoomRequest * has binding name 'PointerTo_ns1__LockRoomRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__LockRoomRequest
#define SOAP_TYPE_PointerTo_ns1__LockRoomRequest (402)
#endif

/* _ns1__UpdateLanguageRequest * has binding name 'PointerTo_ns1__UpdateLanguageRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__UpdateLanguageRequest
#define SOAP_TYPE_PointerTo_ns1__UpdateLanguageRequest (398)
#endif

/* _ns1__UpdatePasswordRequest * has binding name 'PointerTo_ns1__UpdatePasswordRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__UpdatePasswordRequest
#define SOAP_TYPE_PointerTo_ns1__UpdatePasswordRequest (394)
#endif

/* _ns1__DeleteRoomRequest * has binding name 'PointerTo_ns1__DeleteRoomRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__DeleteRoomRequest
#define SOAP_TYPE_PointerTo_ns1__DeleteRoomRequest (390)
#endif

/* _ns1__CreateRoomRequest * has binding name 'PointerTo_ns1__CreateRoomRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__CreateRoomRequest
#define SOAP_TYPE_PointerTo_ns1__CreateRoomRequest (386)
#endif

/* _ns1__RemoveRoomPINRequest * has binding name 'PointerTo_ns1__RemoveRoomPINRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__RemoveRoomPINRequest
#define SOAP_TYPE_PointerTo_ns1__RemoveRoomPINRequest (382)
#endif

/* _ns1__CreateRoomPINRequest * has binding name 'PointerTo_ns1__CreateRoomPINRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__CreateRoomPINRequest
#define SOAP_TYPE_PointerTo_ns1__CreateRoomPINRequest (378)
#endif

/* _ns1__RemoveRoomURLRequest * has binding name 'PointerTo_ns1__RemoveRoomURLRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__RemoveRoomURLRequest
#define SOAP_TYPE_PointerTo_ns1__RemoveRoomURLRequest (374)
#endif

/* _ns1__CreateRoomURLRequest * has binding name 'PointerTo_ns1__CreateRoomURLRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__CreateRoomURLRequest
#define SOAP_TYPE_PointerTo_ns1__CreateRoomURLRequest (370)
#endif

/* _ns1__MyAccountRequest * has binding name 'PointerTo_ns1__MyAccountRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__MyAccountRequest
#define SOAP_TYPE_PointerTo_ns1__MyAccountRequest (366)
#endif

/* _ns1__StopVideoRequest * has binding name 'PointerTo_ns1__StopVideoRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__StopVideoRequest
#define SOAP_TYPE_PointerTo_ns1__StopVideoRequest (362)
#endif

/* _ns1__StartVideoRequest * has binding name 'PointerTo_ns1__StartVideoRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__StartVideoRequest
#define SOAP_TYPE_PointerTo_ns1__StartVideoRequest (358)
#endif

/* _ns1__UnmuteAudioRequest * has binding name 'PointerTo_ns1__UnmuteAudioRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__UnmuteAudioRequest
#define SOAP_TYPE_PointerTo_ns1__UnmuteAudioRequest (354)
#endif

/* _ns1__MuteAudioRequest * has binding name 'PointerTo_ns1__MuteAudioRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__MuteAudioRequest
#define SOAP_TYPE_PointerTo_ns1__MuteAudioRequest (350)
#endif

/* _ns1__LeaveConferenceRequest * has binding name 'PointerTo_ns1__LeaveConferenceRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__LeaveConferenceRequest
#define SOAP_TYPE_PointerTo_ns1__LeaveConferenceRequest (346)
#endif

/* _ns1__GetLectureModeParticipantsRequest * has binding name 'PointerTo_ns1__GetLectureModeParticipantsRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetLectureModeParticipantsRequest
#define SOAP_TYPE_PointerTo_ns1__GetLectureModeParticipantsRequest (342)
#endif

/* _ns1__GetParticipantsRequest * has binding name 'PointerTo_ns1__GetParticipantsRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetParticipantsRequest
#define SOAP_TYPE_PointerTo_ns1__GetParticipantsRequest (338)
#endif

/* _ns1__DirectCallRequest * has binding name 'PointerTo_ns1__DirectCallRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__DirectCallRequest
#define SOAP_TYPE_PointerTo_ns1__DirectCallRequest (334)
#endif

/* _ns1__JoinIPCConferenceRequest * has binding name 'PointerTo_ns1__JoinIPCConferenceRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__JoinIPCConferenceRequest
#define SOAP_TYPE_PointerTo_ns1__JoinIPCConferenceRequest (330)
#endif

/* _ns1__JoinConferenceRequest * has binding name 'PointerTo_ns1__JoinConferenceRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__JoinConferenceRequest
#define SOAP_TYPE_PointerTo_ns1__JoinConferenceRequest (326)
#endif

/* _ns1__CancelOutboundCallRequest * has binding name 'PointerTo_ns1__CancelOutboundCallRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__CancelOutboundCallRequest
#define SOAP_TYPE_PointerTo_ns1__CancelOutboundCallRequest (322)
#endif

/* _ns1__InviteToConferenceRequest * has binding name 'PointerTo_ns1__InviteToConferenceRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__InviteToConferenceRequest
#define SOAP_TYPE_PointerTo_ns1__InviteToConferenceRequest (318)
#endif

/* _ns1__GetEntityByEntityIDRequest * has binding name 'PointerTo_ns1__GetEntityByEntityIDRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetEntityByEntityIDRequest
#define SOAP_TYPE_PointerTo_ns1__GetEntityByEntityIDRequest (314)
#endif

/* _ns1__SearchByEmailRequest * has binding name 'PointerTo_ns1__SearchByEmailRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SearchByEmailRequest
#define SOAP_TYPE_PointerTo_ns1__SearchByEmailRequest (310)
#endif

/* _ns1__SearchByEntityIDRequest * has binding name 'PointerTo_ns1__SearchByEntityIDRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SearchByEntityIDRequest
#define SOAP_TYPE_PointerTo_ns1__SearchByEntityIDRequest (306)
#endif

/* _ns1__SearchRequest * has binding name 'PointerTo_ns1__SearchRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SearchRequest
#define SOAP_TYPE_PointerTo_ns1__SearchRequest (302)
#endif

/* _ns1__RemoveFromMyContactsRequest * has binding name 'PointerTo_ns1__RemoveFromMyContactsRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__RemoveFromMyContactsRequest
#define SOAP_TYPE_PointerTo_ns1__RemoveFromMyContactsRequest (298)
#endif

/* _ns1__AddToMyContactsRequest * has binding name 'PointerTo_ns1__AddToMyContactsRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__AddToMyContactsRequest
#define SOAP_TYPE_PointerTo_ns1__AddToMyContactsRequest (294)
#endif

/* _ns1__SearchMyContactsRequest * has binding name 'PointerTo_ns1__SearchMyContactsRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SearchMyContactsRequest
#define SOAP_TYPE_PointerTo_ns1__SearchMyContactsRequest (290)
#endif

/* _ns1__MyEndpointStatusRequest * has binding name 'PointerTo_ns1__MyEndpointStatusRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__MyEndpointStatusRequest
#define SOAP_TYPE_PointerTo_ns1__MyEndpointStatusRequest (286)
#endif

/* _ns1__LogOutRequest * has binding name 'PointerTo_ns1__LogOutRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__LogOutRequest
#define SOAP_TYPE_PointerTo_ns1__LogOutRequest (282)
#endif

/* _ns1__LinkEndpointRequest * has binding name 'PointerTo_ns1__LinkEndpointRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__LinkEndpointRequest
#define SOAP_TYPE_PointerTo_ns1__LinkEndpointRequest (278)
#endif

/* _ns1__LogInRequest * has binding name 'PointerTo_ns1__LogInRequest' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__LogInRequest
#define SOAP_TYPE_PointerTo_ns1__LogInRequest (274)
#endif

/* _ns1__WrongPINFault * has binding name 'PointerTo_ns1__WrongPINFault' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__WrongPINFault
#define SOAP_TYPE_PointerTo_ns1__WrongPINFault (271)
#endif

/* _ns1__VidyoReplayNotAvailableFault * has binding name 'PointerTo_ns1__VidyoReplayNotAvailableFault' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__VidyoReplayNotAvailableFault
#define SOAP_TYPE_PointerTo_ns1__VidyoReplayNotAvailableFault (270)
#endif

/* _ns1__SeatLicenseExpiredFault * has binding name 'PointerTo_ns1__SeatLicenseExpiredFault' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SeatLicenseExpiredFault
#define SOAP_TYPE_PointerTo_ns1__SeatLicenseExpiredFault (269)
#endif

/* _ns1__ScheduledRoomCreationFault * has binding name 'PointerTo_ns1__ScheduledRoomCreationFault' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__ScheduledRoomCreationFault
#define SOAP_TYPE_PointerTo_ns1__ScheduledRoomCreationFault (268)
#endif

/* _ns1__RoomNotFoundFault * has binding name 'PointerTo_ns1__RoomNotFoundFault' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__RoomNotFoundFault
#define SOAP_TYPE_PointerTo_ns1__RoomNotFoundFault (267)
#endif

/* _ns1__ResourceNotAvailableFault * has binding name 'PointerTo_ns1__ResourceNotAvailableFault' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__ResourceNotAvailableFault
#define SOAP_TYPE_PointerTo_ns1__ResourceNotAvailableFault (266)
#endif

/* _ns1__PrefixNotConfiguredFault * has binding name 'PointerTo_ns1__PrefixNotConfiguredFault' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__PrefixNotConfiguredFault
#define SOAP_TYPE_PointerTo_ns1__PrefixNotConfiguredFault (265)
#endif

/* _ns1__NotLicensedFault * has binding name 'PointerTo_ns1__NotLicensedFault' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__NotLicensedFault
#define SOAP_TYPE_PointerTo_ns1__NotLicensedFault (264)
#endif

/* _ns1__InvalidModeratorPINFormatFault * has binding name 'PointerTo_ns1__InvalidModeratorPINFormatFault' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__InvalidModeratorPINFormatFault
#define SOAP_TYPE_PointerTo_ns1__InvalidModeratorPINFormatFault (263)
#endif

/* _ns1__InvalidArgumentFault * has binding name 'PointerTo_ns1__InvalidArgumentFault' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__InvalidArgumentFault
#define SOAP_TYPE_PointerTo_ns1__InvalidArgumentFault (262)
#endif

/* _ns1__InPointToPointCallFault * has binding name 'PointerTo_ns1__InPointToPointCallFault' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__InPointToPointCallFault
#define SOAP_TYPE_PointerTo_ns1__InPointToPointCallFault (261)
#endif

/* _ns1__GeneralFault * has binding name 'PointerTo_ns1__GeneralFault' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GeneralFault
#define SOAP_TYPE_PointerTo_ns1__GeneralFault (260)
#endif

/* _ns1__FeatureNotAvailableFault * has binding name 'PointerTo_ns1__FeatureNotAvailableFault' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__FeatureNotAvailableFault
#define SOAP_TYPE_PointerTo_ns1__FeatureNotAvailableFault (259)
#endif

/* _ns1__EndpointNotBoundFault * has binding name 'PointerTo_ns1__EndpointNotBoundFault' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__EndpointNotBoundFault
#define SOAP_TYPE_PointerTo_ns1__EndpointNotBoundFault (258)
#endif

/* _ns1__ControlMeetingFault * has binding name 'PointerTo_ns1__ControlMeetingFault' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__ControlMeetingFault
#define SOAP_TYPE_PointerTo_ns1__ControlMeetingFault (257)
#endif

/* _ns1__ConferenceLockedFault * has binding name 'PointerTo_ns1__ConferenceLockedFault' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__ConferenceLockedFault
#define SOAP_TYPE_PointerTo_ns1__ConferenceLockedFault (256)
#endif

/* _ns1__AccessRestrictedFault * has binding name 'PointerTo_ns1__AccessRestrictedFault' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__AccessRestrictedFault
#define SOAP_TYPE_PointerTo_ns1__AccessRestrictedFault (255)
#endif

/* _ns1__WelcomeBannerContent * has binding name 'PointerTo_ns1__WelcomeBannerContent' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__WelcomeBannerContent
#define SOAP_TYPE_PointerTo_ns1__WelcomeBannerContent (253)
#endif

/* _ns1__RoomAccessOption ** has binding name 'PointerToPointerTo_ns1__RoomAccessOption' for type '' */
#ifndef SOAP_TYPE_PointerToPointerTo_ns1__RoomAccessOption
#define SOAP_TYPE_PointerToPointerTo_ns1__RoomAccessOption (252)
#endif

/* _ns1__RoomAccessOption * has binding name 'PointerTo_ns1__RoomAccessOption' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__RoomAccessOption
#define SOAP_TYPE_PointerTo_ns1__RoomAccessOption (251)
#endif

/* _ns1__EndpointFeature ** has binding name 'PointerToPointerTo_ns1__EndpointFeature' for type '' */
#ifndef SOAP_TYPE_PointerToPointerTo_ns1__EndpointFeature
#define SOAP_TYPE_PointerToPointerTo_ns1__EndpointFeature (250)
#endif

/* _ns1__EndpointFeature * has binding name 'PointerTo_ns1__EndpointFeature' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__EndpointFeature
#define SOAP_TYPE_PointerTo_ns1__EndpointFeature (249)
#endif

/* _ns1__PortalFeature ** has binding name 'PointerToPointerTo_ns1__PortalFeature' for type '' */
#ifndef SOAP_TYPE_PointerToPointerTo_ns1__PortalFeature
#define SOAP_TYPE_PointerToPointerTo_ns1__PortalFeature (248)
#endif

/* _ns1__PortalFeature * has binding name 'PointerTo_ns1__PortalFeature' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__PortalFeature
#define SOAP_TYPE_PointerTo_ns1__PortalFeature (247)
#endif

/* char ** has binding name 'PointerTostring' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerTostring
#define SOAP_TYPE_PointerTostring (246)
#endif

/* ns1__RoomProfile ** has binding name 'PointerToPointerTons1__RoomProfile' for type 'ns1:RoomProfile' */
#ifndef SOAP_TYPE_PointerToPointerTons1__RoomProfile
#define SOAP_TYPE_PointerToPointerTons1__RoomProfile (245)
#endif

/* ns1__RoomProfile * has binding name 'PointerTons1__RoomProfile' for type 'ns1:RoomProfile' */
#ifndef SOAP_TYPE_PointerTons1__RoomProfile
#define SOAP_TYPE_PointerTons1__RoomProfile (244)
#endif

/* ns1__Recorder ** has binding name 'PointerToPointerTons1__Recorder' for type 'ns1:Recorder' */
#ifndef SOAP_TYPE_PointerToPointerTons1__Recorder
#define SOAP_TYPE_PointerToPointerTons1__Recorder (243)
#endif

/* ns1__Recorder * has binding name 'PointerTons1__Recorder' for type 'ns1:Recorder' */
#ifndef SOAP_TYPE_PointerTons1__Recorder
#define SOAP_TYPE_PointerTons1__Recorder (242)
#endif

/* _ns1__LectureModeParticipant ** has binding name 'PointerToPointerTo_ns1__LectureModeParticipant' for type '' */
#ifndef SOAP_TYPE_PointerToPointerTo_ns1__LectureModeParticipant
#define SOAP_TYPE_PointerToPointerTo_ns1__LectureModeParticipant (241)
#endif

/* _ns1__LectureModeParticipant * has binding name 'PointerTo_ns1__LectureModeParticipant' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__LectureModeParticipant
#define SOAP_TYPE_PointerTo_ns1__LectureModeParticipant (240)
#endif

/* char ** has binding name 'PointerTons1__EntityID' for type 'ns1:EntityID' */
#ifndef SOAP_TYPE_PointerTons1__EntityID
#define SOAP_TYPE_PointerTons1__EntityID (236)
#endif

/* _ns1__Entity ** has binding name 'PointerToPointerTo_ns1__Entity' for type '' */
#ifndef SOAP_TYPE_PointerToPointerTo_ns1__Entity
#define SOAP_TYPE_PointerToPointerTo_ns1__Entity (235)
#endif

/* _ns1__Filter * has binding name 'PointerTo_ns1__Filter' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__Filter
#define SOAP_TYPE_PointerTo_ns1__Filter (234)
#endif

/* _ns1__Entity * has binding name 'PointerTo_ns1__Entity' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__Entity
#define SOAP_TYPE_PointerTo_ns1__Entity (233)
#endif

/* enum _ns1__ClientType * has binding name 'PointerTo_ns1__ClientType' for type 'ns1:ClientType' */
#ifndef SOAP_TYPE_PointerTo_ns1__ClientType
#define SOAP_TYPE_PointerTo_ns1__ClientType (232)
#endif

/* time_t * has binding name 'PointerTodateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_PointerTodateTime
#define SOAP_TYPE_PointerTodateTime (231)
#endif

/* _ns1__LoginAttempt ** has binding name 'PointerToPointerTo_ns1__LoginAttempt' for type '' */
#ifndef SOAP_TYPE_PointerToPointerTo_ns1__LoginAttempt
#define SOAP_TYPE_PointerToPointerTo_ns1__LoginAttempt (230)
#endif

/* _ns1__LoginAttempt * has binding name 'PointerTo_ns1__LoginAttempt' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__LoginAttempt
#define SOAP_TYPE_PointerTo_ns1__LoginAttempt (229)
#endif

/* _ns1__RoomMode * has binding name 'PointerTo_ns1__RoomMode' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__RoomMode
#define SOAP_TYPE_PointerTo_ns1__RoomMode (227)
#endif

/* enum _ns1__RoomStatus * has binding name 'PointerTo_ns1__RoomStatus' for type 'ns1:RoomStatus' */
#ifndef SOAP_TYPE_PointerTo_ns1__RoomStatus
#define SOAP_TYPE_PointerTo_ns1__RoomStatus (226)
#endif

/* enum _ns1__MemberMode * has binding name 'PointerTo_ns1__MemberMode' for type 'ns1:MemberMode' */
#ifndef SOAP_TYPE_PointerTo_ns1__MemberMode
#define SOAP_TYPE_PointerTo_ns1__MemberMode (225)
#endif

/* enum _ns1__MemberStatus * has binding name 'PointerTo_ns1__MemberStatus' for type 'ns1:MemberStatus' */
#ifndef SOAP_TYPE_PointerTo_ns1__MemberStatus
#define SOAP_TYPE_PointerTo_ns1__MemberStatus (224)
#endif

/* enum _ns1__Language * has binding name 'PointerTo_ns1__Language' for type 'ns1:Language' */
#ifndef SOAP_TYPE_PointerTo_ns1__Language
#define SOAP_TYPE_PointerTo_ns1__Language (223)
#endif

/* enum _ns1__EntityType * has binding name 'PointerTo_ns1__EntityType' for type 'ns1:EntityType' */
#ifndef SOAP_TYPE_PointerTo_ns1__EntityType
#define SOAP_TYPE_PointerTo_ns1__EntityType (222)
#endif

/* enum ns1__sortDir * has binding name 'PointerTons1__sortDir' for type 'ns1:sortDir' */
#ifndef SOAP_TYPE_PointerTons1__sortDir
#define SOAP_TYPE_PointerTons1__sortDir (221)
#endif

/* int * has binding name 'PointerToint' for type 'xsd:int' */
#ifndef SOAP_TYPE_PointerToint
#define SOAP_TYPE_PointerToint (220)
#endif

/* bool * has binding name 'PointerTobool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_PointerTobool
#define SOAP_TYPE_PointerTobool (219)
#endif

/* ns1__EndpointFeatureName has binding name 'ns1__EndpointFeatureName' for type 'ns1:EndpointFeatureName' */
#ifndef SOAP_TYPE_ns1__EndpointFeatureName
#define SOAP_TYPE_ns1__EndpointFeatureName (208)
#endif

/* ns1__PortalFeatureName has binding name 'ns1__PortalFeatureName' for type 'ns1:PortalFeatureName' */
#ifndef SOAP_TYPE_ns1__PortalFeatureName
#define SOAP_TYPE_ns1__PortalFeatureName (207)
#endif

/* ns1__EntityID has binding name 'ns1__EntityID' for type 'ns1:EntityID' */
#ifndef SOAP_TYPE_ns1__EntityID
#define SOAP_TYPE_ns1__EntityID (206)
#endif

/* xsd__anyURI has binding name 'xsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (7)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Client-Side Call Stub Functions                                            *
 *                                                                            *
\******************************************************************************/

    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__logIn(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__LogInRequest *ns1__LogInRequest, _ns1__LogInResponse &ns1__LogInResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__linkEndpoint(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__LinkEndpointRequest *ns1__LinkEndpointRequest, _ns1__LinkEndpointResponse &ns1__LinkEndpointResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__logOut(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__LogOutRequest *ns1__LogOutRequest, _ns1__LogOutResponse &ns1__LogOutResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__myEndpointStatus(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__MyEndpointStatusRequest *ns1__MyEndpointStatusRequest, _ns1__MyEndpointStatusResponse &ns1__MyEndpointStatusResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__searchMyContacts(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SearchMyContactsRequest *ns1__SearchMyContactsRequest, _ns1__SearchMyContactsResponse &ns1__SearchMyContactsResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__addToMyContacts(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__AddToMyContactsRequest *ns1__AddToMyContactsRequest, _ns1__AddToMyContactsResponse &ns1__AddToMyContactsResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__removeFromMyContacts(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__RemoveFromMyContactsRequest *ns1__RemoveFromMyContactsRequest, _ns1__RemoveFromMyContactsResponse &ns1__RemoveFromMyContactsResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__search(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SearchRequest *ns1__SearchRequest, _ns1__SearchResponse &ns1__SearchResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__searchByEntityID(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SearchByEntityIDRequest *ns1__SearchByEntityIDRequest, _ns1__SearchByEntityIDResponse &ns1__SearchByEntityIDResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__searchByEmail(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SearchByEmailRequest *ns1__SearchByEmailRequest, _ns1__SearchByEmailResponse &ns1__SearchByEmailResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getEntityByEntityID(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetEntityByEntityIDRequest *ns1__GetEntityByEntityIDRequest, _ns1__GetEntityByEntityIDResponse &ns1__GetEntityByEntityIDResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__inviteToConference(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InviteToConferenceRequest *ns1__InviteToConferenceRequest, _ns1__InviteToConferenceResponse &ns1__InviteToConferenceResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__cancelOutboundCall(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__CancelOutboundCallRequest *ns1__CancelOutboundCallRequest, _ns1__CancelOutboundCallResponse &ns1__CancelOutboundCallResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__joinConference(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__JoinConferenceRequest *ns1__JoinConferenceRequest, _ns1__JoinConferenceResponse &ns1__JoinConferenceResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__joinIPCConference(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__JoinIPCConferenceRequest *ns1__JoinIPCConferenceRequest, _ns1__JoinIPCConferenceResponse &ns1__JoinIPCConferenceResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__directCall(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__DirectCallRequest *ns1__DirectCallRequest, _ns1__DirectCallResponse &ns1__DirectCallResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getParticipants(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetParticipantsRequest *ns1__GetParticipantsRequest, _ns1__GetParticipantsResponse &ns1__GetParticipantsResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getLectureModeParticipants(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetLectureModeParticipantsRequest *ns1__GetLectureModeParticipantsRequest, _ns1__GetLectureModeParticipantsResponse &ns1__GetLectureModeParticipantsResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__leaveConference(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__LeaveConferenceRequest *ns1__LeaveConferenceRequest, _ns1__LeaveConferenceResponse &ns1__LeaveConferenceResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__muteAudio(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__MuteAudioRequest *ns1__MuteAudioRequest, _ns1__MuteAudioResponse &ns1__MuteAudioResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__unmuteAudio(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__UnmuteAudioRequest *ns1__UnmuteAudioRequest, _ns1__UnmuteAudioResponse &ns1__UnmuteAudioResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__startVideo(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__StartVideoRequest *ns1__StartVideoRequest, _ns1__StartVideoResponse &ns1__StartVideoResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__stopVideo(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__StopVideoRequest *ns1__StopVideoRequest, _ns1__StopVideoResponse &ns1__StopVideoResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__myAccount(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__MyAccountRequest *ns1__MyAccountRequest, _ns1__MyAccountResponse &ns1__MyAccountResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__createRoomURL(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__CreateRoomURLRequest *ns1__CreateRoomURLRequest, _ns1__CreateRoomURLResponse &ns1__CreateRoomURLResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__removeRoomURL(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__RemoveRoomURLRequest *ns1__RemoveRoomURLRequest, _ns1__RemoveRoomURLResponse &ns1__RemoveRoomURLResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__createRoomPIN(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__CreateRoomPINRequest *ns1__CreateRoomPINRequest, _ns1__CreateRoomPINResponse &ns1__CreateRoomPINResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__removeRoomPIN(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__RemoveRoomPINRequest *ns1__RemoveRoomPINRequest, _ns1__RemoveRoomPINResponse &ns1__RemoveRoomPINResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__createRoom(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__CreateRoomRequest *ns1__CreateRoomRequest, _ns1__CreateRoomResponse &ns1__CreateRoomResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__deleteRoom(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__DeleteRoomRequest *ns1__DeleteRoomRequest, _ns1__DeleteRoomResponse &ns1__DeleteRoomResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__updatePassword(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__UpdatePasswordRequest *ns1__UpdatePasswordRequest, _ns1__UpdatePasswordResponse &ns1__UpdatePasswordResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__updateLanguage(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__UpdateLanguageRequest *ns1__UpdateLanguageRequest, _ns1__UpdateLanguageResponse &ns1__UpdateLanguageResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__lockRoom(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__LockRoomRequest *ns1__LockRoomRequest, _ns1__LockRoomResponse &ns1__LockRoomResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__unlockRoom(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__UnlockRoomRequest *ns1__UnlockRoomRequest, _ns1__UnlockRoomResponse &ns1__UnlockRoomResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__setMemberMode(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SetMemberModeRequest *ns1__SetMemberModeRequest, _ns1__SetMemberModeResponse &ns1__SetMemberModeResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getRecordingProfiles(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetRecordingProfilesRequest *ns1__GetRecordingProfilesRequest, _ns1__GetRecordingProfilesResponse &ns1__GetRecordingProfilesResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__startRecording(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__StartRecordingRequest *ns1__StartRecordingRequest, _ns1__StartRecordingResponse &ns1__StartRecordingResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getPortalVersion(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetPortalVersionRequest *ns1__GetPortalVersionRequest, _ns1__GetPortalVersionResponse &ns1__GetPortalVersionResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__pauseRecording(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__PauseRecordingRequest *ns1__PauseRecordingRequest, _ns1__PauseRecordingResponse &ns1__PauseRecordingResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__resumeRecording(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__ResumeRecordingRequest *ns1__ResumeRecordingRequest, _ns1__ResumeRecordingResponse &ns1__ResumeRecordingResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__stopRecording(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__StopRecordingRequest *ns1__StopRecordingRequest, _ns1__StopRecordingResponse &ns1__StopRecordingResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__createWebcastURL(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__CreateWebcastURLRequest *ns1__CreateWebcastURLRequest, _ns1__CreateWebcastURLResponse &ns1__CreateWebcastURLResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__createWebcastPIN(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__CreateWebcastPINRequest *ns1__CreateWebcastPINRequest, _ns1__CreateWebcastPINResponse &ns1__CreateWebcastPINResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__removeWebcastURL(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__RemoveWebcastURLRequest *ns1__RemoveWebcastURLRequest, _ns1__RemoveWebcastURLResponse &ns1__RemoveWebcastURLResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__removeWebcastPIN(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__RemoveWebcastPINRequest *ns1__RemoveWebcastPINRequest, _ns1__RemoveWebcastPINResponse &ns1__RemoveWebcastPINResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getWebcastURL(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetWebcastURLRequest *ns1__GetWebcastURLRequest, _ns1__GetWebcastURLResponse &ns1__GetWebcastURLResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getUserName(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetUserNameRequest *ns1__GetUserNameRequest, _ns1__GetUserNameResponse &ns1__GetUserNameResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getEntityByRoomKey(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetEntityByRoomKeyRequest *ns1__GetEntityByRoomKeyRequest, _ns1__GetEntityByRoomKeyResponse &ns1__GetEntityByRoomKeyResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getInviteContent(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetInviteContentRequest *ns1__GetInviteContentRequest, _ns1__GetInviteContentResponse &ns1__GetInviteContentResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getRoomProfiles(struct soap *soap, const char *soap_endpoint, const char *soap_action, char *ns1__GetRoomProfilesRequest, _ns1__GetRoomProfilesResponse &ns1__GetRoomProfilesResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getRoomProfile(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetRoomProfileRequest *ns1__GetRoomProfileRequest, _ns1__GetRoomProfileResponse &ns1__GetRoomProfileResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__setRoomProfile(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SetRoomProfileRequest *ns1__SetRoomProfileRequest, _ns1__SetRoomProfileResponse &ns1__SetRoomProfileResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__removeRoomProfile(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__RemoveRoomProfileRequest *ns1__RemoveRoomProfileRequest, _ns1__RemoveRoomProfileResponse &ns1__RemoveRoomProfileResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__createModeratorURL(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__CreateModeratorURLRequest *ns1__CreateModeratorURLRequest, _ns1__CreateModeratorURLResponse &ns1__CreateModeratorURLResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__removeModeratorURL(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__RemoveModeratorURLRequest *ns1__RemoveModeratorURLRequest, _ns1__RemoveModeratorURLResponse &ns1__RemoveModeratorURLResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getModeratorURL(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetModeratorURLRequest *ns1__GetModeratorURLRequest, _ns1__GetModeratorURLResponse &ns1__GetModeratorURLResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getModeratorURLWithToken(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetModeratorURLWithTokenRequest *ns1__GetModeratorURLWithTokenRequest, _ns1__GetModeratorURLWithTokenResponse &ns1__GetModeratorURLWithTokenResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__createModeratorPIN(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__CreateModeratorPINRequest *ns1__CreateModeratorPINRequest, _ns1__CreateModeratorPINResponse &ns1__CreateModeratorPINResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__removeModeratorPIN(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__RemoveModeratorPINRequest *ns1__RemoveModeratorPINRequest, _ns1__RemoveModeratorPINResponse &ns1__RemoveModeratorPINResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getConferenceID(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetConferenceIDRequest *ns1__GetConferenceIDRequest, _ns1__GetConferenceIDResponse &ns1__GetConferenceIDResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__generateAuthToken(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GenerateAuthTokenRequest *ns1__GenerateAuthTokenRequest, _ns1__GenerateAuthTokenResponse &ns1__GenerateAuthTokenResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__createScheduledRoom(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__CreateScheduledRoomRequest *ns1__CreateScheduledRoomRequest, _ns1__CreateScheduledRoomResponse &ns1__CreateScheduledRoomResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__deleteScheduledRoom(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__DeleteScheduledRoomRequest *ns1__DeleteScheduledRoomRequest, _ns1__DeleteScheduledRoomResponse &ns1__DeleteScheduledRoomResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getPortalFeatures(struct soap *soap, const char *soap_endpoint, const char *soap_action, char *ns1__GetPortalFeaturesRequest, _ns1__GetPortalFeaturesResponse &ns1__GetPortalFeaturesResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__setEndpointDetails(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SetEndpointDetailsRequest *ns1__SetEndpointDetailsRequest, _ns1__SetEndpointDetailsResponse &ns1__SetEndpointDetailsResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getActiveSessions(struct soap *soap, const char *soap_endpoint, const char *soap_action, char *ns1__GetActiveSessionsRequest, _ns1__GetActiveSessionsResponse &ns1__GetActiveSessionsResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__logoutAllOtherSessions(struct soap *soap, const char *soap_endpoint, const char *soap_action, char *ns1__LogoutAllOtherSessionsRequest, _ns1__LogoutAllOtherSessionsResponse &ns1__LogoutAllOtherSessionsResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__disconnectConferenceAll(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__disconnectConferenceAllRequest *ns1__disconnectConferenceAllRequest, _ns1__disconnectConferenceAllResponse &ns1__disconnectConferenceAllResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__muteAudioServerAll(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__muteAudioServerAllRequest *ns1__muteAudioServerAllRequest, _ns1__muteAudioServerAllResponse &ns1__muteAudioServerAllResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__muteAudioClientAll(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__muteAudioClientAllRequest *ns1__muteAudioClientAllRequest, _ns1__muteAudioClientAllResponse &ns1__muteAudioClientAllResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__muteVideoServerAll(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__muteVideoServerAllRequest *ns1__muteVideoServerAllRequest, _ns1__muteVideoServerAllResponse &ns1__muteVideoServerAllResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__muteVideoClientAll(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__muteVideoClientAllRequest *ns1__muteVideoClientAllRequest, _ns1__muteVideoClientAllResponse &ns1__muteVideoClientAllResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getOnetimeAccessUrl(struct soap *soap, const char *soap_endpoint, const char *soap_action, char *ns1__OnetimeAccessRequest, _ns1__OnetimeAccessResponse &ns1__OnetimeAccessResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getRoomAccessOptions(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__RoomAccessOptionsRequest *ns1__RoomAccessOptionsRequest, _ns1__RoomAccessOptionsResponse &ns1__RoomAccessOptionsResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getPortalPrefix(struct soap *soap, const char *soap_endpoint, const char *soap_action, char *ns1__PortalPrefixRequest, _ns1__PortalPrefixResponse &ns1__PortalPrefixResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getLoginAndWelcomeBanner(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__getLoginAndWelcomeBannerRequest *ns1__getLoginAndWelcomeBannerRequest, _ns1__getLoginAndWelcomeBannerResponse &ns1__getLoginAndWelcomeBannerResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getUserAccountType(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__getUserAccountTypeRequest *ns1__getUserAccountTypeRequest, _ns1__getUserAccountTypeResponse &ns1__getUserAccountTypeResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__startLectureMode(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__StartLectureModeRequest *ns1__StartLectureModeRequest, _ns1__StartLectureModeResponse &ns1__StartLectureModeResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__stopLectureMode(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__StopLectureModeRequest *ns1__StopLectureModeRequest, _ns1__StopLectureModeResponse &ns1__StopLectureModeResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__raiseHand(struct soap *soap, const char *soap_endpoint, const char *soap_action, char *ns1__RaiseHandRequest, _ns1__RaiseHandResponse &ns1__RaiseHandResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__unraiseHand(struct soap *soap, const char *soap_endpoint, const char *soap_action, char *ns1__UnraiseHandRequest, _ns1__UnraiseHandResponse &ns1__UnraiseHandResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__dismissRaisedHand(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__DismissRaisedHandRequest *ns1__DismissRaisedHandRequest, _ns1__DismissRaisedHandResponse &ns1__DismissRaisedHandResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__dismissAllRaisedHand(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__DismissAllRaisedHandRequest *ns1__DismissAllRaisedHandRequest, _ns1__DismissAllRaisedHandResponse &ns1__DismissAllRaisedHandResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__setPresenter(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SetPresenterRequest *ns1__SetPresenterRequest, _ns1__SetPresenterResponse &ns1__SetPresenterResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__removePresenter(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__RemovePresenterRequest *ns1__RemovePresenterRequest, _ns1__RemovePresenterResponse &ns1__RemovePresenterResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getVidyoReplayLibrary(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetVidyoReplayLibraryRequest *ns1__GetVidyoReplayLibraryRequest, _ns1__GetVidyoReplayLibraryResponse &ns1__GetVidyoReplayLibraryResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__whatIsMyIPAddress(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__WhatIsMyIPAddressRequest *ns1__WhatIsMyIPAddressRequest, _ns1__WhatIsMyIPAddressResponse &ns1__WhatIsMyIPAddressResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getChangePasswordHtmlUrlWithToken(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetChangePasswordHtmlUrlWithTokenRequest *ns1__GetChangePasswordHtmlUrlWithTokenRequest, _ns1__GetChangePasswordHtmlUrlWithTokenResponse &ns1__GetChangePasswordHtmlUrlWithTokenResponse);

#endif

/* End of soapStub.h */
