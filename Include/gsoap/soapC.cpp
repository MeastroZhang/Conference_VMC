/* soapC.cpp
   Generated by gSOAP 2.8.30 for WSVidyoUser.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.30 2016-05-09 02:26:05 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_dateTime:
		return soap_in_dateTime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE__ns1__RoomStatus:
		return soap_in__ns1__RoomStatus(soap, NULL, NULL, "ns1:RoomStatus");
	case SOAP_TYPE__ns1__MemberStatus:
		return soap_in__ns1__MemberStatus(soap, NULL, NULL, "ns1:MemberStatus");
	case SOAP_TYPE__ns1__MemberMode:
		return soap_in__ns1__MemberMode(soap, NULL, NULL, "ns1:MemberMode");
	case SOAP_TYPE__ns1__EntityType:
		return soap_in__ns1__EntityType(soap, NULL, NULL, "ns1:EntityType");
	case SOAP_TYPE__ns1__Language:
		return soap_in__ns1__Language(soap, NULL, NULL, "ns1:Language");
	case SOAP_TYPE__ns1__OK:
		return soap_in__ns1__OK(soap, NULL, NULL, "ns1:OK");
	case SOAP_TYPE__ns1__ClientType:
		return soap_in__ns1__ClientType(soap, NULL, NULL, "ns1:ClientType");
	case SOAP_TYPE_ns1__AccessOptionName:
		return soap_in_ns1__AccessOptionName(soap, NULL, NULL, "ns1:AccessOptionName");
	case SOAP_TYPE_ns1__sortDir:
		return soap_in_ns1__sortDir(soap, NULL, NULL, "ns1:sortDir");
	case SOAP_TYPE_ns1__RoomProfile:
		return soap_in_ns1__RoomProfile(soap, NULL, NULL, "ns1:RoomProfile");
	case SOAP_TYPE_ns1__Recorder:
		return soap_in_ns1__Recorder(soap, NULL, NULL, "ns1:Recorder");
	case SOAP_TYPE_PointerTo_ns1__GetChangePasswordHtmlUrlWithTokenRequest:
		return soap_in_PointerTo_ns1__GetChangePasswordHtmlUrlWithTokenRequest(soap, NULL, NULL, "ns1:GetChangePasswordHtmlUrlWithTokenRequest");
	case SOAP_TYPE_PointerTo_ns1__WhatIsMyIPAddressRequest:
		return soap_in_PointerTo_ns1__WhatIsMyIPAddressRequest(soap, NULL, NULL, "ns1:WhatIsMyIPAddressRequest");
	case SOAP_TYPE_PointerTo_ns1__GetVidyoReplayLibraryRequest:
		return soap_in_PointerTo_ns1__GetVidyoReplayLibraryRequest(soap, NULL, NULL, "ns1:GetVidyoReplayLibraryRequest");
	case SOAP_TYPE_PointerTo_ns1__RemovePresenterRequest:
		return soap_in_PointerTo_ns1__RemovePresenterRequest(soap, NULL, NULL, "ns1:RemovePresenterRequest");
	case SOAP_TYPE_PointerTo_ns1__SetPresenterRequest:
		return soap_in_PointerTo_ns1__SetPresenterRequest(soap, NULL, NULL, "ns1:SetPresenterRequest");
	case SOAP_TYPE_PointerTo_ns1__DismissAllRaisedHandRequest:
		return soap_in_PointerTo_ns1__DismissAllRaisedHandRequest(soap, NULL, NULL, "ns1:DismissAllRaisedHandRequest");
	case SOAP_TYPE_PointerTo_ns1__DismissRaisedHandRequest:
		return soap_in_PointerTo_ns1__DismissRaisedHandRequest(soap, NULL, NULL, "ns1:DismissRaisedHandRequest");
	case SOAP_TYPE_PointerTo_ns1__StopLectureModeRequest:
		return soap_in_PointerTo_ns1__StopLectureModeRequest(soap, NULL, NULL, "ns1:StopLectureModeRequest");
	case SOAP_TYPE_PointerTo_ns1__StartLectureModeRequest:
		return soap_in_PointerTo_ns1__StartLectureModeRequest(soap, NULL, NULL, "ns1:StartLectureModeRequest");
	case SOAP_TYPE_PointerTo_ns1__getUserAccountTypeRequest:
		return soap_in_PointerTo_ns1__getUserAccountTypeRequest(soap, NULL, NULL, "ns1:getUserAccountTypeRequest");
	case SOAP_TYPE_PointerTo_ns1__getLoginAndWelcomeBannerRequest:
		return soap_in_PointerTo_ns1__getLoginAndWelcomeBannerRequest(soap, NULL, NULL, "ns1:getLoginAndWelcomeBannerRequest");
	case SOAP_TYPE_PointerTo_ns1__RoomAccessOptionsRequest:
		return soap_in_PointerTo_ns1__RoomAccessOptionsRequest(soap, NULL, NULL, "ns1:RoomAccessOptionsRequest");
	case SOAP_TYPE_PointerTo_ns1__muteVideoClientAllRequest:
		return soap_in_PointerTo_ns1__muteVideoClientAllRequest(soap, NULL, NULL, "ns1:muteVideoClientAllRequest");
	case SOAP_TYPE_PointerTo_ns1__muteVideoServerAllRequest:
		return soap_in_PointerTo_ns1__muteVideoServerAllRequest(soap, NULL, NULL, "ns1:muteVideoServerAllRequest");
	case SOAP_TYPE_PointerTo_ns1__muteAudioClientAllRequest:
		return soap_in_PointerTo_ns1__muteAudioClientAllRequest(soap, NULL, NULL, "ns1:muteAudioClientAllRequest");
	case SOAP_TYPE_PointerTo_ns1__muteAudioServerAllRequest:
		return soap_in_PointerTo_ns1__muteAudioServerAllRequest(soap, NULL, NULL, "ns1:muteAudioServerAllRequest");
	case SOAP_TYPE_PointerTo_ns1__disconnectConferenceAllRequest:
		return soap_in_PointerTo_ns1__disconnectConferenceAllRequest(soap, NULL, NULL, "ns1:disconnectConferenceAllRequest");
	case SOAP_TYPE_PointerTo_ns1__SetEndpointDetailsRequest:
		return soap_in_PointerTo_ns1__SetEndpointDetailsRequest(soap, NULL, NULL, "ns1:SetEndpointDetailsRequest");
	case SOAP_TYPE_PointerTo_ns1__DeleteScheduledRoomRequest:
		return soap_in_PointerTo_ns1__DeleteScheduledRoomRequest(soap, NULL, NULL, "ns1:DeleteScheduledRoomRequest");
	case SOAP_TYPE_PointerTo_ns1__CreateScheduledRoomRequest:
		return soap_in_PointerTo_ns1__CreateScheduledRoomRequest(soap, NULL, NULL, "ns1:CreateScheduledRoomRequest");
	case SOAP_TYPE_PointerTo_ns1__GenerateAuthTokenRequest:
		return soap_in_PointerTo_ns1__GenerateAuthTokenRequest(soap, NULL, NULL, "ns1:GenerateAuthTokenRequest");
	case SOAP_TYPE_PointerTo_ns1__GetConferenceIDRequest:
		return soap_in_PointerTo_ns1__GetConferenceIDRequest(soap, NULL, NULL, "ns1:GetConferenceIDRequest");
	case SOAP_TYPE_PointerTo_ns1__RemoveModeratorPINRequest:
		return soap_in_PointerTo_ns1__RemoveModeratorPINRequest(soap, NULL, NULL, "ns1:RemoveModeratorPINRequest");
	case SOAP_TYPE_PointerTo_ns1__CreateModeratorPINRequest:
		return soap_in_PointerTo_ns1__CreateModeratorPINRequest(soap, NULL, NULL, "ns1:CreateModeratorPINRequest");
	case SOAP_TYPE_PointerTo_ns1__GetModeratorURLWithTokenRequest:
		return soap_in_PointerTo_ns1__GetModeratorURLWithTokenRequest(soap, NULL, NULL, "ns1:GetModeratorURLWithTokenRequest");
	case SOAP_TYPE_PointerTo_ns1__GetModeratorURLRequest:
		return soap_in_PointerTo_ns1__GetModeratorURLRequest(soap, NULL, NULL, "ns1:GetModeratorURLRequest");
	case SOAP_TYPE_PointerTo_ns1__RemoveModeratorURLRequest:
		return soap_in_PointerTo_ns1__RemoveModeratorURLRequest(soap, NULL, NULL, "ns1:RemoveModeratorURLRequest");
	case SOAP_TYPE_PointerTo_ns1__CreateModeratorURLRequest:
		return soap_in_PointerTo_ns1__CreateModeratorURLRequest(soap, NULL, NULL, "ns1:CreateModeratorURLRequest");
	case SOAP_TYPE_PointerTo_ns1__RemoveRoomProfileRequest:
		return soap_in_PointerTo_ns1__RemoveRoomProfileRequest(soap, NULL, NULL, "ns1:RemoveRoomProfileRequest");
	case SOAP_TYPE_PointerTo_ns1__SetRoomProfileRequest:
		return soap_in_PointerTo_ns1__SetRoomProfileRequest(soap, NULL, NULL, "ns1:SetRoomProfileRequest");
	case SOAP_TYPE_PointerTo_ns1__GetRoomProfileRequest:
		return soap_in_PointerTo_ns1__GetRoomProfileRequest(soap, NULL, NULL, "ns1:GetRoomProfileRequest");
	case SOAP_TYPE_PointerTo_ns1__GetInviteContentRequest:
		return soap_in_PointerTo_ns1__GetInviteContentRequest(soap, NULL, NULL, "ns1:GetInviteContentRequest");
	case SOAP_TYPE_PointerTo_ns1__GetEntityByRoomKeyRequest:
		return soap_in_PointerTo_ns1__GetEntityByRoomKeyRequest(soap, NULL, NULL, "ns1:GetEntityByRoomKeyRequest");
	case SOAP_TYPE_PointerTo_ns1__GetUserNameRequest:
		return soap_in_PointerTo_ns1__GetUserNameRequest(soap, NULL, NULL, "ns1:GetUserNameRequest");
	case SOAP_TYPE_PointerTo_ns1__GetWebcastURLRequest:
		return soap_in_PointerTo_ns1__GetWebcastURLRequest(soap, NULL, NULL, "ns1:GetWebcastURLRequest");
	case SOAP_TYPE_PointerTo_ns1__RemoveWebcastPINRequest:
		return soap_in_PointerTo_ns1__RemoveWebcastPINRequest(soap, NULL, NULL, "ns1:RemoveWebcastPINRequest");
	case SOAP_TYPE_PointerTo_ns1__RemoveWebcastURLRequest:
		return soap_in_PointerTo_ns1__RemoveWebcastURLRequest(soap, NULL, NULL, "ns1:RemoveWebcastURLRequest");
	case SOAP_TYPE_PointerTo_ns1__CreateWebcastPINRequest:
		return soap_in_PointerTo_ns1__CreateWebcastPINRequest(soap, NULL, NULL, "ns1:CreateWebcastPINRequest");
	case SOAP_TYPE_PointerTo_ns1__CreateWebcastURLRequest:
		return soap_in_PointerTo_ns1__CreateWebcastURLRequest(soap, NULL, NULL, "ns1:CreateWebcastURLRequest");
	case SOAP_TYPE_PointerTo_ns1__StopRecordingRequest:
		return soap_in_PointerTo_ns1__StopRecordingRequest(soap, NULL, NULL, "ns1:StopRecordingRequest");
	case SOAP_TYPE_PointerTo_ns1__ResumeRecordingRequest:
		return soap_in_PointerTo_ns1__ResumeRecordingRequest(soap, NULL, NULL, "ns1:ResumeRecordingRequest");
	case SOAP_TYPE_PointerTo_ns1__PauseRecordingRequest:
		return soap_in_PointerTo_ns1__PauseRecordingRequest(soap, NULL, NULL, "ns1:PauseRecordingRequest");
	case SOAP_TYPE_PointerTo_ns1__GetPortalVersionRequest:
		return soap_in_PointerTo_ns1__GetPortalVersionRequest(soap, NULL, NULL, "ns1:GetPortalVersionRequest");
	case SOAP_TYPE_PointerTo_ns1__StartRecordingRequest:
		return soap_in_PointerTo_ns1__StartRecordingRequest(soap, NULL, NULL, "ns1:StartRecordingRequest");
	case SOAP_TYPE_PointerTo_ns1__GetRecordingProfilesRequest:
		return soap_in_PointerTo_ns1__GetRecordingProfilesRequest(soap, NULL, NULL, "ns1:GetRecordingProfilesRequest");
	case SOAP_TYPE_PointerTo_ns1__SetMemberModeRequest:
		return soap_in_PointerTo_ns1__SetMemberModeRequest(soap, NULL, NULL, "ns1:SetMemberModeRequest");
	case SOAP_TYPE_PointerTo_ns1__UnlockRoomRequest:
		return soap_in_PointerTo_ns1__UnlockRoomRequest(soap, NULL, NULL, "ns1:UnlockRoomRequest");
	case SOAP_TYPE_PointerTo_ns1__LockRoomRequest:
		return soap_in_PointerTo_ns1__LockRoomRequest(soap, NULL, NULL, "ns1:LockRoomRequest");
	case SOAP_TYPE_PointerTo_ns1__UpdateLanguageRequest:
		return soap_in_PointerTo_ns1__UpdateLanguageRequest(soap, NULL, NULL, "ns1:UpdateLanguageRequest");
	case SOAP_TYPE_PointerTo_ns1__UpdatePasswordRequest:
		return soap_in_PointerTo_ns1__UpdatePasswordRequest(soap, NULL, NULL, "ns1:UpdatePasswordRequest");
	case SOAP_TYPE_PointerTo_ns1__DeleteRoomRequest:
		return soap_in_PointerTo_ns1__DeleteRoomRequest(soap, NULL, NULL, "ns1:DeleteRoomRequest");
	case SOAP_TYPE_PointerTo_ns1__CreateRoomRequest:
		return soap_in_PointerTo_ns1__CreateRoomRequest(soap, NULL, NULL, "ns1:CreateRoomRequest");
	case SOAP_TYPE_PointerTo_ns1__RemoveRoomPINRequest:
		return soap_in_PointerTo_ns1__RemoveRoomPINRequest(soap, NULL, NULL, "ns1:RemoveRoomPINRequest");
	case SOAP_TYPE_PointerTo_ns1__CreateRoomPINRequest:
		return soap_in_PointerTo_ns1__CreateRoomPINRequest(soap, NULL, NULL, "ns1:CreateRoomPINRequest");
	case SOAP_TYPE_PointerTo_ns1__RemoveRoomURLRequest:
		return soap_in_PointerTo_ns1__RemoveRoomURLRequest(soap, NULL, NULL, "ns1:RemoveRoomURLRequest");
	case SOAP_TYPE_PointerTo_ns1__CreateRoomURLRequest:
		return soap_in_PointerTo_ns1__CreateRoomURLRequest(soap, NULL, NULL, "ns1:CreateRoomURLRequest");
	case SOAP_TYPE_PointerTo_ns1__MyAccountRequest:
		return soap_in_PointerTo_ns1__MyAccountRequest(soap, NULL, NULL, "ns1:MyAccountRequest");
	case SOAP_TYPE_PointerTo_ns1__StopVideoRequest:
		return soap_in_PointerTo_ns1__StopVideoRequest(soap, NULL, NULL, "ns1:StopVideoRequest");
	case SOAP_TYPE_PointerTo_ns1__StartVideoRequest:
		return soap_in_PointerTo_ns1__StartVideoRequest(soap, NULL, NULL, "ns1:StartVideoRequest");
	case SOAP_TYPE_PointerTo_ns1__UnmuteAudioRequest:
		return soap_in_PointerTo_ns1__UnmuteAudioRequest(soap, NULL, NULL, "ns1:UnmuteAudioRequest");
	case SOAP_TYPE_PointerTo_ns1__MuteAudioRequest:
		return soap_in_PointerTo_ns1__MuteAudioRequest(soap, NULL, NULL, "ns1:MuteAudioRequest");
	case SOAP_TYPE_PointerTo_ns1__LeaveConferenceRequest:
		return soap_in_PointerTo_ns1__LeaveConferenceRequest(soap, NULL, NULL, "ns1:LeaveConferenceRequest");
	case SOAP_TYPE_PointerTo_ns1__GetLectureModeParticipantsRequest:
		return soap_in_PointerTo_ns1__GetLectureModeParticipantsRequest(soap, NULL, NULL, "ns1:GetLectureModeParticipantsRequest");
	case SOAP_TYPE_PointerTo_ns1__GetParticipantsRequest:
		return soap_in_PointerTo_ns1__GetParticipantsRequest(soap, NULL, NULL, "ns1:GetParticipantsRequest");
	case SOAP_TYPE_PointerTo_ns1__DirectCallRequest:
		return soap_in_PointerTo_ns1__DirectCallRequest(soap, NULL, NULL, "ns1:DirectCallRequest");
	case SOAP_TYPE_PointerTo_ns1__JoinIPCConferenceRequest:
		return soap_in_PointerTo_ns1__JoinIPCConferenceRequest(soap, NULL, NULL, "ns1:JoinIPCConferenceRequest");
	case SOAP_TYPE_PointerTo_ns1__JoinConferenceRequest:
		return soap_in_PointerTo_ns1__JoinConferenceRequest(soap, NULL, NULL, "ns1:JoinConferenceRequest");
	case SOAP_TYPE_PointerTo_ns1__CancelOutboundCallRequest:
		return soap_in_PointerTo_ns1__CancelOutboundCallRequest(soap, NULL, NULL, "ns1:CancelOutboundCallRequest");
	case SOAP_TYPE_PointerTo_ns1__InviteToConferenceRequest:
		return soap_in_PointerTo_ns1__InviteToConferenceRequest(soap, NULL, NULL, "ns1:InviteToConferenceRequest");
	case SOAP_TYPE_PointerTo_ns1__GetEntityByEntityIDRequest:
		return soap_in_PointerTo_ns1__GetEntityByEntityIDRequest(soap, NULL, NULL, "ns1:GetEntityByEntityIDRequest");
	case SOAP_TYPE_PointerTo_ns1__SearchByEmailRequest:
		return soap_in_PointerTo_ns1__SearchByEmailRequest(soap, NULL, NULL, "ns1:SearchByEmailRequest");
	case SOAP_TYPE_PointerTo_ns1__SearchByEntityIDRequest:
		return soap_in_PointerTo_ns1__SearchByEntityIDRequest(soap, NULL, NULL, "ns1:SearchByEntityIDRequest");
	case SOAP_TYPE_PointerTo_ns1__SearchRequest:
		return soap_in_PointerTo_ns1__SearchRequest(soap, NULL, NULL, "ns1:SearchRequest");
	case SOAP_TYPE_PointerTo_ns1__RemoveFromMyContactsRequest:
		return soap_in_PointerTo_ns1__RemoveFromMyContactsRequest(soap, NULL, NULL, "ns1:RemoveFromMyContactsRequest");
	case SOAP_TYPE_PointerTo_ns1__AddToMyContactsRequest:
		return soap_in_PointerTo_ns1__AddToMyContactsRequest(soap, NULL, NULL, "ns1:AddToMyContactsRequest");
	case SOAP_TYPE_PointerTo_ns1__SearchMyContactsRequest:
		return soap_in_PointerTo_ns1__SearchMyContactsRequest(soap, NULL, NULL, "ns1:SearchMyContactsRequest");
	case SOAP_TYPE_PointerTo_ns1__MyEndpointStatusRequest:
		return soap_in_PointerTo_ns1__MyEndpointStatusRequest(soap, NULL, NULL, "ns1:MyEndpointStatusRequest");
	case SOAP_TYPE_PointerTo_ns1__LogOutRequest:
		return soap_in_PointerTo_ns1__LogOutRequest(soap, NULL, NULL, "ns1:LogOutRequest");
	case SOAP_TYPE_PointerTo_ns1__LinkEndpointRequest:
		return soap_in_PointerTo_ns1__LinkEndpointRequest(soap, NULL, NULL, "ns1:LinkEndpointRequest");
	case SOAP_TYPE_PointerTo_ns1__LogInRequest:
		return soap_in_PointerTo_ns1__LogInRequest(soap, NULL, NULL, "ns1:LogInRequest");
	case SOAP_TYPE_PointerTo_ns1__WrongPINFault:
		return soap_in_PointerTo_ns1__WrongPINFault(soap, NULL, NULL, "ns1:WrongPINFault");
	case SOAP_TYPE_PointerTo_ns1__VidyoReplayNotAvailableFault:
		return soap_in_PointerTo_ns1__VidyoReplayNotAvailableFault(soap, NULL, NULL, "ns1:VidyoReplayNotAvailableFault");
	case SOAP_TYPE_PointerTo_ns1__SeatLicenseExpiredFault:
		return soap_in_PointerTo_ns1__SeatLicenseExpiredFault(soap, NULL, NULL, "ns1:SeatLicenseExpiredFault");
	case SOAP_TYPE_PointerTo_ns1__ScheduledRoomCreationFault:
		return soap_in_PointerTo_ns1__ScheduledRoomCreationFault(soap, NULL, NULL, "ns1:ScheduledRoomCreationFault");
	case SOAP_TYPE_PointerTo_ns1__RoomNotFoundFault:
		return soap_in_PointerTo_ns1__RoomNotFoundFault(soap, NULL, NULL, "ns1:RoomNotFoundFault");
	case SOAP_TYPE_PointerTo_ns1__ResourceNotAvailableFault:
		return soap_in_PointerTo_ns1__ResourceNotAvailableFault(soap, NULL, NULL, "ns1:ResourceNotAvailableFault");
	case SOAP_TYPE_PointerTo_ns1__PrefixNotConfiguredFault:
		return soap_in_PointerTo_ns1__PrefixNotConfiguredFault(soap, NULL, NULL, "ns1:PrefixNotConfiguredFault");
	case SOAP_TYPE_PointerTo_ns1__NotLicensedFault:
		return soap_in_PointerTo_ns1__NotLicensedFault(soap, NULL, NULL, "ns1:NotLicensedFault");
	case SOAP_TYPE_PointerTo_ns1__InvalidModeratorPINFormatFault:
		return soap_in_PointerTo_ns1__InvalidModeratorPINFormatFault(soap, NULL, NULL, "ns1:InvalidModeratorPINFormatFault");
	case SOAP_TYPE_PointerTo_ns1__InvalidArgumentFault:
		return soap_in_PointerTo_ns1__InvalidArgumentFault(soap, NULL, NULL, "ns1:InvalidArgumentFault");
	case SOAP_TYPE_PointerTo_ns1__InPointToPointCallFault:
		return soap_in_PointerTo_ns1__InPointToPointCallFault(soap, NULL, NULL, "ns1:InPointToPointCallFault");
	case SOAP_TYPE_PointerTo_ns1__GeneralFault:
		return soap_in_PointerTo_ns1__GeneralFault(soap, NULL, NULL, "ns1:GeneralFault");
	case SOAP_TYPE_PointerTo_ns1__FeatureNotAvailableFault:
		return soap_in_PointerTo_ns1__FeatureNotAvailableFault(soap, NULL, NULL, "ns1:FeatureNotAvailableFault");
	case SOAP_TYPE_PointerTo_ns1__EndpointNotBoundFault:
		return soap_in_PointerTo_ns1__EndpointNotBoundFault(soap, NULL, NULL, "ns1:EndpointNotBoundFault");
	case SOAP_TYPE_PointerTo_ns1__ControlMeetingFault:
		return soap_in_PointerTo_ns1__ControlMeetingFault(soap, NULL, NULL, "ns1:ControlMeetingFault");
	case SOAP_TYPE_PointerTo_ns1__ConferenceLockedFault:
		return soap_in_PointerTo_ns1__ConferenceLockedFault(soap, NULL, NULL, "ns1:ConferenceLockedFault");
	case SOAP_TYPE_PointerTo_ns1__AccessRestrictedFault:
		return soap_in_PointerTo_ns1__AccessRestrictedFault(soap, NULL, NULL, "ns1:AccessRestrictedFault");
	case SOAP_TYPE_PointerTo_ns1__WelcomeBannerContent:
		return soap_in_PointerTo_ns1__WelcomeBannerContent(soap, NULL, NULL, "ns1:WelcomeBannerContent");
	case SOAP_TYPE_PointerToPointerTo_ns1__RoomAccessOption:
		return soap_in_PointerToPointerTo_ns1__RoomAccessOption(soap, NULL, NULL, "ns1:RoomAccessOption");
	case SOAP_TYPE_PointerTo_ns1__RoomAccessOption:
		return soap_in_PointerTo_ns1__RoomAccessOption(soap, NULL, NULL, "ns1:RoomAccessOption");
	case SOAP_TYPE_PointerToPointerTo_ns1__EndpointFeature:
		return soap_in_PointerToPointerTo_ns1__EndpointFeature(soap, NULL, NULL, "ns1:EndpointFeature");
	case SOAP_TYPE_PointerTo_ns1__EndpointFeature:
		return soap_in_PointerTo_ns1__EndpointFeature(soap, NULL, NULL, "ns1:EndpointFeature");
	case SOAP_TYPE_PointerToPointerTo_ns1__PortalFeature:
		return soap_in_PointerToPointerTo_ns1__PortalFeature(soap, NULL, NULL, "ns1:PortalFeature");
	case SOAP_TYPE_PointerTo_ns1__PortalFeature:
		return soap_in_PointerTo_ns1__PortalFeature(soap, NULL, NULL, "ns1:PortalFeature");
	case SOAP_TYPE_PointerTostring:
		return soap_in_PointerTostring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerToPointerTons1__RoomProfile:
		return soap_in_PointerToPointerTons1__RoomProfile(soap, NULL, NULL, "ns1:RoomProfile");
	case SOAP_TYPE_PointerTons1__RoomProfile:
		return soap_in_PointerTons1__RoomProfile(soap, NULL, NULL, "ns1:RoomProfile");
	case SOAP_TYPE_PointerToPointerTons1__Recorder:
		return soap_in_PointerToPointerTons1__Recorder(soap, NULL, NULL, "ns1:Recorder");
	case SOAP_TYPE_PointerTons1__Recorder:
		return soap_in_PointerTons1__Recorder(soap, NULL, NULL, "ns1:Recorder");
	case SOAP_TYPE_PointerToPointerTo_ns1__LectureModeParticipant:
		return soap_in_PointerToPointerTo_ns1__LectureModeParticipant(soap, NULL, NULL, "ns1:LectureModeParticipant");
	case SOAP_TYPE_PointerTo_ns1__LectureModeParticipant:
		return soap_in_PointerTo_ns1__LectureModeParticipant(soap, NULL, NULL, "ns1:LectureModeParticipant");
	case SOAP_TYPE_PointerTons1__EntityID:
		return soap_in_PointerTons1__EntityID(soap, NULL, NULL, "ns1:EntityID");
	case SOAP_TYPE_PointerToPointerTo_ns1__Entity:
		return soap_in_PointerToPointerTo_ns1__Entity(soap, NULL, NULL, "ns1:Entity");
	case SOAP_TYPE_PointerTo_ns1__Filter:
		return soap_in_PointerTo_ns1__Filter(soap, NULL, NULL, "ns1:Filter");
	case SOAP_TYPE_PointerTo_ns1__Entity:
		return soap_in_PointerTo_ns1__Entity(soap, NULL, NULL, "ns1:Entity");
	case SOAP_TYPE_PointerTo_ns1__ClientType:
		return soap_in_PointerTo_ns1__ClientType(soap, NULL, NULL, "ns1:ClientType");
	case SOAP_TYPE_PointerTodateTime:
		return soap_in_PointerTodateTime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerToPointerTo_ns1__LoginAttempt:
		return soap_in_PointerToPointerTo_ns1__LoginAttempt(soap, NULL, NULL, "ns1:LoginAttempt");
	case SOAP_TYPE_PointerTo_ns1__LoginAttempt:
		return soap_in_PointerTo_ns1__LoginAttempt(soap, NULL, NULL, "ns1:LoginAttempt");
	case SOAP_TYPE_PointerTo_ns1__RoomMode:
		return soap_in_PointerTo_ns1__RoomMode(soap, NULL, NULL, "ns1:RoomMode");
	case SOAP_TYPE_PointerTo_ns1__RoomStatus:
		return soap_in_PointerTo_ns1__RoomStatus(soap, NULL, NULL, "ns1:RoomStatus");
	case SOAP_TYPE_PointerTo_ns1__MemberMode:
		return soap_in_PointerTo_ns1__MemberMode(soap, NULL, NULL, "ns1:MemberMode");
	case SOAP_TYPE_PointerTo_ns1__MemberStatus:
		return soap_in_PointerTo_ns1__MemberStatus(soap, NULL, NULL, "ns1:MemberStatus");
	case SOAP_TYPE_PointerTo_ns1__Language:
		return soap_in_PointerTo_ns1__Language(soap, NULL, NULL, "ns1:Language");
	case SOAP_TYPE_PointerTo_ns1__EntityType:
		return soap_in_PointerTo_ns1__EntityType(soap, NULL, NULL, "ns1:EntityType");
	case SOAP_TYPE_PointerTons1__sortDir:
		return soap_in_PointerTons1__sortDir(soap, NULL, NULL, "ns1:sortDir");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerTobool:
		return soap_in_PointerTobool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns1__EndpointFeatureName:
	{	char **s;
		s = soap_in_ns1__EndpointFeatureName(soap, NULL, NULL, "ns1:EndpointFeatureName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ns1__PortalFeatureName:
	{	char **s;
		s = soap_in_ns1__PortalFeatureName(soap, NULL, NULL, "ns1:PortalFeatureName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ns1__EntityID:
	{	char **s;
		s = soap_in_ns1__EntityID(soap, NULL, NULL, "ns1:EntityID");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__anyURI:
	{	char **s;
		s = soap_in_xsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
		return s ? *s : NULL;
	}
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:RoomProfile"))
		{	*type = SOAP_TYPE_ns1__RoomProfile;
			return soap_in_ns1__RoomProfile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Recorder"))
		{	*type = SOAP_TYPE_ns1__Recorder;
			return soap_in_ns1__Recorder(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_dateTime;
			return soap_in_dateTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RoomStatus"))
		{	*type = SOAP_TYPE__ns1__RoomStatus;
			return soap_in__ns1__RoomStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MemberStatus"))
		{	*type = SOAP_TYPE__ns1__MemberStatus;
			return soap_in__ns1__MemberStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MemberMode"))
		{	*type = SOAP_TYPE__ns1__MemberMode;
			return soap_in__ns1__MemberMode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:EntityType"))
		{	*type = SOAP_TYPE__ns1__EntityType;
			return soap_in__ns1__EntityType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Language"))
		{	*type = SOAP_TYPE__ns1__Language;
			return soap_in__ns1__Language(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OK"))
		{	*type = SOAP_TYPE__ns1__OK;
			return soap_in__ns1__OK(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ClientType"))
		{	*type = SOAP_TYPE__ns1__ClientType;
			return soap_in__ns1__ClientType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AccessOptionName"))
		{	*type = SOAP_TYPE_ns1__AccessOptionName;
			return soap_in_ns1__AccessOptionName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:sortDir"))
		{	*type = SOAP_TYPE_ns1__sortDir;
			return soap_in_ns1__sortDir(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:EndpointFeatureName"))
		{	char **s;
			*type = SOAP_TYPE_ns1__EndpointFeatureName;
			s = soap_in_ns1__EndpointFeatureName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "ns1:PortalFeatureName"))
		{	char **s;
			*type = SOAP_TYPE_ns1__PortalFeatureName;
			s = soap_in_ns1__PortalFeatureName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "ns1:EntityID"))
		{	char **s;
			*type = SOAP_TYPE_ns1__EntityID;
			s = soap_in_ns1__EntityID(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	char **s;
			*type = SOAP_TYPE_xsd__anyURI;
			s = soap_in_xsd__anyURI(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:GetChangePasswordHtmlUrlWithTokenResponse"))
		{	*type = SOAP_TYPE__ns1__GetChangePasswordHtmlUrlWithTokenResponse;
			return soap_in__ns1__GetChangePasswordHtmlUrlWithTokenResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetChangePasswordHtmlUrlWithTokenRequest"))
		{	*type = SOAP_TYPE__ns1__GetChangePasswordHtmlUrlWithTokenRequest;
			return soap_in__ns1__GetChangePasswordHtmlUrlWithTokenRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:WhatIsMyIPAddressResponse"))
		{	*type = SOAP_TYPE__ns1__WhatIsMyIPAddressResponse;
			return soap_in__ns1__WhatIsMyIPAddressResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:WhatIsMyIPAddressRequest"))
		{	*type = SOAP_TYPE__ns1__WhatIsMyIPAddressRequest;
			return soap_in__ns1__WhatIsMyIPAddressRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetVidyoReplayLibraryResponse"))
		{	*type = SOAP_TYPE__ns1__GetVidyoReplayLibraryResponse;
			return soap_in__ns1__GetVidyoReplayLibraryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetVidyoReplayLibraryRequest"))
		{	*type = SOAP_TYPE__ns1__GetVidyoReplayLibraryRequest;
			return soap_in__ns1__GetVidyoReplayLibraryRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RemovePresenterResponse"))
		{	*type = SOAP_TYPE__ns1__RemovePresenterResponse;
			return soap_in__ns1__RemovePresenterResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RemovePresenterRequest"))
		{	*type = SOAP_TYPE__ns1__RemovePresenterRequest;
			return soap_in__ns1__RemovePresenterRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetPresenterResponse"))
		{	*type = SOAP_TYPE__ns1__SetPresenterResponse;
			return soap_in__ns1__SetPresenterResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetPresenterRequest"))
		{	*type = SOAP_TYPE__ns1__SetPresenterRequest;
			return soap_in__ns1__SetPresenterRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DismissAllRaisedHandResponse"))
		{	*type = SOAP_TYPE__ns1__DismissAllRaisedHandResponse;
			return soap_in__ns1__DismissAllRaisedHandResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DismissAllRaisedHandRequest"))
		{	*type = SOAP_TYPE__ns1__DismissAllRaisedHandRequest;
			return soap_in__ns1__DismissAllRaisedHandRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DismissRaisedHandResponse"))
		{	*type = SOAP_TYPE__ns1__DismissRaisedHandResponse;
			return soap_in__ns1__DismissRaisedHandResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DismissRaisedHandRequest"))
		{	*type = SOAP_TYPE__ns1__DismissRaisedHandRequest;
			return soap_in__ns1__DismissRaisedHandRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UnraiseHandResponse"))
		{	*type = SOAP_TYPE__ns1__UnraiseHandResponse;
			return soap_in__ns1__UnraiseHandResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RaiseHandResponse"))
		{	*type = SOAP_TYPE__ns1__RaiseHandResponse;
			return soap_in__ns1__RaiseHandResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StopLectureModeResponse"))
		{	*type = SOAP_TYPE__ns1__StopLectureModeResponse;
			return soap_in__ns1__StopLectureModeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StopLectureModeRequest"))
		{	*type = SOAP_TYPE__ns1__StopLectureModeRequest;
			return soap_in__ns1__StopLectureModeRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StartLectureModeResponse"))
		{	*type = SOAP_TYPE__ns1__StartLectureModeResponse;
			return soap_in__ns1__StartLectureModeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StartLectureModeRequest"))
		{	*type = SOAP_TYPE__ns1__StartLectureModeRequest;
			return soap_in__ns1__StartLectureModeRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getUserAccountTypeResponse"))
		{	*type = SOAP_TYPE__ns1__getUserAccountTypeResponse;
			return soap_in__ns1__getUserAccountTypeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getUserAccountTypeRequest"))
		{	*type = SOAP_TYPE__ns1__getUserAccountTypeRequest;
			return soap_in__ns1__getUserAccountTypeRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getLoginAndWelcomeBannerResponse"))
		{	*type = SOAP_TYPE__ns1__getLoginAndWelcomeBannerResponse;
			return soap_in__ns1__getLoginAndWelcomeBannerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getLoginAndWelcomeBannerRequest"))
		{	*type = SOAP_TYPE__ns1__getLoginAndWelcomeBannerRequest;
			return soap_in__ns1__getLoginAndWelcomeBannerRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PrefixNotConfiguredFault"))
		{	*type = SOAP_TYPE__ns1__PrefixNotConfiguredFault;
			return soap_in__ns1__PrefixNotConfiguredFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PortalPrefixResponse"))
		{	*type = SOAP_TYPE__ns1__PortalPrefixResponse;
			return soap_in__ns1__PortalPrefixResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RoomAccessOptionsResponse"))
		{	*type = SOAP_TYPE__ns1__RoomAccessOptionsResponse;
			return soap_in__ns1__RoomAccessOptionsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RoomAccessOptionsRequest"))
		{	*type = SOAP_TYPE__ns1__RoomAccessOptionsRequest;
			return soap_in__ns1__RoomAccessOptionsRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RoomAccessOption"))
		{	*type = SOAP_TYPE__ns1__RoomAccessOption;
			return soap_in__ns1__RoomAccessOption(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OnetimeAccessResponse"))
		{	*type = SOAP_TYPE__ns1__OnetimeAccessResponse;
			return soap_in__ns1__OnetimeAccessResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:muteVideoClientAllResponse"))
		{	*type = SOAP_TYPE__ns1__muteVideoClientAllResponse;
			return soap_in__ns1__muteVideoClientAllResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:muteVideoClientAllRequest"))
		{	*type = SOAP_TYPE__ns1__muteVideoClientAllRequest;
			return soap_in__ns1__muteVideoClientAllRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:muteVideoServerAllResponse"))
		{	*type = SOAP_TYPE__ns1__muteVideoServerAllResponse;
			return soap_in__ns1__muteVideoServerAllResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:muteVideoServerAllRequest"))
		{	*type = SOAP_TYPE__ns1__muteVideoServerAllRequest;
			return soap_in__ns1__muteVideoServerAllRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:muteAudioClientAllResponse"))
		{	*type = SOAP_TYPE__ns1__muteAudioClientAllResponse;
			return soap_in__ns1__muteAudioClientAllResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:muteAudioClientAllRequest"))
		{	*type = SOAP_TYPE__ns1__muteAudioClientAllRequest;
			return soap_in__ns1__muteAudioClientAllRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:muteAudioServerAllResponse"))
		{	*type = SOAP_TYPE__ns1__muteAudioServerAllResponse;
			return soap_in__ns1__muteAudioServerAllResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:muteAudioServerAllRequest"))
		{	*type = SOAP_TYPE__ns1__muteAudioServerAllRequest;
			return soap_in__ns1__muteAudioServerAllRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:disconnectConferenceAllResponse"))
		{	*type = SOAP_TYPE__ns1__disconnectConferenceAllResponse;
			return soap_in__ns1__disconnectConferenceAllResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:disconnectConferenceAllRequest"))
		{	*type = SOAP_TYPE__ns1__disconnectConferenceAllRequest;
			return soap_in__ns1__disconnectConferenceAllRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LogoutAllOtherSessionsResponse"))
		{	*type = SOAP_TYPE__ns1__LogoutAllOtherSessionsResponse;
			return soap_in__ns1__LogoutAllOtherSessionsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetActiveSessionsResponse"))
		{	*type = SOAP_TYPE__ns1__GetActiveSessionsResponse;
			return soap_in__ns1__GetActiveSessionsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetEndpointDetailsResponse"))
		{	*type = SOAP_TYPE__ns1__SetEndpointDetailsResponse;
			return soap_in__ns1__SetEndpointDetailsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetEndpointDetailsRequest"))
		{	*type = SOAP_TYPE__ns1__SetEndpointDetailsRequest;
			return soap_in__ns1__SetEndpointDetailsRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:EndpointFeature"))
		{	*type = SOAP_TYPE__ns1__EndpointFeature;
			return soap_in__ns1__EndpointFeature(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPortalFeaturesResponse"))
		{	*type = SOAP_TYPE__ns1__GetPortalFeaturesResponse;
			return soap_in__ns1__GetPortalFeaturesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PortalFeature"))
		{	*type = SOAP_TYPE__ns1__PortalFeature;
			return soap_in__ns1__PortalFeature(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeleteScheduledRoomResponse"))
		{	*type = SOAP_TYPE__ns1__DeleteScheduledRoomResponse;
			return soap_in__ns1__DeleteScheduledRoomResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeleteScheduledRoomRequest"))
		{	*type = SOAP_TYPE__ns1__DeleteScheduledRoomRequest;
			return soap_in__ns1__DeleteScheduledRoomRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CreateScheduledRoomResponse"))
		{	*type = SOAP_TYPE__ns1__CreateScheduledRoomResponse;
			return soap_in__ns1__CreateScheduledRoomResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CreateScheduledRoomRequest"))
		{	*type = SOAP_TYPE__ns1__CreateScheduledRoomRequest;
			return soap_in__ns1__CreateScheduledRoomRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GenerateAuthTokenResponse"))
		{	*type = SOAP_TYPE__ns1__GenerateAuthTokenResponse;
			return soap_in__ns1__GenerateAuthTokenResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GenerateAuthTokenRequest"))
		{	*type = SOAP_TYPE__ns1__GenerateAuthTokenRequest;
			return soap_in__ns1__GenerateAuthTokenRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetConferenceIDResponse"))
		{	*type = SOAP_TYPE__ns1__GetConferenceIDResponse;
			return soap_in__ns1__GetConferenceIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetConferenceIDRequest"))
		{	*type = SOAP_TYPE__ns1__GetConferenceIDRequest;
			return soap_in__ns1__GetConferenceIDRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RemoveModeratorPINResponse"))
		{	*type = SOAP_TYPE__ns1__RemoveModeratorPINResponse;
			return soap_in__ns1__RemoveModeratorPINResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RemoveModeratorPINRequest"))
		{	*type = SOAP_TYPE__ns1__RemoveModeratorPINRequest;
			return soap_in__ns1__RemoveModeratorPINRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CreateModeratorPINResponse"))
		{	*type = SOAP_TYPE__ns1__CreateModeratorPINResponse;
			return soap_in__ns1__CreateModeratorPINResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CreateModeratorPINRequest"))
		{	*type = SOAP_TYPE__ns1__CreateModeratorPINRequest;
			return soap_in__ns1__CreateModeratorPINRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetModeratorURLWithTokenResponse"))
		{	*type = SOAP_TYPE__ns1__GetModeratorURLWithTokenResponse;
			return soap_in__ns1__GetModeratorURLWithTokenResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetModeratorURLWithTokenRequest"))
		{	*type = SOAP_TYPE__ns1__GetModeratorURLWithTokenRequest;
			return soap_in__ns1__GetModeratorURLWithTokenRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetModeratorURLResponse"))
		{	*type = SOAP_TYPE__ns1__GetModeratorURLResponse;
			return soap_in__ns1__GetModeratorURLResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetModeratorURLRequest"))
		{	*type = SOAP_TYPE__ns1__GetModeratorURLRequest;
			return soap_in__ns1__GetModeratorURLRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RemoveModeratorURLResponse"))
		{	*type = SOAP_TYPE__ns1__RemoveModeratorURLResponse;
			return soap_in__ns1__RemoveModeratorURLResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RemoveModeratorURLRequest"))
		{	*type = SOAP_TYPE__ns1__RemoveModeratorURLRequest;
			return soap_in__ns1__RemoveModeratorURLRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CreateModeratorURLResponse"))
		{	*type = SOAP_TYPE__ns1__CreateModeratorURLResponse;
			return soap_in__ns1__CreateModeratorURLResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CreateModeratorURLRequest"))
		{	*type = SOAP_TYPE__ns1__CreateModeratorURLRequest;
			return soap_in__ns1__CreateModeratorURLRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RemoveRoomProfileResponse"))
		{	*type = SOAP_TYPE__ns1__RemoveRoomProfileResponse;
			return soap_in__ns1__RemoveRoomProfileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RemoveRoomProfileRequest"))
		{	*type = SOAP_TYPE__ns1__RemoveRoomProfileRequest;
			return soap_in__ns1__RemoveRoomProfileRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetRoomProfileResponse"))
		{	*type = SOAP_TYPE__ns1__SetRoomProfileResponse;
			return soap_in__ns1__SetRoomProfileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetRoomProfileRequest"))
		{	*type = SOAP_TYPE__ns1__SetRoomProfileRequest;
			return soap_in__ns1__SetRoomProfileRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetRoomProfileResponse"))
		{	*type = SOAP_TYPE__ns1__GetRoomProfileResponse;
			return soap_in__ns1__GetRoomProfileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetRoomProfileRequest"))
		{	*type = SOAP_TYPE__ns1__GetRoomProfileRequest;
			return soap_in__ns1__GetRoomProfileRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetRoomProfilesResponse"))
		{	*type = SOAP_TYPE__ns1__GetRoomProfilesResponse;
			return soap_in__ns1__GetRoomProfilesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetInviteContentResponse"))
		{	*type = SOAP_TYPE__ns1__GetInviteContentResponse;
			return soap_in__ns1__GetInviteContentResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetInviteContentRequest"))
		{	*type = SOAP_TYPE__ns1__GetInviteContentRequest;
			return soap_in__ns1__GetInviteContentRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetEntityByRoomKeyResponse"))
		{	*type = SOAP_TYPE__ns1__GetEntityByRoomKeyResponse;
			return soap_in__ns1__GetEntityByRoomKeyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetEntityByRoomKeyRequest"))
		{	*type = SOAP_TYPE__ns1__GetEntityByRoomKeyRequest;
			return soap_in__ns1__GetEntityByRoomKeyRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetUserNameResponse"))
		{	*type = SOAP_TYPE__ns1__GetUserNameResponse;
			return soap_in__ns1__GetUserNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetUserNameRequest"))
		{	*type = SOAP_TYPE__ns1__GetUserNameRequest;
			return soap_in__ns1__GetUserNameRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetWebcastURLResponse"))
		{	*type = SOAP_TYPE__ns1__GetWebcastURLResponse;
			return soap_in__ns1__GetWebcastURLResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetWebcastURLRequest"))
		{	*type = SOAP_TYPE__ns1__GetWebcastURLRequest;
			return soap_in__ns1__GetWebcastURLRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RemoveWebcastPINResponse"))
		{	*type = SOAP_TYPE__ns1__RemoveWebcastPINResponse;
			return soap_in__ns1__RemoveWebcastPINResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RemoveWebcastPINRequest"))
		{	*type = SOAP_TYPE__ns1__RemoveWebcastPINRequest;
			return soap_in__ns1__RemoveWebcastPINRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RemoveWebcastURLResponse"))
		{	*type = SOAP_TYPE__ns1__RemoveWebcastURLResponse;
			return soap_in__ns1__RemoveWebcastURLResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RemoveWebcastURLRequest"))
		{	*type = SOAP_TYPE__ns1__RemoveWebcastURLRequest;
			return soap_in__ns1__RemoveWebcastURLRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CreateWebcastPINResponse"))
		{	*type = SOAP_TYPE__ns1__CreateWebcastPINResponse;
			return soap_in__ns1__CreateWebcastPINResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CreateWebcastPINRequest"))
		{	*type = SOAP_TYPE__ns1__CreateWebcastPINRequest;
			return soap_in__ns1__CreateWebcastPINRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CreateWebcastURLResponse"))
		{	*type = SOAP_TYPE__ns1__CreateWebcastURLResponse;
			return soap_in__ns1__CreateWebcastURLResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CreateWebcastURLRequest"))
		{	*type = SOAP_TYPE__ns1__CreateWebcastURLRequest;
			return soap_in__ns1__CreateWebcastURLRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StopRecordingResponse"))
		{	*type = SOAP_TYPE__ns1__StopRecordingResponse;
			return soap_in__ns1__StopRecordingResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StopRecordingRequest"))
		{	*type = SOAP_TYPE__ns1__StopRecordingRequest;
			return soap_in__ns1__StopRecordingRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ResumeRecordingResponse"))
		{	*type = SOAP_TYPE__ns1__ResumeRecordingResponse;
			return soap_in__ns1__ResumeRecordingResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ResumeRecordingRequest"))
		{	*type = SOAP_TYPE__ns1__ResumeRecordingRequest;
			return soap_in__ns1__ResumeRecordingRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PauseRecordingResponse"))
		{	*type = SOAP_TYPE__ns1__PauseRecordingResponse;
			return soap_in__ns1__PauseRecordingResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PauseRecordingRequest"))
		{	*type = SOAP_TYPE__ns1__PauseRecordingRequest;
			return soap_in__ns1__PauseRecordingRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPortalVersionResponse"))
		{	*type = SOAP_TYPE__ns1__GetPortalVersionResponse;
			return soap_in__ns1__GetPortalVersionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPortalVersionRequest"))
		{	*type = SOAP_TYPE__ns1__GetPortalVersionRequest;
			return soap_in__ns1__GetPortalVersionRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StartRecordingResponse"))
		{	*type = SOAP_TYPE__ns1__StartRecordingResponse;
			return soap_in__ns1__StartRecordingResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StartRecordingRequest"))
		{	*type = SOAP_TYPE__ns1__StartRecordingRequest;
			return soap_in__ns1__StartRecordingRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetRecordingProfilesResponse"))
		{	*type = SOAP_TYPE__ns1__GetRecordingProfilesResponse;
			return soap_in__ns1__GetRecordingProfilesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetRecordingProfilesRequest"))
		{	*type = SOAP_TYPE__ns1__GetRecordingProfilesRequest;
			return soap_in__ns1__GetRecordingProfilesRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetMemberModeResponse"))
		{	*type = SOAP_TYPE__ns1__SetMemberModeResponse;
			return soap_in__ns1__SetMemberModeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetMemberModeRequest"))
		{	*type = SOAP_TYPE__ns1__SetMemberModeRequest;
			return soap_in__ns1__SetMemberModeRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UnlockRoomResponse"))
		{	*type = SOAP_TYPE__ns1__UnlockRoomResponse;
			return soap_in__ns1__UnlockRoomResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UnlockRoomRequest"))
		{	*type = SOAP_TYPE__ns1__UnlockRoomRequest;
			return soap_in__ns1__UnlockRoomRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LockRoomResponse"))
		{	*type = SOAP_TYPE__ns1__LockRoomResponse;
			return soap_in__ns1__LockRoomResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LockRoomRequest"))
		{	*type = SOAP_TYPE__ns1__LockRoomRequest;
			return soap_in__ns1__LockRoomRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdateLanguageResponse"))
		{	*type = SOAP_TYPE__ns1__UpdateLanguageResponse;
			return soap_in__ns1__UpdateLanguageResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdateLanguageRequest"))
		{	*type = SOAP_TYPE__ns1__UpdateLanguageRequest;
			return soap_in__ns1__UpdateLanguageRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdatePasswordResponse"))
		{	*type = SOAP_TYPE__ns1__UpdatePasswordResponse;
			return soap_in__ns1__UpdatePasswordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdatePasswordRequest"))
		{	*type = SOAP_TYPE__ns1__UpdatePasswordRequest;
			return soap_in__ns1__UpdatePasswordRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RemoveRoomPINResponse"))
		{	*type = SOAP_TYPE__ns1__RemoveRoomPINResponse;
			return soap_in__ns1__RemoveRoomPINResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RemoveRoomPINRequest"))
		{	*type = SOAP_TYPE__ns1__RemoveRoomPINRequest;
			return soap_in__ns1__RemoveRoomPINRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CreateRoomPINResponse"))
		{	*type = SOAP_TYPE__ns1__CreateRoomPINResponse;
			return soap_in__ns1__CreateRoomPINResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CreateRoomPINRequest"))
		{	*type = SOAP_TYPE__ns1__CreateRoomPINRequest;
			return soap_in__ns1__CreateRoomPINRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RemoveRoomURLResponse"))
		{	*type = SOAP_TYPE__ns1__RemoveRoomURLResponse;
			return soap_in__ns1__RemoveRoomURLResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RemoveRoomURLRequest"))
		{	*type = SOAP_TYPE__ns1__RemoveRoomURLRequest;
			return soap_in__ns1__RemoveRoomURLRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CreateRoomURLResponse"))
		{	*type = SOAP_TYPE__ns1__CreateRoomURLResponse;
			return soap_in__ns1__CreateRoomURLResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CreateRoomURLRequest"))
		{	*type = SOAP_TYPE__ns1__CreateRoomURLRequest;
			return soap_in__ns1__CreateRoomURLRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeleteRoomResponse"))
		{	*type = SOAP_TYPE__ns1__DeleteRoomResponse;
			return soap_in__ns1__DeleteRoomResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeleteRoomRequest"))
		{	*type = SOAP_TYPE__ns1__DeleteRoomRequest;
			return soap_in__ns1__DeleteRoomRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CreateRoomResponse"))
		{	*type = SOAP_TYPE__ns1__CreateRoomResponse;
			return soap_in__ns1__CreateRoomResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CreateRoomRequest"))
		{	*type = SOAP_TYPE__ns1__CreateRoomRequest;
			return soap_in__ns1__CreateRoomRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MyAccountResponse"))
		{	*type = SOAP_TYPE__ns1__MyAccountResponse;
			return soap_in__ns1__MyAccountResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MyAccountRequest"))
		{	*type = SOAP_TYPE__ns1__MyAccountRequest;
			return soap_in__ns1__MyAccountRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StopVideoResponse"))
		{	*type = SOAP_TYPE__ns1__StopVideoResponse;
			return soap_in__ns1__StopVideoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StopVideoRequest"))
		{	*type = SOAP_TYPE__ns1__StopVideoRequest;
			return soap_in__ns1__StopVideoRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StartVideoResponse"))
		{	*type = SOAP_TYPE__ns1__StartVideoResponse;
			return soap_in__ns1__StartVideoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StartVideoRequest"))
		{	*type = SOAP_TYPE__ns1__StartVideoRequest;
			return soap_in__ns1__StartVideoRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UnmuteAudioResponse"))
		{	*type = SOAP_TYPE__ns1__UnmuteAudioResponse;
			return soap_in__ns1__UnmuteAudioResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UnmuteAudioRequest"))
		{	*type = SOAP_TYPE__ns1__UnmuteAudioRequest;
			return soap_in__ns1__UnmuteAudioRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MuteAudioResponse"))
		{	*type = SOAP_TYPE__ns1__MuteAudioResponse;
			return soap_in__ns1__MuteAudioResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MuteAudioRequest"))
		{	*type = SOAP_TYPE__ns1__MuteAudioRequest;
			return soap_in__ns1__MuteAudioRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LeaveConferenceResponse"))
		{	*type = SOAP_TYPE__ns1__LeaveConferenceResponse;
			return soap_in__ns1__LeaveConferenceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LeaveConferenceRequest"))
		{	*type = SOAP_TYPE__ns1__LeaveConferenceRequest;
			return soap_in__ns1__LeaveConferenceRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetLectureModeParticipantsResponse"))
		{	*type = SOAP_TYPE__ns1__GetLectureModeParticipantsResponse;
			return soap_in__ns1__GetLectureModeParticipantsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetLectureModeParticipantsRequest"))
		{	*type = SOAP_TYPE__ns1__GetLectureModeParticipantsRequest;
			return soap_in__ns1__GetLectureModeParticipantsRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetParticipantsResponse"))
		{	*type = SOAP_TYPE__ns1__GetParticipantsResponse;
			return soap_in__ns1__GetParticipantsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetParticipantsRequest"))
		{	*type = SOAP_TYPE__ns1__GetParticipantsRequest;
			return soap_in__ns1__GetParticipantsRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DirectCallResponse"))
		{	*type = SOAP_TYPE__ns1__DirectCallResponse;
			return soap_in__ns1__DirectCallResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DirectCallRequest"))
		{	*type = SOAP_TYPE__ns1__DirectCallRequest;
			return soap_in__ns1__DirectCallRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:JoinIPCConferenceResponse"))
		{	*type = SOAP_TYPE__ns1__JoinIPCConferenceResponse;
			return soap_in__ns1__JoinIPCConferenceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:JoinIPCConferenceRequest"))
		{	*type = SOAP_TYPE__ns1__JoinIPCConferenceRequest;
			return soap_in__ns1__JoinIPCConferenceRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:JoinConferenceResponse"))
		{	*type = SOAP_TYPE__ns1__JoinConferenceResponse;
			return soap_in__ns1__JoinConferenceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:JoinConferenceRequest"))
		{	*type = SOAP_TYPE__ns1__JoinConferenceRequest;
			return soap_in__ns1__JoinConferenceRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CancelOutboundCallResponse"))
		{	*type = SOAP_TYPE__ns1__CancelOutboundCallResponse;
			return soap_in__ns1__CancelOutboundCallResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CancelOutboundCallRequest"))
		{	*type = SOAP_TYPE__ns1__CancelOutboundCallRequest;
			return soap_in__ns1__CancelOutboundCallRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InviteToConferenceResponse"))
		{	*type = SOAP_TYPE__ns1__InviteToConferenceResponse;
			return soap_in__ns1__InviteToConferenceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InviteToConferenceRequest"))
		{	*type = SOAP_TYPE__ns1__InviteToConferenceRequest;
			return soap_in__ns1__InviteToConferenceRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetEntityByEntityIDResponse"))
		{	*type = SOAP_TYPE__ns1__GetEntityByEntityIDResponse;
			return soap_in__ns1__GetEntityByEntityIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetEntityByEntityIDRequest"))
		{	*type = SOAP_TYPE__ns1__GetEntityByEntityIDRequest;
			return soap_in__ns1__GetEntityByEntityIDRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SearchByEmailResponse"))
		{	*type = SOAP_TYPE__ns1__SearchByEmailResponse;
			return soap_in__ns1__SearchByEmailResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SearchByEmailRequest"))
		{	*type = SOAP_TYPE__ns1__SearchByEmailRequest;
			return soap_in__ns1__SearchByEmailRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SearchByEntityIDResponse"))
		{	*type = SOAP_TYPE__ns1__SearchByEntityIDResponse;
			return soap_in__ns1__SearchByEntityIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SearchByEntityIDRequest"))
		{	*type = SOAP_TYPE__ns1__SearchByEntityIDRequest;
			return soap_in__ns1__SearchByEntityIDRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SearchResponse"))
		{	*type = SOAP_TYPE__ns1__SearchResponse;
			return soap_in__ns1__SearchResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SearchRequest"))
		{	*type = SOAP_TYPE__ns1__SearchRequest;
			return soap_in__ns1__SearchRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RemoveFromMyContactsResponse"))
		{	*type = SOAP_TYPE__ns1__RemoveFromMyContactsResponse;
			return soap_in__ns1__RemoveFromMyContactsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RemoveFromMyContactsRequest"))
		{	*type = SOAP_TYPE__ns1__RemoveFromMyContactsRequest;
			return soap_in__ns1__RemoveFromMyContactsRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AddToMyContactsResponse"))
		{	*type = SOAP_TYPE__ns1__AddToMyContactsResponse;
			return soap_in__ns1__AddToMyContactsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AddToMyContactsRequest"))
		{	*type = SOAP_TYPE__ns1__AddToMyContactsRequest;
			return soap_in__ns1__AddToMyContactsRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SearchMyContactsResponse"))
		{	*type = SOAP_TYPE__ns1__SearchMyContactsResponse;
			return soap_in__ns1__SearchMyContactsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SearchMyContactsRequest"))
		{	*type = SOAP_TYPE__ns1__SearchMyContactsRequest;
			return soap_in__ns1__SearchMyContactsRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MyEndpointStatusResponse"))
		{	*type = SOAP_TYPE__ns1__MyEndpointStatusResponse;
			return soap_in__ns1__MyEndpointStatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MyEndpointStatusRequest"))
		{	*type = SOAP_TYPE__ns1__MyEndpointStatusRequest;
			return soap_in__ns1__MyEndpointStatusRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LogOutResponse"))
		{	*type = SOAP_TYPE__ns1__LogOutResponse;
			return soap_in__ns1__LogOutResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LogOutRequest"))
		{	*type = SOAP_TYPE__ns1__LogOutRequest;
			return soap_in__ns1__LogOutRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LinkEndpointResponse"))
		{	*type = SOAP_TYPE__ns1__LinkEndpointResponse;
			return soap_in__ns1__LinkEndpointResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LinkEndpointRequest"))
		{	*type = SOAP_TYPE__ns1__LinkEndpointRequest;
			return soap_in__ns1__LinkEndpointRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LogInResponse"))
		{	*type = SOAP_TYPE__ns1__LogInResponse;
			return soap_in__ns1__LogInResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LogInRequest"))
		{	*type = SOAP_TYPE__ns1__LogInRequest;
			return soap_in__ns1__LogInRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:WelcomeBannerContent"))
		{	*type = SOAP_TYPE__ns1__WelcomeBannerContent;
			return soap_in__ns1__WelcomeBannerContent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LoginAttempt"))
		{	*type = SOAP_TYPE__ns1__LoginAttempt;
			return soap_in__ns1__LoginAttempt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LectureModeParticipant"))
		{	*type = SOAP_TYPE__ns1__LectureModeParticipant;
			return soap_in__ns1__LectureModeParticipant(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Entity"))
		{	*type = SOAP_TYPE__ns1__Entity;
			return soap_in__ns1__Entity(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Filter"))
		{	*type = SOAP_TYPE__ns1__Filter;
			return soap_in__ns1__Filter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RoomMode"))
		{	*type = SOAP_TYPE__ns1__RoomMode;
			return soap_in__ns1__RoomMode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RoomNotFoundFault"))
		{	*type = SOAP_TYPE__ns1__RoomNotFoundFault;
			return soap_in__ns1__RoomNotFoundFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:VidyoReplayNotAvailableFault"))
		{	*type = SOAP_TYPE__ns1__VidyoReplayNotAvailableFault;
			return soap_in__ns1__VidyoReplayNotAvailableFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FeatureNotAvailableFault"))
		{	*type = SOAP_TYPE__ns1__FeatureNotAvailableFault;
			return soap_in__ns1__FeatureNotAvailableFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PrefixNotConfiguredException"))
		{	*type = SOAP_TYPE__ns1__PrefixNotConfiguredException;
			return soap_in__ns1__PrefixNotConfiguredException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InPointToPointCallFault"))
		{	*type = SOAP_TYPE__ns1__InPointToPointCallFault;
			return soap_in__ns1__InPointToPointCallFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:EndpointNotBoundFault"))
		{	*type = SOAP_TYPE__ns1__EndpointNotBoundFault;
			return soap_in__ns1__EndpointNotBoundFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ScheduledRoomCreationFault"))
		{	*type = SOAP_TYPE__ns1__ScheduledRoomCreationFault;
			return soap_in__ns1__ScheduledRoomCreationFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ControlMeetingFault"))
		{	*type = SOAP_TYPE__ns1__ControlMeetingFault;
			return soap_in__ns1__ControlMeetingFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InvalidModeratorPINFormatFault"))
		{	*type = SOAP_TYPE__ns1__InvalidModeratorPINFormatFault;
			return soap_in__ns1__InvalidModeratorPINFormatFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AccessRestrictedFault"))
		{	*type = SOAP_TYPE__ns1__AccessRestrictedFault;
			return soap_in__ns1__AccessRestrictedFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ResourceNotAvailableFault"))
		{	*type = SOAP_TYPE__ns1__ResourceNotAvailableFault;
			return soap_in__ns1__ResourceNotAvailableFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:NotLicensedFault"))
		{	*type = SOAP_TYPE__ns1__NotLicensedFault;
			return soap_in__ns1__NotLicensedFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ConferenceLockedFault"))
		{	*type = SOAP_TYPE__ns1__ConferenceLockedFault;
			return soap_in__ns1__ConferenceLockedFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:WrongPINFault"))
		{	*type = SOAP_TYPE__ns1__WrongPINFault;
			return soap_in__ns1__WrongPINFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SeatLicenseExpiredFault"))
		{	*type = SOAP_TYPE__ns1__SeatLicenseExpiredFault;
			return soap_in__ns1__SeatLicenseExpiredFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InvalidArgumentFault"))
		{	*type = SOAP_TYPE__ns1__InvalidArgumentFault;
			return soap_in__ns1__InvalidArgumentFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GeneralFault"))
		{	*type = SOAP_TYPE__ns1__GeneralFault;
			return soap_in__ns1__GeneralFault(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				if (soap_ignore(soap) || soap_element_end_in(soap, NULL))
					return soap->error;
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_dateTime:
		return soap_out_dateTime(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE__ns1__RoomStatus:
		return soap_out__ns1__RoomStatus(soap, tag, id, (const enum _ns1__RoomStatus *)ptr, "ns1:RoomStatus");
	case SOAP_TYPE__ns1__MemberStatus:
		return soap_out__ns1__MemberStatus(soap, tag, id, (const enum _ns1__MemberStatus *)ptr, "ns1:MemberStatus");
	case SOAP_TYPE__ns1__MemberMode:
		return soap_out__ns1__MemberMode(soap, tag, id, (const enum _ns1__MemberMode *)ptr, "ns1:MemberMode");
	case SOAP_TYPE__ns1__EntityType:
		return soap_out__ns1__EntityType(soap, tag, id, (const enum _ns1__EntityType *)ptr, "ns1:EntityType");
	case SOAP_TYPE__ns1__Language:
		return soap_out__ns1__Language(soap, tag, id, (const enum _ns1__Language *)ptr, "ns1:Language");
	case SOAP_TYPE__ns1__OK:
		return soap_out__ns1__OK(soap, tag, id, (const enum _ns1__OK *)ptr, "ns1:OK");
	case SOAP_TYPE__ns1__ClientType:
		return soap_out__ns1__ClientType(soap, tag, id, (const enum _ns1__ClientType *)ptr, "ns1:ClientType");
	case SOAP_TYPE_ns1__AccessOptionName:
		return soap_out_ns1__AccessOptionName(soap, tag, id, (const enum ns1__AccessOptionName *)ptr, "ns1:AccessOptionName");
	case SOAP_TYPE_ns1__sortDir:
		return soap_out_ns1__sortDir(soap, tag, id, (const enum ns1__sortDir *)ptr, "ns1:sortDir");
	case SOAP_TYPE__ns1__GetChangePasswordHtmlUrlWithTokenResponse:
		return ((_ns1__GetChangePasswordHtmlUrlWithTokenResponse *)ptr)->soap_out(soap, "ns1:GetChangePasswordHtmlUrlWithTokenResponse", id, NULL);
	case SOAP_TYPE__ns1__GetChangePasswordHtmlUrlWithTokenRequest:
		return ((_ns1__GetChangePasswordHtmlUrlWithTokenRequest *)ptr)->soap_out(soap, "ns1:GetChangePasswordHtmlUrlWithTokenRequest", id, NULL);
	case SOAP_TYPE__ns1__WhatIsMyIPAddressResponse:
		return ((_ns1__WhatIsMyIPAddressResponse *)ptr)->soap_out(soap, "ns1:WhatIsMyIPAddressResponse", id, NULL);
	case SOAP_TYPE__ns1__WhatIsMyIPAddressRequest:
		return ((_ns1__WhatIsMyIPAddressRequest *)ptr)->soap_out(soap, "ns1:WhatIsMyIPAddressRequest", id, NULL);
	case SOAP_TYPE__ns1__GetVidyoReplayLibraryResponse:
		return ((_ns1__GetVidyoReplayLibraryResponse *)ptr)->soap_out(soap, "ns1:GetVidyoReplayLibraryResponse", id, NULL);
	case SOAP_TYPE__ns1__GetVidyoReplayLibraryRequest:
		return ((_ns1__GetVidyoReplayLibraryRequest *)ptr)->soap_out(soap, "ns1:GetVidyoReplayLibraryRequest", id, NULL);
	case SOAP_TYPE__ns1__RemovePresenterResponse:
		return ((_ns1__RemovePresenterResponse *)ptr)->soap_out(soap, "ns1:RemovePresenterResponse", id, NULL);
	case SOAP_TYPE__ns1__RemovePresenterRequest:
		return ((_ns1__RemovePresenterRequest *)ptr)->soap_out(soap, "ns1:RemovePresenterRequest", id, NULL);
	case SOAP_TYPE__ns1__SetPresenterResponse:
		return ((_ns1__SetPresenterResponse *)ptr)->soap_out(soap, "ns1:SetPresenterResponse", id, NULL);
	case SOAP_TYPE__ns1__SetPresenterRequest:
		return ((_ns1__SetPresenterRequest *)ptr)->soap_out(soap, "ns1:SetPresenterRequest", id, NULL);
	case SOAP_TYPE__ns1__DismissAllRaisedHandResponse:
		return ((_ns1__DismissAllRaisedHandResponse *)ptr)->soap_out(soap, "ns1:DismissAllRaisedHandResponse", id, NULL);
	case SOAP_TYPE__ns1__DismissAllRaisedHandRequest:
		return ((_ns1__DismissAllRaisedHandRequest *)ptr)->soap_out(soap, "ns1:DismissAllRaisedHandRequest", id, NULL);
	case SOAP_TYPE__ns1__DismissRaisedHandResponse:
		return ((_ns1__DismissRaisedHandResponse *)ptr)->soap_out(soap, "ns1:DismissRaisedHandResponse", id, NULL);
	case SOAP_TYPE__ns1__DismissRaisedHandRequest:
		return ((_ns1__DismissRaisedHandRequest *)ptr)->soap_out(soap, "ns1:DismissRaisedHandRequest", id, NULL);
	case SOAP_TYPE__ns1__UnraiseHandResponse:
		return ((_ns1__UnraiseHandResponse *)ptr)->soap_out(soap, "ns1:UnraiseHandResponse", id, NULL);
	case SOAP_TYPE__ns1__RaiseHandResponse:
		return ((_ns1__RaiseHandResponse *)ptr)->soap_out(soap, "ns1:RaiseHandResponse", id, NULL);
	case SOAP_TYPE__ns1__StopLectureModeResponse:
		return ((_ns1__StopLectureModeResponse *)ptr)->soap_out(soap, "ns1:StopLectureModeResponse", id, NULL);
	case SOAP_TYPE__ns1__StopLectureModeRequest:
		return ((_ns1__StopLectureModeRequest *)ptr)->soap_out(soap, "ns1:StopLectureModeRequest", id, NULL);
	case SOAP_TYPE__ns1__StartLectureModeResponse:
		return ((_ns1__StartLectureModeResponse *)ptr)->soap_out(soap, "ns1:StartLectureModeResponse", id, NULL);
	case SOAP_TYPE__ns1__StartLectureModeRequest:
		return ((_ns1__StartLectureModeRequest *)ptr)->soap_out(soap, "ns1:StartLectureModeRequest", id, NULL);
	case SOAP_TYPE__ns1__getUserAccountTypeResponse:
		return ((_ns1__getUserAccountTypeResponse *)ptr)->soap_out(soap, "ns1:getUserAccountTypeResponse", id, NULL);
	case SOAP_TYPE__ns1__getUserAccountTypeRequest:
		return ((_ns1__getUserAccountTypeRequest *)ptr)->soap_out(soap, "ns1:getUserAccountTypeRequest", id, NULL);
	case SOAP_TYPE__ns1__getLoginAndWelcomeBannerResponse:
		return ((_ns1__getLoginAndWelcomeBannerResponse *)ptr)->soap_out(soap, "ns1:getLoginAndWelcomeBannerResponse", id, NULL);
	case SOAP_TYPE__ns1__getLoginAndWelcomeBannerRequest:
		return ((_ns1__getLoginAndWelcomeBannerRequest *)ptr)->soap_out(soap, "ns1:getLoginAndWelcomeBannerRequest", id, NULL);
	case SOAP_TYPE__ns1__PrefixNotConfiguredFault:
		return ((_ns1__PrefixNotConfiguredFault *)ptr)->soap_out(soap, "ns1:PrefixNotConfiguredFault", id, NULL);
	case SOAP_TYPE__ns1__PortalPrefixResponse:
		return ((_ns1__PortalPrefixResponse *)ptr)->soap_out(soap, "ns1:PortalPrefixResponse", id, NULL);
	case SOAP_TYPE__ns1__RoomAccessOptionsResponse:
		return ((_ns1__RoomAccessOptionsResponse *)ptr)->soap_out(soap, "ns1:RoomAccessOptionsResponse", id, NULL);
	case SOAP_TYPE__ns1__RoomAccessOptionsRequest:
		return ((_ns1__RoomAccessOptionsRequest *)ptr)->soap_out(soap, "ns1:RoomAccessOptionsRequest", id, NULL);
	case SOAP_TYPE__ns1__RoomAccessOption:
		return ((_ns1__RoomAccessOption *)ptr)->soap_out(soap, "ns1:RoomAccessOption", id, NULL);
	case SOAP_TYPE__ns1__OnetimeAccessResponse:
		return ((_ns1__OnetimeAccessResponse *)ptr)->soap_out(soap, "ns1:OnetimeAccessResponse", id, NULL);
	case SOAP_TYPE__ns1__muteVideoClientAllResponse:
		return ((_ns1__muteVideoClientAllResponse *)ptr)->soap_out(soap, "ns1:muteVideoClientAllResponse", id, NULL);
	case SOAP_TYPE__ns1__muteVideoClientAllRequest:
		return ((_ns1__muteVideoClientAllRequest *)ptr)->soap_out(soap, "ns1:muteVideoClientAllRequest", id, NULL);
	case SOAP_TYPE__ns1__muteVideoServerAllResponse:
		return ((_ns1__muteVideoServerAllResponse *)ptr)->soap_out(soap, "ns1:muteVideoServerAllResponse", id, NULL);
	case SOAP_TYPE__ns1__muteVideoServerAllRequest:
		return ((_ns1__muteVideoServerAllRequest *)ptr)->soap_out(soap, "ns1:muteVideoServerAllRequest", id, NULL);
	case SOAP_TYPE__ns1__muteAudioClientAllResponse:
		return ((_ns1__muteAudioClientAllResponse *)ptr)->soap_out(soap, "ns1:muteAudioClientAllResponse", id, NULL);
	case SOAP_TYPE__ns1__muteAudioClientAllRequest:
		return ((_ns1__muteAudioClientAllRequest *)ptr)->soap_out(soap, "ns1:muteAudioClientAllRequest", id, NULL);
	case SOAP_TYPE__ns1__muteAudioServerAllResponse:
		return ((_ns1__muteAudioServerAllResponse *)ptr)->soap_out(soap, "ns1:muteAudioServerAllResponse", id, NULL);
	case SOAP_TYPE__ns1__muteAudioServerAllRequest:
		return ((_ns1__muteAudioServerAllRequest *)ptr)->soap_out(soap, "ns1:muteAudioServerAllRequest", id, NULL);
	case SOAP_TYPE__ns1__disconnectConferenceAllResponse:
		return ((_ns1__disconnectConferenceAllResponse *)ptr)->soap_out(soap, "ns1:disconnectConferenceAllResponse", id, NULL);
	case SOAP_TYPE__ns1__disconnectConferenceAllRequest:
		return ((_ns1__disconnectConferenceAllRequest *)ptr)->soap_out(soap, "ns1:disconnectConferenceAllRequest", id, NULL);
	case SOAP_TYPE__ns1__LogoutAllOtherSessionsResponse:
		return ((_ns1__LogoutAllOtherSessionsResponse *)ptr)->soap_out(soap, "ns1:LogoutAllOtherSessionsResponse", id, NULL);
	case SOAP_TYPE__ns1__GetActiveSessionsResponse:
		return ((_ns1__GetActiveSessionsResponse *)ptr)->soap_out(soap, "ns1:GetActiveSessionsResponse", id, NULL);
	case SOAP_TYPE__ns1__SetEndpointDetailsResponse:
		return ((_ns1__SetEndpointDetailsResponse *)ptr)->soap_out(soap, "ns1:SetEndpointDetailsResponse", id, NULL);
	case SOAP_TYPE__ns1__SetEndpointDetailsRequest:
		return ((_ns1__SetEndpointDetailsRequest *)ptr)->soap_out(soap, "ns1:SetEndpointDetailsRequest", id, NULL);
	case SOAP_TYPE__ns1__EndpointFeature:
		return ((_ns1__EndpointFeature *)ptr)->soap_out(soap, "ns1:EndpointFeature", id, NULL);
	case SOAP_TYPE__ns1__GetPortalFeaturesResponse:
		return ((_ns1__GetPortalFeaturesResponse *)ptr)->soap_out(soap, "ns1:GetPortalFeaturesResponse", id, NULL);
	case SOAP_TYPE__ns1__PortalFeature:
		return ((_ns1__PortalFeature *)ptr)->soap_out(soap, "ns1:PortalFeature", id, NULL);
	case SOAP_TYPE__ns1__DeleteScheduledRoomResponse:
		return ((_ns1__DeleteScheduledRoomResponse *)ptr)->soap_out(soap, "ns1:DeleteScheduledRoomResponse", id, NULL);
	case SOAP_TYPE__ns1__DeleteScheduledRoomRequest:
		return ((_ns1__DeleteScheduledRoomRequest *)ptr)->soap_out(soap, "ns1:DeleteScheduledRoomRequest", id, NULL);
	case SOAP_TYPE__ns1__CreateScheduledRoomResponse:
		return ((_ns1__CreateScheduledRoomResponse *)ptr)->soap_out(soap, "ns1:CreateScheduledRoomResponse", id, NULL);
	case SOAP_TYPE__ns1__CreateScheduledRoomRequest:
		return ((_ns1__CreateScheduledRoomRequest *)ptr)->soap_out(soap, "ns1:CreateScheduledRoomRequest", id, NULL);
	case SOAP_TYPE__ns1__GenerateAuthTokenResponse:
		return ((_ns1__GenerateAuthTokenResponse *)ptr)->soap_out(soap, "ns1:GenerateAuthTokenResponse", id, NULL);
	case SOAP_TYPE__ns1__GenerateAuthTokenRequest:
		return ((_ns1__GenerateAuthTokenRequest *)ptr)->soap_out(soap, "ns1:GenerateAuthTokenRequest", id, NULL);
	case SOAP_TYPE__ns1__GetConferenceIDResponse:
		return ((_ns1__GetConferenceIDResponse *)ptr)->soap_out(soap, "ns1:GetConferenceIDResponse", id, NULL);
	case SOAP_TYPE__ns1__GetConferenceIDRequest:
		return ((_ns1__GetConferenceIDRequest *)ptr)->soap_out(soap, "ns1:GetConferenceIDRequest", id, NULL);
	case SOAP_TYPE__ns1__RemoveModeratorPINResponse:
		return ((_ns1__RemoveModeratorPINResponse *)ptr)->soap_out(soap, "ns1:RemoveModeratorPINResponse", id, NULL);
	case SOAP_TYPE__ns1__RemoveModeratorPINRequest:
		return ((_ns1__RemoveModeratorPINRequest *)ptr)->soap_out(soap, "ns1:RemoveModeratorPINRequest", id, NULL);
	case SOAP_TYPE__ns1__CreateModeratorPINResponse:
		return ((_ns1__CreateModeratorPINResponse *)ptr)->soap_out(soap, "ns1:CreateModeratorPINResponse", id, NULL);
	case SOAP_TYPE__ns1__CreateModeratorPINRequest:
		return ((_ns1__CreateModeratorPINRequest *)ptr)->soap_out(soap, "ns1:CreateModeratorPINRequest", id, NULL);
	case SOAP_TYPE__ns1__GetModeratorURLWithTokenResponse:
		return ((_ns1__GetModeratorURLWithTokenResponse *)ptr)->soap_out(soap, "ns1:GetModeratorURLWithTokenResponse", id, NULL);
	case SOAP_TYPE__ns1__GetModeratorURLWithTokenRequest:
		return ((_ns1__GetModeratorURLWithTokenRequest *)ptr)->soap_out(soap, "ns1:GetModeratorURLWithTokenRequest", id, NULL);
	case SOAP_TYPE__ns1__GetModeratorURLResponse:
		return ((_ns1__GetModeratorURLResponse *)ptr)->soap_out(soap, "ns1:GetModeratorURLResponse", id, NULL);
	case SOAP_TYPE__ns1__GetModeratorURLRequest:
		return ((_ns1__GetModeratorURLRequest *)ptr)->soap_out(soap, "ns1:GetModeratorURLRequest", id, NULL);
	case SOAP_TYPE__ns1__RemoveModeratorURLResponse:
		return ((_ns1__RemoveModeratorURLResponse *)ptr)->soap_out(soap, "ns1:RemoveModeratorURLResponse", id, NULL);
	case SOAP_TYPE__ns1__RemoveModeratorURLRequest:
		return ((_ns1__RemoveModeratorURLRequest *)ptr)->soap_out(soap, "ns1:RemoveModeratorURLRequest", id, NULL);
	case SOAP_TYPE__ns1__CreateModeratorURLResponse:
		return ((_ns1__CreateModeratorURLResponse *)ptr)->soap_out(soap, "ns1:CreateModeratorURLResponse", id, NULL);
	case SOAP_TYPE__ns1__CreateModeratorURLRequest:
		return ((_ns1__CreateModeratorURLRequest *)ptr)->soap_out(soap, "ns1:CreateModeratorURLRequest", id, NULL);
	case SOAP_TYPE__ns1__RemoveRoomProfileResponse:
		return ((_ns1__RemoveRoomProfileResponse *)ptr)->soap_out(soap, "ns1:RemoveRoomProfileResponse", id, NULL);
	case SOAP_TYPE__ns1__RemoveRoomProfileRequest:
		return ((_ns1__RemoveRoomProfileRequest *)ptr)->soap_out(soap, "ns1:RemoveRoomProfileRequest", id, NULL);
	case SOAP_TYPE__ns1__SetRoomProfileResponse:
		return ((_ns1__SetRoomProfileResponse *)ptr)->soap_out(soap, "ns1:SetRoomProfileResponse", id, NULL);
	case SOAP_TYPE__ns1__SetRoomProfileRequest:
		return ((_ns1__SetRoomProfileRequest *)ptr)->soap_out(soap, "ns1:SetRoomProfileRequest", id, NULL);
	case SOAP_TYPE__ns1__GetRoomProfileResponse:
		return ((_ns1__GetRoomProfileResponse *)ptr)->soap_out(soap, "ns1:GetRoomProfileResponse", id, NULL);
	case SOAP_TYPE__ns1__GetRoomProfileRequest:
		return ((_ns1__GetRoomProfileRequest *)ptr)->soap_out(soap, "ns1:GetRoomProfileRequest", id, NULL);
	case SOAP_TYPE__ns1__GetRoomProfilesResponse:
		return ((_ns1__GetRoomProfilesResponse *)ptr)->soap_out(soap, "ns1:GetRoomProfilesResponse", id, NULL);
	case SOAP_TYPE__ns1__GetInviteContentResponse:
		return ((_ns1__GetInviteContentResponse *)ptr)->soap_out(soap, "ns1:GetInviteContentResponse", id, NULL);
	case SOAP_TYPE__ns1__GetInviteContentRequest:
		return ((_ns1__GetInviteContentRequest *)ptr)->soap_out(soap, "ns1:GetInviteContentRequest", id, NULL);
	case SOAP_TYPE__ns1__GetEntityByRoomKeyResponse:
		return ((_ns1__GetEntityByRoomKeyResponse *)ptr)->soap_out(soap, "ns1:GetEntityByRoomKeyResponse", id, NULL);
	case SOAP_TYPE__ns1__GetEntityByRoomKeyRequest:
		return ((_ns1__GetEntityByRoomKeyRequest *)ptr)->soap_out(soap, "ns1:GetEntityByRoomKeyRequest", id, NULL);
	case SOAP_TYPE__ns1__GetUserNameResponse:
		return ((_ns1__GetUserNameResponse *)ptr)->soap_out(soap, "ns1:GetUserNameResponse", id, NULL);
	case SOAP_TYPE__ns1__GetUserNameRequest:
		return ((_ns1__GetUserNameRequest *)ptr)->soap_out(soap, "ns1:GetUserNameRequest", id, NULL);
	case SOAP_TYPE__ns1__GetWebcastURLResponse:
		return ((_ns1__GetWebcastURLResponse *)ptr)->soap_out(soap, "ns1:GetWebcastURLResponse", id, NULL);
	case SOAP_TYPE__ns1__GetWebcastURLRequest:
		return ((_ns1__GetWebcastURLRequest *)ptr)->soap_out(soap, "ns1:GetWebcastURLRequest", id, NULL);
	case SOAP_TYPE__ns1__RemoveWebcastPINResponse:
		return ((_ns1__RemoveWebcastPINResponse *)ptr)->soap_out(soap, "ns1:RemoveWebcastPINResponse", id, NULL);
	case SOAP_TYPE__ns1__RemoveWebcastPINRequest:
		return ((_ns1__RemoveWebcastPINRequest *)ptr)->soap_out(soap, "ns1:RemoveWebcastPINRequest", id, NULL);
	case SOAP_TYPE__ns1__RemoveWebcastURLResponse:
		return ((_ns1__RemoveWebcastURLResponse *)ptr)->soap_out(soap, "ns1:RemoveWebcastURLResponse", id, NULL);
	case SOAP_TYPE__ns1__RemoveWebcastURLRequest:
		return ((_ns1__RemoveWebcastURLRequest *)ptr)->soap_out(soap, "ns1:RemoveWebcastURLRequest", id, NULL);
	case SOAP_TYPE__ns1__CreateWebcastPINResponse:
		return ((_ns1__CreateWebcastPINResponse *)ptr)->soap_out(soap, "ns1:CreateWebcastPINResponse", id, NULL);
	case SOAP_TYPE__ns1__CreateWebcastPINRequest:
		return ((_ns1__CreateWebcastPINRequest *)ptr)->soap_out(soap, "ns1:CreateWebcastPINRequest", id, NULL);
	case SOAP_TYPE__ns1__CreateWebcastURLResponse:
		return ((_ns1__CreateWebcastURLResponse *)ptr)->soap_out(soap, "ns1:CreateWebcastURLResponse", id, NULL);
	case SOAP_TYPE__ns1__CreateWebcastURLRequest:
		return ((_ns1__CreateWebcastURLRequest *)ptr)->soap_out(soap, "ns1:CreateWebcastURLRequest", id, NULL);
	case SOAP_TYPE__ns1__StopRecordingResponse:
		return ((_ns1__StopRecordingResponse *)ptr)->soap_out(soap, "ns1:StopRecordingResponse", id, NULL);
	case SOAP_TYPE__ns1__StopRecordingRequest:
		return ((_ns1__StopRecordingRequest *)ptr)->soap_out(soap, "ns1:StopRecordingRequest", id, NULL);
	case SOAP_TYPE__ns1__ResumeRecordingResponse:
		return ((_ns1__ResumeRecordingResponse *)ptr)->soap_out(soap, "ns1:ResumeRecordingResponse", id, NULL);
	case SOAP_TYPE__ns1__ResumeRecordingRequest:
		return ((_ns1__ResumeRecordingRequest *)ptr)->soap_out(soap, "ns1:ResumeRecordingRequest", id, NULL);
	case SOAP_TYPE__ns1__PauseRecordingResponse:
		return ((_ns1__PauseRecordingResponse *)ptr)->soap_out(soap, "ns1:PauseRecordingResponse", id, NULL);
	case SOAP_TYPE__ns1__PauseRecordingRequest:
		return ((_ns1__PauseRecordingRequest *)ptr)->soap_out(soap, "ns1:PauseRecordingRequest", id, NULL);
	case SOAP_TYPE__ns1__GetPortalVersionResponse:
		return ((_ns1__GetPortalVersionResponse *)ptr)->soap_out(soap, "ns1:GetPortalVersionResponse", id, NULL);
	case SOAP_TYPE__ns1__GetPortalVersionRequest:
		return ((_ns1__GetPortalVersionRequest *)ptr)->soap_out(soap, "ns1:GetPortalVersionRequest", id, NULL);
	case SOAP_TYPE__ns1__StartRecordingResponse:
		return ((_ns1__StartRecordingResponse *)ptr)->soap_out(soap, "ns1:StartRecordingResponse", id, NULL);
	case SOAP_TYPE__ns1__StartRecordingRequest:
		return ((_ns1__StartRecordingRequest *)ptr)->soap_out(soap, "ns1:StartRecordingRequest", id, NULL);
	case SOAP_TYPE__ns1__GetRecordingProfilesResponse:
		return ((_ns1__GetRecordingProfilesResponse *)ptr)->soap_out(soap, "ns1:GetRecordingProfilesResponse", id, NULL);
	case SOAP_TYPE__ns1__GetRecordingProfilesRequest:
		return ((_ns1__GetRecordingProfilesRequest *)ptr)->soap_out(soap, "ns1:GetRecordingProfilesRequest", id, NULL);
	case SOAP_TYPE__ns1__SetMemberModeResponse:
		return ((_ns1__SetMemberModeResponse *)ptr)->soap_out(soap, "ns1:SetMemberModeResponse", id, NULL);
	case SOAP_TYPE__ns1__SetMemberModeRequest:
		return ((_ns1__SetMemberModeRequest *)ptr)->soap_out(soap, "ns1:SetMemberModeRequest", id, NULL);
	case SOAP_TYPE__ns1__UnlockRoomResponse:
		return ((_ns1__UnlockRoomResponse *)ptr)->soap_out(soap, "ns1:UnlockRoomResponse", id, NULL);
	case SOAP_TYPE__ns1__UnlockRoomRequest:
		return ((_ns1__UnlockRoomRequest *)ptr)->soap_out(soap, "ns1:UnlockRoomRequest", id, NULL);
	case SOAP_TYPE__ns1__LockRoomResponse:
		return ((_ns1__LockRoomResponse *)ptr)->soap_out(soap, "ns1:LockRoomResponse", id, NULL);
	case SOAP_TYPE__ns1__LockRoomRequest:
		return ((_ns1__LockRoomRequest *)ptr)->soap_out(soap, "ns1:LockRoomRequest", id, NULL);
	case SOAP_TYPE__ns1__UpdateLanguageResponse:
		return ((_ns1__UpdateLanguageResponse *)ptr)->soap_out(soap, "ns1:UpdateLanguageResponse", id, NULL);
	case SOAP_TYPE__ns1__UpdateLanguageRequest:
		return ((_ns1__UpdateLanguageRequest *)ptr)->soap_out(soap, "ns1:UpdateLanguageRequest", id, NULL);
	case SOAP_TYPE__ns1__UpdatePasswordResponse:
		return ((_ns1__UpdatePasswordResponse *)ptr)->soap_out(soap, "ns1:UpdatePasswordResponse", id, NULL);
	case SOAP_TYPE__ns1__UpdatePasswordRequest:
		return ((_ns1__UpdatePasswordRequest *)ptr)->soap_out(soap, "ns1:UpdatePasswordRequest", id, NULL);
	case SOAP_TYPE__ns1__RemoveRoomPINResponse:
		return ((_ns1__RemoveRoomPINResponse *)ptr)->soap_out(soap, "ns1:RemoveRoomPINResponse", id, NULL);
	case SOAP_TYPE__ns1__RemoveRoomPINRequest:
		return ((_ns1__RemoveRoomPINRequest *)ptr)->soap_out(soap, "ns1:RemoveRoomPINRequest", id, NULL);
	case SOAP_TYPE__ns1__CreateRoomPINResponse:
		return ((_ns1__CreateRoomPINResponse *)ptr)->soap_out(soap, "ns1:CreateRoomPINResponse", id, NULL);
	case SOAP_TYPE__ns1__CreateRoomPINRequest:
		return ((_ns1__CreateRoomPINRequest *)ptr)->soap_out(soap, "ns1:CreateRoomPINRequest", id, NULL);
	case SOAP_TYPE__ns1__RemoveRoomURLResponse:
		return ((_ns1__RemoveRoomURLResponse *)ptr)->soap_out(soap, "ns1:RemoveRoomURLResponse", id, NULL);
	case SOAP_TYPE__ns1__RemoveRoomURLRequest:
		return ((_ns1__RemoveRoomURLRequest *)ptr)->soap_out(soap, "ns1:RemoveRoomURLRequest", id, NULL);
	case SOAP_TYPE__ns1__CreateRoomURLResponse:
		return ((_ns1__CreateRoomURLResponse *)ptr)->soap_out(soap, "ns1:CreateRoomURLResponse", id, NULL);
	case SOAP_TYPE__ns1__CreateRoomURLRequest:
		return ((_ns1__CreateRoomURLRequest *)ptr)->soap_out(soap, "ns1:CreateRoomURLRequest", id, NULL);
	case SOAP_TYPE__ns1__DeleteRoomResponse:
		return ((_ns1__DeleteRoomResponse *)ptr)->soap_out(soap, "ns1:DeleteRoomResponse", id, NULL);
	case SOAP_TYPE__ns1__DeleteRoomRequest:
		return ((_ns1__DeleteRoomRequest *)ptr)->soap_out(soap, "ns1:DeleteRoomRequest", id, NULL);
	case SOAP_TYPE__ns1__CreateRoomResponse:
		return ((_ns1__CreateRoomResponse *)ptr)->soap_out(soap, "ns1:CreateRoomResponse", id, NULL);
	case SOAP_TYPE__ns1__CreateRoomRequest:
		return ((_ns1__CreateRoomRequest *)ptr)->soap_out(soap, "ns1:CreateRoomRequest", id, NULL);
	case SOAP_TYPE__ns1__MyAccountResponse:
		return ((_ns1__MyAccountResponse *)ptr)->soap_out(soap, "ns1:MyAccountResponse", id, NULL);
	case SOAP_TYPE__ns1__MyAccountRequest:
		return ((_ns1__MyAccountRequest *)ptr)->soap_out(soap, "ns1:MyAccountRequest", id, NULL);
	case SOAP_TYPE__ns1__StopVideoResponse:
		return ((_ns1__StopVideoResponse *)ptr)->soap_out(soap, "ns1:StopVideoResponse", id, NULL);
	case SOAP_TYPE__ns1__StopVideoRequest:
		return ((_ns1__StopVideoRequest *)ptr)->soap_out(soap, "ns1:StopVideoRequest", id, NULL);
	case SOAP_TYPE__ns1__StartVideoResponse:
		return ((_ns1__StartVideoResponse *)ptr)->soap_out(soap, "ns1:StartVideoResponse", id, NULL);
	case SOAP_TYPE__ns1__StartVideoRequest:
		return ((_ns1__StartVideoRequest *)ptr)->soap_out(soap, "ns1:StartVideoRequest", id, NULL);
	case SOAP_TYPE__ns1__UnmuteAudioResponse:
		return ((_ns1__UnmuteAudioResponse *)ptr)->soap_out(soap, "ns1:UnmuteAudioResponse", id, NULL);
	case SOAP_TYPE__ns1__UnmuteAudioRequest:
		return ((_ns1__UnmuteAudioRequest *)ptr)->soap_out(soap, "ns1:UnmuteAudioRequest", id, NULL);
	case SOAP_TYPE__ns1__MuteAudioResponse:
		return ((_ns1__MuteAudioResponse *)ptr)->soap_out(soap, "ns1:MuteAudioResponse", id, NULL);
	case SOAP_TYPE__ns1__MuteAudioRequest:
		return ((_ns1__MuteAudioRequest *)ptr)->soap_out(soap, "ns1:MuteAudioRequest", id, NULL);
	case SOAP_TYPE__ns1__LeaveConferenceResponse:
		return ((_ns1__LeaveConferenceResponse *)ptr)->soap_out(soap, "ns1:LeaveConferenceResponse", id, NULL);
	case SOAP_TYPE__ns1__LeaveConferenceRequest:
		return ((_ns1__LeaveConferenceRequest *)ptr)->soap_out(soap, "ns1:LeaveConferenceRequest", id, NULL);
	case SOAP_TYPE__ns1__GetLectureModeParticipantsResponse:
		return ((_ns1__GetLectureModeParticipantsResponse *)ptr)->soap_out(soap, "ns1:GetLectureModeParticipantsResponse", id, NULL);
	case SOAP_TYPE__ns1__GetLectureModeParticipantsRequest:
		return ((_ns1__GetLectureModeParticipantsRequest *)ptr)->soap_out(soap, "ns1:GetLectureModeParticipantsRequest", id, NULL);
	case SOAP_TYPE__ns1__GetParticipantsResponse:
		return ((_ns1__GetParticipantsResponse *)ptr)->soap_out(soap, "ns1:GetParticipantsResponse", id, NULL);
	case SOAP_TYPE__ns1__GetParticipantsRequest:
		return ((_ns1__GetParticipantsRequest *)ptr)->soap_out(soap, "ns1:GetParticipantsRequest", id, NULL);
	case SOAP_TYPE__ns1__DirectCallResponse:
		return ((_ns1__DirectCallResponse *)ptr)->soap_out(soap, "ns1:DirectCallResponse", id, NULL);
	case SOAP_TYPE__ns1__DirectCallRequest:
		return ((_ns1__DirectCallRequest *)ptr)->soap_out(soap, "ns1:DirectCallRequest", id, NULL);
	case SOAP_TYPE__ns1__JoinIPCConferenceResponse:
		return ((_ns1__JoinIPCConferenceResponse *)ptr)->soap_out(soap, "ns1:JoinIPCConferenceResponse", id, NULL);
	case SOAP_TYPE__ns1__JoinIPCConferenceRequest:
		return ((_ns1__JoinIPCConferenceRequest *)ptr)->soap_out(soap, "ns1:JoinIPCConferenceRequest", id, NULL);
	case SOAP_TYPE__ns1__JoinConferenceResponse:
		return ((_ns1__JoinConferenceResponse *)ptr)->soap_out(soap, "ns1:JoinConferenceResponse", id, NULL);
	case SOAP_TYPE__ns1__JoinConferenceRequest:
		return ((_ns1__JoinConferenceRequest *)ptr)->soap_out(soap, "ns1:JoinConferenceRequest", id, NULL);
	case SOAP_TYPE__ns1__CancelOutboundCallResponse:
		return ((_ns1__CancelOutboundCallResponse *)ptr)->soap_out(soap, "ns1:CancelOutboundCallResponse", id, NULL);
	case SOAP_TYPE__ns1__CancelOutboundCallRequest:
		return ((_ns1__CancelOutboundCallRequest *)ptr)->soap_out(soap, "ns1:CancelOutboundCallRequest", id, NULL);
	case SOAP_TYPE__ns1__InviteToConferenceResponse:
		return ((_ns1__InviteToConferenceResponse *)ptr)->soap_out(soap, "ns1:InviteToConferenceResponse", id, NULL);
	case SOAP_TYPE__ns1__InviteToConferenceRequest:
		return ((_ns1__InviteToConferenceRequest *)ptr)->soap_out(soap, "ns1:InviteToConferenceRequest", id, NULL);
	case SOAP_TYPE__ns1__GetEntityByEntityIDResponse:
		return ((_ns1__GetEntityByEntityIDResponse *)ptr)->soap_out(soap, "ns1:GetEntityByEntityIDResponse", id, NULL);
	case SOAP_TYPE__ns1__GetEntityByEntityIDRequest:
		return ((_ns1__GetEntityByEntityIDRequest *)ptr)->soap_out(soap, "ns1:GetEntityByEntityIDRequest", id, NULL);
	case SOAP_TYPE__ns1__SearchByEmailResponse:
		return ((_ns1__SearchByEmailResponse *)ptr)->soap_out(soap, "ns1:SearchByEmailResponse", id, NULL);
	case SOAP_TYPE__ns1__SearchByEmailRequest:
		return ((_ns1__SearchByEmailRequest *)ptr)->soap_out(soap, "ns1:SearchByEmailRequest", id, NULL);
	case SOAP_TYPE__ns1__SearchByEntityIDResponse:
		return ((_ns1__SearchByEntityIDResponse *)ptr)->soap_out(soap, "ns1:SearchByEntityIDResponse", id, NULL);
	case SOAP_TYPE__ns1__SearchByEntityIDRequest:
		return ((_ns1__SearchByEntityIDRequest *)ptr)->soap_out(soap, "ns1:SearchByEntityIDRequest", id, NULL);
	case SOAP_TYPE__ns1__SearchResponse:
		return ((_ns1__SearchResponse *)ptr)->soap_out(soap, "ns1:SearchResponse", id, NULL);
	case SOAP_TYPE__ns1__SearchRequest:
		return ((_ns1__SearchRequest *)ptr)->soap_out(soap, "ns1:SearchRequest", id, NULL);
	case SOAP_TYPE__ns1__RemoveFromMyContactsResponse:
		return ((_ns1__RemoveFromMyContactsResponse *)ptr)->soap_out(soap, "ns1:RemoveFromMyContactsResponse", id, NULL);
	case SOAP_TYPE__ns1__RemoveFromMyContactsRequest:
		return ((_ns1__RemoveFromMyContactsRequest *)ptr)->soap_out(soap, "ns1:RemoveFromMyContactsRequest", id, NULL);
	case SOAP_TYPE__ns1__AddToMyContactsResponse:
		return ((_ns1__AddToMyContactsResponse *)ptr)->soap_out(soap, "ns1:AddToMyContactsResponse", id, NULL);
	case SOAP_TYPE__ns1__AddToMyContactsRequest:
		return ((_ns1__AddToMyContactsRequest *)ptr)->soap_out(soap, "ns1:AddToMyContactsRequest", id, NULL);
	case SOAP_TYPE__ns1__SearchMyContactsResponse:
		return ((_ns1__SearchMyContactsResponse *)ptr)->soap_out(soap, "ns1:SearchMyContactsResponse", id, NULL);
	case SOAP_TYPE__ns1__SearchMyContactsRequest:
		return ((_ns1__SearchMyContactsRequest *)ptr)->soap_out(soap, "ns1:SearchMyContactsRequest", id, NULL);
	case SOAP_TYPE__ns1__MyEndpointStatusResponse:
		return ((_ns1__MyEndpointStatusResponse *)ptr)->soap_out(soap, "ns1:MyEndpointStatusResponse", id, NULL);
	case SOAP_TYPE__ns1__MyEndpointStatusRequest:
		return ((_ns1__MyEndpointStatusRequest *)ptr)->soap_out(soap, "ns1:MyEndpointStatusRequest", id, NULL);
	case SOAP_TYPE__ns1__LogOutResponse:
		return ((_ns1__LogOutResponse *)ptr)->soap_out(soap, "ns1:LogOutResponse", id, NULL);
	case SOAP_TYPE__ns1__LogOutRequest:
		return ((_ns1__LogOutRequest *)ptr)->soap_out(soap, "ns1:LogOutRequest", id, NULL);
	case SOAP_TYPE__ns1__LinkEndpointResponse:
		return ((_ns1__LinkEndpointResponse *)ptr)->soap_out(soap, "ns1:LinkEndpointResponse", id, NULL);
	case SOAP_TYPE__ns1__LinkEndpointRequest:
		return ((_ns1__LinkEndpointRequest *)ptr)->soap_out(soap, "ns1:LinkEndpointRequest", id, NULL);
	case SOAP_TYPE__ns1__LogInResponse:
		return ((_ns1__LogInResponse *)ptr)->soap_out(soap, "ns1:LogInResponse", id, NULL);
	case SOAP_TYPE__ns1__LogInRequest:
		return ((_ns1__LogInRequest *)ptr)->soap_out(soap, "ns1:LogInRequest", id, NULL);
	case SOAP_TYPE__ns1__WelcomeBannerContent:
		return ((_ns1__WelcomeBannerContent *)ptr)->soap_out(soap, "ns1:WelcomeBannerContent", id, NULL);
	case SOAP_TYPE__ns1__LoginAttempt:
		return ((_ns1__LoginAttempt *)ptr)->soap_out(soap, "ns1:LoginAttempt", id, NULL);
	case SOAP_TYPE__ns1__LectureModeParticipant:
		return ((_ns1__LectureModeParticipant *)ptr)->soap_out(soap, "ns1:LectureModeParticipant", id, NULL);
	case SOAP_TYPE__ns1__Entity:
		return ((_ns1__Entity *)ptr)->soap_out(soap, "ns1:Entity", id, NULL);
	case SOAP_TYPE__ns1__Filter:
		return ((_ns1__Filter *)ptr)->soap_out(soap, "ns1:Filter", id, NULL);
	case SOAP_TYPE__ns1__RoomMode:
		return ((_ns1__RoomMode *)ptr)->soap_out(soap, "ns1:RoomMode", id, NULL);
	case SOAP_TYPE__ns1__RoomNotFoundFault:
		return ((_ns1__RoomNotFoundFault *)ptr)->soap_out(soap, "ns1:RoomNotFoundFault", id, NULL);
	case SOAP_TYPE__ns1__VidyoReplayNotAvailableFault:
		return ((_ns1__VidyoReplayNotAvailableFault *)ptr)->soap_out(soap, "ns1:VidyoReplayNotAvailableFault", id, NULL);
	case SOAP_TYPE__ns1__FeatureNotAvailableFault:
		return ((_ns1__FeatureNotAvailableFault *)ptr)->soap_out(soap, "ns1:FeatureNotAvailableFault", id, NULL);
	case SOAP_TYPE__ns1__PrefixNotConfiguredException:
		return ((_ns1__PrefixNotConfiguredException *)ptr)->soap_out(soap, "ns1:PrefixNotConfiguredException", id, NULL);
	case SOAP_TYPE__ns1__InPointToPointCallFault:
		return ((_ns1__InPointToPointCallFault *)ptr)->soap_out(soap, "ns1:InPointToPointCallFault", id, NULL);
	case SOAP_TYPE__ns1__EndpointNotBoundFault:
		return ((_ns1__EndpointNotBoundFault *)ptr)->soap_out(soap, "ns1:EndpointNotBoundFault", id, NULL);
	case SOAP_TYPE__ns1__ScheduledRoomCreationFault:
		return ((_ns1__ScheduledRoomCreationFault *)ptr)->soap_out(soap, "ns1:ScheduledRoomCreationFault", id, NULL);
	case SOAP_TYPE__ns1__ControlMeetingFault:
		return ((_ns1__ControlMeetingFault *)ptr)->soap_out(soap, "ns1:ControlMeetingFault", id, NULL);
	case SOAP_TYPE__ns1__InvalidModeratorPINFormatFault:
		return ((_ns1__InvalidModeratorPINFormatFault *)ptr)->soap_out(soap, "ns1:InvalidModeratorPINFormatFault", id, NULL);
	case SOAP_TYPE__ns1__AccessRestrictedFault:
		return ((_ns1__AccessRestrictedFault *)ptr)->soap_out(soap, "ns1:AccessRestrictedFault", id, NULL);
	case SOAP_TYPE__ns1__ResourceNotAvailableFault:
		return ((_ns1__ResourceNotAvailableFault *)ptr)->soap_out(soap, "ns1:ResourceNotAvailableFault", id, NULL);
	case SOAP_TYPE__ns1__NotLicensedFault:
		return ((_ns1__NotLicensedFault *)ptr)->soap_out(soap, "ns1:NotLicensedFault", id, NULL);
	case SOAP_TYPE__ns1__ConferenceLockedFault:
		return ((_ns1__ConferenceLockedFault *)ptr)->soap_out(soap, "ns1:ConferenceLockedFault", id, NULL);
	case SOAP_TYPE__ns1__WrongPINFault:
		return ((_ns1__WrongPINFault *)ptr)->soap_out(soap, "ns1:WrongPINFault", id, NULL);
	case SOAP_TYPE__ns1__SeatLicenseExpiredFault:
		return ((_ns1__SeatLicenseExpiredFault *)ptr)->soap_out(soap, "ns1:SeatLicenseExpiredFault", id, NULL);
	case SOAP_TYPE__ns1__InvalidArgumentFault:
		return ((_ns1__InvalidArgumentFault *)ptr)->soap_out(soap, "ns1:InvalidArgumentFault", id, NULL);
	case SOAP_TYPE__ns1__GeneralFault:
		return ((_ns1__GeneralFault *)ptr)->soap_out(soap, "ns1:GeneralFault", id, NULL);
	case SOAP_TYPE_ns1__RoomProfile:
		return ((ns1__RoomProfile *)ptr)->soap_out(soap, tag, id, "ns1:RoomProfile");
	case SOAP_TYPE_ns1__Recorder:
		return ((ns1__Recorder *)ptr)->soap_out(soap, tag, id, "ns1:Recorder");
	case SOAP_TYPE_PointerTo_ns1__GetChangePasswordHtmlUrlWithTokenRequest:
		return soap_out_PointerTo_ns1__GetChangePasswordHtmlUrlWithTokenRequest(soap, tag, id, (_ns1__GetChangePasswordHtmlUrlWithTokenRequest *const*)ptr, "ns1:GetChangePasswordHtmlUrlWithTokenRequest");
	case SOAP_TYPE_PointerTo_ns1__WhatIsMyIPAddressRequest:
		return soap_out_PointerTo_ns1__WhatIsMyIPAddressRequest(soap, tag, id, (_ns1__WhatIsMyIPAddressRequest *const*)ptr, "ns1:WhatIsMyIPAddressRequest");
	case SOAP_TYPE_PointerTo_ns1__GetVidyoReplayLibraryRequest:
		return soap_out_PointerTo_ns1__GetVidyoReplayLibraryRequest(soap, tag, id, (_ns1__GetVidyoReplayLibraryRequest *const*)ptr, "ns1:GetVidyoReplayLibraryRequest");
	case SOAP_TYPE_PointerTo_ns1__RemovePresenterRequest:
		return soap_out_PointerTo_ns1__RemovePresenterRequest(soap, tag, id, (_ns1__RemovePresenterRequest *const*)ptr, "ns1:RemovePresenterRequest");
	case SOAP_TYPE_PointerTo_ns1__SetPresenterRequest:
		return soap_out_PointerTo_ns1__SetPresenterRequest(soap, tag, id, (_ns1__SetPresenterRequest *const*)ptr, "ns1:SetPresenterRequest");
	case SOAP_TYPE_PointerTo_ns1__DismissAllRaisedHandRequest:
		return soap_out_PointerTo_ns1__DismissAllRaisedHandRequest(soap, tag, id, (_ns1__DismissAllRaisedHandRequest *const*)ptr, "ns1:DismissAllRaisedHandRequest");
	case SOAP_TYPE_PointerTo_ns1__DismissRaisedHandRequest:
		return soap_out_PointerTo_ns1__DismissRaisedHandRequest(soap, tag, id, (_ns1__DismissRaisedHandRequest *const*)ptr, "ns1:DismissRaisedHandRequest");
	case SOAP_TYPE_PointerTo_ns1__StopLectureModeRequest:
		return soap_out_PointerTo_ns1__StopLectureModeRequest(soap, tag, id, (_ns1__StopLectureModeRequest *const*)ptr, "ns1:StopLectureModeRequest");
	case SOAP_TYPE_PointerTo_ns1__StartLectureModeRequest:
		return soap_out_PointerTo_ns1__StartLectureModeRequest(soap, tag, id, (_ns1__StartLectureModeRequest *const*)ptr, "ns1:StartLectureModeRequest");
	case SOAP_TYPE_PointerTo_ns1__getUserAccountTypeRequest:
		return soap_out_PointerTo_ns1__getUserAccountTypeRequest(soap, tag, id, (_ns1__getUserAccountTypeRequest *const*)ptr, "ns1:getUserAccountTypeRequest");
	case SOAP_TYPE_PointerTo_ns1__getLoginAndWelcomeBannerRequest:
		return soap_out_PointerTo_ns1__getLoginAndWelcomeBannerRequest(soap, tag, id, (_ns1__getLoginAndWelcomeBannerRequest *const*)ptr, "ns1:getLoginAndWelcomeBannerRequest");
	case SOAP_TYPE_PointerTo_ns1__RoomAccessOptionsRequest:
		return soap_out_PointerTo_ns1__RoomAccessOptionsRequest(soap, tag, id, (_ns1__RoomAccessOptionsRequest *const*)ptr, "ns1:RoomAccessOptionsRequest");
	case SOAP_TYPE_PointerTo_ns1__muteVideoClientAllRequest:
		return soap_out_PointerTo_ns1__muteVideoClientAllRequest(soap, tag, id, (_ns1__muteVideoClientAllRequest *const*)ptr, "ns1:muteVideoClientAllRequest");
	case SOAP_TYPE_PointerTo_ns1__muteVideoServerAllRequest:
		return soap_out_PointerTo_ns1__muteVideoServerAllRequest(soap, tag, id, (_ns1__muteVideoServerAllRequest *const*)ptr, "ns1:muteVideoServerAllRequest");
	case SOAP_TYPE_PointerTo_ns1__muteAudioClientAllRequest:
		return soap_out_PointerTo_ns1__muteAudioClientAllRequest(soap, tag, id, (_ns1__muteAudioClientAllRequest *const*)ptr, "ns1:muteAudioClientAllRequest");
	case SOAP_TYPE_PointerTo_ns1__muteAudioServerAllRequest:
		return soap_out_PointerTo_ns1__muteAudioServerAllRequest(soap, tag, id, (_ns1__muteAudioServerAllRequest *const*)ptr, "ns1:muteAudioServerAllRequest");
	case SOAP_TYPE_PointerTo_ns1__disconnectConferenceAllRequest:
		return soap_out_PointerTo_ns1__disconnectConferenceAllRequest(soap, tag, id, (_ns1__disconnectConferenceAllRequest *const*)ptr, "ns1:disconnectConferenceAllRequest");
	case SOAP_TYPE_PointerTo_ns1__SetEndpointDetailsRequest:
		return soap_out_PointerTo_ns1__SetEndpointDetailsRequest(soap, tag, id, (_ns1__SetEndpointDetailsRequest *const*)ptr, "ns1:SetEndpointDetailsRequest");
	case SOAP_TYPE_PointerTo_ns1__DeleteScheduledRoomRequest:
		return soap_out_PointerTo_ns1__DeleteScheduledRoomRequest(soap, tag, id, (_ns1__DeleteScheduledRoomRequest *const*)ptr, "ns1:DeleteScheduledRoomRequest");
	case SOAP_TYPE_PointerTo_ns1__CreateScheduledRoomRequest:
		return soap_out_PointerTo_ns1__CreateScheduledRoomRequest(soap, tag, id, (_ns1__CreateScheduledRoomRequest *const*)ptr, "ns1:CreateScheduledRoomRequest");
	case SOAP_TYPE_PointerTo_ns1__GenerateAuthTokenRequest:
		return soap_out_PointerTo_ns1__GenerateAuthTokenRequest(soap, tag, id, (_ns1__GenerateAuthTokenRequest *const*)ptr, "ns1:GenerateAuthTokenRequest");
	case SOAP_TYPE_PointerTo_ns1__GetConferenceIDRequest:
		return soap_out_PointerTo_ns1__GetConferenceIDRequest(soap, tag, id, (_ns1__GetConferenceIDRequest *const*)ptr, "ns1:GetConferenceIDRequest");
	case SOAP_TYPE_PointerTo_ns1__RemoveModeratorPINRequest:
		return soap_out_PointerTo_ns1__RemoveModeratorPINRequest(soap, tag, id, (_ns1__RemoveModeratorPINRequest *const*)ptr, "ns1:RemoveModeratorPINRequest");
	case SOAP_TYPE_PointerTo_ns1__CreateModeratorPINRequest:
		return soap_out_PointerTo_ns1__CreateModeratorPINRequest(soap, tag, id, (_ns1__CreateModeratorPINRequest *const*)ptr, "ns1:CreateModeratorPINRequest");
	case SOAP_TYPE_PointerTo_ns1__GetModeratorURLWithTokenRequest:
		return soap_out_PointerTo_ns1__GetModeratorURLWithTokenRequest(soap, tag, id, (_ns1__GetModeratorURLWithTokenRequest *const*)ptr, "ns1:GetModeratorURLWithTokenRequest");
	case SOAP_TYPE_PointerTo_ns1__GetModeratorURLRequest:
		return soap_out_PointerTo_ns1__GetModeratorURLRequest(soap, tag, id, (_ns1__GetModeratorURLRequest *const*)ptr, "ns1:GetModeratorURLRequest");
	case SOAP_TYPE_PointerTo_ns1__RemoveModeratorURLRequest:
		return soap_out_PointerTo_ns1__RemoveModeratorURLRequest(soap, tag, id, (_ns1__RemoveModeratorURLRequest *const*)ptr, "ns1:RemoveModeratorURLRequest");
	case SOAP_TYPE_PointerTo_ns1__CreateModeratorURLRequest:
		return soap_out_PointerTo_ns1__CreateModeratorURLRequest(soap, tag, id, (_ns1__CreateModeratorURLRequest *const*)ptr, "ns1:CreateModeratorURLRequest");
	case SOAP_TYPE_PointerTo_ns1__RemoveRoomProfileRequest:
		return soap_out_PointerTo_ns1__RemoveRoomProfileRequest(soap, tag, id, (_ns1__RemoveRoomProfileRequest *const*)ptr, "ns1:RemoveRoomProfileRequest");
	case SOAP_TYPE_PointerTo_ns1__SetRoomProfileRequest:
		return soap_out_PointerTo_ns1__SetRoomProfileRequest(soap, tag, id, (_ns1__SetRoomProfileRequest *const*)ptr, "ns1:SetRoomProfileRequest");
	case SOAP_TYPE_PointerTo_ns1__GetRoomProfileRequest:
		return soap_out_PointerTo_ns1__GetRoomProfileRequest(soap, tag, id, (_ns1__GetRoomProfileRequest *const*)ptr, "ns1:GetRoomProfileRequest");
	case SOAP_TYPE_PointerTo_ns1__GetInviteContentRequest:
		return soap_out_PointerTo_ns1__GetInviteContentRequest(soap, tag, id, (_ns1__GetInviteContentRequest *const*)ptr, "ns1:GetInviteContentRequest");
	case SOAP_TYPE_PointerTo_ns1__GetEntityByRoomKeyRequest:
		return soap_out_PointerTo_ns1__GetEntityByRoomKeyRequest(soap, tag, id, (_ns1__GetEntityByRoomKeyRequest *const*)ptr, "ns1:GetEntityByRoomKeyRequest");
	case SOAP_TYPE_PointerTo_ns1__GetUserNameRequest:
		return soap_out_PointerTo_ns1__GetUserNameRequest(soap, tag, id, (_ns1__GetUserNameRequest *const*)ptr, "ns1:GetUserNameRequest");
	case SOAP_TYPE_PointerTo_ns1__GetWebcastURLRequest:
		return soap_out_PointerTo_ns1__GetWebcastURLRequest(soap, tag, id, (_ns1__GetWebcastURLRequest *const*)ptr, "ns1:GetWebcastURLRequest");
	case SOAP_TYPE_PointerTo_ns1__RemoveWebcastPINRequest:
		return soap_out_PointerTo_ns1__RemoveWebcastPINRequest(soap, tag, id, (_ns1__RemoveWebcastPINRequest *const*)ptr, "ns1:RemoveWebcastPINRequest");
	case SOAP_TYPE_PointerTo_ns1__RemoveWebcastURLRequest:
		return soap_out_PointerTo_ns1__RemoveWebcastURLRequest(soap, tag, id, (_ns1__RemoveWebcastURLRequest *const*)ptr, "ns1:RemoveWebcastURLRequest");
	case SOAP_TYPE_PointerTo_ns1__CreateWebcastPINRequest:
		return soap_out_PointerTo_ns1__CreateWebcastPINRequest(soap, tag, id, (_ns1__CreateWebcastPINRequest *const*)ptr, "ns1:CreateWebcastPINRequest");
	case SOAP_TYPE_PointerTo_ns1__CreateWebcastURLRequest:
		return soap_out_PointerTo_ns1__CreateWebcastURLRequest(soap, tag, id, (_ns1__CreateWebcastURLRequest *const*)ptr, "ns1:CreateWebcastURLRequest");
	case SOAP_TYPE_PointerTo_ns1__StopRecordingRequest:
		return soap_out_PointerTo_ns1__StopRecordingRequest(soap, tag, id, (_ns1__StopRecordingRequest *const*)ptr, "ns1:StopRecordingRequest");
	case SOAP_TYPE_PointerTo_ns1__ResumeRecordingRequest:
		return soap_out_PointerTo_ns1__ResumeRecordingRequest(soap, tag, id, (_ns1__ResumeRecordingRequest *const*)ptr, "ns1:ResumeRecordingRequest");
	case SOAP_TYPE_PointerTo_ns1__PauseRecordingRequest:
		return soap_out_PointerTo_ns1__PauseRecordingRequest(soap, tag, id, (_ns1__PauseRecordingRequest *const*)ptr, "ns1:PauseRecordingRequest");
	case SOAP_TYPE_PointerTo_ns1__GetPortalVersionRequest:
		return soap_out_PointerTo_ns1__GetPortalVersionRequest(soap, tag, id, (_ns1__GetPortalVersionRequest *const*)ptr, "ns1:GetPortalVersionRequest");
	case SOAP_TYPE_PointerTo_ns1__StartRecordingRequest:
		return soap_out_PointerTo_ns1__StartRecordingRequest(soap, tag, id, (_ns1__StartRecordingRequest *const*)ptr, "ns1:StartRecordingRequest");
	case SOAP_TYPE_PointerTo_ns1__GetRecordingProfilesRequest:
		return soap_out_PointerTo_ns1__GetRecordingProfilesRequest(soap, tag, id, (_ns1__GetRecordingProfilesRequest *const*)ptr, "ns1:GetRecordingProfilesRequest");
	case SOAP_TYPE_PointerTo_ns1__SetMemberModeRequest:
		return soap_out_PointerTo_ns1__SetMemberModeRequest(soap, tag, id, (_ns1__SetMemberModeRequest *const*)ptr, "ns1:SetMemberModeRequest");
	case SOAP_TYPE_PointerTo_ns1__UnlockRoomRequest:
		return soap_out_PointerTo_ns1__UnlockRoomRequest(soap, tag, id, (_ns1__UnlockRoomRequest *const*)ptr, "ns1:UnlockRoomRequest");
	case SOAP_TYPE_PointerTo_ns1__LockRoomRequest:
		return soap_out_PointerTo_ns1__LockRoomRequest(soap, tag, id, (_ns1__LockRoomRequest *const*)ptr, "ns1:LockRoomRequest");
	case SOAP_TYPE_PointerTo_ns1__UpdateLanguageRequest:
		return soap_out_PointerTo_ns1__UpdateLanguageRequest(soap, tag, id, (_ns1__UpdateLanguageRequest *const*)ptr, "ns1:UpdateLanguageRequest");
	case SOAP_TYPE_PointerTo_ns1__UpdatePasswordRequest:
		return soap_out_PointerTo_ns1__UpdatePasswordRequest(soap, tag, id, (_ns1__UpdatePasswordRequest *const*)ptr, "ns1:UpdatePasswordRequest");
	case SOAP_TYPE_PointerTo_ns1__DeleteRoomRequest:
		return soap_out_PointerTo_ns1__DeleteRoomRequest(soap, tag, id, (_ns1__DeleteRoomRequest *const*)ptr, "ns1:DeleteRoomRequest");
	case SOAP_TYPE_PointerTo_ns1__CreateRoomRequest:
		return soap_out_PointerTo_ns1__CreateRoomRequest(soap, tag, id, (_ns1__CreateRoomRequest *const*)ptr, "ns1:CreateRoomRequest");
	case SOAP_TYPE_PointerTo_ns1__RemoveRoomPINRequest:
		return soap_out_PointerTo_ns1__RemoveRoomPINRequest(soap, tag, id, (_ns1__RemoveRoomPINRequest *const*)ptr, "ns1:RemoveRoomPINRequest");
	case SOAP_TYPE_PointerTo_ns1__CreateRoomPINRequest:
		return soap_out_PointerTo_ns1__CreateRoomPINRequest(soap, tag, id, (_ns1__CreateRoomPINRequest *const*)ptr, "ns1:CreateRoomPINRequest");
	case SOAP_TYPE_PointerTo_ns1__RemoveRoomURLRequest:
		return soap_out_PointerTo_ns1__RemoveRoomURLRequest(soap, tag, id, (_ns1__RemoveRoomURLRequest *const*)ptr, "ns1:RemoveRoomURLRequest");
	case SOAP_TYPE_PointerTo_ns1__CreateRoomURLRequest:
		return soap_out_PointerTo_ns1__CreateRoomURLRequest(soap, tag, id, (_ns1__CreateRoomURLRequest *const*)ptr, "ns1:CreateRoomURLRequest");
	case SOAP_TYPE_PointerTo_ns1__MyAccountRequest:
		return soap_out_PointerTo_ns1__MyAccountRequest(soap, tag, id, (_ns1__MyAccountRequest *const*)ptr, "ns1:MyAccountRequest");
	case SOAP_TYPE_PointerTo_ns1__StopVideoRequest:
		return soap_out_PointerTo_ns1__StopVideoRequest(soap, tag, id, (_ns1__StopVideoRequest *const*)ptr, "ns1:StopVideoRequest");
	case SOAP_TYPE_PointerTo_ns1__StartVideoRequest:
		return soap_out_PointerTo_ns1__StartVideoRequest(soap, tag, id, (_ns1__StartVideoRequest *const*)ptr, "ns1:StartVideoRequest");
	case SOAP_TYPE_PointerTo_ns1__UnmuteAudioRequest:
		return soap_out_PointerTo_ns1__UnmuteAudioRequest(soap, tag, id, (_ns1__UnmuteAudioRequest *const*)ptr, "ns1:UnmuteAudioRequest");
	case SOAP_TYPE_PointerTo_ns1__MuteAudioRequest:
		return soap_out_PointerTo_ns1__MuteAudioRequest(soap, tag, id, (_ns1__MuteAudioRequest *const*)ptr, "ns1:MuteAudioRequest");
	case SOAP_TYPE_PointerTo_ns1__LeaveConferenceRequest:
		return soap_out_PointerTo_ns1__LeaveConferenceRequest(soap, tag, id, (_ns1__LeaveConferenceRequest *const*)ptr, "ns1:LeaveConferenceRequest");
	case SOAP_TYPE_PointerTo_ns1__GetLectureModeParticipantsRequest:
		return soap_out_PointerTo_ns1__GetLectureModeParticipantsRequest(soap, tag, id, (_ns1__GetLectureModeParticipantsRequest *const*)ptr, "ns1:GetLectureModeParticipantsRequest");
	case SOAP_TYPE_PointerTo_ns1__GetParticipantsRequest:
		return soap_out_PointerTo_ns1__GetParticipantsRequest(soap, tag, id, (_ns1__GetParticipantsRequest *const*)ptr, "ns1:GetParticipantsRequest");
	case SOAP_TYPE_PointerTo_ns1__DirectCallRequest:
		return soap_out_PointerTo_ns1__DirectCallRequest(soap, tag, id, (_ns1__DirectCallRequest *const*)ptr, "ns1:DirectCallRequest");
	case SOAP_TYPE_PointerTo_ns1__JoinIPCConferenceRequest:
		return soap_out_PointerTo_ns1__JoinIPCConferenceRequest(soap, tag, id, (_ns1__JoinIPCConferenceRequest *const*)ptr, "ns1:JoinIPCConferenceRequest");
	case SOAP_TYPE_PointerTo_ns1__JoinConferenceRequest:
		return soap_out_PointerTo_ns1__JoinConferenceRequest(soap, tag, id, (_ns1__JoinConferenceRequest *const*)ptr, "ns1:JoinConferenceRequest");
	case SOAP_TYPE_PointerTo_ns1__CancelOutboundCallRequest:
		return soap_out_PointerTo_ns1__CancelOutboundCallRequest(soap, tag, id, (_ns1__CancelOutboundCallRequest *const*)ptr, "ns1:CancelOutboundCallRequest");
	case SOAP_TYPE_PointerTo_ns1__InviteToConferenceRequest:
		return soap_out_PointerTo_ns1__InviteToConferenceRequest(soap, tag, id, (_ns1__InviteToConferenceRequest *const*)ptr, "ns1:InviteToConferenceRequest");
	case SOAP_TYPE_PointerTo_ns1__GetEntityByEntityIDRequest:
		return soap_out_PointerTo_ns1__GetEntityByEntityIDRequest(soap, tag, id, (_ns1__GetEntityByEntityIDRequest *const*)ptr, "ns1:GetEntityByEntityIDRequest");
	case SOAP_TYPE_PointerTo_ns1__SearchByEmailRequest:
		return soap_out_PointerTo_ns1__SearchByEmailRequest(soap, tag, id, (_ns1__SearchByEmailRequest *const*)ptr, "ns1:SearchByEmailRequest");
	case SOAP_TYPE_PointerTo_ns1__SearchByEntityIDRequest:
		return soap_out_PointerTo_ns1__SearchByEntityIDRequest(soap, tag, id, (_ns1__SearchByEntityIDRequest *const*)ptr, "ns1:SearchByEntityIDRequest");
	case SOAP_TYPE_PointerTo_ns1__SearchRequest:
		return soap_out_PointerTo_ns1__SearchRequest(soap, tag, id, (_ns1__SearchRequest *const*)ptr, "ns1:SearchRequest");
	case SOAP_TYPE_PointerTo_ns1__RemoveFromMyContactsRequest:
		return soap_out_PointerTo_ns1__RemoveFromMyContactsRequest(soap, tag, id, (_ns1__RemoveFromMyContactsRequest *const*)ptr, "ns1:RemoveFromMyContactsRequest");
	case SOAP_TYPE_PointerTo_ns1__AddToMyContactsRequest:
		return soap_out_PointerTo_ns1__AddToMyContactsRequest(soap, tag, id, (_ns1__AddToMyContactsRequest *const*)ptr, "ns1:AddToMyContactsRequest");
	case SOAP_TYPE_PointerTo_ns1__SearchMyContactsRequest:
		return soap_out_PointerTo_ns1__SearchMyContactsRequest(soap, tag, id, (_ns1__SearchMyContactsRequest *const*)ptr, "ns1:SearchMyContactsRequest");
	case SOAP_TYPE_PointerTo_ns1__MyEndpointStatusRequest:
		return soap_out_PointerTo_ns1__MyEndpointStatusRequest(soap, tag, id, (_ns1__MyEndpointStatusRequest *const*)ptr, "ns1:MyEndpointStatusRequest");
	case SOAP_TYPE_PointerTo_ns1__LogOutRequest:
		return soap_out_PointerTo_ns1__LogOutRequest(soap, tag, id, (_ns1__LogOutRequest *const*)ptr, "ns1:LogOutRequest");
	case SOAP_TYPE_PointerTo_ns1__LinkEndpointRequest:
		return soap_out_PointerTo_ns1__LinkEndpointRequest(soap, tag, id, (_ns1__LinkEndpointRequest *const*)ptr, "ns1:LinkEndpointRequest");
	case SOAP_TYPE_PointerTo_ns1__LogInRequest:
		return soap_out_PointerTo_ns1__LogInRequest(soap, tag, id, (_ns1__LogInRequest *const*)ptr, "ns1:LogInRequest");
	case SOAP_TYPE_PointerTo_ns1__WrongPINFault:
		return soap_out_PointerTo_ns1__WrongPINFault(soap, tag, id, (_ns1__WrongPINFault *const*)ptr, "ns1:WrongPINFault");
	case SOAP_TYPE_PointerTo_ns1__VidyoReplayNotAvailableFault:
		return soap_out_PointerTo_ns1__VidyoReplayNotAvailableFault(soap, tag, id, (_ns1__VidyoReplayNotAvailableFault *const*)ptr, "ns1:VidyoReplayNotAvailableFault");
	case SOAP_TYPE_PointerTo_ns1__SeatLicenseExpiredFault:
		return soap_out_PointerTo_ns1__SeatLicenseExpiredFault(soap, tag, id, (_ns1__SeatLicenseExpiredFault *const*)ptr, "ns1:SeatLicenseExpiredFault");
	case SOAP_TYPE_PointerTo_ns1__ScheduledRoomCreationFault:
		return soap_out_PointerTo_ns1__ScheduledRoomCreationFault(soap, tag, id, (_ns1__ScheduledRoomCreationFault *const*)ptr, "ns1:ScheduledRoomCreationFault");
	case SOAP_TYPE_PointerTo_ns1__RoomNotFoundFault:
		return soap_out_PointerTo_ns1__RoomNotFoundFault(soap, tag, id, (_ns1__RoomNotFoundFault *const*)ptr, "ns1:RoomNotFoundFault");
	case SOAP_TYPE_PointerTo_ns1__ResourceNotAvailableFault:
		return soap_out_PointerTo_ns1__ResourceNotAvailableFault(soap, tag, id, (_ns1__ResourceNotAvailableFault *const*)ptr, "ns1:ResourceNotAvailableFault");
	case SOAP_TYPE_PointerTo_ns1__PrefixNotConfiguredFault:
		return soap_out_PointerTo_ns1__PrefixNotConfiguredFault(soap, tag, id, (_ns1__PrefixNotConfiguredFault *const*)ptr, "ns1:PrefixNotConfiguredFault");
	case SOAP_TYPE_PointerTo_ns1__NotLicensedFault:
		return soap_out_PointerTo_ns1__NotLicensedFault(soap, tag, id, (_ns1__NotLicensedFault *const*)ptr, "ns1:NotLicensedFault");
	case SOAP_TYPE_PointerTo_ns1__InvalidModeratorPINFormatFault:
		return soap_out_PointerTo_ns1__InvalidModeratorPINFormatFault(soap, tag, id, (_ns1__InvalidModeratorPINFormatFault *const*)ptr, "ns1:InvalidModeratorPINFormatFault");
	case SOAP_TYPE_PointerTo_ns1__InvalidArgumentFault:
		return soap_out_PointerTo_ns1__InvalidArgumentFault(soap, tag, id, (_ns1__InvalidArgumentFault *const*)ptr, "ns1:InvalidArgumentFault");
	case SOAP_TYPE_PointerTo_ns1__InPointToPointCallFault:
		return soap_out_PointerTo_ns1__InPointToPointCallFault(soap, tag, id, (_ns1__InPointToPointCallFault *const*)ptr, "ns1:InPointToPointCallFault");
	case SOAP_TYPE_PointerTo_ns1__GeneralFault:
		return soap_out_PointerTo_ns1__GeneralFault(soap, tag, id, (_ns1__GeneralFault *const*)ptr, "ns1:GeneralFault");
	case SOAP_TYPE_PointerTo_ns1__FeatureNotAvailableFault:
		return soap_out_PointerTo_ns1__FeatureNotAvailableFault(soap, tag, id, (_ns1__FeatureNotAvailableFault *const*)ptr, "ns1:FeatureNotAvailableFault");
	case SOAP_TYPE_PointerTo_ns1__EndpointNotBoundFault:
		return soap_out_PointerTo_ns1__EndpointNotBoundFault(soap, tag, id, (_ns1__EndpointNotBoundFault *const*)ptr, "ns1:EndpointNotBoundFault");
	case SOAP_TYPE_PointerTo_ns1__ControlMeetingFault:
		return soap_out_PointerTo_ns1__ControlMeetingFault(soap, tag, id, (_ns1__ControlMeetingFault *const*)ptr, "ns1:ControlMeetingFault");
	case SOAP_TYPE_PointerTo_ns1__ConferenceLockedFault:
		return soap_out_PointerTo_ns1__ConferenceLockedFault(soap, tag, id, (_ns1__ConferenceLockedFault *const*)ptr, "ns1:ConferenceLockedFault");
	case SOAP_TYPE_PointerTo_ns1__AccessRestrictedFault:
		return soap_out_PointerTo_ns1__AccessRestrictedFault(soap, tag, id, (_ns1__AccessRestrictedFault *const*)ptr, "ns1:AccessRestrictedFault");
	case SOAP_TYPE_PointerTo_ns1__WelcomeBannerContent:
		return soap_out_PointerTo_ns1__WelcomeBannerContent(soap, tag, id, (_ns1__WelcomeBannerContent *const*)ptr, "ns1:WelcomeBannerContent");
	case SOAP_TYPE_PointerToPointerTo_ns1__RoomAccessOption:
		return soap_out_PointerToPointerTo_ns1__RoomAccessOption(soap, tag, id, (_ns1__RoomAccessOption **const*)ptr, "ns1:RoomAccessOption");
	case SOAP_TYPE_PointerTo_ns1__RoomAccessOption:
		return soap_out_PointerTo_ns1__RoomAccessOption(soap, tag, id, (_ns1__RoomAccessOption *const*)ptr, "ns1:RoomAccessOption");
	case SOAP_TYPE_PointerToPointerTo_ns1__EndpointFeature:
		return soap_out_PointerToPointerTo_ns1__EndpointFeature(soap, tag, id, (_ns1__EndpointFeature **const*)ptr, "ns1:EndpointFeature");
	case SOAP_TYPE_PointerTo_ns1__EndpointFeature:
		return soap_out_PointerTo_ns1__EndpointFeature(soap, tag, id, (_ns1__EndpointFeature *const*)ptr, "ns1:EndpointFeature");
	case SOAP_TYPE_PointerToPointerTo_ns1__PortalFeature:
		return soap_out_PointerToPointerTo_ns1__PortalFeature(soap, tag, id, (_ns1__PortalFeature **const*)ptr, "ns1:PortalFeature");
	case SOAP_TYPE_PointerTo_ns1__PortalFeature:
		return soap_out_PointerTo_ns1__PortalFeature(soap, tag, id, (_ns1__PortalFeature *const*)ptr, "ns1:PortalFeature");
	case SOAP_TYPE_PointerTostring:
		return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToPointerTons1__RoomProfile:
		return soap_out_PointerToPointerTons1__RoomProfile(soap, tag, id, (ns1__RoomProfile **const*)ptr, "ns1:RoomProfile");
	case SOAP_TYPE_PointerTons1__RoomProfile:
		return soap_out_PointerTons1__RoomProfile(soap, tag, id, (ns1__RoomProfile *const*)ptr, "ns1:RoomProfile");
	case SOAP_TYPE_PointerToPointerTons1__Recorder:
		return soap_out_PointerToPointerTons1__Recorder(soap, tag, id, (ns1__Recorder **const*)ptr, "ns1:Recorder");
	case SOAP_TYPE_PointerTons1__Recorder:
		return soap_out_PointerTons1__Recorder(soap, tag, id, (ns1__Recorder *const*)ptr, "ns1:Recorder");
	case SOAP_TYPE_PointerToPointerTo_ns1__LectureModeParticipant:
		return soap_out_PointerToPointerTo_ns1__LectureModeParticipant(soap, tag, id, (_ns1__LectureModeParticipant **const*)ptr, "ns1:LectureModeParticipant");
	case SOAP_TYPE_PointerTo_ns1__LectureModeParticipant:
		return soap_out_PointerTo_ns1__LectureModeParticipant(soap, tag, id, (_ns1__LectureModeParticipant *const*)ptr, "ns1:LectureModeParticipant");
	case SOAP_TYPE_PointerTons1__EntityID:
		return soap_out_PointerTons1__EntityID(soap, tag, id, (char **const*)ptr, "ns1:EntityID");
	case SOAP_TYPE_PointerToPointerTo_ns1__Entity:
		return soap_out_PointerToPointerTo_ns1__Entity(soap, tag, id, (_ns1__Entity **const*)ptr, "ns1:Entity");
	case SOAP_TYPE_PointerTo_ns1__Filter:
		return soap_out_PointerTo_ns1__Filter(soap, tag, id, (_ns1__Filter *const*)ptr, "ns1:Filter");
	case SOAP_TYPE_PointerTo_ns1__Entity:
		return soap_out_PointerTo_ns1__Entity(soap, tag, id, (_ns1__Entity *const*)ptr, "ns1:Entity");
	case SOAP_TYPE_PointerTo_ns1__ClientType:
		return soap_out_PointerTo_ns1__ClientType(soap, tag, id, (enum _ns1__ClientType *const*)ptr, "ns1:ClientType");
	case SOAP_TYPE_PointerTodateTime:
		return soap_out_PointerTodateTime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerToPointerTo_ns1__LoginAttempt:
		return soap_out_PointerToPointerTo_ns1__LoginAttempt(soap, tag, id, (_ns1__LoginAttempt **const*)ptr, "ns1:LoginAttempt");
	case SOAP_TYPE_PointerTo_ns1__LoginAttempt:
		return soap_out_PointerTo_ns1__LoginAttempt(soap, tag, id, (_ns1__LoginAttempt *const*)ptr, "ns1:LoginAttempt");
	case SOAP_TYPE_PointerTo_ns1__RoomMode:
		return soap_out_PointerTo_ns1__RoomMode(soap, tag, id, (_ns1__RoomMode *const*)ptr, "ns1:RoomMode");
	case SOAP_TYPE_PointerTo_ns1__RoomStatus:
		return soap_out_PointerTo_ns1__RoomStatus(soap, tag, id, (enum _ns1__RoomStatus *const*)ptr, "ns1:RoomStatus");
	case SOAP_TYPE_PointerTo_ns1__MemberMode:
		return soap_out_PointerTo_ns1__MemberMode(soap, tag, id, (enum _ns1__MemberMode *const*)ptr, "ns1:MemberMode");
	case SOAP_TYPE_PointerTo_ns1__MemberStatus:
		return soap_out_PointerTo_ns1__MemberStatus(soap, tag, id, (enum _ns1__MemberStatus *const*)ptr, "ns1:MemberStatus");
	case SOAP_TYPE_PointerTo_ns1__Language:
		return soap_out_PointerTo_ns1__Language(soap, tag, id, (enum _ns1__Language *const*)ptr, "ns1:Language");
	case SOAP_TYPE_PointerTo_ns1__EntityType:
		return soap_out_PointerTo_ns1__EntityType(soap, tag, id, (enum _ns1__EntityType *const*)ptr, "ns1:EntityType");
	case SOAP_TYPE_PointerTons1__sortDir:
		return soap_out_PointerTons1__sortDir(soap, tag, id, (enum ns1__sortDir *const*)ptr, "ns1:sortDir");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerTobool:
		return soap_out_PointerTobool(soap, tag, id, (bool *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_ns1__EndpointFeatureName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "ns1:EndpointFeatureName");
	case SOAP_TYPE_ns1__PortalFeatureName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "ns1:PortalFeatureName");
	case SOAP_TYPE_ns1__EntityID:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "ns1:EntityID");
	case SOAP_TYPE_xsd__anyURI:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:anyURI");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__ns1__GetChangePasswordHtmlUrlWithTokenResponse:
		((_ns1__GetChangePasswordHtmlUrlWithTokenResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetChangePasswordHtmlUrlWithTokenRequest:
		((_ns1__GetChangePasswordHtmlUrlWithTokenRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__WhatIsMyIPAddressResponse:
		((_ns1__WhatIsMyIPAddressResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__WhatIsMyIPAddressRequest:
		((_ns1__WhatIsMyIPAddressRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetVidyoReplayLibraryResponse:
		((_ns1__GetVidyoReplayLibraryResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetVidyoReplayLibraryRequest:
		((_ns1__GetVidyoReplayLibraryRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RemovePresenterResponse:
		((_ns1__RemovePresenterResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RemovePresenterRequest:
		((_ns1__RemovePresenterRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetPresenterResponse:
		((_ns1__SetPresenterResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetPresenterRequest:
		((_ns1__SetPresenterRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DismissAllRaisedHandResponse:
		((_ns1__DismissAllRaisedHandResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DismissAllRaisedHandRequest:
		((_ns1__DismissAllRaisedHandRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DismissRaisedHandResponse:
		((_ns1__DismissRaisedHandResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DismissRaisedHandRequest:
		((_ns1__DismissRaisedHandRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UnraiseHandResponse:
		((_ns1__UnraiseHandResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RaiseHandResponse:
		((_ns1__RaiseHandResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__StopLectureModeResponse:
		((_ns1__StopLectureModeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__StopLectureModeRequest:
		((_ns1__StopLectureModeRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__StartLectureModeResponse:
		((_ns1__StartLectureModeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__StartLectureModeRequest:
		((_ns1__StartLectureModeRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getUserAccountTypeResponse:
		((_ns1__getUserAccountTypeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getUserAccountTypeRequest:
		((_ns1__getUserAccountTypeRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getLoginAndWelcomeBannerResponse:
		((_ns1__getLoginAndWelcomeBannerResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__getLoginAndWelcomeBannerRequest:
		((_ns1__getLoginAndWelcomeBannerRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__PrefixNotConfiguredFault:
		((_ns1__PrefixNotConfiguredFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__PortalPrefixResponse:
		((_ns1__PortalPrefixResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RoomAccessOptionsResponse:
		((_ns1__RoomAccessOptionsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RoomAccessOptionsRequest:
		((_ns1__RoomAccessOptionsRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RoomAccessOption:
		((_ns1__RoomAccessOption *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__OnetimeAccessResponse:
		((_ns1__OnetimeAccessResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__muteVideoClientAllResponse:
		((_ns1__muteVideoClientAllResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__muteVideoClientAllRequest:
		((_ns1__muteVideoClientAllRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__muteVideoServerAllResponse:
		((_ns1__muteVideoServerAllResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__muteVideoServerAllRequest:
		((_ns1__muteVideoServerAllRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__muteAudioClientAllResponse:
		((_ns1__muteAudioClientAllResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__muteAudioClientAllRequest:
		((_ns1__muteAudioClientAllRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__muteAudioServerAllResponse:
		((_ns1__muteAudioServerAllResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__muteAudioServerAllRequest:
		((_ns1__muteAudioServerAllRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__disconnectConferenceAllResponse:
		((_ns1__disconnectConferenceAllResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__disconnectConferenceAllRequest:
		((_ns1__disconnectConferenceAllRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__LogoutAllOtherSessionsResponse:
		((_ns1__LogoutAllOtherSessionsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetActiveSessionsResponse:
		((_ns1__GetActiveSessionsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetEndpointDetailsResponse:
		((_ns1__SetEndpointDetailsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetEndpointDetailsRequest:
		((_ns1__SetEndpointDetailsRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__EndpointFeature:
		((_ns1__EndpointFeature *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPortalFeaturesResponse:
		((_ns1__GetPortalFeaturesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__PortalFeature:
		((_ns1__PortalFeature *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DeleteScheduledRoomResponse:
		((_ns1__DeleteScheduledRoomResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DeleteScheduledRoomRequest:
		((_ns1__DeleteScheduledRoomRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CreateScheduledRoomResponse:
		((_ns1__CreateScheduledRoomResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CreateScheduledRoomRequest:
		((_ns1__CreateScheduledRoomRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GenerateAuthTokenResponse:
		((_ns1__GenerateAuthTokenResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GenerateAuthTokenRequest:
		((_ns1__GenerateAuthTokenRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetConferenceIDResponse:
		((_ns1__GetConferenceIDResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetConferenceIDRequest:
		((_ns1__GetConferenceIDRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RemoveModeratorPINResponse:
		((_ns1__RemoveModeratorPINResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RemoveModeratorPINRequest:
		((_ns1__RemoveModeratorPINRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CreateModeratorPINResponse:
		((_ns1__CreateModeratorPINResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CreateModeratorPINRequest:
		((_ns1__CreateModeratorPINRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetModeratorURLWithTokenResponse:
		((_ns1__GetModeratorURLWithTokenResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetModeratorURLWithTokenRequest:
		((_ns1__GetModeratorURLWithTokenRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetModeratorURLResponse:
		((_ns1__GetModeratorURLResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetModeratorURLRequest:
		((_ns1__GetModeratorURLRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RemoveModeratorURLResponse:
		((_ns1__RemoveModeratorURLResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RemoveModeratorURLRequest:
		((_ns1__RemoveModeratorURLRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CreateModeratorURLResponse:
		((_ns1__CreateModeratorURLResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CreateModeratorURLRequest:
		((_ns1__CreateModeratorURLRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RemoveRoomProfileResponse:
		((_ns1__RemoveRoomProfileResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RemoveRoomProfileRequest:
		((_ns1__RemoveRoomProfileRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetRoomProfileResponse:
		((_ns1__SetRoomProfileResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetRoomProfileRequest:
		((_ns1__SetRoomProfileRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetRoomProfileResponse:
		((_ns1__GetRoomProfileResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetRoomProfileRequest:
		((_ns1__GetRoomProfileRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetRoomProfilesResponse:
		((_ns1__GetRoomProfilesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetInviteContentResponse:
		((_ns1__GetInviteContentResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetInviteContentRequest:
		((_ns1__GetInviteContentRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetEntityByRoomKeyResponse:
		((_ns1__GetEntityByRoomKeyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetEntityByRoomKeyRequest:
		((_ns1__GetEntityByRoomKeyRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetUserNameResponse:
		((_ns1__GetUserNameResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetUserNameRequest:
		((_ns1__GetUserNameRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetWebcastURLResponse:
		((_ns1__GetWebcastURLResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetWebcastURLRequest:
		((_ns1__GetWebcastURLRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RemoveWebcastPINResponse:
		((_ns1__RemoveWebcastPINResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RemoveWebcastPINRequest:
		((_ns1__RemoveWebcastPINRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RemoveWebcastURLResponse:
		((_ns1__RemoveWebcastURLResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RemoveWebcastURLRequest:
		((_ns1__RemoveWebcastURLRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CreateWebcastPINResponse:
		((_ns1__CreateWebcastPINResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CreateWebcastPINRequest:
		((_ns1__CreateWebcastPINRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CreateWebcastURLResponse:
		((_ns1__CreateWebcastURLResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CreateWebcastURLRequest:
		((_ns1__CreateWebcastURLRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__StopRecordingResponse:
		((_ns1__StopRecordingResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__StopRecordingRequest:
		((_ns1__StopRecordingRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ResumeRecordingResponse:
		((_ns1__ResumeRecordingResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ResumeRecordingRequest:
		((_ns1__ResumeRecordingRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__PauseRecordingResponse:
		((_ns1__PauseRecordingResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__PauseRecordingRequest:
		((_ns1__PauseRecordingRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPortalVersionResponse:
		((_ns1__GetPortalVersionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPortalVersionRequest:
		((_ns1__GetPortalVersionRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__StartRecordingResponse:
		((_ns1__StartRecordingResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__StartRecordingRequest:
		((_ns1__StartRecordingRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetRecordingProfilesResponse:
		((_ns1__GetRecordingProfilesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetRecordingProfilesRequest:
		((_ns1__GetRecordingProfilesRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetMemberModeResponse:
		((_ns1__SetMemberModeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetMemberModeRequest:
		((_ns1__SetMemberModeRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UnlockRoomResponse:
		((_ns1__UnlockRoomResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UnlockRoomRequest:
		((_ns1__UnlockRoomRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__LockRoomResponse:
		((_ns1__LockRoomResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__LockRoomRequest:
		((_ns1__LockRoomRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpdateLanguageResponse:
		((_ns1__UpdateLanguageResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpdateLanguageRequest:
		((_ns1__UpdateLanguageRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpdatePasswordResponse:
		((_ns1__UpdatePasswordResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpdatePasswordRequest:
		((_ns1__UpdatePasswordRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RemoveRoomPINResponse:
		((_ns1__RemoveRoomPINResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RemoveRoomPINRequest:
		((_ns1__RemoveRoomPINRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CreateRoomPINResponse:
		((_ns1__CreateRoomPINResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CreateRoomPINRequest:
		((_ns1__CreateRoomPINRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RemoveRoomURLResponse:
		((_ns1__RemoveRoomURLResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RemoveRoomURLRequest:
		((_ns1__RemoveRoomURLRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CreateRoomURLResponse:
		((_ns1__CreateRoomURLResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CreateRoomURLRequest:
		((_ns1__CreateRoomURLRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DeleteRoomResponse:
		((_ns1__DeleteRoomResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DeleteRoomRequest:
		((_ns1__DeleteRoomRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CreateRoomResponse:
		((_ns1__CreateRoomResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CreateRoomRequest:
		((_ns1__CreateRoomRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__MyAccountResponse:
		((_ns1__MyAccountResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__MyAccountRequest:
		((_ns1__MyAccountRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__StopVideoResponse:
		((_ns1__StopVideoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__StopVideoRequest:
		((_ns1__StopVideoRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__StartVideoResponse:
		((_ns1__StartVideoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__StartVideoRequest:
		((_ns1__StartVideoRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UnmuteAudioResponse:
		((_ns1__UnmuteAudioResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UnmuteAudioRequest:
		((_ns1__UnmuteAudioRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__MuteAudioResponse:
		((_ns1__MuteAudioResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__MuteAudioRequest:
		((_ns1__MuteAudioRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__LeaveConferenceResponse:
		((_ns1__LeaveConferenceResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__LeaveConferenceRequest:
		((_ns1__LeaveConferenceRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetLectureModeParticipantsResponse:
		((_ns1__GetLectureModeParticipantsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetLectureModeParticipantsRequest:
		((_ns1__GetLectureModeParticipantsRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetParticipantsResponse:
		((_ns1__GetParticipantsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetParticipantsRequest:
		((_ns1__GetParticipantsRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DirectCallResponse:
		((_ns1__DirectCallResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DirectCallRequest:
		((_ns1__DirectCallRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__JoinIPCConferenceResponse:
		((_ns1__JoinIPCConferenceResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__JoinIPCConferenceRequest:
		((_ns1__JoinIPCConferenceRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__JoinConferenceResponse:
		((_ns1__JoinConferenceResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__JoinConferenceRequest:
		((_ns1__JoinConferenceRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CancelOutboundCallResponse:
		((_ns1__CancelOutboundCallResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CancelOutboundCallRequest:
		((_ns1__CancelOutboundCallRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InviteToConferenceResponse:
		((_ns1__InviteToConferenceResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InviteToConferenceRequest:
		((_ns1__InviteToConferenceRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetEntityByEntityIDResponse:
		((_ns1__GetEntityByEntityIDResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetEntityByEntityIDRequest:
		((_ns1__GetEntityByEntityIDRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SearchByEmailResponse:
		((_ns1__SearchByEmailResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SearchByEmailRequest:
		((_ns1__SearchByEmailRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SearchByEntityIDResponse:
		((_ns1__SearchByEntityIDResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SearchByEntityIDRequest:
		((_ns1__SearchByEntityIDRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SearchResponse:
		((_ns1__SearchResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SearchRequest:
		((_ns1__SearchRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RemoveFromMyContactsResponse:
		((_ns1__RemoveFromMyContactsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RemoveFromMyContactsRequest:
		((_ns1__RemoveFromMyContactsRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__AddToMyContactsResponse:
		((_ns1__AddToMyContactsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__AddToMyContactsRequest:
		((_ns1__AddToMyContactsRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SearchMyContactsResponse:
		((_ns1__SearchMyContactsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SearchMyContactsRequest:
		((_ns1__SearchMyContactsRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__MyEndpointStatusResponse:
		((_ns1__MyEndpointStatusResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__MyEndpointStatusRequest:
		((_ns1__MyEndpointStatusRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__LogOutResponse:
		((_ns1__LogOutResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__LogOutRequest:
		((_ns1__LogOutRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__LinkEndpointResponse:
		((_ns1__LinkEndpointResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__LinkEndpointRequest:
		((_ns1__LinkEndpointRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__LogInResponse:
		((_ns1__LogInResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__LogInRequest:
		((_ns1__LogInRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__WelcomeBannerContent:
		((_ns1__WelcomeBannerContent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__LoginAttempt:
		((_ns1__LoginAttempt *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__LectureModeParticipant:
		((_ns1__LectureModeParticipant *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__Entity:
		((_ns1__Entity *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__Filter:
		((_ns1__Filter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RoomMode:
		((_ns1__RoomMode *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RoomNotFoundFault:
		((_ns1__RoomNotFoundFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__VidyoReplayNotAvailableFault:
		((_ns1__VidyoReplayNotAvailableFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__FeatureNotAvailableFault:
		((_ns1__FeatureNotAvailableFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__PrefixNotConfiguredException:
		((_ns1__PrefixNotConfiguredException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InPointToPointCallFault:
		((_ns1__InPointToPointCallFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__EndpointNotBoundFault:
		((_ns1__EndpointNotBoundFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ScheduledRoomCreationFault:
		((_ns1__ScheduledRoomCreationFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ControlMeetingFault:
		((_ns1__ControlMeetingFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InvalidModeratorPINFormatFault:
		((_ns1__InvalidModeratorPINFormatFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__AccessRestrictedFault:
		((_ns1__AccessRestrictedFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ResourceNotAvailableFault:
		((_ns1__ResourceNotAvailableFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__NotLicensedFault:
		((_ns1__NotLicensedFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ConferenceLockedFault:
		((_ns1__ConferenceLockedFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__WrongPINFault:
		((_ns1__WrongPINFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SeatLicenseExpiredFault:
		((_ns1__SeatLicenseExpiredFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InvalidArgumentFault:
		((_ns1__InvalidArgumentFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GeneralFault:
		((_ns1__GeneralFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RoomProfile:
		((ns1__RoomProfile *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Recorder:
		((ns1__Recorder *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns1__getChangePasswordHtmlUrlWithToken:
		soap_serialize___ns1__getChangePasswordHtmlUrlWithToken(soap, (const struct __ns1__getChangePasswordHtmlUrlWithToken *)ptr);
		break;
	case SOAP_TYPE___ns1__whatIsMyIPAddress:
		soap_serialize___ns1__whatIsMyIPAddress(soap, (const struct __ns1__whatIsMyIPAddress *)ptr);
		break;
	case SOAP_TYPE___ns1__getVidyoReplayLibrary:
		soap_serialize___ns1__getVidyoReplayLibrary(soap, (const struct __ns1__getVidyoReplayLibrary *)ptr);
		break;
	case SOAP_TYPE___ns1__removePresenter:
		soap_serialize___ns1__removePresenter(soap, (const struct __ns1__removePresenter *)ptr);
		break;
	case SOAP_TYPE___ns1__setPresenter:
		soap_serialize___ns1__setPresenter(soap, (const struct __ns1__setPresenter *)ptr);
		break;
	case SOAP_TYPE___ns1__dismissAllRaisedHand:
		soap_serialize___ns1__dismissAllRaisedHand(soap, (const struct __ns1__dismissAllRaisedHand *)ptr);
		break;
	case SOAP_TYPE___ns1__dismissRaisedHand:
		soap_serialize___ns1__dismissRaisedHand(soap, (const struct __ns1__dismissRaisedHand *)ptr);
		break;
	case SOAP_TYPE___ns1__unraiseHand:
		soap_serialize___ns1__unraiseHand(soap, (const struct __ns1__unraiseHand *)ptr);
		break;
	case SOAP_TYPE___ns1__raiseHand:
		soap_serialize___ns1__raiseHand(soap, (const struct __ns1__raiseHand *)ptr);
		break;
	case SOAP_TYPE___ns1__stopLectureMode:
		soap_serialize___ns1__stopLectureMode(soap, (const struct __ns1__stopLectureMode *)ptr);
		break;
	case SOAP_TYPE___ns1__startLectureMode:
		soap_serialize___ns1__startLectureMode(soap, (const struct __ns1__startLectureMode *)ptr);
		break;
	case SOAP_TYPE___ns1__getUserAccountType:
		soap_serialize___ns1__getUserAccountType(soap, (const struct __ns1__getUserAccountType *)ptr);
		break;
	case SOAP_TYPE___ns1__getLoginAndWelcomeBanner:
		soap_serialize___ns1__getLoginAndWelcomeBanner(soap, (const struct __ns1__getLoginAndWelcomeBanner *)ptr);
		break;
	case SOAP_TYPE___ns1__getPortalPrefix:
		soap_serialize___ns1__getPortalPrefix(soap, (const struct __ns1__getPortalPrefix *)ptr);
		break;
	case SOAP_TYPE___ns1__getRoomAccessOptions:
		soap_serialize___ns1__getRoomAccessOptions(soap, (const struct __ns1__getRoomAccessOptions *)ptr);
		break;
	case SOAP_TYPE___ns1__getOnetimeAccessUrl:
		soap_serialize___ns1__getOnetimeAccessUrl(soap, (const struct __ns1__getOnetimeAccessUrl *)ptr);
		break;
	case SOAP_TYPE___ns1__muteVideoClientAll:
		soap_serialize___ns1__muteVideoClientAll(soap, (const struct __ns1__muteVideoClientAll *)ptr);
		break;
	case SOAP_TYPE___ns1__muteVideoServerAll:
		soap_serialize___ns1__muteVideoServerAll(soap, (const struct __ns1__muteVideoServerAll *)ptr);
		break;
	case SOAP_TYPE___ns1__muteAudioClientAll:
		soap_serialize___ns1__muteAudioClientAll(soap, (const struct __ns1__muteAudioClientAll *)ptr);
		break;
	case SOAP_TYPE___ns1__muteAudioServerAll:
		soap_serialize___ns1__muteAudioServerAll(soap, (const struct __ns1__muteAudioServerAll *)ptr);
		break;
	case SOAP_TYPE___ns1__disconnectConferenceAll:
		soap_serialize___ns1__disconnectConferenceAll(soap, (const struct __ns1__disconnectConferenceAll *)ptr);
		break;
	case SOAP_TYPE___ns1__logoutAllOtherSessions:
		soap_serialize___ns1__logoutAllOtherSessions(soap, (const struct __ns1__logoutAllOtherSessions *)ptr);
		break;
	case SOAP_TYPE___ns1__getActiveSessions:
		soap_serialize___ns1__getActiveSessions(soap, (const struct __ns1__getActiveSessions *)ptr);
		break;
	case SOAP_TYPE___ns1__setEndpointDetails:
		soap_serialize___ns1__setEndpointDetails(soap, (const struct __ns1__setEndpointDetails *)ptr);
		break;
	case SOAP_TYPE___ns1__getPortalFeatures:
		soap_serialize___ns1__getPortalFeatures(soap, (const struct __ns1__getPortalFeatures *)ptr);
		break;
	case SOAP_TYPE___ns1__deleteScheduledRoom:
		soap_serialize___ns1__deleteScheduledRoom(soap, (const struct __ns1__deleteScheduledRoom *)ptr);
		break;
	case SOAP_TYPE___ns1__createScheduledRoom:
		soap_serialize___ns1__createScheduledRoom(soap, (const struct __ns1__createScheduledRoom *)ptr);
		break;
	case SOAP_TYPE___ns1__generateAuthToken:
		soap_serialize___ns1__generateAuthToken(soap, (const struct __ns1__generateAuthToken *)ptr);
		break;
	case SOAP_TYPE___ns1__getConferenceID:
		soap_serialize___ns1__getConferenceID(soap, (const struct __ns1__getConferenceID *)ptr);
		break;
	case SOAP_TYPE___ns1__removeModeratorPIN:
		soap_serialize___ns1__removeModeratorPIN(soap, (const struct __ns1__removeModeratorPIN *)ptr);
		break;
	case SOAP_TYPE___ns1__createModeratorPIN:
		soap_serialize___ns1__createModeratorPIN(soap, (const struct __ns1__createModeratorPIN *)ptr);
		break;
	case SOAP_TYPE___ns1__getModeratorURLWithToken:
		soap_serialize___ns1__getModeratorURLWithToken(soap, (const struct __ns1__getModeratorURLWithToken *)ptr);
		break;
	case SOAP_TYPE___ns1__getModeratorURL:
		soap_serialize___ns1__getModeratorURL(soap, (const struct __ns1__getModeratorURL *)ptr);
		break;
	case SOAP_TYPE___ns1__removeModeratorURL:
		soap_serialize___ns1__removeModeratorURL(soap, (const struct __ns1__removeModeratorURL *)ptr);
		break;
	case SOAP_TYPE___ns1__createModeratorURL:
		soap_serialize___ns1__createModeratorURL(soap, (const struct __ns1__createModeratorURL *)ptr);
		break;
	case SOAP_TYPE___ns1__removeRoomProfile:
		soap_serialize___ns1__removeRoomProfile(soap, (const struct __ns1__removeRoomProfile *)ptr);
		break;
	case SOAP_TYPE___ns1__setRoomProfile:
		soap_serialize___ns1__setRoomProfile(soap, (const struct __ns1__setRoomProfile *)ptr);
		break;
	case SOAP_TYPE___ns1__getRoomProfile:
		soap_serialize___ns1__getRoomProfile(soap, (const struct __ns1__getRoomProfile *)ptr);
		break;
	case SOAP_TYPE___ns1__getRoomProfiles:
		soap_serialize___ns1__getRoomProfiles(soap, (const struct __ns1__getRoomProfiles *)ptr);
		break;
	case SOAP_TYPE___ns1__getInviteContent:
		soap_serialize___ns1__getInviteContent(soap, (const struct __ns1__getInviteContent *)ptr);
		break;
	case SOAP_TYPE___ns1__getEntityByRoomKey:
		soap_serialize___ns1__getEntityByRoomKey(soap, (const struct __ns1__getEntityByRoomKey *)ptr);
		break;
	case SOAP_TYPE___ns1__getUserName:
		soap_serialize___ns1__getUserName(soap, (const struct __ns1__getUserName *)ptr);
		break;
	case SOAP_TYPE___ns1__getWebcastURL:
		soap_serialize___ns1__getWebcastURL(soap, (const struct __ns1__getWebcastURL *)ptr);
		break;
	case SOAP_TYPE___ns1__removeWebcastPIN:
		soap_serialize___ns1__removeWebcastPIN(soap, (const struct __ns1__removeWebcastPIN *)ptr);
		break;
	case SOAP_TYPE___ns1__removeWebcastURL:
		soap_serialize___ns1__removeWebcastURL(soap, (const struct __ns1__removeWebcastURL *)ptr);
		break;
	case SOAP_TYPE___ns1__createWebcastPIN:
		soap_serialize___ns1__createWebcastPIN(soap, (const struct __ns1__createWebcastPIN *)ptr);
		break;
	case SOAP_TYPE___ns1__createWebcastURL:
		soap_serialize___ns1__createWebcastURL(soap, (const struct __ns1__createWebcastURL *)ptr);
		break;
	case SOAP_TYPE___ns1__stopRecording:
		soap_serialize___ns1__stopRecording(soap, (const struct __ns1__stopRecording *)ptr);
		break;
	case SOAP_TYPE___ns1__resumeRecording:
		soap_serialize___ns1__resumeRecording(soap, (const struct __ns1__resumeRecording *)ptr);
		break;
	case SOAP_TYPE___ns1__pauseRecording:
		soap_serialize___ns1__pauseRecording(soap, (const struct __ns1__pauseRecording *)ptr);
		break;
	case SOAP_TYPE___ns1__getPortalVersion:
		soap_serialize___ns1__getPortalVersion(soap, (const struct __ns1__getPortalVersion *)ptr);
		break;
	case SOAP_TYPE___ns1__startRecording:
		soap_serialize___ns1__startRecording(soap, (const struct __ns1__startRecording *)ptr);
		break;
	case SOAP_TYPE___ns1__getRecordingProfiles:
		soap_serialize___ns1__getRecordingProfiles(soap, (const struct __ns1__getRecordingProfiles *)ptr);
		break;
	case SOAP_TYPE___ns1__setMemberMode:
		soap_serialize___ns1__setMemberMode(soap, (const struct __ns1__setMemberMode *)ptr);
		break;
	case SOAP_TYPE___ns1__unlockRoom:
		soap_serialize___ns1__unlockRoom(soap, (const struct __ns1__unlockRoom *)ptr);
		break;
	case SOAP_TYPE___ns1__lockRoom:
		soap_serialize___ns1__lockRoom(soap, (const struct __ns1__lockRoom *)ptr);
		break;
	case SOAP_TYPE___ns1__updateLanguage:
		soap_serialize___ns1__updateLanguage(soap, (const struct __ns1__updateLanguage *)ptr);
		break;
	case SOAP_TYPE___ns1__updatePassword:
		soap_serialize___ns1__updatePassword(soap, (const struct __ns1__updatePassword *)ptr);
		break;
	case SOAP_TYPE___ns1__deleteRoom:
		soap_serialize___ns1__deleteRoom(soap, (const struct __ns1__deleteRoom *)ptr);
		break;
	case SOAP_TYPE___ns1__createRoom:
		soap_serialize___ns1__createRoom(soap, (const struct __ns1__createRoom *)ptr);
		break;
	case SOAP_TYPE___ns1__removeRoomPIN:
		soap_serialize___ns1__removeRoomPIN(soap, (const struct __ns1__removeRoomPIN *)ptr);
		break;
	case SOAP_TYPE___ns1__createRoomPIN:
		soap_serialize___ns1__createRoomPIN(soap, (const struct __ns1__createRoomPIN *)ptr);
		break;
	case SOAP_TYPE___ns1__removeRoomURL:
		soap_serialize___ns1__removeRoomURL(soap, (const struct __ns1__removeRoomURL *)ptr);
		break;
	case SOAP_TYPE___ns1__createRoomURL:
		soap_serialize___ns1__createRoomURL(soap, (const struct __ns1__createRoomURL *)ptr);
		break;
	case SOAP_TYPE___ns1__myAccount:
		soap_serialize___ns1__myAccount(soap, (const struct __ns1__myAccount *)ptr);
		break;
	case SOAP_TYPE___ns1__stopVideo:
		soap_serialize___ns1__stopVideo(soap, (const struct __ns1__stopVideo *)ptr);
		break;
	case SOAP_TYPE___ns1__startVideo:
		soap_serialize___ns1__startVideo(soap, (const struct __ns1__startVideo *)ptr);
		break;
	case SOAP_TYPE___ns1__unmuteAudio:
		soap_serialize___ns1__unmuteAudio(soap, (const struct __ns1__unmuteAudio *)ptr);
		break;
	case SOAP_TYPE___ns1__muteAudio:
		soap_serialize___ns1__muteAudio(soap, (const struct __ns1__muteAudio *)ptr);
		break;
	case SOAP_TYPE___ns1__leaveConference:
		soap_serialize___ns1__leaveConference(soap, (const struct __ns1__leaveConference *)ptr);
		break;
	case SOAP_TYPE___ns1__getLectureModeParticipants:
		soap_serialize___ns1__getLectureModeParticipants(soap, (const struct __ns1__getLectureModeParticipants *)ptr);
		break;
	case SOAP_TYPE___ns1__getParticipants:
		soap_serialize___ns1__getParticipants(soap, (const struct __ns1__getParticipants *)ptr);
		break;
	case SOAP_TYPE___ns1__directCall:
		soap_serialize___ns1__directCall(soap, (const struct __ns1__directCall *)ptr);
		break;
	case SOAP_TYPE___ns1__joinIPCConference:
		soap_serialize___ns1__joinIPCConference(soap, (const struct __ns1__joinIPCConference *)ptr);
		break;
	case SOAP_TYPE___ns1__joinConference:
		soap_serialize___ns1__joinConference(soap, (const struct __ns1__joinConference *)ptr);
		break;
	case SOAP_TYPE___ns1__cancelOutboundCall:
		soap_serialize___ns1__cancelOutboundCall(soap, (const struct __ns1__cancelOutboundCall *)ptr);
		break;
	case SOAP_TYPE___ns1__inviteToConference:
		soap_serialize___ns1__inviteToConference(soap, (const struct __ns1__inviteToConference *)ptr);
		break;
	case SOAP_TYPE___ns1__getEntityByEntityID:
		soap_serialize___ns1__getEntityByEntityID(soap, (const struct __ns1__getEntityByEntityID *)ptr);
		break;
	case SOAP_TYPE___ns1__searchByEmail:
		soap_serialize___ns1__searchByEmail(soap, (const struct __ns1__searchByEmail *)ptr);
		break;
	case SOAP_TYPE___ns1__searchByEntityID:
		soap_serialize___ns1__searchByEntityID(soap, (const struct __ns1__searchByEntityID *)ptr);
		break;
	case SOAP_TYPE___ns1__search:
		soap_serialize___ns1__search(soap, (const struct __ns1__search *)ptr);
		break;
	case SOAP_TYPE___ns1__removeFromMyContacts:
		soap_serialize___ns1__removeFromMyContacts(soap, (const struct __ns1__removeFromMyContacts *)ptr);
		break;
	case SOAP_TYPE___ns1__addToMyContacts:
		soap_serialize___ns1__addToMyContacts(soap, (const struct __ns1__addToMyContacts *)ptr);
		break;
	case SOAP_TYPE___ns1__searchMyContacts:
		soap_serialize___ns1__searchMyContacts(soap, (const struct __ns1__searchMyContacts *)ptr);
		break;
	case SOAP_TYPE___ns1__myEndpointStatus:
		soap_serialize___ns1__myEndpointStatus(soap, (const struct __ns1__myEndpointStatus *)ptr);
		break;
	case SOAP_TYPE___ns1__logOut:
		soap_serialize___ns1__logOut(soap, (const struct __ns1__logOut *)ptr);
		break;
	case SOAP_TYPE___ns1__linkEndpoint:
		soap_serialize___ns1__linkEndpoint(soap, (const struct __ns1__linkEndpoint *)ptr);
		break;
	case SOAP_TYPE___ns1__logIn:
		soap_serialize___ns1__logIn(soap, (const struct __ns1__logIn *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetChangePasswordHtmlUrlWithTokenRequest:
		soap_serialize_PointerTo_ns1__GetChangePasswordHtmlUrlWithTokenRequest(soap, (_ns1__GetChangePasswordHtmlUrlWithTokenRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__WhatIsMyIPAddressRequest:
		soap_serialize_PointerTo_ns1__WhatIsMyIPAddressRequest(soap, (_ns1__WhatIsMyIPAddressRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetVidyoReplayLibraryRequest:
		soap_serialize_PointerTo_ns1__GetVidyoReplayLibraryRequest(soap, (_ns1__GetVidyoReplayLibraryRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__RemovePresenterRequest:
		soap_serialize_PointerTo_ns1__RemovePresenterRequest(soap, (_ns1__RemovePresenterRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SetPresenterRequest:
		soap_serialize_PointerTo_ns1__SetPresenterRequest(soap, (_ns1__SetPresenterRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__DismissAllRaisedHandRequest:
		soap_serialize_PointerTo_ns1__DismissAllRaisedHandRequest(soap, (_ns1__DismissAllRaisedHandRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__DismissRaisedHandRequest:
		soap_serialize_PointerTo_ns1__DismissRaisedHandRequest(soap, (_ns1__DismissRaisedHandRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__StopLectureModeRequest:
		soap_serialize_PointerTo_ns1__StopLectureModeRequest(soap, (_ns1__StopLectureModeRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__StartLectureModeRequest:
		soap_serialize_PointerTo_ns1__StartLectureModeRequest(soap, (_ns1__StartLectureModeRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getUserAccountTypeRequest:
		soap_serialize_PointerTo_ns1__getUserAccountTypeRequest(soap, (_ns1__getUserAccountTypeRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__getLoginAndWelcomeBannerRequest:
		soap_serialize_PointerTo_ns1__getLoginAndWelcomeBannerRequest(soap, (_ns1__getLoginAndWelcomeBannerRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__RoomAccessOptionsRequest:
		soap_serialize_PointerTo_ns1__RoomAccessOptionsRequest(soap, (_ns1__RoomAccessOptionsRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__muteVideoClientAllRequest:
		soap_serialize_PointerTo_ns1__muteVideoClientAllRequest(soap, (_ns1__muteVideoClientAllRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__muteVideoServerAllRequest:
		soap_serialize_PointerTo_ns1__muteVideoServerAllRequest(soap, (_ns1__muteVideoServerAllRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__muteAudioClientAllRequest:
		soap_serialize_PointerTo_ns1__muteAudioClientAllRequest(soap, (_ns1__muteAudioClientAllRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__muteAudioServerAllRequest:
		soap_serialize_PointerTo_ns1__muteAudioServerAllRequest(soap, (_ns1__muteAudioServerAllRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__disconnectConferenceAllRequest:
		soap_serialize_PointerTo_ns1__disconnectConferenceAllRequest(soap, (_ns1__disconnectConferenceAllRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SetEndpointDetailsRequest:
		soap_serialize_PointerTo_ns1__SetEndpointDetailsRequest(soap, (_ns1__SetEndpointDetailsRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__DeleteScheduledRoomRequest:
		soap_serialize_PointerTo_ns1__DeleteScheduledRoomRequest(soap, (_ns1__DeleteScheduledRoomRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__CreateScheduledRoomRequest:
		soap_serialize_PointerTo_ns1__CreateScheduledRoomRequest(soap, (_ns1__CreateScheduledRoomRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GenerateAuthTokenRequest:
		soap_serialize_PointerTo_ns1__GenerateAuthTokenRequest(soap, (_ns1__GenerateAuthTokenRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetConferenceIDRequest:
		soap_serialize_PointerTo_ns1__GetConferenceIDRequest(soap, (_ns1__GetConferenceIDRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__RemoveModeratorPINRequest:
		soap_serialize_PointerTo_ns1__RemoveModeratorPINRequest(soap, (_ns1__RemoveModeratorPINRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__CreateModeratorPINRequest:
		soap_serialize_PointerTo_ns1__CreateModeratorPINRequest(soap, (_ns1__CreateModeratorPINRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetModeratorURLWithTokenRequest:
		soap_serialize_PointerTo_ns1__GetModeratorURLWithTokenRequest(soap, (_ns1__GetModeratorURLWithTokenRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetModeratorURLRequest:
		soap_serialize_PointerTo_ns1__GetModeratorURLRequest(soap, (_ns1__GetModeratorURLRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__RemoveModeratorURLRequest:
		soap_serialize_PointerTo_ns1__RemoveModeratorURLRequest(soap, (_ns1__RemoveModeratorURLRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__CreateModeratorURLRequest:
		soap_serialize_PointerTo_ns1__CreateModeratorURLRequest(soap, (_ns1__CreateModeratorURLRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__RemoveRoomProfileRequest:
		soap_serialize_PointerTo_ns1__RemoveRoomProfileRequest(soap, (_ns1__RemoveRoomProfileRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SetRoomProfileRequest:
		soap_serialize_PointerTo_ns1__SetRoomProfileRequest(soap, (_ns1__SetRoomProfileRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetRoomProfileRequest:
		soap_serialize_PointerTo_ns1__GetRoomProfileRequest(soap, (_ns1__GetRoomProfileRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetInviteContentRequest:
		soap_serialize_PointerTo_ns1__GetInviteContentRequest(soap, (_ns1__GetInviteContentRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetEntityByRoomKeyRequest:
		soap_serialize_PointerTo_ns1__GetEntityByRoomKeyRequest(soap, (_ns1__GetEntityByRoomKeyRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetUserNameRequest:
		soap_serialize_PointerTo_ns1__GetUserNameRequest(soap, (_ns1__GetUserNameRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetWebcastURLRequest:
		soap_serialize_PointerTo_ns1__GetWebcastURLRequest(soap, (_ns1__GetWebcastURLRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__RemoveWebcastPINRequest:
		soap_serialize_PointerTo_ns1__RemoveWebcastPINRequest(soap, (_ns1__RemoveWebcastPINRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__RemoveWebcastURLRequest:
		soap_serialize_PointerTo_ns1__RemoveWebcastURLRequest(soap, (_ns1__RemoveWebcastURLRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__CreateWebcastPINRequest:
		soap_serialize_PointerTo_ns1__CreateWebcastPINRequest(soap, (_ns1__CreateWebcastPINRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__CreateWebcastURLRequest:
		soap_serialize_PointerTo_ns1__CreateWebcastURLRequest(soap, (_ns1__CreateWebcastURLRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__StopRecordingRequest:
		soap_serialize_PointerTo_ns1__StopRecordingRequest(soap, (_ns1__StopRecordingRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ResumeRecordingRequest:
		soap_serialize_PointerTo_ns1__ResumeRecordingRequest(soap, (_ns1__ResumeRecordingRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__PauseRecordingRequest:
		soap_serialize_PointerTo_ns1__PauseRecordingRequest(soap, (_ns1__PauseRecordingRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPortalVersionRequest:
		soap_serialize_PointerTo_ns1__GetPortalVersionRequest(soap, (_ns1__GetPortalVersionRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__StartRecordingRequest:
		soap_serialize_PointerTo_ns1__StartRecordingRequest(soap, (_ns1__StartRecordingRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetRecordingProfilesRequest:
		soap_serialize_PointerTo_ns1__GetRecordingProfilesRequest(soap, (_ns1__GetRecordingProfilesRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SetMemberModeRequest:
		soap_serialize_PointerTo_ns1__SetMemberModeRequest(soap, (_ns1__SetMemberModeRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UnlockRoomRequest:
		soap_serialize_PointerTo_ns1__UnlockRoomRequest(soap, (_ns1__UnlockRoomRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__LockRoomRequest:
		soap_serialize_PointerTo_ns1__LockRoomRequest(soap, (_ns1__LockRoomRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UpdateLanguageRequest:
		soap_serialize_PointerTo_ns1__UpdateLanguageRequest(soap, (_ns1__UpdateLanguageRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UpdatePasswordRequest:
		soap_serialize_PointerTo_ns1__UpdatePasswordRequest(soap, (_ns1__UpdatePasswordRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__DeleteRoomRequest:
		soap_serialize_PointerTo_ns1__DeleteRoomRequest(soap, (_ns1__DeleteRoomRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__CreateRoomRequest:
		soap_serialize_PointerTo_ns1__CreateRoomRequest(soap, (_ns1__CreateRoomRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__RemoveRoomPINRequest:
		soap_serialize_PointerTo_ns1__RemoveRoomPINRequest(soap, (_ns1__RemoveRoomPINRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__CreateRoomPINRequest:
		soap_serialize_PointerTo_ns1__CreateRoomPINRequest(soap, (_ns1__CreateRoomPINRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__RemoveRoomURLRequest:
		soap_serialize_PointerTo_ns1__RemoveRoomURLRequest(soap, (_ns1__RemoveRoomURLRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__CreateRoomURLRequest:
		soap_serialize_PointerTo_ns1__CreateRoomURLRequest(soap, (_ns1__CreateRoomURLRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__MyAccountRequest:
		soap_serialize_PointerTo_ns1__MyAccountRequest(soap, (_ns1__MyAccountRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__StopVideoRequest:
		soap_serialize_PointerTo_ns1__StopVideoRequest(soap, (_ns1__StopVideoRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__StartVideoRequest:
		soap_serialize_PointerTo_ns1__StartVideoRequest(soap, (_ns1__StartVideoRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UnmuteAudioRequest:
		soap_serialize_PointerTo_ns1__UnmuteAudioRequest(soap, (_ns1__UnmuteAudioRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__MuteAudioRequest:
		soap_serialize_PointerTo_ns1__MuteAudioRequest(soap, (_ns1__MuteAudioRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__LeaveConferenceRequest:
		soap_serialize_PointerTo_ns1__LeaveConferenceRequest(soap, (_ns1__LeaveConferenceRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetLectureModeParticipantsRequest:
		soap_serialize_PointerTo_ns1__GetLectureModeParticipantsRequest(soap, (_ns1__GetLectureModeParticipantsRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetParticipantsRequest:
		soap_serialize_PointerTo_ns1__GetParticipantsRequest(soap, (_ns1__GetParticipantsRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__DirectCallRequest:
		soap_serialize_PointerTo_ns1__DirectCallRequest(soap, (_ns1__DirectCallRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__JoinIPCConferenceRequest:
		soap_serialize_PointerTo_ns1__JoinIPCConferenceRequest(soap, (_ns1__JoinIPCConferenceRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__JoinConferenceRequest:
		soap_serialize_PointerTo_ns1__JoinConferenceRequest(soap, (_ns1__JoinConferenceRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__CancelOutboundCallRequest:
		soap_serialize_PointerTo_ns1__CancelOutboundCallRequest(soap, (_ns1__CancelOutboundCallRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InviteToConferenceRequest:
		soap_serialize_PointerTo_ns1__InviteToConferenceRequest(soap, (_ns1__InviteToConferenceRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetEntityByEntityIDRequest:
		soap_serialize_PointerTo_ns1__GetEntityByEntityIDRequest(soap, (_ns1__GetEntityByEntityIDRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SearchByEmailRequest:
		soap_serialize_PointerTo_ns1__SearchByEmailRequest(soap, (_ns1__SearchByEmailRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SearchByEntityIDRequest:
		soap_serialize_PointerTo_ns1__SearchByEntityIDRequest(soap, (_ns1__SearchByEntityIDRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SearchRequest:
		soap_serialize_PointerTo_ns1__SearchRequest(soap, (_ns1__SearchRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__RemoveFromMyContactsRequest:
		soap_serialize_PointerTo_ns1__RemoveFromMyContactsRequest(soap, (_ns1__RemoveFromMyContactsRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__AddToMyContactsRequest:
		soap_serialize_PointerTo_ns1__AddToMyContactsRequest(soap, (_ns1__AddToMyContactsRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SearchMyContactsRequest:
		soap_serialize_PointerTo_ns1__SearchMyContactsRequest(soap, (_ns1__SearchMyContactsRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__MyEndpointStatusRequest:
		soap_serialize_PointerTo_ns1__MyEndpointStatusRequest(soap, (_ns1__MyEndpointStatusRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__LogOutRequest:
		soap_serialize_PointerTo_ns1__LogOutRequest(soap, (_ns1__LogOutRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__LinkEndpointRequest:
		soap_serialize_PointerTo_ns1__LinkEndpointRequest(soap, (_ns1__LinkEndpointRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__LogInRequest:
		soap_serialize_PointerTo_ns1__LogInRequest(soap, (_ns1__LogInRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__WrongPINFault:
		soap_serialize_PointerTo_ns1__WrongPINFault(soap, (_ns1__WrongPINFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__VidyoReplayNotAvailableFault:
		soap_serialize_PointerTo_ns1__VidyoReplayNotAvailableFault(soap, (_ns1__VidyoReplayNotAvailableFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SeatLicenseExpiredFault:
		soap_serialize_PointerTo_ns1__SeatLicenseExpiredFault(soap, (_ns1__SeatLicenseExpiredFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ScheduledRoomCreationFault:
		soap_serialize_PointerTo_ns1__ScheduledRoomCreationFault(soap, (_ns1__ScheduledRoomCreationFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__RoomNotFoundFault:
		soap_serialize_PointerTo_ns1__RoomNotFoundFault(soap, (_ns1__RoomNotFoundFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ResourceNotAvailableFault:
		soap_serialize_PointerTo_ns1__ResourceNotAvailableFault(soap, (_ns1__ResourceNotAvailableFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__PrefixNotConfiguredFault:
		soap_serialize_PointerTo_ns1__PrefixNotConfiguredFault(soap, (_ns1__PrefixNotConfiguredFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__NotLicensedFault:
		soap_serialize_PointerTo_ns1__NotLicensedFault(soap, (_ns1__NotLicensedFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InvalidModeratorPINFormatFault:
		soap_serialize_PointerTo_ns1__InvalidModeratorPINFormatFault(soap, (_ns1__InvalidModeratorPINFormatFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InvalidArgumentFault:
		soap_serialize_PointerTo_ns1__InvalidArgumentFault(soap, (_ns1__InvalidArgumentFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InPointToPointCallFault:
		soap_serialize_PointerTo_ns1__InPointToPointCallFault(soap, (_ns1__InPointToPointCallFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GeneralFault:
		soap_serialize_PointerTo_ns1__GeneralFault(soap, (_ns1__GeneralFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__FeatureNotAvailableFault:
		soap_serialize_PointerTo_ns1__FeatureNotAvailableFault(soap, (_ns1__FeatureNotAvailableFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__EndpointNotBoundFault:
		soap_serialize_PointerTo_ns1__EndpointNotBoundFault(soap, (_ns1__EndpointNotBoundFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ControlMeetingFault:
		soap_serialize_PointerTo_ns1__ControlMeetingFault(soap, (_ns1__ControlMeetingFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ConferenceLockedFault:
		soap_serialize_PointerTo_ns1__ConferenceLockedFault(soap, (_ns1__ConferenceLockedFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__AccessRestrictedFault:
		soap_serialize_PointerTo_ns1__AccessRestrictedFault(soap, (_ns1__AccessRestrictedFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__WelcomeBannerContent:
		soap_serialize_PointerTo_ns1__WelcomeBannerContent(soap, (_ns1__WelcomeBannerContent *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTo_ns1__RoomAccessOption:
		soap_serialize_PointerToPointerTo_ns1__RoomAccessOption(soap, (_ns1__RoomAccessOption **const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__RoomAccessOption:
		soap_serialize_PointerTo_ns1__RoomAccessOption(soap, (_ns1__RoomAccessOption *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTo_ns1__EndpointFeature:
		soap_serialize_PointerToPointerTo_ns1__EndpointFeature(soap, (_ns1__EndpointFeature **const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__EndpointFeature:
		soap_serialize_PointerTo_ns1__EndpointFeature(soap, (_ns1__EndpointFeature *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTo_ns1__PortalFeature:
		soap_serialize_PointerToPointerTo_ns1__PortalFeature(soap, (_ns1__PortalFeature **const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__PortalFeature:
		soap_serialize_PointerTo_ns1__PortalFeature(soap, (_ns1__PortalFeature *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostring:
		soap_serialize_PointerTostring(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__RoomProfile:
		soap_serialize_PointerToPointerTons1__RoomProfile(soap, (ns1__RoomProfile **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RoomProfile:
		soap_serialize_PointerTons1__RoomProfile(soap, (ns1__RoomProfile *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__Recorder:
		soap_serialize_PointerToPointerTons1__Recorder(soap, (ns1__Recorder **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Recorder:
		soap_serialize_PointerTons1__Recorder(soap, (ns1__Recorder *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTo_ns1__LectureModeParticipant:
		soap_serialize_PointerToPointerTo_ns1__LectureModeParticipant(soap, (_ns1__LectureModeParticipant **const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__LectureModeParticipant:
		soap_serialize_PointerTo_ns1__LectureModeParticipant(soap, (_ns1__LectureModeParticipant *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__EntityID:
		soap_serialize_PointerTons1__EntityID(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTo_ns1__Entity:
		soap_serialize_PointerToPointerTo_ns1__Entity(soap, (_ns1__Entity **const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__Filter:
		soap_serialize_PointerTo_ns1__Filter(soap, (_ns1__Filter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__Entity:
		soap_serialize_PointerTo_ns1__Entity(soap, (_ns1__Entity *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ClientType:
		soap_serialize_PointerTo_ns1__ClientType(soap, (enum _ns1__ClientType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTodateTime:
		soap_serialize_PointerTodateTime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTo_ns1__LoginAttempt:
		soap_serialize_PointerToPointerTo_ns1__LoginAttempt(soap, (_ns1__LoginAttempt **const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__LoginAttempt:
		soap_serialize_PointerTo_ns1__LoginAttempt(soap, (_ns1__LoginAttempt *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__RoomMode:
		soap_serialize_PointerTo_ns1__RoomMode(soap, (_ns1__RoomMode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__RoomStatus:
		soap_serialize_PointerTo_ns1__RoomStatus(soap, (enum _ns1__RoomStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__MemberMode:
		soap_serialize_PointerTo_ns1__MemberMode(soap, (enum _ns1__MemberMode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__MemberStatus:
		soap_serialize_PointerTo_ns1__MemberStatus(soap, (enum _ns1__MemberStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__Language:
		soap_serialize_PointerTo_ns1__Language(soap, (enum _ns1__Language *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__EntityType:
		soap_serialize_PointerTo_ns1__EntityType(soap, (enum _ns1__EntityType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__sortDir:
		soap_serialize_PointerTons1__sortDir(soap, (enum ns1__sortDir *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobool:
		soap_serialize_PointerTobool(soap, (bool *const*)ptr);
		break;
	case SOAP_TYPE_ns1__EndpointFeatureName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_ns1__PortalFeatureName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_ns1__EntityID:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_xsd__anyURI:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_ns1__Recorder:
		return (void*)soap_instantiate_ns1__Recorder(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RoomProfile:
		return (void*)soap_instantiate_ns1__RoomProfile(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GeneralFault:
		return (void*)soap_instantiate__ns1__GeneralFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InvalidArgumentFault:
		return (void*)soap_instantiate__ns1__InvalidArgumentFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SeatLicenseExpiredFault:
		return (void*)soap_instantiate__ns1__SeatLicenseExpiredFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__WrongPINFault:
		return (void*)soap_instantiate__ns1__WrongPINFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ConferenceLockedFault:
		return (void*)soap_instantiate__ns1__ConferenceLockedFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__NotLicensedFault:
		return (void*)soap_instantiate__ns1__NotLicensedFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ResourceNotAvailableFault:
		return (void*)soap_instantiate__ns1__ResourceNotAvailableFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__AccessRestrictedFault:
		return (void*)soap_instantiate__ns1__AccessRestrictedFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InvalidModeratorPINFormatFault:
		return (void*)soap_instantiate__ns1__InvalidModeratorPINFormatFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ControlMeetingFault:
		return (void*)soap_instantiate__ns1__ControlMeetingFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ScheduledRoomCreationFault:
		return (void*)soap_instantiate__ns1__ScheduledRoomCreationFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__EndpointNotBoundFault:
		return (void*)soap_instantiate__ns1__EndpointNotBoundFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InPointToPointCallFault:
		return (void*)soap_instantiate__ns1__InPointToPointCallFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__PrefixNotConfiguredException:
		return (void*)soap_instantiate__ns1__PrefixNotConfiguredException(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__FeatureNotAvailableFault:
		return (void*)soap_instantiate__ns1__FeatureNotAvailableFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__VidyoReplayNotAvailableFault:
		return (void*)soap_instantiate__ns1__VidyoReplayNotAvailableFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RoomNotFoundFault:
		return (void*)soap_instantiate__ns1__RoomNotFoundFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RoomMode:
		return (void*)soap_instantiate__ns1__RoomMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__Filter:
		return (void*)soap_instantiate__ns1__Filter(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__Entity:
		return (void*)soap_instantiate__ns1__Entity(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__LectureModeParticipant:
		return (void*)soap_instantiate__ns1__LectureModeParticipant(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__LoginAttempt:
		return (void*)soap_instantiate__ns1__LoginAttempt(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__WelcomeBannerContent:
		return (void*)soap_instantiate__ns1__WelcomeBannerContent(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__LogInRequest:
		return (void*)soap_instantiate__ns1__LogInRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__LogInResponse:
		return (void*)soap_instantiate__ns1__LogInResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__LinkEndpointRequest:
		return (void*)soap_instantiate__ns1__LinkEndpointRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__LinkEndpointResponse:
		return (void*)soap_instantiate__ns1__LinkEndpointResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__LogOutRequest:
		return (void*)soap_instantiate__ns1__LogOutRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__LogOutResponse:
		return (void*)soap_instantiate__ns1__LogOutResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__MyEndpointStatusRequest:
		return (void*)soap_instantiate__ns1__MyEndpointStatusRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__MyEndpointStatusResponse:
		return (void*)soap_instantiate__ns1__MyEndpointStatusResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SearchMyContactsRequest:
		return (void*)soap_instantiate__ns1__SearchMyContactsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SearchMyContactsResponse:
		return (void*)soap_instantiate__ns1__SearchMyContactsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__AddToMyContactsRequest:
		return (void*)soap_instantiate__ns1__AddToMyContactsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__AddToMyContactsResponse:
		return (void*)soap_instantiate__ns1__AddToMyContactsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RemoveFromMyContactsRequest:
		return (void*)soap_instantiate__ns1__RemoveFromMyContactsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RemoveFromMyContactsResponse:
		return (void*)soap_instantiate__ns1__RemoveFromMyContactsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SearchRequest:
		return (void*)soap_instantiate__ns1__SearchRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SearchResponse:
		return (void*)soap_instantiate__ns1__SearchResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SearchByEntityIDRequest:
		return (void*)soap_instantiate__ns1__SearchByEntityIDRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SearchByEntityIDResponse:
		return (void*)soap_instantiate__ns1__SearchByEntityIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SearchByEmailRequest:
		return (void*)soap_instantiate__ns1__SearchByEmailRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SearchByEmailResponse:
		return (void*)soap_instantiate__ns1__SearchByEmailResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetEntityByEntityIDRequest:
		return (void*)soap_instantiate__ns1__GetEntityByEntityIDRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetEntityByEntityIDResponse:
		return (void*)soap_instantiate__ns1__GetEntityByEntityIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InviteToConferenceRequest:
		return (void*)soap_instantiate__ns1__InviteToConferenceRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InviteToConferenceResponse:
		return (void*)soap_instantiate__ns1__InviteToConferenceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CancelOutboundCallRequest:
		return (void*)soap_instantiate__ns1__CancelOutboundCallRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CancelOutboundCallResponse:
		return (void*)soap_instantiate__ns1__CancelOutboundCallResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__JoinConferenceRequest:
		return (void*)soap_instantiate__ns1__JoinConferenceRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__JoinConferenceResponse:
		return (void*)soap_instantiate__ns1__JoinConferenceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__JoinIPCConferenceRequest:
		return (void*)soap_instantiate__ns1__JoinIPCConferenceRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__JoinIPCConferenceResponse:
		return (void*)soap_instantiate__ns1__JoinIPCConferenceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DirectCallRequest:
		return (void*)soap_instantiate__ns1__DirectCallRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DirectCallResponse:
		return (void*)soap_instantiate__ns1__DirectCallResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetParticipantsRequest:
		return (void*)soap_instantiate__ns1__GetParticipantsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetParticipantsResponse:
		return (void*)soap_instantiate__ns1__GetParticipantsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetLectureModeParticipantsRequest:
		return (void*)soap_instantiate__ns1__GetLectureModeParticipantsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetLectureModeParticipantsResponse:
		return (void*)soap_instantiate__ns1__GetLectureModeParticipantsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__LeaveConferenceRequest:
		return (void*)soap_instantiate__ns1__LeaveConferenceRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__LeaveConferenceResponse:
		return (void*)soap_instantiate__ns1__LeaveConferenceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__MuteAudioRequest:
		return (void*)soap_instantiate__ns1__MuteAudioRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__MuteAudioResponse:
		return (void*)soap_instantiate__ns1__MuteAudioResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UnmuteAudioRequest:
		return (void*)soap_instantiate__ns1__UnmuteAudioRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UnmuteAudioResponse:
		return (void*)soap_instantiate__ns1__UnmuteAudioResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__StartVideoRequest:
		return (void*)soap_instantiate__ns1__StartVideoRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__StartVideoResponse:
		return (void*)soap_instantiate__ns1__StartVideoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__StopVideoRequest:
		return (void*)soap_instantiate__ns1__StopVideoRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__StopVideoResponse:
		return (void*)soap_instantiate__ns1__StopVideoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__MyAccountRequest:
		return (void*)soap_instantiate__ns1__MyAccountRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__MyAccountResponse:
		return (void*)soap_instantiate__ns1__MyAccountResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CreateRoomRequest:
		return (void*)soap_instantiate__ns1__CreateRoomRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CreateRoomResponse:
		return (void*)soap_instantiate__ns1__CreateRoomResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DeleteRoomRequest:
		return (void*)soap_instantiate__ns1__DeleteRoomRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DeleteRoomResponse:
		return (void*)soap_instantiate__ns1__DeleteRoomResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CreateRoomURLRequest:
		return (void*)soap_instantiate__ns1__CreateRoomURLRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CreateRoomURLResponse:
		return (void*)soap_instantiate__ns1__CreateRoomURLResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RemoveRoomURLRequest:
		return (void*)soap_instantiate__ns1__RemoveRoomURLRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RemoveRoomURLResponse:
		return (void*)soap_instantiate__ns1__RemoveRoomURLResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CreateRoomPINRequest:
		return (void*)soap_instantiate__ns1__CreateRoomPINRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CreateRoomPINResponse:
		return (void*)soap_instantiate__ns1__CreateRoomPINResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RemoveRoomPINRequest:
		return (void*)soap_instantiate__ns1__RemoveRoomPINRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RemoveRoomPINResponse:
		return (void*)soap_instantiate__ns1__RemoveRoomPINResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpdatePasswordRequest:
		return (void*)soap_instantiate__ns1__UpdatePasswordRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpdatePasswordResponse:
		return (void*)soap_instantiate__ns1__UpdatePasswordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpdateLanguageRequest:
		return (void*)soap_instantiate__ns1__UpdateLanguageRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpdateLanguageResponse:
		return (void*)soap_instantiate__ns1__UpdateLanguageResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__LockRoomRequest:
		return (void*)soap_instantiate__ns1__LockRoomRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__LockRoomResponse:
		return (void*)soap_instantiate__ns1__LockRoomResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UnlockRoomRequest:
		return (void*)soap_instantiate__ns1__UnlockRoomRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UnlockRoomResponse:
		return (void*)soap_instantiate__ns1__UnlockRoomResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetMemberModeRequest:
		return (void*)soap_instantiate__ns1__SetMemberModeRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetMemberModeResponse:
		return (void*)soap_instantiate__ns1__SetMemberModeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetRecordingProfilesRequest:
		return (void*)soap_instantiate__ns1__GetRecordingProfilesRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetRecordingProfilesResponse:
		return (void*)soap_instantiate__ns1__GetRecordingProfilesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__StartRecordingRequest:
		return (void*)soap_instantiate__ns1__StartRecordingRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__StartRecordingResponse:
		return (void*)soap_instantiate__ns1__StartRecordingResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPortalVersionRequest:
		return (void*)soap_instantiate__ns1__GetPortalVersionRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPortalVersionResponse:
		return (void*)soap_instantiate__ns1__GetPortalVersionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__PauseRecordingRequest:
		return (void*)soap_instantiate__ns1__PauseRecordingRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__PauseRecordingResponse:
		return (void*)soap_instantiate__ns1__PauseRecordingResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ResumeRecordingRequest:
		return (void*)soap_instantiate__ns1__ResumeRecordingRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ResumeRecordingResponse:
		return (void*)soap_instantiate__ns1__ResumeRecordingResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__StopRecordingRequest:
		return (void*)soap_instantiate__ns1__StopRecordingRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__StopRecordingResponse:
		return (void*)soap_instantiate__ns1__StopRecordingResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CreateWebcastURLRequest:
		return (void*)soap_instantiate__ns1__CreateWebcastURLRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CreateWebcastURLResponse:
		return (void*)soap_instantiate__ns1__CreateWebcastURLResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CreateWebcastPINRequest:
		return (void*)soap_instantiate__ns1__CreateWebcastPINRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CreateWebcastPINResponse:
		return (void*)soap_instantiate__ns1__CreateWebcastPINResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RemoveWebcastURLRequest:
		return (void*)soap_instantiate__ns1__RemoveWebcastURLRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RemoveWebcastURLResponse:
		return (void*)soap_instantiate__ns1__RemoveWebcastURLResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RemoveWebcastPINRequest:
		return (void*)soap_instantiate__ns1__RemoveWebcastPINRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RemoveWebcastPINResponse:
		return (void*)soap_instantiate__ns1__RemoveWebcastPINResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetWebcastURLRequest:
		return (void*)soap_instantiate__ns1__GetWebcastURLRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetWebcastURLResponse:
		return (void*)soap_instantiate__ns1__GetWebcastURLResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetUserNameRequest:
		return (void*)soap_instantiate__ns1__GetUserNameRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetUserNameResponse:
		return (void*)soap_instantiate__ns1__GetUserNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetEntityByRoomKeyRequest:
		return (void*)soap_instantiate__ns1__GetEntityByRoomKeyRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetEntityByRoomKeyResponse:
		return (void*)soap_instantiate__ns1__GetEntityByRoomKeyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetInviteContentRequest:
		return (void*)soap_instantiate__ns1__GetInviteContentRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetInviteContentResponse:
		return (void*)soap_instantiate__ns1__GetInviteContentResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetRoomProfilesResponse:
		return (void*)soap_instantiate__ns1__GetRoomProfilesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetRoomProfileRequest:
		return (void*)soap_instantiate__ns1__GetRoomProfileRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetRoomProfileResponse:
		return (void*)soap_instantiate__ns1__GetRoomProfileResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetRoomProfileRequest:
		return (void*)soap_instantiate__ns1__SetRoomProfileRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetRoomProfileResponse:
		return (void*)soap_instantiate__ns1__SetRoomProfileResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RemoveRoomProfileRequest:
		return (void*)soap_instantiate__ns1__RemoveRoomProfileRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RemoveRoomProfileResponse:
		return (void*)soap_instantiate__ns1__RemoveRoomProfileResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CreateModeratorURLRequest:
		return (void*)soap_instantiate__ns1__CreateModeratorURLRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CreateModeratorURLResponse:
		return (void*)soap_instantiate__ns1__CreateModeratorURLResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RemoveModeratorURLRequest:
		return (void*)soap_instantiate__ns1__RemoveModeratorURLRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RemoveModeratorURLResponse:
		return (void*)soap_instantiate__ns1__RemoveModeratorURLResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetModeratorURLRequest:
		return (void*)soap_instantiate__ns1__GetModeratorURLRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetModeratorURLResponse:
		return (void*)soap_instantiate__ns1__GetModeratorURLResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetModeratorURLWithTokenRequest:
		return (void*)soap_instantiate__ns1__GetModeratorURLWithTokenRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetModeratorURLWithTokenResponse:
		return (void*)soap_instantiate__ns1__GetModeratorURLWithTokenResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CreateModeratorPINRequest:
		return (void*)soap_instantiate__ns1__CreateModeratorPINRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CreateModeratorPINResponse:
		return (void*)soap_instantiate__ns1__CreateModeratorPINResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RemoveModeratorPINRequest:
		return (void*)soap_instantiate__ns1__RemoveModeratorPINRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RemoveModeratorPINResponse:
		return (void*)soap_instantiate__ns1__RemoveModeratorPINResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetConferenceIDRequest:
		return (void*)soap_instantiate__ns1__GetConferenceIDRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetConferenceIDResponse:
		return (void*)soap_instantiate__ns1__GetConferenceIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GenerateAuthTokenRequest:
		return (void*)soap_instantiate__ns1__GenerateAuthTokenRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GenerateAuthTokenResponse:
		return (void*)soap_instantiate__ns1__GenerateAuthTokenResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CreateScheduledRoomRequest:
		return (void*)soap_instantiate__ns1__CreateScheduledRoomRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CreateScheduledRoomResponse:
		return (void*)soap_instantiate__ns1__CreateScheduledRoomResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DeleteScheduledRoomRequest:
		return (void*)soap_instantiate__ns1__DeleteScheduledRoomRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DeleteScheduledRoomResponse:
		return (void*)soap_instantiate__ns1__DeleteScheduledRoomResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__PortalFeature:
		return (void*)soap_instantiate__ns1__PortalFeature(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPortalFeaturesResponse:
		return (void*)soap_instantiate__ns1__GetPortalFeaturesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__EndpointFeature:
		return (void*)soap_instantiate__ns1__EndpointFeature(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetEndpointDetailsRequest:
		return (void*)soap_instantiate__ns1__SetEndpointDetailsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetEndpointDetailsResponse:
		return (void*)soap_instantiate__ns1__SetEndpointDetailsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetActiveSessionsResponse:
		return (void*)soap_instantiate__ns1__GetActiveSessionsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__LogoutAllOtherSessionsResponse:
		return (void*)soap_instantiate__ns1__LogoutAllOtherSessionsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__disconnectConferenceAllRequest:
		return (void*)soap_instantiate__ns1__disconnectConferenceAllRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__disconnectConferenceAllResponse:
		return (void*)soap_instantiate__ns1__disconnectConferenceAllResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__muteAudioServerAllRequest:
		return (void*)soap_instantiate__ns1__muteAudioServerAllRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__muteAudioServerAllResponse:
		return (void*)soap_instantiate__ns1__muteAudioServerAllResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__muteAudioClientAllRequest:
		return (void*)soap_instantiate__ns1__muteAudioClientAllRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__muteAudioClientAllResponse:
		return (void*)soap_instantiate__ns1__muteAudioClientAllResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__muteVideoServerAllRequest:
		return (void*)soap_instantiate__ns1__muteVideoServerAllRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__muteVideoServerAllResponse:
		return (void*)soap_instantiate__ns1__muteVideoServerAllResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__muteVideoClientAllRequest:
		return (void*)soap_instantiate__ns1__muteVideoClientAllRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__muteVideoClientAllResponse:
		return (void*)soap_instantiate__ns1__muteVideoClientAllResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__OnetimeAccessResponse:
		return (void*)soap_instantiate__ns1__OnetimeAccessResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RoomAccessOption:
		return (void*)soap_instantiate__ns1__RoomAccessOption(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RoomAccessOptionsRequest:
		return (void*)soap_instantiate__ns1__RoomAccessOptionsRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RoomAccessOptionsResponse:
		return (void*)soap_instantiate__ns1__RoomAccessOptionsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__PortalPrefixResponse:
		return (void*)soap_instantiate__ns1__PortalPrefixResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__PrefixNotConfiguredFault:
		return (void*)soap_instantiate__ns1__PrefixNotConfiguredFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getLoginAndWelcomeBannerRequest:
		return (void*)soap_instantiate__ns1__getLoginAndWelcomeBannerRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getLoginAndWelcomeBannerResponse:
		return (void*)soap_instantiate__ns1__getLoginAndWelcomeBannerResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getUserAccountTypeRequest:
		return (void*)soap_instantiate__ns1__getUserAccountTypeRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__getUserAccountTypeResponse:
		return (void*)soap_instantiate__ns1__getUserAccountTypeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__StartLectureModeRequest:
		return (void*)soap_instantiate__ns1__StartLectureModeRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__StartLectureModeResponse:
		return (void*)soap_instantiate__ns1__StartLectureModeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__StopLectureModeRequest:
		return (void*)soap_instantiate__ns1__StopLectureModeRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__StopLectureModeResponse:
		return (void*)soap_instantiate__ns1__StopLectureModeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RaiseHandResponse:
		return (void*)soap_instantiate__ns1__RaiseHandResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UnraiseHandResponse:
		return (void*)soap_instantiate__ns1__UnraiseHandResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DismissRaisedHandRequest:
		return (void*)soap_instantiate__ns1__DismissRaisedHandRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DismissRaisedHandResponse:
		return (void*)soap_instantiate__ns1__DismissRaisedHandResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DismissAllRaisedHandRequest:
		return (void*)soap_instantiate__ns1__DismissAllRaisedHandRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DismissAllRaisedHandResponse:
		return (void*)soap_instantiate__ns1__DismissAllRaisedHandResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetPresenterRequest:
		return (void*)soap_instantiate__ns1__SetPresenterRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetPresenterResponse:
		return (void*)soap_instantiate__ns1__SetPresenterResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RemovePresenterRequest:
		return (void*)soap_instantiate__ns1__RemovePresenterRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RemovePresenterResponse:
		return (void*)soap_instantiate__ns1__RemovePresenterResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetVidyoReplayLibraryRequest:
		return (void*)soap_instantiate__ns1__GetVidyoReplayLibraryRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetVidyoReplayLibraryResponse:
		return (void*)soap_instantiate__ns1__GetVidyoReplayLibraryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__WhatIsMyIPAddressRequest:
		return (void*)soap_instantiate__ns1__WhatIsMyIPAddressRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__WhatIsMyIPAddressResponse:
		return (void*)soap_instantiate__ns1__WhatIsMyIPAddressResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetChangePasswordHtmlUrlWithTokenRequest:
		return (void*)soap_instantiate__ns1__GetChangePasswordHtmlUrlWithTokenRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetChangePasswordHtmlUrlWithTokenResponse:
		return (void*)soap_instantiate__ns1__GetChangePasswordHtmlUrlWithTokenResponse(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE___ns1__logIn:
		return (void*)soap_instantiate___ns1__logIn(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__linkEndpoint:
		return (void*)soap_instantiate___ns1__linkEndpoint(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__logOut:
		return (void*)soap_instantiate___ns1__logOut(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__myEndpointStatus:
		return (void*)soap_instantiate___ns1__myEndpointStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__searchMyContacts:
		return (void*)soap_instantiate___ns1__searchMyContacts(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__addToMyContacts:
		return (void*)soap_instantiate___ns1__addToMyContacts(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeFromMyContacts:
		return (void*)soap_instantiate___ns1__removeFromMyContacts(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__search:
		return (void*)soap_instantiate___ns1__search(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__searchByEntityID:
		return (void*)soap_instantiate___ns1__searchByEntityID(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__searchByEmail:
		return (void*)soap_instantiate___ns1__searchByEmail(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getEntityByEntityID:
		return (void*)soap_instantiate___ns1__getEntityByEntityID(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__inviteToConference:
		return (void*)soap_instantiate___ns1__inviteToConference(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__cancelOutboundCall:
		return (void*)soap_instantiate___ns1__cancelOutboundCall(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__joinConference:
		return (void*)soap_instantiate___ns1__joinConference(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__joinIPCConference:
		return (void*)soap_instantiate___ns1__joinIPCConference(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__directCall:
		return (void*)soap_instantiate___ns1__directCall(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getParticipants:
		return (void*)soap_instantiate___ns1__getParticipants(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getLectureModeParticipants:
		return (void*)soap_instantiate___ns1__getLectureModeParticipants(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__leaveConference:
		return (void*)soap_instantiate___ns1__leaveConference(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__muteAudio:
		return (void*)soap_instantiate___ns1__muteAudio(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__unmuteAudio:
		return (void*)soap_instantiate___ns1__unmuteAudio(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__startVideo:
		return (void*)soap_instantiate___ns1__startVideo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__stopVideo:
		return (void*)soap_instantiate___ns1__stopVideo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__myAccount:
		return (void*)soap_instantiate___ns1__myAccount(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__createRoomURL:
		return (void*)soap_instantiate___ns1__createRoomURL(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeRoomURL:
		return (void*)soap_instantiate___ns1__removeRoomURL(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__createRoomPIN:
		return (void*)soap_instantiate___ns1__createRoomPIN(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeRoomPIN:
		return (void*)soap_instantiate___ns1__removeRoomPIN(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__createRoom:
		return (void*)soap_instantiate___ns1__createRoom(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__deleteRoom:
		return (void*)soap_instantiate___ns1__deleteRoom(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__updatePassword:
		return (void*)soap_instantiate___ns1__updatePassword(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__updateLanguage:
		return (void*)soap_instantiate___ns1__updateLanguage(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__lockRoom:
		return (void*)soap_instantiate___ns1__lockRoom(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__unlockRoom:
		return (void*)soap_instantiate___ns1__unlockRoom(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__setMemberMode:
		return (void*)soap_instantiate___ns1__setMemberMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getRecordingProfiles:
		return (void*)soap_instantiate___ns1__getRecordingProfiles(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__startRecording:
		return (void*)soap_instantiate___ns1__startRecording(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getPortalVersion:
		return (void*)soap_instantiate___ns1__getPortalVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__pauseRecording:
		return (void*)soap_instantiate___ns1__pauseRecording(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__resumeRecording:
		return (void*)soap_instantiate___ns1__resumeRecording(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__stopRecording:
		return (void*)soap_instantiate___ns1__stopRecording(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__createWebcastURL:
		return (void*)soap_instantiate___ns1__createWebcastURL(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__createWebcastPIN:
		return (void*)soap_instantiate___ns1__createWebcastPIN(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeWebcastURL:
		return (void*)soap_instantiate___ns1__removeWebcastURL(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeWebcastPIN:
		return (void*)soap_instantiate___ns1__removeWebcastPIN(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getWebcastURL:
		return (void*)soap_instantiate___ns1__getWebcastURL(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getUserName:
		return (void*)soap_instantiate___ns1__getUserName(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getEntityByRoomKey:
		return (void*)soap_instantiate___ns1__getEntityByRoomKey(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getInviteContent:
		return (void*)soap_instantiate___ns1__getInviteContent(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getRoomProfiles:
		return (void*)soap_instantiate___ns1__getRoomProfiles(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getRoomProfile:
		return (void*)soap_instantiate___ns1__getRoomProfile(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__setRoomProfile:
		return (void*)soap_instantiate___ns1__setRoomProfile(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeRoomProfile:
		return (void*)soap_instantiate___ns1__removeRoomProfile(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__createModeratorURL:
		return (void*)soap_instantiate___ns1__createModeratorURL(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeModeratorURL:
		return (void*)soap_instantiate___ns1__removeModeratorURL(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getModeratorURL:
		return (void*)soap_instantiate___ns1__getModeratorURL(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getModeratorURLWithToken:
		return (void*)soap_instantiate___ns1__getModeratorURLWithToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__createModeratorPIN:
		return (void*)soap_instantiate___ns1__createModeratorPIN(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeModeratorPIN:
		return (void*)soap_instantiate___ns1__removeModeratorPIN(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getConferenceID:
		return (void*)soap_instantiate___ns1__getConferenceID(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__generateAuthToken:
		return (void*)soap_instantiate___ns1__generateAuthToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__createScheduledRoom:
		return (void*)soap_instantiate___ns1__createScheduledRoom(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__deleteScheduledRoom:
		return (void*)soap_instantiate___ns1__deleteScheduledRoom(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getPortalFeatures:
		return (void*)soap_instantiate___ns1__getPortalFeatures(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__setEndpointDetails:
		return (void*)soap_instantiate___ns1__setEndpointDetails(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getActiveSessions:
		return (void*)soap_instantiate___ns1__getActiveSessions(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__logoutAllOtherSessions:
		return (void*)soap_instantiate___ns1__logoutAllOtherSessions(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__disconnectConferenceAll:
		return (void*)soap_instantiate___ns1__disconnectConferenceAll(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__muteAudioServerAll:
		return (void*)soap_instantiate___ns1__muteAudioServerAll(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__muteAudioClientAll:
		return (void*)soap_instantiate___ns1__muteAudioClientAll(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__muteVideoServerAll:
		return (void*)soap_instantiate___ns1__muteVideoServerAll(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__muteVideoClientAll:
		return (void*)soap_instantiate___ns1__muteVideoClientAll(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getOnetimeAccessUrl:
		return (void*)soap_instantiate___ns1__getOnetimeAccessUrl(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getRoomAccessOptions:
		return (void*)soap_instantiate___ns1__getRoomAccessOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getPortalPrefix:
		return (void*)soap_instantiate___ns1__getPortalPrefix(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getLoginAndWelcomeBanner:
		return (void*)soap_instantiate___ns1__getLoginAndWelcomeBanner(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getUserAccountType:
		return (void*)soap_instantiate___ns1__getUserAccountType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__startLectureMode:
		return (void*)soap_instantiate___ns1__startLectureMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__stopLectureMode:
		return (void*)soap_instantiate___ns1__stopLectureMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__raiseHand:
		return (void*)soap_instantiate___ns1__raiseHand(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__unraiseHand:
		return (void*)soap_instantiate___ns1__unraiseHand(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__dismissRaisedHand:
		return (void*)soap_instantiate___ns1__dismissRaisedHand(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__dismissAllRaisedHand:
		return (void*)soap_instantiate___ns1__dismissAllRaisedHand(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__setPresenter:
		return (void*)soap_instantiate___ns1__setPresenter(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removePresenter:
		return (void*)soap_instantiate___ns1__removePresenter(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getVidyoReplayLibrary:
		return (void*)soap_instantiate___ns1__getVidyoReplayLibrary(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__whatIsMyIPAddress:
		return (void*)soap_instantiate___ns1__whatIsMyIPAddress(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getChangePasswordHtmlUrlWithToken:
		return (void*)soap_instantiate___ns1__getChangePasswordHtmlUrlWithToken(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_ns1__Recorder:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__Recorder*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__Recorder*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__RoomProfile:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__RoomProfile*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__RoomProfile*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GeneralFault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GeneralFault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GeneralFault*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InvalidArgumentFault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InvalidArgumentFault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InvalidArgumentFault*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SeatLicenseExpiredFault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SeatLicenseExpiredFault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SeatLicenseExpiredFault*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__WrongPINFault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__WrongPINFault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__WrongPINFault*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__ConferenceLockedFault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__ConferenceLockedFault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__ConferenceLockedFault*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__NotLicensedFault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__NotLicensedFault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__NotLicensedFault*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__ResourceNotAvailableFault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__ResourceNotAvailableFault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__ResourceNotAvailableFault*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__AccessRestrictedFault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__AccessRestrictedFault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__AccessRestrictedFault*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InvalidModeratorPINFormatFault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InvalidModeratorPINFormatFault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InvalidModeratorPINFormatFault*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__ControlMeetingFault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__ControlMeetingFault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__ControlMeetingFault*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__ScheduledRoomCreationFault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__ScheduledRoomCreationFault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__ScheduledRoomCreationFault*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__EndpointNotBoundFault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__EndpointNotBoundFault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__EndpointNotBoundFault*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InPointToPointCallFault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InPointToPointCallFault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InPointToPointCallFault*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__PrefixNotConfiguredException:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__PrefixNotConfiguredException*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__PrefixNotConfiguredException*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__FeatureNotAvailableFault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__FeatureNotAvailableFault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__FeatureNotAvailableFault*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__VidyoReplayNotAvailableFault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__VidyoReplayNotAvailableFault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__VidyoReplayNotAvailableFault*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__RoomNotFoundFault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__RoomNotFoundFault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__RoomNotFoundFault*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__RoomMode:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__RoomMode*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__RoomMode*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__Filter:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__Filter*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__Filter*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__Entity:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__Entity*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__Entity*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__LectureModeParticipant:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__LectureModeParticipant*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__LectureModeParticipant*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__LoginAttempt:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__LoginAttempt*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__LoginAttempt*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__WelcomeBannerContent:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__WelcomeBannerContent*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__WelcomeBannerContent*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__LogInRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__LogInRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__LogInRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__LogInResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__LogInResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__LogInResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__LinkEndpointRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__LinkEndpointRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__LinkEndpointRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__LinkEndpointResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__LinkEndpointResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__LinkEndpointResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__LogOutRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__LogOutRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__LogOutRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__LogOutResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__LogOutResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__LogOutResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__MyEndpointStatusRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__MyEndpointStatusRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__MyEndpointStatusRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__MyEndpointStatusResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__MyEndpointStatusResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__MyEndpointStatusResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SearchMyContactsRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SearchMyContactsRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SearchMyContactsRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SearchMyContactsResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SearchMyContactsResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SearchMyContactsResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__AddToMyContactsRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__AddToMyContactsRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__AddToMyContactsRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__AddToMyContactsResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__AddToMyContactsResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__AddToMyContactsResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__RemoveFromMyContactsRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__RemoveFromMyContactsRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__RemoveFromMyContactsRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__RemoveFromMyContactsResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__RemoveFromMyContactsResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__RemoveFromMyContactsResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SearchRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SearchRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SearchRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SearchResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SearchResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SearchResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SearchByEntityIDRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SearchByEntityIDRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SearchByEntityIDRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SearchByEntityIDResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SearchByEntityIDResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SearchByEntityIDResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SearchByEmailRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SearchByEmailRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SearchByEmailRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SearchByEmailResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SearchByEmailResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SearchByEmailResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetEntityByEntityIDRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetEntityByEntityIDRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetEntityByEntityIDRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetEntityByEntityIDResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetEntityByEntityIDResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetEntityByEntityIDResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InviteToConferenceRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InviteToConferenceRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InviteToConferenceRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__InviteToConferenceResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__InviteToConferenceResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__InviteToConferenceResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__CancelOutboundCallRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__CancelOutboundCallRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__CancelOutboundCallRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__CancelOutboundCallResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__CancelOutboundCallResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__CancelOutboundCallResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__JoinConferenceRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__JoinConferenceRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__JoinConferenceRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__JoinConferenceResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__JoinConferenceResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__JoinConferenceResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__JoinIPCConferenceRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__JoinIPCConferenceRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__JoinIPCConferenceRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__JoinIPCConferenceResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__JoinIPCConferenceResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__JoinIPCConferenceResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__DirectCallRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__DirectCallRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__DirectCallRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__DirectCallResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__DirectCallResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__DirectCallResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetParticipantsRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetParticipantsRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetParticipantsRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetParticipantsResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetParticipantsResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetParticipantsResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetLectureModeParticipantsRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetLectureModeParticipantsRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetLectureModeParticipantsRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetLectureModeParticipantsResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetLectureModeParticipantsResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetLectureModeParticipantsResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__LeaveConferenceRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__LeaveConferenceRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__LeaveConferenceRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__LeaveConferenceResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__LeaveConferenceResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__LeaveConferenceResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__MuteAudioRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__MuteAudioRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__MuteAudioRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__MuteAudioResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__MuteAudioResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__MuteAudioResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__UnmuteAudioRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__UnmuteAudioRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__UnmuteAudioRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__UnmuteAudioResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__UnmuteAudioResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__UnmuteAudioResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__StartVideoRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__StartVideoRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__StartVideoRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__StartVideoResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__StartVideoResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__StartVideoResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__StopVideoRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__StopVideoRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__StopVideoRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__StopVideoResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__StopVideoResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__StopVideoResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__MyAccountRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__MyAccountRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__MyAccountRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__MyAccountResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__MyAccountResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__MyAccountResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__CreateRoomRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__CreateRoomRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__CreateRoomRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__CreateRoomResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__CreateRoomResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__CreateRoomResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__DeleteRoomRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__DeleteRoomRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__DeleteRoomRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__DeleteRoomResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__DeleteRoomResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__DeleteRoomResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__CreateRoomURLRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__CreateRoomURLRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__CreateRoomURLRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__CreateRoomURLResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__CreateRoomURLResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__CreateRoomURLResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__RemoveRoomURLRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__RemoveRoomURLRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__RemoveRoomURLRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__RemoveRoomURLResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__RemoveRoomURLResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__RemoveRoomURLResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__CreateRoomPINRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__CreateRoomPINRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__CreateRoomPINRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__CreateRoomPINResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__CreateRoomPINResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__CreateRoomPINResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__RemoveRoomPINRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__RemoveRoomPINRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__RemoveRoomPINRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__RemoveRoomPINResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__RemoveRoomPINResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__RemoveRoomPINResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__UpdatePasswordRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__UpdatePasswordRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__UpdatePasswordRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__UpdatePasswordResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__UpdatePasswordResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__UpdatePasswordResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__UpdateLanguageRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__UpdateLanguageRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__UpdateLanguageRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__UpdateLanguageResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__UpdateLanguageResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__UpdateLanguageResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__LockRoomRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__LockRoomRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__LockRoomRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__LockRoomResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__LockRoomResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__LockRoomResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__UnlockRoomRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__UnlockRoomRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__UnlockRoomRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__UnlockRoomResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__UnlockRoomResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__UnlockRoomResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SetMemberModeRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SetMemberModeRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SetMemberModeRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SetMemberModeResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SetMemberModeResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SetMemberModeResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetRecordingProfilesRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetRecordingProfilesRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetRecordingProfilesRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetRecordingProfilesResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetRecordingProfilesResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetRecordingProfilesResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__StartRecordingRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__StartRecordingRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__StartRecordingRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__StartRecordingResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__StartRecordingResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__StartRecordingResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetPortalVersionRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetPortalVersionRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetPortalVersionRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetPortalVersionResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetPortalVersionResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetPortalVersionResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__PauseRecordingRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__PauseRecordingRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__PauseRecordingRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__PauseRecordingResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__PauseRecordingResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__PauseRecordingResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__ResumeRecordingRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__ResumeRecordingRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__ResumeRecordingRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__ResumeRecordingResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__ResumeRecordingResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__ResumeRecordingResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__StopRecordingRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__StopRecordingRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__StopRecordingRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__StopRecordingResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__StopRecordingResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__StopRecordingResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__CreateWebcastURLRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__CreateWebcastURLRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__CreateWebcastURLRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__CreateWebcastURLResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__CreateWebcastURLResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__CreateWebcastURLResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__CreateWebcastPINRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__CreateWebcastPINRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__CreateWebcastPINRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__CreateWebcastPINResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__CreateWebcastPINResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__CreateWebcastPINResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__RemoveWebcastURLRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__RemoveWebcastURLRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__RemoveWebcastURLRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__RemoveWebcastURLResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__RemoveWebcastURLResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__RemoveWebcastURLResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__RemoveWebcastPINRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__RemoveWebcastPINRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__RemoveWebcastPINRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__RemoveWebcastPINResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__RemoveWebcastPINResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__RemoveWebcastPINResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetWebcastURLRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetWebcastURLRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetWebcastURLRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetWebcastURLResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetWebcastURLResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetWebcastURLResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetUserNameRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetUserNameRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetUserNameRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetUserNameResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetUserNameResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetUserNameResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetEntityByRoomKeyRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetEntityByRoomKeyRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetEntityByRoomKeyRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetEntityByRoomKeyResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetEntityByRoomKeyResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetEntityByRoomKeyResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetInviteContentRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetInviteContentRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetInviteContentRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetInviteContentResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetInviteContentResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetInviteContentResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetRoomProfilesResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetRoomProfilesResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetRoomProfilesResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetRoomProfileRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetRoomProfileRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetRoomProfileRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetRoomProfileResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetRoomProfileResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetRoomProfileResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SetRoomProfileRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SetRoomProfileRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SetRoomProfileRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SetRoomProfileResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SetRoomProfileResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SetRoomProfileResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__RemoveRoomProfileRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__RemoveRoomProfileRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__RemoveRoomProfileRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__RemoveRoomProfileResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__RemoveRoomProfileResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__RemoveRoomProfileResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__CreateModeratorURLRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__CreateModeratorURLRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__CreateModeratorURLRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__CreateModeratorURLResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__CreateModeratorURLResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__CreateModeratorURLResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__RemoveModeratorURLRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__RemoveModeratorURLRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__RemoveModeratorURLRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__RemoveModeratorURLResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__RemoveModeratorURLResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__RemoveModeratorURLResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetModeratorURLRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetModeratorURLRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetModeratorURLRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetModeratorURLResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetModeratorURLResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetModeratorURLResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetModeratorURLWithTokenRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetModeratorURLWithTokenRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetModeratorURLWithTokenRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetModeratorURLWithTokenResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetModeratorURLWithTokenResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetModeratorURLWithTokenResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__CreateModeratorPINRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__CreateModeratorPINRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__CreateModeratorPINRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__CreateModeratorPINResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__CreateModeratorPINResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__CreateModeratorPINResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__RemoveModeratorPINRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__RemoveModeratorPINRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__RemoveModeratorPINRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__RemoveModeratorPINResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__RemoveModeratorPINResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__RemoveModeratorPINResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetConferenceIDRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetConferenceIDRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetConferenceIDRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetConferenceIDResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetConferenceIDResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetConferenceIDResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GenerateAuthTokenRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GenerateAuthTokenRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GenerateAuthTokenRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GenerateAuthTokenResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GenerateAuthTokenResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GenerateAuthTokenResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__CreateScheduledRoomRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__CreateScheduledRoomRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__CreateScheduledRoomRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__CreateScheduledRoomResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__CreateScheduledRoomResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__CreateScheduledRoomResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__DeleteScheduledRoomRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__DeleteScheduledRoomRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__DeleteScheduledRoomRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__DeleteScheduledRoomResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__DeleteScheduledRoomResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__DeleteScheduledRoomResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__PortalFeature:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__PortalFeature*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__PortalFeature*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetPortalFeaturesResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetPortalFeaturesResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetPortalFeaturesResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__EndpointFeature:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__EndpointFeature*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__EndpointFeature*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SetEndpointDetailsRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SetEndpointDetailsRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SetEndpointDetailsRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SetEndpointDetailsResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SetEndpointDetailsResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SetEndpointDetailsResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetActiveSessionsResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetActiveSessionsResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetActiveSessionsResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__LogoutAllOtherSessionsResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__LogoutAllOtherSessionsResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__LogoutAllOtherSessionsResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__disconnectConferenceAllRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__disconnectConferenceAllRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__disconnectConferenceAllRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__disconnectConferenceAllResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__disconnectConferenceAllResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__disconnectConferenceAllResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__muteAudioServerAllRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__muteAudioServerAllRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__muteAudioServerAllRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__muteAudioServerAllResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__muteAudioServerAllResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__muteAudioServerAllResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__muteAudioClientAllRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__muteAudioClientAllRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__muteAudioClientAllRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__muteAudioClientAllResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__muteAudioClientAllResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__muteAudioClientAllResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__muteVideoServerAllRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__muteVideoServerAllRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__muteVideoServerAllRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__muteVideoServerAllResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__muteVideoServerAllResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__muteVideoServerAllResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__muteVideoClientAllRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__muteVideoClientAllRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__muteVideoClientAllRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__muteVideoClientAllResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__muteVideoClientAllResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__muteVideoClientAllResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__OnetimeAccessResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__OnetimeAccessResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__OnetimeAccessResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__RoomAccessOption:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__RoomAccessOption*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__RoomAccessOption*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__RoomAccessOptionsRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__RoomAccessOptionsRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__RoomAccessOptionsRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__RoomAccessOptionsResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__RoomAccessOptionsResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__RoomAccessOptionsResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__PortalPrefixResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__PortalPrefixResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__PortalPrefixResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__PrefixNotConfiguredFault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__PrefixNotConfiguredFault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__PrefixNotConfiguredFault*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getLoginAndWelcomeBannerRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getLoginAndWelcomeBannerRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getLoginAndWelcomeBannerRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getLoginAndWelcomeBannerResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getLoginAndWelcomeBannerResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getLoginAndWelcomeBannerResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getUserAccountTypeRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getUserAccountTypeRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getUserAccountTypeRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__getUserAccountTypeResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__getUserAccountTypeResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__getUserAccountTypeResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__StartLectureModeRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__StartLectureModeRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__StartLectureModeRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__StartLectureModeResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__StartLectureModeResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__StartLectureModeResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__StopLectureModeRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__StopLectureModeRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__StopLectureModeRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__StopLectureModeResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__StopLectureModeResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__StopLectureModeResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__RaiseHandResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__RaiseHandResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__RaiseHandResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__UnraiseHandResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__UnraiseHandResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__UnraiseHandResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__DismissRaisedHandRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__DismissRaisedHandRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__DismissRaisedHandRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__DismissRaisedHandResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__DismissRaisedHandResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__DismissRaisedHandResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__DismissAllRaisedHandRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__DismissAllRaisedHandRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__DismissAllRaisedHandRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__DismissAllRaisedHandResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__DismissAllRaisedHandResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__DismissAllRaisedHandResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SetPresenterRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SetPresenterRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SetPresenterRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SetPresenterResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SetPresenterResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SetPresenterResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__RemovePresenterRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__RemovePresenterRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__RemovePresenterRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__RemovePresenterResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__RemovePresenterResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__RemovePresenterResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetVidyoReplayLibraryRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetVidyoReplayLibraryRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetVidyoReplayLibraryRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetVidyoReplayLibraryResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetVidyoReplayLibraryResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetVidyoReplayLibraryResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__WhatIsMyIPAddressRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__WhatIsMyIPAddressRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__WhatIsMyIPAddressRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__WhatIsMyIPAddressResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__WhatIsMyIPAddressResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__WhatIsMyIPAddressResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetChangePasswordHtmlUrlWithTokenRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetChangePasswordHtmlUrlWithTokenRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetChangePasswordHtmlUrlWithTokenRequest*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetChangePasswordHtmlUrlWithTokenResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetChangePasswordHtmlUrlWithTokenResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetChangePasswordHtmlUrlWithTokenResponse*>(p->ptr));
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Detail*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Detail*>(p->ptr));
		break;
#endif
	case SOAP_TYPE___ns1__logIn:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__logIn*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__logIn*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__linkEndpoint:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__linkEndpoint*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__linkEndpoint*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__logOut:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__logOut*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__logOut*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__myEndpointStatus:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__myEndpointStatus*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__myEndpointStatus*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__searchMyContacts:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__searchMyContacts*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__searchMyContacts*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__addToMyContacts:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__addToMyContacts*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__addToMyContacts*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__removeFromMyContacts:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__removeFromMyContacts*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__removeFromMyContacts*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__search:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__search*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__search*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__searchByEntityID:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__searchByEntityID*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__searchByEntityID*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__searchByEmail:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__searchByEmail*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__searchByEmail*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getEntityByEntityID:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getEntityByEntityID*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getEntityByEntityID*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__inviteToConference:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__inviteToConference*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__inviteToConference*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__cancelOutboundCall:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__cancelOutboundCall*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__cancelOutboundCall*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__joinConference:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__joinConference*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__joinConference*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__joinIPCConference:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__joinIPCConference*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__joinIPCConference*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__directCall:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__directCall*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__directCall*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getParticipants:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getParticipants*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getParticipants*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getLectureModeParticipants:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getLectureModeParticipants*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getLectureModeParticipants*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__leaveConference:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__leaveConference*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__leaveConference*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__muteAudio:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__muteAudio*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__muteAudio*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__unmuteAudio:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__unmuteAudio*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__unmuteAudio*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__startVideo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__startVideo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__startVideo*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__stopVideo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__stopVideo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__stopVideo*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__myAccount:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__myAccount*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__myAccount*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__createRoomURL:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__createRoomURL*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__createRoomURL*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__removeRoomURL:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__removeRoomURL*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__removeRoomURL*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__createRoomPIN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__createRoomPIN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__createRoomPIN*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__removeRoomPIN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__removeRoomPIN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__removeRoomPIN*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__createRoom:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__createRoom*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__createRoom*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__deleteRoom:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__deleteRoom*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__deleteRoom*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__updatePassword:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__updatePassword*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__updatePassword*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__updateLanguage:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__updateLanguage*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__updateLanguage*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__lockRoom:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__lockRoom*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__lockRoom*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__unlockRoom:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__unlockRoom*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__unlockRoom*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__setMemberMode:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__setMemberMode*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__setMemberMode*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getRecordingProfiles:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getRecordingProfiles*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getRecordingProfiles*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__startRecording:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__startRecording*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__startRecording*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getPortalVersion:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getPortalVersion*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getPortalVersion*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__pauseRecording:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__pauseRecording*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__pauseRecording*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__resumeRecording:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__resumeRecording*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__resumeRecording*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__stopRecording:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__stopRecording*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__stopRecording*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__createWebcastURL:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__createWebcastURL*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__createWebcastURL*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__createWebcastPIN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__createWebcastPIN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__createWebcastPIN*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__removeWebcastURL:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__removeWebcastURL*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__removeWebcastURL*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__removeWebcastPIN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__removeWebcastPIN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__removeWebcastPIN*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getWebcastURL:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getWebcastURL*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getWebcastURL*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getUserName:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getUserName*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getUserName*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getEntityByRoomKey:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getEntityByRoomKey*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getEntityByRoomKey*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getInviteContent:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getInviteContent*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getInviteContent*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getRoomProfiles:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getRoomProfiles*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getRoomProfiles*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getRoomProfile:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getRoomProfile*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getRoomProfile*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__setRoomProfile:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__setRoomProfile*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__setRoomProfile*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__removeRoomProfile:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__removeRoomProfile*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__removeRoomProfile*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__createModeratorURL:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__createModeratorURL*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__createModeratorURL*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__removeModeratorURL:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__removeModeratorURL*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__removeModeratorURL*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getModeratorURL:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getModeratorURL*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getModeratorURL*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getModeratorURLWithToken:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getModeratorURLWithToken*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getModeratorURLWithToken*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__createModeratorPIN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__createModeratorPIN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__createModeratorPIN*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__removeModeratorPIN:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__removeModeratorPIN*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__removeModeratorPIN*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getConferenceID:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getConferenceID*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getConferenceID*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__generateAuthToken:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__generateAuthToken*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__generateAuthToken*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__createScheduledRoom:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__createScheduledRoom*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__createScheduledRoom*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__deleteScheduledRoom:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__deleteScheduledRoom*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__deleteScheduledRoom*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getPortalFeatures:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getPortalFeatures*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getPortalFeatures*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__setEndpointDetails:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__setEndpointDetails*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__setEndpointDetails*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getActiveSessions:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getActiveSessions*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getActiveSessions*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__logoutAllOtherSessions:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__logoutAllOtherSessions*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__logoutAllOtherSessions*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__disconnectConferenceAll:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__disconnectConferenceAll*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__disconnectConferenceAll*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__muteAudioServerAll:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__muteAudioServerAll*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__muteAudioServerAll*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__muteAudioClientAll:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__muteAudioClientAll*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__muteAudioClientAll*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__muteVideoServerAll:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__muteVideoServerAll*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__muteVideoServerAll*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__muteVideoClientAll:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__muteVideoClientAll*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__muteVideoClientAll*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getOnetimeAccessUrl:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getOnetimeAccessUrl*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getOnetimeAccessUrl*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getRoomAccessOptions:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getRoomAccessOptions*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getRoomAccessOptions*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getPortalPrefix:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getPortalPrefix*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getPortalPrefix*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getLoginAndWelcomeBanner:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getLoginAndWelcomeBanner*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getLoginAndWelcomeBanner*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getUserAccountType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getUserAccountType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getUserAccountType*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__startLectureMode:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__startLectureMode*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__startLectureMode*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__stopLectureMode:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__stopLectureMode*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__stopLectureMode*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__raiseHand:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__raiseHand*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__raiseHand*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__unraiseHand:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__unraiseHand*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__unraiseHand*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__dismissRaisedHand:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__dismissRaisedHand*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__dismissRaisedHand*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__dismissAllRaisedHand:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__dismissAllRaisedHand*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__dismissAllRaisedHand*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__setPresenter:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__setPresenter*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__setPresenter*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__removePresenter:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__removePresenter*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__removePresenter*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getVidyoReplayLibrary:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getVidyoReplayLibrary*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getVidyoReplayLibrary*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__whatIsMyIPAddress:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__whatIsMyIPAddress*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__whatIsMyIPAddress*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__getChangePasswordHtmlUrlWithToken:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__getChangePasswordHtmlUrlWithToken*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__getChangePasswordHtmlUrlWithToken*>(p->ptr));
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Header*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Header*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Code*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Code*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Reason*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Reason*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Fault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Fault*>(p->ptr));
		break;
#endif
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_fbase(int t, int b)
{
	do
	{	switch (t)
		{
		default: return 0;
		}
	}
	while (t != b);
	return 1;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_ns1__Recorder:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Recorder type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Recorder*)p = *(ns1__Recorder*)q;
		break;
	case SOAP_TYPE_ns1__RoomProfile:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__RoomProfile type=%d location=%p object=%p\n", t, p, q));
		*(ns1__RoomProfile*)p = *(ns1__RoomProfile*)q;
		break;
	case SOAP_TYPE__ns1__GeneralFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GeneralFault type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GeneralFault*)p = *(_ns1__GeneralFault*)q;
		break;
	case SOAP_TYPE__ns1__InvalidArgumentFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InvalidArgumentFault type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InvalidArgumentFault*)p = *(_ns1__InvalidArgumentFault*)q;
		break;
	case SOAP_TYPE__ns1__SeatLicenseExpiredFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SeatLicenseExpiredFault type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SeatLicenseExpiredFault*)p = *(_ns1__SeatLicenseExpiredFault*)q;
		break;
	case SOAP_TYPE__ns1__WrongPINFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__WrongPINFault type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__WrongPINFault*)p = *(_ns1__WrongPINFault*)q;
		break;
	case SOAP_TYPE__ns1__ConferenceLockedFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ConferenceLockedFault type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ConferenceLockedFault*)p = *(_ns1__ConferenceLockedFault*)q;
		break;
	case SOAP_TYPE__ns1__NotLicensedFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__NotLicensedFault type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__NotLicensedFault*)p = *(_ns1__NotLicensedFault*)q;
		break;
	case SOAP_TYPE__ns1__ResourceNotAvailableFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ResourceNotAvailableFault type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ResourceNotAvailableFault*)p = *(_ns1__ResourceNotAvailableFault*)q;
		break;
	case SOAP_TYPE__ns1__AccessRestrictedFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__AccessRestrictedFault type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__AccessRestrictedFault*)p = *(_ns1__AccessRestrictedFault*)q;
		break;
	case SOAP_TYPE__ns1__InvalidModeratorPINFormatFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InvalidModeratorPINFormatFault type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InvalidModeratorPINFormatFault*)p = *(_ns1__InvalidModeratorPINFormatFault*)q;
		break;
	case SOAP_TYPE__ns1__ControlMeetingFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ControlMeetingFault type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ControlMeetingFault*)p = *(_ns1__ControlMeetingFault*)q;
		break;
	case SOAP_TYPE__ns1__ScheduledRoomCreationFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ScheduledRoomCreationFault type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ScheduledRoomCreationFault*)p = *(_ns1__ScheduledRoomCreationFault*)q;
		break;
	case SOAP_TYPE__ns1__EndpointNotBoundFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__EndpointNotBoundFault type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__EndpointNotBoundFault*)p = *(_ns1__EndpointNotBoundFault*)q;
		break;
	case SOAP_TYPE__ns1__InPointToPointCallFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InPointToPointCallFault type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InPointToPointCallFault*)p = *(_ns1__InPointToPointCallFault*)q;
		break;
	case SOAP_TYPE__ns1__PrefixNotConfiguredException:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__PrefixNotConfiguredException type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__PrefixNotConfiguredException*)p = *(_ns1__PrefixNotConfiguredException*)q;
		break;
	case SOAP_TYPE__ns1__FeatureNotAvailableFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__FeatureNotAvailableFault type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__FeatureNotAvailableFault*)p = *(_ns1__FeatureNotAvailableFault*)q;
		break;
	case SOAP_TYPE__ns1__VidyoReplayNotAvailableFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__VidyoReplayNotAvailableFault type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__VidyoReplayNotAvailableFault*)p = *(_ns1__VidyoReplayNotAvailableFault*)q;
		break;
	case SOAP_TYPE__ns1__RoomNotFoundFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__RoomNotFoundFault type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__RoomNotFoundFault*)p = *(_ns1__RoomNotFoundFault*)q;
		break;
	case SOAP_TYPE__ns1__RoomMode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__RoomMode type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__RoomMode*)p = *(_ns1__RoomMode*)q;
		break;
	case SOAP_TYPE__ns1__Filter:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__Filter type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__Filter*)p = *(_ns1__Filter*)q;
		break;
	case SOAP_TYPE__ns1__Entity:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__Entity type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__Entity*)p = *(_ns1__Entity*)q;
		break;
	case SOAP_TYPE__ns1__LectureModeParticipant:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__LectureModeParticipant type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__LectureModeParticipant*)p = *(_ns1__LectureModeParticipant*)q;
		break;
	case SOAP_TYPE__ns1__LoginAttempt:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__LoginAttempt type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__LoginAttempt*)p = *(_ns1__LoginAttempt*)q;
		break;
	case SOAP_TYPE__ns1__WelcomeBannerContent:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__WelcomeBannerContent type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__WelcomeBannerContent*)p = *(_ns1__WelcomeBannerContent*)q;
		break;
	case SOAP_TYPE__ns1__LogInRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__LogInRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__LogInRequest*)p = *(_ns1__LogInRequest*)q;
		break;
	case SOAP_TYPE__ns1__LogInResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__LogInResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__LogInResponse*)p = *(_ns1__LogInResponse*)q;
		break;
	case SOAP_TYPE__ns1__LinkEndpointRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__LinkEndpointRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__LinkEndpointRequest*)p = *(_ns1__LinkEndpointRequest*)q;
		break;
	case SOAP_TYPE__ns1__LinkEndpointResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__LinkEndpointResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__LinkEndpointResponse*)p = *(_ns1__LinkEndpointResponse*)q;
		break;
	case SOAP_TYPE__ns1__LogOutRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__LogOutRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__LogOutRequest*)p = *(_ns1__LogOutRequest*)q;
		break;
	case SOAP_TYPE__ns1__LogOutResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__LogOutResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__LogOutResponse*)p = *(_ns1__LogOutResponse*)q;
		break;
	case SOAP_TYPE__ns1__MyEndpointStatusRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__MyEndpointStatusRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__MyEndpointStatusRequest*)p = *(_ns1__MyEndpointStatusRequest*)q;
		break;
	case SOAP_TYPE__ns1__MyEndpointStatusResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__MyEndpointStatusResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__MyEndpointStatusResponse*)p = *(_ns1__MyEndpointStatusResponse*)q;
		break;
	case SOAP_TYPE__ns1__SearchMyContactsRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SearchMyContactsRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SearchMyContactsRequest*)p = *(_ns1__SearchMyContactsRequest*)q;
		break;
	case SOAP_TYPE__ns1__SearchMyContactsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SearchMyContactsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SearchMyContactsResponse*)p = *(_ns1__SearchMyContactsResponse*)q;
		break;
	case SOAP_TYPE__ns1__AddToMyContactsRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__AddToMyContactsRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__AddToMyContactsRequest*)p = *(_ns1__AddToMyContactsRequest*)q;
		break;
	case SOAP_TYPE__ns1__AddToMyContactsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__AddToMyContactsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__AddToMyContactsResponse*)p = *(_ns1__AddToMyContactsResponse*)q;
		break;
	case SOAP_TYPE__ns1__RemoveFromMyContactsRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__RemoveFromMyContactsRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__RemoveFromMyContactsRequest*)p = *(_ns1__RemoveFromMyContactsRequest*)q;
		break;
	case SOAP_TYPE__ns1__RemoveFromMyContactsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__RemoveFromMyContactsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__RemoveFromMyContactsResponse*)p = *(_ns1__RemoveFromMyContactsResponse*)q;
		break;
	case SOAP_TYPE__ns1__SearchRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SearchRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SearchRequest*)p = *(_ns1__SearchRequest*)q;
		break;
	case SOAP_TYPE__ns1__SearchResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SearchResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SearchResponse*)p = *(_ns1__SearchResponse*)q;
		break;
	case SOAP_TYPE__ns1__SearchByEntityIDRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SearchByEntityIDRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SearchByEntityIDRequest*)p = *(_ns1__SearchByEntityIDRequest*)q;
		break;
	case SOAP_TYPE__ns1__SearchByEntityIDResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SearchByEntityIDResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SearchByEntityIDResponse*)p = *(_ns1__SearchByEntityIDResponse*)q;
		break;
	case SOAP_TYPE__ns1__SearchByEmailRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SearchByEmailRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SearchByEmailRequest*)p = *(_ns1__SearchByEmailRequest*)q;
		break;
	case SOAP_TYPE__ns1__SearchByEmailResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SearchByEmailResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SearchByEmailResponse*)p = *(_ns1__SearchByEmailResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetEntityByEntityIDRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetEntityByEntityIDRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetEntityByEntityIDRequest*)p = *(_ns1__GetEntityByEntityIDRequest*)q;
		break;
	case SOAP_TYPE__ns1__GetEntityByEntityIDResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetEntityByEntityIDResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetEntityByEntityIDResponse*)p = *(_ns1__GetEntityByEntityIDResponse*)q;
		break;
	case SOAP_TYPE__ns1__union_InviteToConferenceRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union _ns1__union_InviteToConferenceRequest type=%d location=%p object=%p\n", t, p, q));
		*(union _ns1__union_InviteToConferenceRequest*)p = *(union _ns1__union_InviteToConferenceRequest*)q;
		break;
	case SOAP_TYPE__ns1__InviteToConferenceRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InviteToConferenceRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InviteToConferenceRequest*)p = *(_ns1__InviteToConferenceRequest*)q;
		break;
	case SOAP_TYPE__ns1__InviteToConferenceResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__InviteToConferenceResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__InviteToConferenceResponse*)p = *(_ns1__InviteToConferenceResponse*)q;
		break;
	case SOAP_TYPE__ns1__CancelOutboundCallRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CancelOutboundCallRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CancelOutboundCallRequest*)p = *(_ns1__CancelOutboundCallRequest*)q;
		break;
	case SOAP_TYPE__ns1__CancelOutboundCallResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CancelOutboundCallResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CancelOutboundCallResponse*)p = *(_ns1__CancelOutboundCallResponse*)q;
		break;
	case SOAP_TYPE__ns1__union_JoinConferenceRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union _ns1__union_JoinConferenceRequest type=%d location=%p object=%p\n", t, p, q));
		*(union _ns1__union_JoinConferenceRequest*)p = *(union _ns1__union_JoinConferenceRequest*)q;
		break;
	case SOAP_TYPE__ns1__JoinConferenceRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__JoinConferenceRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__JoinConferenceRequest*)p = *(_ns1__JoinConferenceRequest*)q;
		break;
	case SOAP_TYPE__ns1__JoinConferenceResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__JoinConferenceResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__JoinConferenceResponse*)p = *(_ns1__JoinConferenceResponse*)q;
		break;
	case SOAP_TYPE__ns1__JoinIPCConferenceRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__JoinIPCConferenceRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__JoinIPCConferenceRequest*)p = *(_ns1__JoinIPCConferenceRequest*)q;
		break;
	case SOAP_TYPE__ns1__JoinIPCConferenceResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__JoinIPCConferenceResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__JoinIPCConferenceResponse*)p = *(_ns1__JoinIPCConferenceResponse*)q;
		break;
	case SOAP_TYPE__ns1__union_DirectCallRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union _ns1__union_DirectCallRequest type=%d location=%p object=%p\n", t, p, q));
		*(union _ns1__union_DirectCallRequest*)p = *(union _ns1__union_DirectCallRequest*)q;
		break;
	case SOAP_TYPE__ns1__DirectCallRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__DirectCallRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__DirectCallRequest*)p = *(_ns1__DirectCallRequest*)q;
		break;
	case SOAP_TYPE__ns1__DirectCallResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__DirectCallResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__DirectCallResponse*)p = *(_ns1__DirectCallResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetParticipantsRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetParticipantsRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetParticipantsRequest*)p = *(_ns1__GetParticipantsRequest*)q;
		break;
	case SOAP_TYPE__ns1__GetParticipantsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetParticipantsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetParticipantsResponse*)p = *(_ns1__GetParticipantsResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetLectureModeParticipantsRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetLectureModeParticipantsRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetLectureModeParticipantsRequest*)p = *(_ns1__GetLectureModeParticipantsRequest*)q;
		break;
	case SOAP_TYPE__ns1__GetLectureModeParticipantsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetLectureModeParticipantsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetLectureModeParticipantsResponse*)p = *(_ns1__GetLectureModeParticipantsResponse*)q;
		break;
	case SOAP_TYPE__ns1__LeaveConferenceRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__LeaveConferenceRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__LeaveConferenceRequest*)p = *(_ns1__LeaveConferenceRequest*)q;
		break;
	case SOAP_TYPE__ns1__LeaveConferenceResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__LeaveConferenceResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__LeaveConferenceResponse*)p = *(_ns1__LeaveConferenceResponse*)q;
		break;
	case SOAP_TYPE__ns1__MuteAudioRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__MuteAudioRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__MuteAudioRequest*)p = *(_ns1__MuteAudioRequest*)q;
		break;
	case SOAP_TYPE__ns1__MuteAudioResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__MuteAudioResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__MuteAudioResponse*)p = *(_ns1__MuteAudioResponse*)q;
		break;
	case SOAP_TYPE__ns1__UnmuteAudioRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__UnmuteAudioRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__UnmuteAudioRequest*)p = *(_ns1__UnmuteAudioRequest*)q;
		break;
	case SOAP_TYPE__ns1__UnmuteAudioResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__UnmuteAudioResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__UnmuteAudioResponse*)p = *(_ns1__UnmuteAudioResponse*)q;
		break;
	case SOAP_TYPE__ns1__StartVideoRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__StartVideoRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__StartVideoRequest*)p = *(_ns1__StartVideoRequest*)q;
		break;
	case SOAP_TYPE__ns1__StartVideoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__StartVideoResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__StartVideoResponse*)p = *(_ns1__StartVideoResponse*)q;
		break;
	case SOAP_TYPE__ns1__StopVideoRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__StopVideoRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__StopVideoRequest*)p = *(_ns1__StopVideoRequest*)q;
		break;
	case SOAP_TYPE__ns1__StopVideoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__StopVideoResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__StopVideoResponse*)p = *(_ns1__StopVideoResponse*)q;
		break;
	case SOAP_TYPE__ns1__MyAccountRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__MyAccountRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__MyAccountRequest*)p = *(_ns1__MyAccountRequest*)q;
		break;
	case SOAP_TYPE__ns1__MyAccountResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__MyAccountResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__MyAccountResponse*)p = *(_ns1__MyAccountResponse*)q;
		break;
	case SOAP_TYPE__ns1__CreateRoomRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CreateRoomRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CreateRoomRequest*)p = *(_ns1__CreateRoomRequest*)q;
		break;
	case SOAP_TYPE__ns1__CreateRoomResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CreateRoomResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CreateRoomResponse*)p = *(_ns1__CreateRoomResponse*)q;
		break;
	case SOAP_TYPE__ns1__DeleteRoomRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__DeleteRoomRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__DeleteRoomRequest*)p = *(_ns1__DeleteRoomRequest*)q;
		break;
	case SOAP_TYPE__ns1__DeleteRoomResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__DeleteRoomResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__DeleteRoomResponse*)p = *(_ns1__DeleteRoomResponse*)q;
		break;
	case SOAP_TYPE__ns1__CreateRoomURLRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CreateRoomURLRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CreateRoomURLRequest*)p = *(_ns1__CreateRoomURLRequest*)q;
		break;
	case SOAP_TYPE__ns1__CreateRoomURLResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CreateRoomURLResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CreateRoomURLResponse*)p = *(_ns1__CreateRoomURLResponse*)q;
		break;
	case SOAP_TYPE__ns1__RemoveRoomURLRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__RemoveRoomURLRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__RemoveRoomURLRequest*)p = *(_ns1__RemoveRoomURLRequest*)q;
		break;
	case SOAP_TYPE__ns1__RemoveRoomURLResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__RemoveRoomURLResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__RemoveRoomURLResponse*)p = *(_ns1__RemoveRoomURLResponse*)q;
		break;
	case SOAP_TYPE__ns1__CreateRoomPINRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CreateRoomPINRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CreateRoomPINRequest*)p = *(_ns1__CreateRoomPINRequest*)q;
		break;
	case SOAP_TYPE__ns1__CreateRoomPINResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CreateRoomPINResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CreateRoomPINResponse*)p = *(_ns1__CreateRoomPINResponse*)q;
		break;
	case SOAP_TYPE__ns1__RemoveRoomPINRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__RemoveRoomPINRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__RemoveRoomPINRequest*)p = *(_ns1__RemoveRoomPINRequest*)q;
		break;
	case SOAP_TYPE__ns1__RemoveRoomPINResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__RemoveRoomPINResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__RemoveRoomPINResponse*)p = *(_ns1__RemoveRoomPINResponse*)q;
		break;
	case SOAP_TYPE__ns1__UpdatePasswordRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__UpdatePasswordRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__UpdatePasswordRequest*)p = *(_ns1__UpdatePasswordRequest*)q;
		break;
	case SOAP_TYPE__ns1__UpdatePasswordResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__UpdatePasswordResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__UpdatePasswordResponse*)p = *(_ns1__UpdatePasswordResponse*)q;
		break;
	case SOAP_TYPE__ns1__UpdateLanguageRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__UpdateLanguageRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__UpdateLanguageRequest*)p = *(_ns1__UpdateLanguageRequest*)q;
		break;
	case SOAP_TYPE__ns1__UpdateLanguageResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__UpdateLanguageResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__UpdateLanguageResponse*)p = *(_ns1__UpdateLanguageResponse*)q;
		break;
	case SOAP_TYPE__ns1__LockRoomRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__LockRoomRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__LockRoomRequest*)p = *(_ns1__LockRoomRequest*)q;
		break;
	case SOAP_TYPE__ns1__LockRoomResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__LockRoomResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__LockRoomResponse*)p = *(_ns1__LockRoomResponse*)q;
		break;
	case SOAP_TYPE__ns1__UnlockRoomRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__UnlockRoomRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__UnlockRoomRequest*)p = *(_ns1__UnlockRoomRequest*)q;
		break;
	case SOAP_TYPE__ns1__UnlockRoomResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__UnlockRoomResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__UnlockRoomResponse*)p = *(_ns1__UnlockRoomResponse*)q;
		break;
	case SOAP_TYPE__ns1__SetMemberModeRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SetMemberModeRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SetMemberModeRequest*)p = *(_ns1__SetMemberModeRequest*)q;
		break;
	case SOAP_TYPE__ns1__SetMemberModeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SetMemberModeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SetMemberModeResponse*)p = *(_ns1__SetMemberModeResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetRecordingProfilesRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetRecordingProfilesRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetRecordingProfilesRequest*)p = *(_ns1__GetRecordingProfilesRequest*)q;
		break;
	case SOAP_TYPE__ns1__GetRecordingProfilesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetRecordingProfilesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetRecordingProfilesResponse*)p = *(_ns1__GetRecordingProfilesResponse*)q;
		break;
	case SOAP_TYPE__ns1__StartRecordingRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__StartRecordingRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__StartRecordingRequest*)p = *(_ns1__StartRecordingRequest*)q;
		break;
	case SOAP_TYPE__ns1__StartRecordingResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__StartRecordingResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__StartRecordingResponse*)p = *(_ns1__StartRecordingResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetPortalVersionRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetPortalVersionRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetPortalVersionRequest*)p = *(_ns1__GetPortalVersionRequest*)q;
		break;
	case SOAP_TYPE__ns1__GetPortalVersionResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetPortalVersionResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetPortalVersionResponse*)p = *(_ns1__GetPortalVersionResponse*)q;
		break;
	case SOAP_TYPE__ns1__PauseRecordingRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__PauseRecordingRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__PauseRecordingRequest*)p = *(_ns1__PauseRecordingRequest*)q;
		break;
	case SOAP_TYPE__ns1__PauseRecordingResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__PauseRecordingResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__PauseRecordingResponse*)p = *(_ns1__PauseRecordingResponse*)q;
		break;
	case SOAP_TYPE__ns1__ResumeRecordingRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ResumeRecordingRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ResumeRecordingRequest*)p = *(_ns1__ResumeRecordingRequest*)q;
		break;
	case SOAP_TYPE__ns1__ResumeRecordingResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ResumeRecordingResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ResumeRecordingResponse*)p = *(_ns1__ResumeRecordingResponse*)q;
		break;
	case SOAP_TYPE__ns1__StopRecordingRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__StopRecordingRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__StopRecordingRequest*)p = *(_ns1__StopRecordingRequest*)q;
		break;
	case SOAP_TYPE__ns1__StopRecordingResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__StopRecordingResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__StopRecordingResponse*)p = *(_ns1__StopRecordingResponse*)q;
		break;
	case SOAP_TYPE__ns1__CreateWebcastURLRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CreateWebcastURLRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CreateWebcastURLRequest*)p = *(_ns1__CreateWebcastURLRequest*)q;
		break;
	case SOAP_TYPE__ns1__CreateWebcastURLResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CreateWebcastURLResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CreateWebcastURLResponse*)p = *(_ns1__CreateWebcastURLResponse*)q;
		break;
	case SOAP_TYPE__ns1__CreateWebcastPINRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CreateWebcastPINRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CreateWebcastPINRequest*)p = *(_ns1__CreateWebcastPINRequest*)q;
		break;
	case SOAP_TYPE__ns1__CreateWebcastPINResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CreateWebcastPINResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CreateWebcastPINResponse*)p = *(_ns1__CreateWebcastPINResponse*)q;
		break;
	case SOAP_TYPE__ns1__RemoveWebcastURLRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__RemoveWebcastURLRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__RemoveWebcastURLRequest*)p = *(_ns1__RemoveWebcastURLRequest*)q;
		break;
	case SOAP_TYPE__ns1__RemoveWebcastURLResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__RemoveWebcastURLResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__RemoveWebcastURLResponse*)p = *(_ns1__RemoveWebcastURLResponse*)q;
		break;
	case SOAP_TYPE__ns1__RemoveWebcastPINRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__RemoveWebcastPINRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__RemoveWebcastPINRequest*)p = *(_ns1__RemoveWebcastPINRequest*)q;
		break;
	case SOAP_TYPE__ns1__RemoveWebcastPINResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__RemoveWebcastPINResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__RemoveWebcastPINResponse*)p = *(_ns1__RemoveWebcastPINResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetWebcastURLRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetWebcastURLRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetWebcastURLRequest*)p = *(_ns1__GetWebcastURLRequest*)q;
		break;
	case SOAP_TYPE__ns1__GetWebcastURLResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetWebcastURLResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetWebcastURLResponse*)p = *(_ns1__GetWebcastURLResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetUserNameRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetUserNameRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetUserNameRequest*)p = *(_ns1__GetUserNameRequest*)q;
		break;
	case SOAP_TYPE__ns1__GetUserNameResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetUserNameResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetUserNameResponse*)p = *(_ns1__GetUserNameResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetEntityByRoomKeyRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetEntityByRoomKeyRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetEntityByRoomKeyRequest*)p = *(_ns1__GetEntityByRoomKeyRequest*)q;
		break;
	case SOAP_TYPE__ns1__GetEntityByRoomKeyResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetEntityByRoomKeyResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetEntityByRoomKeyResponse*)p = *(_ns1__GetEntityByRoomKeyResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetInviteContentRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetInviteContentRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetInviteContentRequest*)p = *(_ns1__GetInviteContentRequest*)q;
		break;
	case SOAP_TYPE__ns1__GetInviteContentResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetInviteContentResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetInviteContentResponse*)p = *(_ns1__GetInviteContentResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetRoomProfilesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetRoomProfilesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetRoomProfilesResponse*)p = *(_ns1__GetRoomProfilesResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetRoomProfileRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetRoomProfileRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetRoomProfileRequest*)p = *(_ns1__GetRoomProfileRequest*)q;
		break;
	case SOAP_TYPE__ns1__GetRoomProfileResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetRoomProfileResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetRoomProfileResponse*)p = *(_ns1__GetRoomProfileResponse*)q;
		break;
	case SOAP_TYPE__ns1__SetRoomProfileRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SetRoomProfileRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SetRoomProfileRequest*)p = *(_ns1__SetRoomProfileRequest*)q;
		break;
	case SOAP_TYPE__ns1__SetRoomProfileResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SetRoomProfileResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SetRoomProfileResponse*)p = *(_ns1__SetRoomProfileResponse*)q;
		break;
	case SOAP_TYPE__ns1__RemoveRoomProfileRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__RemoveRoomProfileRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__RemoveRoomProfileRequest*)p = *(_ns1__RemoveRoomProfileRequest*)q;
		break;
	case SOAP_TYPE__ns1__RemoveRoomProfileResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__RemoveRoomProfileResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__RemoveRoomProfileResponse*)p = *(_ns1__RemoveRoomProfileResponse*)q;
		break;
	case SOAP_TYPE__ns1__CreateModeratorURLRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CreateModeratorURLRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CreateModeratorURLRequest*)p = *(_ns1__CreateModeratorURLRequest*)q;
		break;
	case SOAP_TYPE__ns1__CreateModeratorURLResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CreateModeratorURLResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CreateModeratorURLResponse*)p = *(_ns1__CreateModeratorURLResponse*)q;
		break;
	case SOAP_TYPE__ns1__RemoveModeratorURLRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__RemoveModeratorURLRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__RemoveModeratorURLRequest*)p = *(_ns1__RemoveModeratorURLRequest*)q;
		break;
	case SOAP_TYPE__ns1__RemoveModeratorURLResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__RemoveModeratorURLResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__RemoveModeratorURLResponse*)p = *(_ns1__RemoveModeratorURLResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetModeratorURLRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetModeratorURLRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetModeratorURLRequest*)p = *(_ns1__GetModeratorURLRequest*)q;
		break;
	case SOAP_TYPE__ns1__GetModeratorURLResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetModeratorURLResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetModeratorURLResponse*)p = *(_ns1__GetModeratorURLResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetModeratorURLWithTokenRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetModeratorURLWithTokenRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetModeratorURLWithTokenRequest*)p = *(_ns1__GetModeratorURLWithTokenRequest*)q;
		break;
	case SOAP_TYPE__ns1__GetModeratorURLWithTokenResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetModeratorURLWithTokenResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetModeratorURLWithTokenResponse*)p = *(_ns1__GetModeratorURLWithTokenResponse*)q;
		break;
	case SOAP_TYPE__ns1__CreateModeratorPINRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CreateModeratorPINRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CreateModeratorPINRequest*)p = *(_ns1__CreateModeratorPINRequest*)q;
		break;
	case SOAP_TYPE__ns1__CreateModeratorPINResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CreateModeratorPINResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CreateModeratorPINResponse*)p = *(_ns1__CreateModeratorPINResponse*)q;
		break;
	case SOAP_TYPE__ns1__RemoveModeratorPINRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__RemoveModeratorPINRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__RemoveModeratorPINRequest*)p = *(_ns1__RemoveModeratorPINRequest*)q;
		break;
	case SOAP_TYPE__ns1__RemoveModeratorPINResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__RemoveModeratorPINResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__RemoveModeratorPINResponse*)p = *(_ns1__RemoveModeratorPINResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetConferenceIDRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetConferenceIDRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetConferenceIDRequest*)p = *(_ns1__GetConferenceIDRequest*)q;
		break;
	case SOAP_TYPE__ns1__GetConferenceIDResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetConferenceIDResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetConferenceIDResponse*)p = *(_ns1__GetConferenceIDResponse*)q;
		break;
	case SOAP_TYPE__ns1__GenerateAuthTokenRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GenerateAuthTokenRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GenerateAuthTokenRequest*)p = *(_ns1__GenerateAuthTokenRequest*)q;
		break;
	case SOAP_TYPE__ns1__GenerateAuthTokenResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GenerateAuthTokenResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GenerateAuthTokenResponse*)p = *(_ns1__GenerateAuthTokenResponse*)q;
		break;
	case SOAP_TYPE__ns1__CreateScheduledRoomRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CreateScheduledRoomRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CreateScheduledRoomRequest*)p = *(_ns1__CreateScheduledRoomRequest*)q;
		break;
	case SOAP_TYPE__ns1__CreateScheduledRoomResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CreateScheduledRoomResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CreateScheduledRoomResponse*)p = *(_ns1__CreateScheduledRoomResponse*)q;
		break;
	case SOAP_TYPE__ns1__DeleteScheduledRoomRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__DeleteScheduledRoomRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__DeleteScheduledRoomRequest*)p = *(_ns1__DeleteScheduledRoomRequest*)q;
		break;
	case SOAP_TYPE__ns1__DeleteScheduledRoomResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__DeleteScheduledRoomResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__DeleteScheduledRoomResponse*)p = *(_ns1__DeleteScheduledRoomResponse*)q;
		break;
	case SOAP_TYPE__ns1__PortalFeature:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__PortalFeature type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__PortalFeature*)p = *(_ns1__PortalFeature*)q;
		break;
	case SOAP_TYPE__ns1__GetPortalFeaturesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetPortalFeaturesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetPortalFeaturesResponse*)p = *(_ns1__GetPortalFeaturesResponse*)q;
		break;
	case SOAP_TYPE__ns1__EndpointFeature:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__EndpointFeature type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__EndpointFeature*)p = *(_ns1__EndpointFeature*)q;
		break;
	case SOAP_TYPE__ns1__SetEndpointDetailsRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SetEndpointDetailsRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SetEndpointDetailsRequest*)p = *(_ns1__SetEndpointDetailsRequest*)q;
		break;
	case SOAP_TYPE__ns1__SetEndpointDetailsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SetEndpointDetailsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SetEndpointDetailsResponse*)p = *(_ns1__SetEndpointDetailsResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetActiveSessionsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetActiveSessionsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetActiveSessionsResponse*)p = *(_ns1__GetActiveSessionsResponse*)q;
		break;
	case SOAP_TYPE__ns1__LogoutAllOtherSessionsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__LogoutAllOtherSessionsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__LogoutAllOtherSessionsResponse*)p = *(_ns1__LogoutAllOtherSessionsResponse*)q;
		break;
	case SOAP_TYPE__ns1__disconnectConferenceAllRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__disconnectConferenceAllRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__disconnectConferenceAllRequest*)p = *(_ns1__disconnectConferenceAllRequest*)q;
		break;
	case SOAP_TYPE__ns1__disconnectConferenceAllResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__disconnectConferenceAllResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__disconnectConferenceAllResponse*)p = *(_ns1__disconnectConferenceAllResponse*)q;
		break;
	case SOAP_TYPE__ns1__muteAudioServerAllRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__muteAudioServerAllRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__muteAudioServerAllRequest*)p = *(_ns1__muteAudioServerAllRequest*)q;
		break;
	case SOAP_TYPE__ns1__muteAudioServerAllResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__muteAudioServerAllResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__muteAudioServerAllResponse*)p = *(_ns1__muteAudioServerAllResponse*)q;
		break;
	case SOAP_TYPE__ns1__muteAudioClientAllRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__muteAudioClientAllRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__muteAudioClientAllRequest*)p = *(_ns1__muteAudioClientAllRequest*)q;
		break;
	case SOAP_TYPE__ns1__muteAudioClientAllResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__muteAudioClientAllResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__muteAudioClientAllResponse*)p = *(_ns1__muteAudioClientAllResponse*)q;
		break;
	case SOAP_TYPE__ns1__muteVideoServerAllRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__muteVideoServerAllRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__muteVideoServerAllRequest*)p = *(_ns1__muteVideoServerAllRequest*)q;
		break;
	case SOAP_TYPE__ns1__muteVideoServerAllResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__muteVideoServerAllResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__muteVideoServerAllResponse*)p = *(_ns1__muteVideoServerAllResponse*)q;
		break;
	case SOAP_TYPE__ns1__muteVideoClientAllRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__muteVideoClientAllRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__muteVideoClientAllRequest*)p = *(_ns1__muteVideoClientAllRequest*)q;
		break;
	case SOAP_TYPE__ns1__muteVideoClientAllResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__muteVideoClientAllResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__muteVideoClientAllResponse*)p = *(_ns1__muteVideoClientAllResponse*)q;
		break;
	case SOAP_TYPE__ns1__OnetimeAccessResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__OnetimeAccessResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__OnetimeAccessResponse*)p = *(_ns1__OnetimeAccessResponse*)q;
		break;
	case SOAP_TYPE__ns1__RoomAccessOption:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__RoomAccessOption type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__RoomAccessOption*)p = *(_ns1__RoomAccessOption*)q;
		break;
	case SOAP_TYPE__ns1__RoomAccessOptionsRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__RoomAccessOptionsRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__RoomAccessOptionsRequest*)p = *(_ns1__RoomAccessOptionsRequest*)q;
		break;
	case SOAP_TYPE__ns1__RoomAccessOptionsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__RoomAccessOptionsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__RoomAccessOptionsResponse*)p = *(_ns1__RoomAccessOptionsResponse*)q;
		break;
	case SOAP_TYPE__ns1__PortalPrefixResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__PortalPrefixResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__PortalPrefixResponse*)p = *(_ns1__PortalPrefixResponse*)q;
		break;
	case SOAP_TYPE__ns1__PrefixNotConfiguredFault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__PrefixNotConfiguredFault type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__PrefixNotConfiguredFault*)p = *(_ns1__PrefixNotConfiguredFault*)q;
		break;
	case SOAP_TYPE__ns1__getLoginAndWelcomeBannerRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getLoginAndWelcomeBannerRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getLoginAndWelcomeBannerRequest*)p = *(_ns1__getLoginAndWelcomeBannerRequest*)q;
		break;
	case SOAP_TYPE__ns1__getLoginAndWelcomeBannerResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getLoginAndWelcomeBannerResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getLoginAndWelcomeBannerResponse*)p = *(_ns1__getLoginAndWelcomeBannerResponse*)q;
		break;
	case SOAP_TYPE__ns1__getUserAccountTypeRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getUserAccountTypeRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getUserAccountTypeRequest*)p = *(_ns1__getUserAccountTypeRequest*)q;
		break;
	case SOAP_TYPE__ns1__getUserAccountTypeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__getUserAccountTypeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__getUserAccountTypeResponse*)p = *(_ns1__getUserAccountTypeResponse*)q;
		break;
	case SOAP_TYPE__ns1__StartLectureModeRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__StartLectureModeRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__StartLectureModeRequest*)p = *(_ns1__StartLectureModeRequest*)q;
		break;
	case SOAP_TYPE__ns1__StartLectureModeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__StartLectureModeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__StartLectureModeResponse*)p = *(_ns1__StartLectureModeResponse*)q;
		break;
	case SOAP_TYPE__ns1__StopLectureModeRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__StopLectureModeRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__StopLectureModeRequest*)p = *(_ns1__StopLectureModeRequest*)q;
		break;
	case SOAP_TYPE__ns1__StopLectureModeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__StopLectureModeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__StopLectureModeResponse*)p = *(_ns1__StopLectureModeResponse*)q;
		break;
	case SOAP_TYPE__ns1__RaiseHandResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__RaiseHandResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__RaiseHandResponse*)p = *(_ns1__RaiseHandResponse*)q;
		break;
	case SOAP_TYPE__ns1__UnraiseHandResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__UnraiseHandResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__UnraiseHandResponse*)p = *(_ns1__UnraiseHandResponse*)q;
		break;
	case SOAP_TYPE__ns1__DismissRaisedHandRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__DismissRaisedHandRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__DismissRaisedHandRequest*)p = *(_ns1__DismissRaisedHandRequest*)q;
		break;
	case SOAP_TYPE__ns1__DismissRaisedHandResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__DismissRaisedHandResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__DismissRaisedHandResponse*)p = *(_ns1__DismissRaisedHandResponse*)q;
		break;
	case SOAP_TYPE__ns1__DismissAllRaisedHandRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__DismissAllRaisedHandRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__DismissAllRaisedHandRequest*)p = *(_ns1__DismissAllRaisedHandRequest*)q;
		break;
	case SOAP_TYPE__ns1__DismissAllRaisedHandResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__DismissAllRaisedHandResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__DismissAllRaisedHandResponse*)p = *(_ns1__DismissAllRaisedHandResponse*)q;
		break;
	case SOAP_TYPE__ns1__SetPresenterRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SetPresenterRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SetPresenterRequest*)p = *(_ns1__SetPresenterRequest*)q;
		break;
	case SOAP_TYPE__ns1__SetPresenterResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SetPresenterResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SetPresenterResponse*)p = *(_ns1__SetPresenterResponse*)q;
		break;
	case SOAP_TYPE__ns1__RemovePresenterRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__RemovePresenterRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__RemovePresenterRequest*)p = *(_ns1__RemovePresenterRequest*)q;
		break;
	case SOAP_TYPE__ns1__RemovePresenterResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__RemovePresenterResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__RemovePresenterResponse*)p = *(_ns1__RemovePresenterResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetVidyoReplayLibraryRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetVidyoReplayLibraryRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetVidyoReplayLibraryRequest*)p = *(_ns1__GetVidyoReplayLibraryRequest*)q;
		break;
	case SOAP_TYPE__ns1__GetVidyoReplayLibraryResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetVidyoReplayLibraryResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetVidyoReplayLibraryResponse*)p = *(_ns1__GetVidyoReplayLibraryResponse*)q;
		break;
	case SOAP_TYPE__ns1__WhatIsMyIPAddressRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__WhatIsMyIPAddressRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__WhatIsMyIPAddressRequest*)p = *(_ns1__WhatIsMyIPAddressRequest*)q;
		break;
	case SOAP_TYPE__ns1__WhatIsMyIPAddressResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__WhatIsMyIPAddressResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__WhatIsMyIPAddressResponse*)p = *(_ns1__WhatIsMyIPAddressResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetChangePasswordHtmlUrlWithTokenRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetChangePasswordHtmlUrlWithTokenRequest type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetChangePasswordHtmlUrlWithTokenRequest*)p = *(_ns1__GetChangePasswordHtmlUrlWithTokenRequest*)q;
		break;
	case SOAP_TYPE__ns1__GetChangePasswordHtmlUrlWithTokenResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetChangePasswordHtmlUrlWithTokenResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetChangePasswordHtmlUrlWithTokenResponse*)p = *(_ns1__GetChangePasswordHtmlUrlWithTokenResponse*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
	case SOAP_TYPE___ns1__logIn:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__logIn type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__logIn*)p = *(struct __ns1__logIn*)q;
		break;
	case SOAP_TYPE___ns1__linkEndpoint:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__linkEndpoint type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__linkEndpoint*)p = *(struct __ns1__linkEndpoint*)q;
		break;
	case SOAP_TYPE___ns1__logOut:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__logOut type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__logOut*)p = *(struct __ns1__logOut*)q;
		break;
	case SOAP_TYPE___ns1__myEndpointStatus:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__myEndpointStatus type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__myEndpointStatus*)p = *(struct __ns1__myEndpointStatus*)q;
		break;
	case SOAP_TYPE___ns1__searchMyContacts:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__searchMyContacts type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__searchMyContacts*)p = *(struct __ns1__searchMyContacts*)q;
		break;
	case SOAP_TYPE___ns1__addToMyContacts:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__addToMyContacts type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__addToMyContacts*)p = *(struct __ns1__addToMyContacts*)q;
		break;
	case SOAP_TYPE___ns1__removeFromMyContacts:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__removeFromMyContacts type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__removeFromMyContacts*)p = *(struct __ns1__removeFromMyContacts*)q;
		break;
	case SOAP_TYPE___ns1__search:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__search type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__search*)p = *(struct __ns1__search*)q;
		break;
	case SOAP_TYPE___ns1__searchByEntityID:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__searchByEntityID type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__searchByEntityID*)p = *(struct __ns1__searchByEntityID*)q;
		break;
	case SOAP_TYPE___ns1__searchByEmail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__searchByEmail type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__searchByEmail*)p = *(struct __ns1__searchByEmail*)q;
		break;
	case SOAP_TYPE___ns1__getEntityByEntityID:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getEntityByEntityID type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getEntityByEntityID*)p = *(struct __ns1__getEntityByEntityID*)q;
		break;
	case SOAP_TYPE___ns1__inviteToConference:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__inviteToConference type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__inviteToConference*)p = *(struct __ns1__inviteToConference*)q;
		break;
	case SOAP_TYPE___ns1__cancelOutboundCall:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__cancelOutboundCall type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__cancelOutboundCall*)p = *(struct __ns1__cancelOutboundCall*)q;
		break;
	case SOAP_TYPE___ns1__joinConference:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__joinConference type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__joinConference*)p = *(struct __ns1__joinConference*)q;
		break;
	case SOAP_TYPE___ns1__joinIPCConference:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__joinIPCConference type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__joinIPCConference*)p = *(struct __ns1__joinIPCConference*)q;
		break;
	case SOAP_TYPE___ns1__directCall:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__directCall type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__directCall*)p = *(struct __ns1__directCall*)q;
		break;
	case SOAP_TYPE___ns1__getParticipants:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getParticipants type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getParticipants*)p = *(struct __ns1__getParticipants*)q;
		break;
	case SOAP_TYPE___ns1__getLectureModeParticipants:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getLectureModeParticipants type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getLectureModeParticipants*)p = *(struct __ns1__getLectureModeParticipants*)q;
		break;
	case SOAP_TYPE___ns1__leaveConference:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__leaveConference type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__leaveConference*)p = *(struct __ns1__leaveConference*)q;
		break;
	case SOAP_TYPE___ns1__muteAudio:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__muteAudio type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__muteAudio*)p = *(struct __ns1__muteAudio*)q;
		break;
	case SOAP_TYPE___ns1__unmuteAudio:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__unmuteAudio type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__unmuteAudio*)p = *(struct __ns1__unmuteAudio*)q;
		break;
	case SOAP_TYPE___ns1__startVideo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__startVideo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__startVideo*)p = *(struct __ns1__startVideo*)q;
		break;
	case SOAP_TYPE___ns1__stopVideo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__stopVideo type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__stopVideo*)p = *(struct __ns1__stopVideo*)q;
		break;
	case SOAP_TYPE___ns1__myAccount:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__myAccount type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__myAccount*)p = *(struct __ns1__myAccount*)q;
		break;
	case SOAP_TYPE___ns1__createRoomURL:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__createRoomURL type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__createRoomURL*)p = *(struct __ns1__createRoomURL*)q;
		break;
	case SOAP_TYPE___ns1__removeRoomURL:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__removeRoomURL type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__removeRoomURL*)p = *(struct __ns1__removeRoomURL*)q;
		break;
	case SOAP_TYPE___ns1__createRoomPIN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__createRoomPIN type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__createRoomPIN*)p = *(struct __ns1__createRoomPIN*)q;
		break;
	case SOAP_TYPE___ns1__removeRoomPIN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__removeRoomPIN type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__removeRoomPIN*)p = *(struct __ns1__removeRoomPIN*)q;
		break;
	case SOAP_TYPE___ns1__createRoom:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__createRoom type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__createRoom*)p = *(struct __ns1__createRoom*)q;
		break;
	case SOAP_TYPE___ns1__deleteRoom:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__deleteRoom type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__deleteRoom*)p = *(struct __ns1__deleteRoom*)q;
		break;
	case SOAP_TYPE___ns1__updatePassword:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__updatePassword type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__updatePassword*)p = *(struct __ns1__updatePassword*)q;
		break;
	case SOAP_TYPE___ns1__updateLanguage:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__updateLanguage type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__updateLanguage*)p = *(struct __ns1__updateLanguage*)q;
		break;
	case SOAP_TYPE___ns1__lockRoom:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__lockRoom type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__lockRoom*)p = *(struct __ns1__lockRoom*)q;
		break;
	case SOAP_TYPE___ns1__unlockRoom:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__unlockRoom type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__unlockRoom*)p = *(struct __ns1__unlockRoom*)q;
		break;
	case SOAP_TYPE___ns1__setMemberMode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__setMemberMode type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__setMemberMode*)p = *(struct __ns1__setMemberMode*)q;
		break;
	case SOAP_TYPE___ns1__getRecordingProfiles:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getRecordingProfiles type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getRecordingProfiles*)p = *(struct __ns1__getRecordingProfiles*)q;
		break;
	case SOAP_TYPE___ns1__startRecording:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__startRecording type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__startRecording*)p = *(struct __ns1__startRecording*)q;
		break;
	case SOAP_TYPE___ns1__getPortalVersion:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getPortalVersion type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getPortalVersion*)p = *(struct __ns1__getPortalVersion*)q;
		break;
	case SOAP_TYPE___ns1__pauseRecording:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__pauseRecording type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__pauseRecording*)p = *(struct __ns1__pauseRecording*)q;
		break;
	case SOAP_TYPE___ns1__resumeRecording:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__resumeRecording type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__resumeRecording*)p = *(struct __ns1__resumeRecording*)q;
		break;
	case SOAP_TYPE___ns1__stopRecording:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__stopRecording type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__stopRecording*)p = *(struct __ns1__stopRecording*)q;
		break;
	case SOAP_TYPE___ns1__createWebcastURL:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__createWebcastURL type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__createWebcastURL*)p = *(struct __ns1__createWebcastURL*)q;
		break;
	case SOAP_TYPE___ns1__createWebcastPIN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__createWebcastPIN type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__createWebcastPIN*)p = *(struct __ns1__createWebcastPIN*)q;
		break;
	case SOAP_TYPE___ns1__removeWebcastURL:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__removeWebcastURL type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__removeWebcastURL*)p = *(struct __ns1__removeWebcastURL*)q;
		break;
	case SOAP_TYPE___ns1__removeWebcastPIN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__removeWebcastPIN type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__removeWebcastPIN*)p = *(struct __ns1__removeWebcastPIN*)q;
		break;
	case SOAP_TYPE___ns1__getWebcastURL:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getWebcastURL type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getWebcastURL*)p = *(struct __ns1__getWebcastURL*)q;
		break;
	case SOAP_TYPE___ns1__getUserName:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getUserName type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getUserName*)p = *(struct __ns1__getUserName*)q;
		break;
	case SOAP_TYPE___ns1__getEntityByRoomKey:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getEntityByRoomKey type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getEntityByRoomKey*)p = *(struct __ns1__getEntityByRoomKey*)q;
		break;
	case SOAP_TYPE___ns1__getInviteContent:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getInviteContent type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getInviteContent*)p = *(struct __ns1__getInviteContent*)q;
		break;
	case SOAP_TYPE___ns1__getRoomProfiles:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getRoomProfiles type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getRoomProfiles*)p = *(struct __ns1__getRoomProfiles*)q;
		break;
	case SOAP_TYPE___ns1__getRoomProfile:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getRoomProfile type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getRoomProfile*)p = *(struct __ns1__getRoomProfile*)q;
		break;
	case SOAP_TYPE___ns1__setRoomProfile:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__setRoomProfile type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__setRoomProfile*)p = *(struct __ns1__setRoomProfile*)q;
		break;
	case SOAP_TYPE___ns1__removeRoomProfile:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__removeRoomProfile type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__removeRoomProfile*)p = *(struct __ns1__removeRoomProfile*)q;
		break;
	case SOAP_TYPE___ns1__createModeratorURL:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__createModeratorURL type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__createModeratorURL*)p = *(struct __ns1__createModeratorURL*)q;
		break;
	case SOAP_TYPE___ns1__removeModeratorURL:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__removeModeratorURL type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__removeModeratorURL*)p = *(struct __ns1__removeModeratorURL*)q;
		break;
	case SOAP_TYPE___ns1__getModeratorURL:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getModeratorURL type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getModeratorURL*)p = *(struct __ns1__getModeratorURL*)q;
		break;
	case SOAP_TYPE___ns1__getModeratorURLWithToken:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getModeratorURLWithToken type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getModeratorURLWithToken*)p = *(struct __ns1__getModeratorURLWithToken*)q;
		break;
	case SOAP_TYPE___ns1__createModeratorPIN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__createModeratorPIN type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__createModeratorPIN*)p = *(struct __ns1__createModeratorPIN*)q;
		break;
	case SOAP_TYPE___ns1__removeModeratorPIN:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__removeModeratorPIN type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__removeModeratorPIN*)p = *(struct __ns1__removeModeratorPIN*)q;
		break;
	case SOAP_TYPE___ns1__getConferenceID:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getConferenceID type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getConferenceID*)p = *(struct __ns1__getConferenceID*)q;
		break;
	case SOAP_TYPE___ns1__generateAuthToken:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__generateAuthToken type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__generateAuthToken*)p = *(struct __ns1__generateAuthToken*)q;
		break;
	case SOAP_TYPE___ns1__createScheduledRoom:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__createScheduledRoom type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__createScheduledRoom*)p = *(struct __ns1__createScheduledRoom*)q;
		break;
	case SOAP_TYPE___ns1__deleteScheduledRoom:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__deleteScheduledRoom type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__deleteScheduledRoom*)p = *(struct __ns1__deleteScheduledRoom*)q;
		break;
	case SOAP_TYPE___ns1__getPortalFeatures:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getPortalFeatures type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getPortalFeatures*)p = *(struct __ns1__getPortalFeatures*)q;
		break;
	case SOAP_TYPE___ns1__setEndpointDetails:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__setEndpointDetails type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__setEndpointDetails*)p = *(struct __ns1__setEndpointDetails*)q;
		break;
	case SOAP_TYPE___ns1__getActiveSessions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getActiveSessions type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getActiveSessions*)p = *(struct __ns1__getActiveSessions*)q;
		break;
	case SOAP_TYPE___ns1__logoutAllOtherSessions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__logoutAllOtherSessions type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__logoutAllOtherSessions*)p = *(struct __ns1__logoutAllOtherSessions*)q;
		break;
	case SOAP_TYPE___ns1__disconnectConferenceAll:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__disconnectConferenceAll type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__disconnectConferenceAll*)p = *(struct __ns1__disconnectConferenceAll*)q;
		break;
	case SOAP_TYPE___ns1__muteAudioServerAll:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__muteAudioServerAll type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__muteAudioServerAll*)p = *(struct __ns1__muteAudioServerAll*)q;
		break;
	case SOAP_TYPE___ns1__muteAudioClientAll:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__muteAudioClientAll type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__muteAudioClientAll*)p = *(struct __ns1__muteAudioClientAll*)q;
		break;
	case SOAP_TYPE___ns1__muteVideoServerAll:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__muteVideoServerAll type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__muteVideoServerAll*)p = *(struct __ns1__muteVideoServerAll*)q;
		break;
	case SOAP_TYPE___ns1__muteVideoClientAll:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__muteVideoClientAll type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__muteVideoClientAll*)p = *(struct __ns1__muteVideoClientAll*)q;
		break;
	case SOAP_TYPE___ns1__getOnetimeAccessUrl:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getOnetimeAccessUrl type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getOnetimeAccessUrl*)p = *(struct __ns1__getOnetimeAccessUrl*)q;
		break;
	case SOAP_TYPE___ns1__getRoomAccessOptions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getRoomAccessOptions type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getRoomAccessOptions*)p = *(struct __ns1__getRoomAccessOptions*)q;
		break;
	case SOAP_TYPE___ns1__getPortalPrefix:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getPortalPrefix type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getPortalPrefix*)p = *(struct __ns1__getPortalPrefix*)q;
		break;
	case SOAP_TYPE___ns1__getLoginAndWelcomeBanner:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getLoginAndWelcomeBanner type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getLoginAndWelcomeBanner*)p = *(struct __ns1__getLoginAndWelcomeBanner*)q;
		break;
	case SOAP_TYPE___ns1__getUserAccountType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getUserAccountType type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getUserAccountType*)p = *(struct __ns1__getUserAccountType*)q;
		break;
	case SOAP_TYPE___ns1__startLectureMode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__startLectureMode type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__startLectureMode*)p = *(struct __ns1__startLectureMode*)q;
		break;
	case SOAP_TYPE___ns1__stopLectureMode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__stopLectureMode type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__stopLectureMode*)p = *(struct __ns1__stopLectureMode*)q;
		break;
	case SOAP_TYPE___ns1__raiseHand:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__raiseHand type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__raiseHand*)p = *(struct __ns1__raiseHand*)q;
		break;
	case SOAP_TYPE___ns1__unraiseHand:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__unraiseHand type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__unraiseHand*)p = *(struct __ns1__unraiseHand*)q;
		break;
	case SOAP_TYPE___ns1__dismissRaisedHand:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__dismissRaisedHand type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__dismissRaisedHand*)p = *(struct __ns1__dismissRaisedHand*)q;
		break;
	case SOAP_TYPE___ns1__dismissAllRaisedHand:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__dismissAllRaisedHand type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__dismissAllRaisedHand*)p = *(struct __ns1__dismissAllRaisedHand*)q;
		break;
	case SOAP_TYPE___ns1__setPresenter:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__setPresenter type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__setPresenter*)p = *(struct __ns1__setPresenter*)q;
		break;
	case SOAP_TYPE___ns1__removePresenter:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__removePresenter type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__removePresenter*)p = *(struct __ns1__removePresenter*)q;
		break;
	case SOAP_TYPE___ns1__getVidyoReplayLibrary:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getVidyoReplayLibrary type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getVidyoReplayLibrary*)p = *(struct __ns1__getVidyoReplayLibrary*)q;
		break;
	case SOAP_TYPE___ns1__whatIsMyIPAddress:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__whatIsMyIPAddress type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__whatIsMyIPAddress*)p = *(struct __ns1__whatIsMyIPAddress*)q;
		break;
	case SOAP_TYPE___ns1__getChangePasswordHtmlUrlWithToken:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__getChangePasswordHtmlUrlWithToken type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__getChangePasswordHtmlUrlWithToken*)p = *(struct __ns1__getChangePasswordHtmlUrlWithToken*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type = %d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag?tag:"byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag?tag:"int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dateTime(struct soap *soap, time_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_dateTime
	*a = SOAP_DEFAULT_dateTime;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dateTime(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_dateTime);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_dateTime(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	a = soap_indateTime(soap, tag, a, type, SOAP_TYPE_dateTime);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dateTime(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	if (soap_out_dateTime(soap, tag?tag:"dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_dateTime(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (LONG64)false, "false" },
	{ (LONG64)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	if (soap_out_bool(soap, tag?tag:"boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__RoomStatus(struct soap *soap, enum _ns1__RoomStatus *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__ns1__RoomStatus
	*a = SOAP_DEFAULT__ns1__RoomStatus;
#else
	*a = (enum _ns1__RoomStatus)0;
#endif
}

static const struct soap_code_map soap_codes__ns1__RoomStatus[] =
{	{ (LONG64)_ns1__RoomStatus__Empty, "Empty" },
	{ (LONG64)_ns1__RoomStatus__Full, "Full" },
	{ (LONG64)_ns1__RoomStatus__Occupied, "Occupied" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__ns1__RoomStatus2s(struct soap *soap, enum _ns1__RoomStatus n)
{	const char *s = soap_code_str(soap_codes__ns1__RoomStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RoomStatus(struct soap *soap, const char *tag, int id, const enum _ns1__RoomStatus *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RoomStatus), type) || soap_send(soap, soap__ns1__RoomStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_ns1__RoomStatus(struct soap *soap, const char *s, enum _ns1__RoomStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__ns1__RoomStatus, s);
	if (map)
		*a = (enum _ns1__RoomStatus)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum _ns1__RoomStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _ns1__RoomStatus * SOAP_FMAC4 soap_in__ns1__RoomStatus(struct soap *soap, const char *tag, enum _ns1__RoomStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _ns1__RoomStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RoomStatus, sizeof(enum _ns1__RoomStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2_ns1__RoomStatus(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _ns1__RoomStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RoomStatus, SOAP_TYPE__ns1__RoomStatus, sizeof(enum _ns1__RoomStatus), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__RoomStatus(struct soap *soap, const enum _ns1__RoomStatus *a, const char *tag, const char *type)
{
	if (soap_out__ns1__RoomStatus(soap, tag?tag:"ns1:RoomStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _ns1__RoomStatus * SOAP_FMAC4 soap_get__ns1__RoomStatus(struct soap *soap, enum _ns1__RoomStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RoomStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__MemberStatus(struct soap *soap, enum _ns1__MemberStatus *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__ns1__MemberStatus
	*a = SOAP_DEFAULT__ns1__MemberStatus;
#else
	*a = (enum _ns1__MemberStatus)0;
#endif
}

static const struct soap_code_map soap_codes__ns1__MemberStatus[] =
{	{ (LONG64)_ns1__MemberStatus__Offline, "Offline" },
	{ (LONG64)_ns1__MemberStatus__Online, "Online" },
	{ (LONG64)_ns1__MemberStatus__Busy, "Busy" },
	{ (LONG64)_ns1__MemberStatus__BusyInOwnRoom, "BusyInOwnRoom" },
	{ (LONG64)_ns1__MemberStatus__Ringing, "Ringing" },
	{ (LONG64)_ns1__MemberStatus__RingAccepted, "RingAccepted" },
	{ (LONG64)_ns1__MemberStatus__RingRejected, "RingRejected" },
	{ (LONG64)_ns1__MemberStatus__RingNoAnswer, "RingNoAnswer" },
	{ (LONG64)_ns1__MemberStatus__Alerting, "Alerting" },
	{ (LONG64)_ns1__MemberStatus__AlertCancelled, "AlertCancelled" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__ns1__MemberStatus2s(struct soap *soap, enum _ns1__MemberStatus n)
{	const char *s = soap_code_str(soap_codes__ns1__MemberStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__MemberStatus(struct soap *soap, const char *tag, int id, const enum _ns1__MemberStatus *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__MemberStatus), type) || soap_send(soap, soap__ns1__MemberStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_ns1__MemberStatus(struct soap *soap, const char *s, enum _ns1__MemberStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__ns1__MemberStatus, s);
	if (map)
		*a = (enum _ns1__MemberStatus)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 9)))
			return soap->error = SOAP_TYPE;
		*a = (enum _ns1__MemberStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _ns1__MemberStatus * SOAP_FMAC4 soap_in__ns1__MemberStatus(struct soap *soap, const char *tag, enum _ns1__MemberStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _ns1__MemberStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__MemberStatus, sizeof(enum _ns1__MemberStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2_ns1__MemberStatus(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _ns1__MemberStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__MemberStatus, SOAP_TYPE__ns1__MemberStatus, sizeof(enum _ns1__MemberStatus), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__MemberStatus(struct soap *soap, const enum _ns1__MemberStatus *a, const char *tag, const char *type)
{
	if (soap_out__ns1__MemberStatus(soap, tag?tag:"ns1:MemberStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _ns1__MemberStatus * SOAP_FMAC4 soap_get__ns1__MemberStatus(struct soap *soap, enum _ns1__MemberStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__MemberStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__MemberMode(struct soap *soap, enum _ns1__MemberMode *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__ns1__MemberMode
	*a = SOAP_DEFAULT__ns1__MemberMode;
#else
	*a = (enum _ns1__MemberMode)0;
#endif
}

static const struct soap_code_map soap_codes__ns1__MemberMode[] =
{	{ (LONG64)_ns1__MemberMode__Available, "Available" },
	{ (LONG64)_ns1__MemberMode__Away, "Away" },
	{ (LONG64)_ns1__MemberMode__DoNotDisturb, "DoNotDisturb" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__ns1__MemberMode2s(struct soap *soap, enum _ns1__MemberMode n)
{	const char *s = soap_code_str(soap_codes__ns1__MemberMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__MemberMode(struct soap *soap, const char *tag, int id, const enum _ns1__MemberMode *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__MemberMode), type) || soap_send(soap, soap__ns1__MemberMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_ns1__MemberMode(struct soap *soap, const char *s, enum _ns1__MemberMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__ns1__MemberMode, s);
	if (map)
		*a = (enum _ns1__MemberMode)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum _ns1__MemberMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _ns1__MemberMode * SOAP_FMAC4 soap_in__ns1__MemberMode(struct soap *soap, const char *tag, enum _ns1__MemberMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _ns1__MemberMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__MemberMode, sizeof(enum _ns1__MemberMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2_ns1__MemberMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _ns1__MemberMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__MemberMode, SOAP_TYPE__ns1__MemberMode, sizeof(enum _ns1__MemberMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__MemberMode(struct soap *soap, const enum _ns1__MemberMode *a, const char *tag, const char *type)
{
	if (soap_out__ns1__MemberMode(soap, tag?tag:"ns1:MemberMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _ns1__MemberMode * SOAP_FMAC4 soap_get__ns1__MemberMode(struct soap *soap, enum _ns1__MemberMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__MemberMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__EntityType(struct soap *soap, enum _ns1__EntityType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__ns1__EntityType
	*a = SOAP_DEFAULT__ns1__EntityType;
#else
	*a = (enum _ns1__EntityType)0;
#endif
}

static const struct soap_code_map soap_codes__ns1__EntityType[] =
{	{ (LONG64)_ns1__EntityType__Member, "Member" },
	{ (LONG64)_ns1__EntityType__Room, "Room" },
	{ (LONG64)_ns1__EntityType__Legacy, "Legacy" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__ns1__EntityType2s(struct soap *soap, enum _ns1__EntityType n)
{	const char *s = soap_code_str(soap_codes__ns1__EntityType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__EntityType(struct soap *soap, const char *tag, int id, const enum _ns1__EntityType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__EntityType), type) || soap_send(soap, soap__ns1__EntityType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_ns1__EntityType(struct soap *soap, const char *s, enum _ns1__EntityType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__ns1__EntityType, s);
	if (map)
		*a = (enum _ns1__EntityType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum _ns1__EntityType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _ns1__EntityType * SOAP_FMAC4 soap_in__ns1__EntityType(struct soap *soap, const char *tag, enum _ns1__EntityType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _ns1__EntityType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__EntityType, sizeof(enum _ns1__EntityType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2_ns1__EntityType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _ns1__EntityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__EntityType, SOAP_TYPE__ns1__EntityType, sizeof(enum _ns1__EntityType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__EntityType(struct soap *soap, const enum _ns1__EntityType *a, const char *tag, const char *type)
{
	if (soap_out__ns1__EntityType(soap, tag?tag:"ns1:EntityType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _ns1__EntityType * SOAP_FMAC4 soap_get__ns1__EntityType(struct soap *soap, enum _ns1__EntityType *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__EntityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__Language(struct soap *soap, enum _ns1__Language *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__ns1__Language
	*a = SOAP_DEFAULT__ns1__Language;
#else
	*a = (enum _ns1__Language)0;
#endif
}

static const struct soap_code_map soap_codes__ns1__Language[] =
{	{ (LONG64)_ns1__Language__en, "en" },
	{ (LONG64)_ns1__Language__de, "de" },
	{ (LONG64)_ns1__Language__es, "es" },
	{ (LONG64)_ns1__Language__fr, "fr" },
	{ (LONG64)_ns1__Language__it, "it" },
	{ (LONG64)_ns1__Language__ja, "ja" },
	{ (LONG64)_ns1__Language__ko, "ko" },
	{ (LONG64)_ns1__Language__pt, "pt" },
	{ (LONG64)_ns1__Language__zh_USCORECN, "zh_CN" },
	{ (LONG64)_ns1__Language__fi, "fi" },
	{ (LONG64)_ns1__Language__pl, "pl" },
	{ (LONG64)_ns1__Language__zh_USCORETW, "zh_TW" },
	{ (LONG64)_ns1__Language__th, "th" },
	{ (LONG64)_ns1__Language__ru, "ru" },
	{ (LONG64)_ns1__Language__tr, "tr" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__ns1__Language2s(struct soap *soap, enum _ns1__Language n)
{	const char *s = soap_code_str(soap_codes__ns1__Language, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Language(struct soap *soap, const char *tag, int id, const enum _ns1__Language *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__Language), type) || soap_send(soap, soap__ns1__Language2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_ns1__Language(struct soap *soap, const char *s, enum _ns1__Language *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__ns1__Language, s);
	if (map)
		*a = (enum _ns1__Language)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 14)))
			return soap->error = SOAP_TYPE;
		*a = (enum _ns1__Language)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _ns1__Language * SOAP_FMAC4 soap_in__ns1__Language(struct soap *soap, const char *tag, enum _ns1__Language *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _ns1__Language *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__Language, sizeof(enum _ns1__Language), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2_ns1__Language(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _ns1__Language *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__Language, SOAP_TYPE__ns1__Language, sizeof(enum _ns1__Language), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__Language(struct soap *soap, const enum _ns1__Language *a, const char *tag, const char *type)
{
	if (soap_out__ns1__Language(soap, tag?tag:"ns1:Language", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _ns1__Language * SOAP_FMAC4 soap_get__ns1__Language(struct soap *soap, enum _ns1__Language *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Language(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__OK(struct soap *soap, enum _ns1__OK *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__ns1__OK
	*a = SOAP_DEFAULT__ns1__OK;
#else
	*a = (enum _ns1__OK)0;
#endif
}

static const struct soap_code_map soap_codes__ns1__OK[] =
{	{ (LONG64)_ns1__OK__OK, "OK" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__ns1__OK2s(struct soap *soap, enum _ns1__OK n)
{	const char *s = soap_code_str(soap_codes__ns1__OK, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__OK(struct soap *soap, const char *tag, int id, const enum _ns1__OK *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__OK), type) || soap_send(soap, soap__ns1__OK2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_ns1__OK(struct soap *soap, const char *s, enum _ns1__OK *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__ns1__OK, s);
	if (map)
		*a = (enum _ns1__OK)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 0)))
			return soap->error = SOAP_TYPE;
		*a = (enum _ns1__OK)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _ns1__OK * SOAP_FMAC4 soap_in__ns1__OK(struct soap *soap, const char *tag, enum _ns1__OK *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _ns1__OK *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__OK, sizeof(enum _ns1__OK), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2_ns1__OK(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _ns1__OK *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__OK, SOAP_TYPE__ns1__OK, sizeof(enum _ns1__OK), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__OK(struct soap *soap, const enum _ns1__OK *a, const char *tag, const char *type)
{
	if (soap_out__ns1__OK(soap, tag?tag:"ns1:OK", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _ns1__OK * SOAP_FMAC4 soap_get__ns1__OK(struct soap *soap, enum _ns1__OK *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__OK(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__ClientType(struct soap *soap, enum _ns1__ClientType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__ns1__ClientType
	*a = SOAP_DEFAULT__ns1__ClientType;
#else
	*a = (enum _ns1__ClientType)0;
#endif
}

static const struct soap_code_map soap_codes__ns1__ClientType[] =
{	{ (LONG64)_ns1__ClientType__W, "W" },
	{ (LONG64)_ns1__ClientType__M, "M" },
	{ (LONG64)_ns1__ClientType__V, "V" },
	{ (LONG64)_ns1__ClientType__R, "R" },
	{ (LONG64)_ns1__ClientType__L, "L" },
	{ (LONG64)_ns1__ClientType__S, "S" },
	{ (LONG64)_ns1__ClientType__U, "U" },
	{ (LONG64)_ns1__ClientType__T, "T" },
	{ (LONG64)_ns1__ClientType__X, "X" },
	{ (LONG64)_ns1__ClientType__I, "I" },
	{ (LONG64)_ns1__ClientType__A, "A" },
	{ (LONG64)_ns1__ClientType__P, "P" },
	{ (LONG64)_ns1__ClientType__N, "N" },
	{ (LONG64)_ns1__ClientType__O, "O" },
	{ (LONG64)_ns1__ClientType__Q, "Q" },
	{ (LONG64)_ns1__ClientType__Y, "Y" },
	{ (LONG64)_ns1__ClientType__Z, "Z" },
	{ (LONG64)_ns1__ClientType__B, "B" },
	{ (LONG64)_ns1__ClientType__C, "C" },
	{ (LONG64)_ns1__ClientType__D, "D" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__ns1__ClientType2s(struct soap *soap, enum _ns1__ClientType n)
{	const char *s = soap_code_str(soap_codes__ns1__ClientType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ClientType(struct soap *soap, const char *tag, int id, const enum _ns1__ClientType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ClientType), type) || soap_send(soap, soap__ns1__ClientType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_ns1__ClientType(struct soap *soap, const char *s, enum _ns1__ClientType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__ns1__ClientType, s);
	if (map)
		*a = (enum _ns1__ClientType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 90)))
			return soap->error = SOAP_TYPE;
		*a = (enum _ns1__ClientType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _ns1__ClientType * SOAP_FMAC4 soap_in__ns1__ClientType(struct soap *soap, const char *tag, enum _ns1__ClientType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _ns1__ClientType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ClientType, sizeof(enum _ns1__ClientType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2_ns1__ClientType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _ns1__ClientType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ClientType, SOAP_TYPE__ns1__ClientType, sizeof(enum _ns1__ClientType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__ClientType(struct soap *soap, const enum _ns1__ClientType *a, const char *tag, const char *type)
{
	if (soap_out__ns1__ClientType(soap, tag?tag:"ns1:ClientType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _ns1__ClientType * SOAP_FMAC4 soap_get__ns1__ClientType(struct soap *soap, enum _ns1__ClientType *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ClientType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__AccessOptionName(struct soap *soap, enum ns1__AccessOptionName *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__AccessOptionName
	*a = SOAP_DEFAULT_ns1__AccessOptionName;
#else
	*a = (enum ns1__AccessOptionName)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__AccessOptionName[] =
{	{ (LONG64)ns1__AccessOptionName__roomURL, "roomURL" },
	{ (LONG64)ns1__AccessOptionName__extension, "extension" },
	{ (LONG64)ns1__AccessOptionName__PIN, "PIN" },
	{ (LONG64)ns1__AccessOptionName__dial_in_Number, "dial-in-Number" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__AccessOptionName2s(struct soap *soap, enum ns1__AccessOptionName n)
{	const char *s = soap_code_str(soap_codes_ns1__AccessOptionName, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AccessOptionName(struct soap *soap, const char *tag, int id, const enum ns1__AccessOptionName *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AccessOptionName), type) || soap_send(soap, soap_ns1__AccessOptionName2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__AccessOptionName(struct soap *soap, const char *s, enum ns1__AccessOptionName *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__AccessOptionName, s);
	if (map)
		*a = (enum ns1__AccessOptionName)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__AccessOptionName)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__AccessOptionName * SOAP_FMAC4 soap_in_ns1__AccessOptionName(struct soap *soap, const char *tag, enum ns1__AccessOptionName *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__AccessOptionName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AccessOptionName, sizeof(enum ns1__AccessOptionName), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2ns1__AccessOptionName(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__AccessOptionName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AccessOptionName, SOAP_TYPE_ns1__AccessOptionName, sizeof(enum ns1__AccessOptionName), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__AccessOptionName(struct soap *soap, const enum ns1__AccessOptionName *a, const char *tag, const char *type)
{
	if (soap_out_ns1__AccessOptionName(soap, tag?tag:"ns1:AccessOptionName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__AccessOptionName * SOAP_FMAC4 soap_get_ns1__AccessOptionName(struct soap *soap, enum ns1__AccessOptionName *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AccessOptionName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__sortDir(struct soap *soap, enum ns1__sortDir *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__sortDir
	*a = SOAP_DEFAULT_ns1__sortDir;
#else
	*a = (enum ns1__sortDir)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__sortDir[] =
{	{ (LONG64)ns1__sortDir__ASC, "ASC" },
	{ (LONG64)ns1__sortDir__DESC, "DESC" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__sortDir2s(struct soap *soap, enum ns1__sortDir n)
{	const char *s = soap_code_str(soap_codes_ns1__sortDir, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__sortDir(struct soap *soap, const char *tag, int id, const enum ns1__sortDir *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__sortDir), type) || soap_send(soap, soap_ns1__sortDir2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__sortDir(struct soap *soap, const char *s, enum ns1__sortDir *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__sortDir, s);
	if (map)
		*a = (enum ns1__sortDir)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__sortDir)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__sortDir * SOAP_FMAC4 soap_in_ns1__sortDir(struct soap *soap, const char *tag, enum ns1__sortDir *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__sortDir *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__sortDir, sizeof(enum ns1__sortDir), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2ns1__sortDir(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__sortDir *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__sortDir, SOAP_TYPE_ns1__sortDir, sizeof(enum ns1__sortDir), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__sortDir(struct soap *soap, const enum ns1__sortDir *a, const char *tag, const char *type)
{
	if (soap_out_ns1__sortDir(soap, tag?tag:"ns1:sortDir", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__sortDir * SOAP_FMAC4 soap_get_ns1__sortDir(struct soap *soap, enum ns1__sortDir *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__sortDir(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetChangePasswordHtmlUrlWithTokenResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetChangePasswordHtmlUrlWithTokenResponse::changePasswordHtmlUrlWithToken);
	/* transient soap skipped */
}

void _ns1__GetChangePasswordHtmlUrlWithTokenResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetChangePasswordHtmlUrlWithTokenResponse::changePasswordHtmlUrlWithToken);
#endif
}

int _ns1__GetChangePasswordHtmlUrlWithTokenResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetChangePasswordHtmlUrlWithTokenResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetChangePasswordHtmlUrlWithTokenResponse(struct soap *soap, const char *tag, int id, const _ns1__GetChangePasswordHtmlUrlWithTokenResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetChangePasswordHtmlUrlWithTokenResponse), type))
		return soap->error;
	if (a->changePasswordHtmlUrlWithToken)
		soap_element_result(soap, "ns1:changePasswordHtmlUrlWithToken");
	if (!a->_ns1__GetChangePasswordHtmlUrlWithTokenResponse::changePasswordHtmlUrlWithToken)
	{	if (soap_element_nil(soap, "ns1:changePasswordHtmlUrlWithToken"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:changePasswordHtmlUrlWithToken", -1, (char*const*)&a->_ns1__GetChangePasswordHtmlUrlWithTokenResponse::changePasswordHtmlUrlWithToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetChangePasswordHtmlUrlWithTokenResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetChangePasswordHtmlUrlWithTokenResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetChangePasswordHtmlUrlWithTokenResponse * SOAP_FMAC4 soap_in__ns1__GetChangePasswordHtmlUrlWithTokenResponse(struct soap *soap, const char *tag, _ns1__GetChangePasswordHtmlUrlWithTokenResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetChangePasswordHtmlUrlWithTokenResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetChangePasswordHtmlUrlWithTokenResponse, sizeof(_ns1__GetChangePasswordHtmlUrlWithTokenResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_changePasswordHtmlUrlWithToken1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_changePasswordHtmlUrlWithToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:changePasswordHtmlUrlWithToken", (char**)&a->_ns1__GetChangePasswordHtmlUrlWithTokenResponse::changePasswordHtmlUrlWithToken, "xsd:string"))
				{	soap_flag_changePasswordHtmlUrlWithToken1--;
					continue;
				}
			soap_check_result(soap, "ns1:changePasswordHtmlUrlWithToken");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_changePasswordHtmlUrlWithToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetChangePasswordHtmlUrlWithTokenResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetChangePasswordHtmlUrlWithTokenResponse, SOAP_TYPE__ns1__GetChangePasswordHtmlUrlWithTokenResponse, sizeof(_ns1__GetChangePasswordHtmlUrlWithTokenResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetChangePasswordHtmlUrlWithTokenResponse * SOAP_FMAC2 soap_instantiate__ns1__GetChangePasswordHtmlUrlWithTokenResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetChangePasswordHtmlUrlWithTokenResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetChangePasswordHtmlUrlWithTokenResponse *p;
	size_t k = sizeof(_ns1__GetChangePasswordHtmlUrlWithTokenResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetChangePasswordHtmlUrlWithTokenResponse);
		if (p)
			((_ns1__GetChangePasswordHtmlUrlWithTokenResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetChangePasswordHtmlUrlWithTokenResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetChangePasswordHtmlUrlWithTokenResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetChangePasswordHtmlUrlWithTokenResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetChangePasswordHtmlUrlWithTokenResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetChangePasswordHtmlUrlWithTokenResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:GetChangePasswordHtmlUrlWithTokenResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetChangePasswordHtmlUrlWithTokenResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetChangePasswordHtmlUrlWithTokenResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetChangePasswordHtmlUrlWithTokenResponse * SOAP_FMAC4 soap_get__ns1__GetChangePasswordHtmlUrlWithTokenResponse(struct soap *soap, _ns1__GetChangePasswordHtmlUrlWithTokenResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetChangePasswordHtmlUrlWithTokenResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetChangePasswordHtmlUrlWithTokenRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__GetChangePasswordHtmlUrlWithTokenRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__GetChangePasswordHtmlUrlWithTokenRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetChangePasswordHtmlUrlWithTokenRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetChangePasswordHtmlUrlWithTokenRequest(struct soap *soap, const char *tag, int id, const _ns1__GetChangePasswordHtmlUrlWithTokenRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetChangePasswordHtmlUrlWithTokenRequest), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetChangePasswordHtmlUrlWithTokenRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetChangePasswordHtmlUrlWithTokenRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetChangePasswordHtmlUrlWithTokenRequest * SOAP_FMAC4 soap_in__ns1__GetChangePasswordHtmlUrlWithTokenRequest(struct soap *soap, const char *tag, _ns1__GetChangePasswordHtmlUrlWithTokenRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetChangePasswordHtmlUrlWithTokenRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetChangePasswordHtmlUrlWithTokenRequest, sizeof(_ns1__GetChangePasswordHtmlUrlWithTokenRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetChangePasswordHtmlUrlWithTokenRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetChangePasswordHtmlUrlWithTokenRequest, SOAP_TYPE__ns1__GetChangePasswordHtmlUrlWithTokenRequest, sizeof(_ns1__GetChangePasswordHtmlUrlWithTokenRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetChangePasswordHtmlUrlWithTokenRequest * SOAP_FMAC2 soap_instantiate__ns1__GetChangePasswordHtmlUrlWithTokenRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetChangePasswordHtmlUrlWithTokenRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetChangePasswordHtmlUrlWithTokenRequest *p;
	size_t k = sizeof(_ns1__GetChangePasswordHtmlUrlWithTokenRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetChangePasswordHtmlUrlWithTokenRequest);
		if (p)
			((_ns1__GetChangePasswordHtmlUrlWithTokenRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetChangePasswordHtmlUrlWithTokenRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetChangePasswordHtmlUrlWithTokenRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetChangePasswordHtmlUrlWithTokenRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetChangePasswordHtmlUrlWithTokenRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetChangePasswordHtmlUrlWithTokenRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:GetChangePasswordHtmlUrlWithTokenRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetChangePasswordHtmlUrlWithTokenRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetChangePasswordHtmlUrlWithTokenRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetChangePasswordHtmlUrlWithTokenRequest * SOAP_FMAC4 soap_get__ns1__GetChangePasswordHtmlUrlWithTokenRequest(struct soap *soap, _ns1__GetChangePasswordHtmlUrlWithTokenRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetChangePasswordHtmlUrlWithTokenRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__WhatIsMyIPAddressResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__WhatIsMyIPAddressResponse::endpointExternalIPAddress);
	/* transient soap skipped */
}

void _ns1__WhatIsMyIPAddressResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__WhatIsMyIPAddressResponse::endpointExternalIPAddress);
#endif
}

int _ns1__WhatIsMyIPAddressResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__WhatIsMyIPAddressResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__WhatIsMyIPAddressResponse(struct soap *soap, const char *tag, int id, const _ns1__WhatIsMyIPAddressResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__WhatIsMyIPAddressResponse), type))
		return soap->error;
	if (a->endpointExternalIPAddress)
		soap_element_result(soap, "ns1:endpointExternalIPAddress");
	if (!a->_ns1__WhatIsMyIPAddressResponse::endpointExternalIPAddress)
	{	if (soap_element_nil(soap, "ns1:endpointExternalIPAddress"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:endpointExternalIPAddress", -1, (char*const*)&a->_ns1__WhatIsMyIPAddressResponse::endpointExternalIPAddress, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__WhatIsMyIPAddressResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__WhatIsMyIPAddressResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__WhatIsMyIPAddressResponse * SOAP_FMAC4 soap_in__ns1__WhatIsMyIPAddressResponse(struct soap *soap, const char *tag, _ns1__WhatIsMyIPAddressResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__WhatIsMyIPAddressResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__WhatIsMyIPAddressResponse, sizeof(_ns1__WhatIsMyIPAddressResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_endpointExternalIPAddress1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_endpointExternalIPAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:endpointExternalIPAddress", (char**)&a->_ns1__WhatIsMyIPAddressResponse::endpointExternalIPAddress, "xsd:string"))
				{	soap_flag_endpointExternalIPAddress1--;
					continue;
				}
			soap_check_result(soap, "ns1:endpointExternalIPAddress");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_endpointExternalIPAddress1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__WhatIsMyIPAddressResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__WhatIsMyIPAddressResponse, SOAP_TYPE__ns1__WhatIsMyIPAddressResponse, sizeof(_ns1__WhatIsMyIPAddressResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__WhatIsMyIPAddressResponse * SOAP_FMAC2 soap_instantiate__ns1__WhatIsMyIPAddressResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__WhatIsMyIPAddressResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__WhatIsMyIPAddressResponse *p;
	size_t k = sizeof(_ns1__WhatIsMyIPAddressResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__WhatIsMyIPAddressResponse);
		if (p)
			((_ns1__WhatIsMyIPAddressResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__WhatIsMyIPAddressResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__WhatIsMyIPAddressResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__WhatIsMyIPAddressResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__WhatIsMyIPAddressResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__WhatIsMyIPAddressResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:WhatIsMyIPAddressResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__WhatIsMyIPAddressResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__WhatIsMyIPAddressResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__WhatIsMyIPAddressResponse * SOAP_FMAC4 soap_get__ns1__WhatIsMyIPAddressResponse(struct soap *soap, _ns1__WhatIsMyIPAddressResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__WhatIsMyIPAddressResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__WhatIsMyIPAddressRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__WhatIsMyIPAddressRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__WhatIsMyIPAddressRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__WhatIsMyIPAddressRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__WhatIsMyIPAddressRequest(struct soap *soap, const char *tag, int id, const _ns1__WhatIsMyIPAddressRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__WhatIsMyIPAddressRequest), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__WhatIsMyIPAddressRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__WhatIsMyIPAddressRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__WhatIsMyIPAddressRequest * SOAP_FMAC4 soap_in__ns1__WhatIsMyIPAddressRequest(struct soap *soap, const char *tag, _ns1__WhatIsMyIPAddressRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__WhatIsMyIPAddressRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__WhatIsMyIPAddressRequest, sizeof(_ns1__WhatIsMyIPAddressRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__WhatIsMyIPAddressRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__WhatIsMyIPAddressRequest, SOAP_TYPE__ns1__WhatIsMyIPAddressRequest, sizeof(_ns1__WhatIsMyIPAddressRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__WhatIsMyIPAddressRequest * SOAP_FMAC2 soap_instantiate__ns1__WhatIsMyIPAddressRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__WhatIsMyIPAddressRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__WhatIsMyIPAddressRequest *p;
	size_t k = sizeof(_ns1__WhatIsMyIPAddressRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__WhatIsMyIPAddressRequest);
		if (p)
			((_ns1__WhatIsMyIPAddressRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__WhatIsMyIPAddressRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__WhatIsMyIPAddressRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__WhatIsMyIPAddressRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__WhatIsMyIPAddressRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__WhatIsMyIPAddressRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:WhatIsMyIPAddressRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__WhatIsMyIPAddressRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__WhatIsMyIPAddressRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__WhatIsMyIPAddressRequest * SOAP_FMAC4 soap_get__ns1__WhatIsMyIPAddressRequest(struct soap *soap, _ns1__WhatIsMyIPAddressRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__WhatIsMyIPAddressRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetVidyoReplayLibraryResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetVidyoReplayLibraryResponse::authToken);
	soap_default_string(soap, &this->_ns1__GetVidyoReplayLibraryResponse::vidyoReplayLibraryUrl);
	/* transient soap skipped */
}

void _ns1__GetVidyoReplayLibraryResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetVidyoReplayLibraryResponse::authToken);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetVidyoReplayLibraryResponse::vidyoReplayLibraryUrl);
#endif
}

int _ns1__GetVidyoReplayLibraryResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetVidyoReplayLibraryResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetVidyoReplayLibraryResponse(struct soap *soap, const char *tag, int id, const _ns1__GetVidyoReplayLibraryResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetVidyoReplayLibraryResponse), type))
		return soap->error;
	if (a->authToken)
		soap_element_result(soap, "ns1:authToken");
	if (!a->_ns1__GetVidyoReplayLibraryResponse::authToken)
	{	if (soap_element_nil(soap, "ns1:authToken"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:authToken", -1, (char*const*)&a->_ns1__GetVidyoReplayLibraryResponse::authToken, ""))
		return soap->error;
	if (!a->_ns1__GetVidyoReplayLibraryResponse::vidyoReplayLibraryUrl)
	{	if (soap_element_nil(soap, "ns1:vidyoReplayLibraryUrl"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:vidyoReplayLibraryUrl", -1, (char*const*)&a->_ns1__GetVidyoReplayLibraryResponse::vidyoReplayLibraryUrl, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetVidyoReplayLibraryResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetVidyoReplayLibraryResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetVidyoReplayLibraryResponse * SOAP_FMAC4 soap_in__ns1__GetVidyoReplayLibraryResponse(struct soap *soap, const char *tag, _ns1__GetVidyoReplayLibraryResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetVidyoReplayLibraryResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetVidyoReplayLibraryResponse, sizeof(_ns1__GetVidyoReplayLibraryResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_authToken1 = 1;
	size_t soap_flag_vidyoReplayLibraryUrl1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:authToken", (char**)&a->_ns1__GetVidyoReplayLibraryResponse::authToken, "xsd:string"))
				{	soap_flag_authToken1--;
					continue;
				}
			if (soap_flag_vidyoReplayLibraryUrl1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:vidyoReplayLibraryUrl", (char**)&a->_ns1__GetVidyoReplayLibraryResponse::vidyoReplayLibraryUrl, "xsd:string"))
				{	soap_flag_vidyoReplayLibraryUrl1--;
					continue;
				}
			soap_check_result(soap, "ns1:authToken");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_authToken1 > 0 || soap_flag_vidyoReplayLibraryUrl1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetVidyoReplayLibraryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetVidyoReplayLibraryResponse, SOAP_TYPE__ns1__GetVidyoReplayLibraryResponse, sizeof(_ns1__GetVidyoReplayLibraryResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetVidyoReplayLibraryResponse * SOAP_FMAC2 soap_instantiate__ns1__GetVidyoReplayLibraryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetVidyoReplayLibraryResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetVidyoReplayLibraryResponse *p;
	size_t k = sizeof(_ns1__GetVidyoReplayLibraryResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetVidyoReplayLibraryResponse);
		if (p)
			((_ns1__GetVidyoReplayLibraryResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetVidyoReplayLibraryResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetVidyoReplayLibraryResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetVidyoReplayLibraryResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetVidyoReplayLibraryResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetVidyoReplayLibraryResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:GetVidyoReplayLibraryResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetVidyoReplayLibraryResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetVidyoReplayLibraryResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetVidyoReplayLibraryResponse * SOAP_FMAC4 soap_get__ns1__GetVidyoReplayLibraryResponse(struct soap *soap, _ns1__GetVidyoReplayLibraryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetVidyoReplayLibraryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetVidyoReplayLibraryRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__GetVidyoReplayLibraryRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__GetVidyoReplayLibraryRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetVidyoReplayLibraryRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetVidyoReplayLibraryRequest(struct soap *soap, const char *tag, int id, const _ns1__GetVidyoReplayLibraryRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetVidyoReplayLibraryRequest), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetVidyoReplayLibraryRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetVidyoReplayLibraryRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetVidyoReplayLibraryRequest * SOAP_FMAC4 soap_in__ns1__GetVidyoReplayLibraryRequest(struct soap *soap, const char *tag, _ns1__GetVidyoReplayLibraryRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetVidyoReplayLibraryRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetVidyoReplayLibraryRequest, sizeof(_ns1__GetVidyoReplayLibraryRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetVidyoReplayLibraryRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetVidyoReplayLibraryRequest, SOAP_TYPE__ns1__GetVidyoReplayLibraryRequest, sizeof(_ns1__GetVidyoReplayLibraryRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetVidyoReplayLibraryRequest * SOAP_FMAC2 soap_instantiate__ns1__GetVidyoReplayLibraryRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetVidyoReplayLibraryRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetVidyoReplayLibraryRequest *p;
	size_t k = sizeof(_ns1__GetVidyoReplayLibraryRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetVidyoReplayLibraryRequest);
		if (p)
			((_ns1__GetVidyoReplayLibraryRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetVidyoReplayLibraryRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetVidyoReplayLibraryRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetVidyoReplayLibraryRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetVidyoReplayLibraryRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetVidyoReplayLibraryRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:GetVidyoReplayLibraryRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetVidyoReplayLibraryRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetVidyoReplayLibraryRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetVidyoReplayLibraryRequest * SOAP_FMAC4 soap_get__ns1__GetVidyoReplayLibraryRequest(struct soap *soap, _ns1__GetVidyoReplayLibraryRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetVidyoReplayLibraryRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__RemovePresenterResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__RemovePresenterResponse::OK);
	/* transient soap skipped */
}

void _ns1__RemovePresenterResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__RemovePresenterResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RemovePresenterResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RemovePresenterResponse(struct soap *soap, const char *tag, int id, const _ns1__RemovePresenterResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RemovePresenterResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__RemovePresenterResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__RemovePresenterResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RemovePresenterResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RemovePresenterResponse * SOAP_FMAC4 soap_in__ns1__RemovePresenterResponse(struct soap *soap, const char *tag, _ns1__RemovePresenterResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RemovePresenterResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RemovePresenterResponse, sizeof(_ns1__RemovePresenterResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__RemovePresenterResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__RemovePresenterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RemovePresenterResponse, SOAP_TYPE__ns1__RemovePresenterResponse, sizeof(_ns1__RemovePresenterResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__RemovePresenterResponse * SOAP_FMAC2 soap_instantiate__ns1__RemovePresenterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RemovePresenterResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__RemovePresenterResponse *p;
	size_t k = sizeof(_ns1__RemovePresenterResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__RemovePresenterResponse);
		if (p)
			((_ns1__RemovePresenterResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__RemovePresenterResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__RemovePresenterResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__RemovePresenterResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__RemovePresenterResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__RemovePresenterResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:RemovePresenterResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RemovePresenterResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RemovePresenterResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RemovePresenterResponse * SOAP_FMAC4 soap_get__ns1__RemovePresenterResponse(struct soap *soap, _ns1__RemovePresenterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RemovePresenterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__RemovePresenterRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__RemovePresenterRequest::conferenceID);
	soap_default_ns1__EntityID(soap, &this->_ns1__RemovePresenterRequest::participantID);
	soap_default_string(soap, &this->_ns1__RemovePresenterRequest::moderatorPIN);
	/* transient soap skipped */
}

void _ns1__RemovePresenterRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__RemovePresenterRequest::conferenceID);
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__RemovePresenterRequest::participantID);
	soap_serialize_string(soap, (char*const*)&this->_ns1__RemovePresenterRequest::moderatorPIN);
#endif
}

int _ns1__RemovePresenterRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RemovePresenterRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RemovePresenterRequest(struct soap *soap, const char *tag, int id, const _ns1__RemovePresenterRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RemovePresenterRequest), type))
		return soap->error;
	if (!a->_ns1__RemovePresenterRequest::conferenceID)
	{	if (soap_element_nil(soap, "ns1:conferenceID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:conferenceID", -1, (char*const*)&a->_ns1__RemovePresenterRequest::conferenceID, ""))
		return soap->error;
	if (!a->_ns1__RemovePresenterRequest::participantID)
	{	if (soap_element_nil(soap, "ns1:participantID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:participantID", -1, (char*const*)&a->_ns1__RemovePresenterRequest::participantID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:moderatorPIN", -1, (char*const*)&a->_ns1__RemovePresenterRequest::moderatorPIN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__RemovePresenterRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RemovePresenterRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RemovePresenterRequest * SOAP_FMAC4 soap_in__ns1__RemovePresenterRequest(struct soap *soap, const char *tag, _ns1__RemovePresenterRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RemovePresenterRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RemovePresenterRequest, sizeof(_ns1__RemovePresenterRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_conferenceID1 = 1;
	size_t soap_flag_participantID1 = 1;
	size_t soap_flag_moderatorPIN1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_conferenceID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:conferenceID", (char**)&a->_ns1__RemovePresenterRequest::conferenceID, "ns1:EntityID"))
				{	soap_flag_conferenceID1--;
					continue;
				}
			if (soap_flag_participantID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:participantID", (char**)&a->_ns1__RemovePresenterRequest::participantID, "ns1:EntityID"))
				{	soap_flag_participantID1--;
					continue;
				}
			if (soap_flag_moderatorPIN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:moderatorPIN", (char**)&a->_ns1__RemovePresenterRequest::moderatorPIN, "xsd:string"))
				{	soap_flag_moderatorPIN1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_conferenceID1 > 0 || soap_flag_participantID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__RemovePresenterRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RemovePresenterRequest, SOAP_TYPE__ns1__RemovePresenterRequest, sizeof(_ns1__RemovePresenterRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__RemovePresenterRequest * SOAP_FMAC2 soap_instantiate__ns1__RemovePresenterRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RemovePresenterRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__RemovePresenterRequest *p;
	size_t k = sizeof(_ns1__RemovePresenterRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__RemovePresenterRequest);
		if (p)
			((_ns1__RemovePresenterRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__RemovePresenterRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__RemovePresenterRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__RemovePresenterRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__RemovePresenterRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__RemovePresenterRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:RemovePresenterRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RemovePresenterRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RemovePresenterRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RemovePresenterRequest * SOAP_FMAC4 soap_get__ns1__RemovePresenterRequest(struct soap *soap, _ns1__RemovePresenterRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RemovePresenterRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SetPresenterResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__SetPresenterResponse::OK);
	/* transient soap skipped */
}

void _ns1__SetPresenterResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__SetPresenterResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetPresenterResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetPresenterResponse(struct soap *soap, const char *tag, int id, const _ns1__SetPresenterResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetPresenterResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__SetPresenterResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetPresenterResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetPresenterResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetPresenterResponse * SOAP_FMAC4 soap_in__ns1__SetPresenterResponse(struct soap *soap, const char *tag, _ns1__SetPresenterResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetPresenterResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetPresenterResponse, sizeof(_ns1__SetPresenterResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__SetPresenterResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__SetPresenterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetPresenterResponse, SOAP_TYPE__ns1__SetPresenterResponse, sizeof(_ns1__SetPresenterResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SetPresenterResponse * SOAP_FMAC2 soap_instantiate__ns1__SetPresenterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetPresenterResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SetPresenterResponse *p;
	size_t k = sizeof(_ns1__SetPresenterResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SetPresenterResponse);
		if (p)
			((_ns1__SetPresenterResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SetPresenterResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SetPresenterResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SetPresenterResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SetPresenterResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SetPresenterResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SetPresenterResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SetPresenterResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetPresenterResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetPresenterResponse * SOAP_FMAC4 soap_get__ns1__SetPresenterResponse(struct soap *soap, _ns1__SetPresenterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetPresenterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SetPresenterRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__SetPresenterRequest::conferenceID);
	soap_default_ns1__EntityID(soap, &this->_ns1__SetPresenterRequest::participantID);
	soap_default_string(soap, &this->_ns1__SetPresenterRequest::moderatorPIN);
	/* transient soap skipped */
}

void _ns1__SetPresenterRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__SetPresenterRequest::conferenceID);
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__SetPresenterRequest::participantID);
	soap_serialize_string(soap, (char*const*)&this->_ns1__SetPresenterRequest::moderatorPIN);
#endif
}

int _ns1__SetPresenterRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetPresenterRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetPresenterRequest(struct soap *soap, const char *tag, int id, const _ns1__SetPresenterRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetPresenterRequest), type))
		return soap->error;
	if (!a->_ns1__SetPresenterRequest::conferenceID)
	{	if (soap_element_nil(soap, "ns1:conferenceID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:conferenceID", -1, (char*const*)&a->_ns1__SetPresenterRequest::conferenceID, ""))
		return soap->error;
	if (!a->_ns1__SetPresenterRequest::participantID)
	{	if (soap_element_nil(soap, "ns1:participantID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:participantID", -1, (char*const*)&a->_ns1__SetPresenterRequest::participantID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:moderatorPIN", -1, (char*const*)&a->_ns1__SetPresenterRequest::moderatorPIN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetPresenterRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetPresenterRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetPresenterRequest * SOAP_FMAC4 soap_in__ns1__SetPresenterRequest(struct soap *soap, const char *tag, _ns1__SetPresenterRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetPresenterRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetPresenterRequest, sizeof(_ns1__SetPresenterRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_conferenceID1 = 1;
	size_t soap_flag_participantID1 = 1;
	size_t soap_flag_moderatorPIN1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_conferenceID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:conferenceID", (char**)&a->_ns1__SetPresenterRequest::conferenceID, "ns1:EntityID"))
				{	soap_flag_conferenceID1--;
					continue;
				}
			if (soap_flag_participantID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:participantID", (char**)&a->_ns1__SetPresenterRequest::participantID, "ns1:EntityID"))
				{	soap_flag_participantID1--;
					continue;
				}
			if (soap_flag_moderatorPIN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:moderatorPIN", (char**)&a->_ns1__SetPresenterRequest::moderatorPIN, "xsd:string"))
				{	soap_flag_moderatorPIN1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_conferenceID1 > 0 || soap_flag_participantID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__SetPresenterRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetPresenterRequest, SOAP_TYPE__ns1__SetPresenterRequest, sizeof(_ns1__SetPresenterRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SetPresenterRequest * SOAP_FMAC2 soap_instantiate__ns1__SetPresenterRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetPresenterRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SetPresenterRequest *p;
	size_t k = sizeof(_ns1__SetPresenterRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SetPresenterRequest);
		if (p)
			((_ns1__SetPresenterRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SetPresenterRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SetPresenterRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SetPresenterRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SetPresenterRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SetPresenterRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SetPresenterRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SetPresenterRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetPresenterRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetPresenterRequest * SOAP_FMAC4 soap_get__ns1__SetPresenterRequest(struct soap *soap, _ns1__SetPresenterRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetPresenterRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__DismissAllRaisedHandResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__DismissAllRaisedHandResponse::OK);
	/* transient soap skipped */
}

void _ns1__DismissAllRaisedHandResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__DismissAllRaisedHandResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DismissAllRaisedHandResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DismissAllRaisedHandResponse(struct soap *soap, const char *tag, int id, const _ns1__DismissAllRaisedHandResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DismissAllRaisedHandResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__DismissAllRaisedHandResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__DismissAllRaisedHandResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DismissAllRaisedHandResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DismissAllRaisedHandResponse * SOAP_FMAC4 soap_in__ns1__DismissAllRaisedHandResponse(struct soap *soap, const char *tag, _ns1__DismissAllRaisedHandResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DismissAllRaisedHandResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DismissAllRaisedHandResponse, sizeof(_ns1__DismissAllRaisedHandResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__DismissAllRaisedHandResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__DismissAllRaisedHandResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DismissAllRaisedHandResponse, SOAP_TYPE__ns1__DismissAllRaisedHandResponse, sizeof(_ns1__DismissAllRaisedHandResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__DismissAllRaisedHandResponse * SOAP_FMAC2 soap_instantiate__ns1__DismissAllRaisedHandResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DismissAllRaisedHandResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__DismissAllRaisedHandResponse *p;
	size_t k = sizeof(_ns1__DismissAllRaisedHandResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__DismissAllRaisedHandResponse);
		if (p)
			((_ns1__DismissAllRaisedHandResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__DismissAllRaisedHandResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__DismissAllRaisedHandResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__DismissAllRaisedHandResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__DismissAllRaisedHandResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__DismissAllRaisedHandResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:DismissAllRaisedHandResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DismissAllRaisedHandResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DismissAllRaisedHandResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DismissAllRaisedHandResponse * SOAP_FMAC4 soap_get__ns1__DismissAllRaisedHandResponse(struct soap *soap, _ns1__DismissAllRaisedHandResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DismissAllRaisedHandResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__DismissAllRaisedHandRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__DismissAllRaisedHandRequest::conferenceID);
	soap_default_string(soap, &this->_ns1__DismissAllRaisedHandRequest::moderatorPIN);
	/* transient soap skipped */
}

void _ns1__DismissAllRaisedHandRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__DismissAllRaisedHandRequest::conferenceID);
	soap_serialize_string(soap, (char*const*)&this->_ns1__DismissAllRaisedHandRequest::moderatorPIN);
#endif
}

int _ns1__DismissAllRaisedHandRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DismissAllRaisedHandRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DismissAllRaisedHandRequest(struct soap *soap, const char *tag, int id, const _ns1__DismissAllRaisedHandRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DismissAllRaisedHandRequest), type))
		return soap->error;
	if (!a->_ns1__DismissAllRaisedHandRequest::conferenceID)
	{	if (soap_element_nil(soap, "ns1:conferenceID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:conferenceID", -1, (char*const*)&a->_ns1__DismissAllRaisedHandRequest::conferenceID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:moderatorPIN", -1, (char*const*)&a->_ns1__DismissAllRaisedHandRequest::moderatorPIN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__DismissAllRaisedHandRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DismissAllRaisedHandRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DismissAllRaisedHandRequest * SOAP_FMAC4 soap_in__ns1__DismissAllRaisedHandRequest(struct soap *soap, const char *tag, _ns1__DismissAllRaisedHandRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DismissAllRaisedHandRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DismissAllRaisedHandRequest, sizeof(_ns1__DismissAllRaisedHandRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_conferenceID1 = 1;
	size_t soap_flag_moderatorPIN1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_conferenceID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:conferenceID", (char**)&a->_ns1__DismissAllRaisedHandRequest::conferenceID, "ns1:EntityID"))
				{	soap_flag_conferenceID1--;
					continue;
				}
			if (soap_flag_moderatorPIN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:moderatorPIN", (char**)&a->_ns1__DismissAllRaisedHandRequest::moderatorPIN, "xsd:string"))
				{	soap_flag_moderatorPIN1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_conferenceID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__DismissAllRaisedHandRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DismissAllRaisedHandRequest, SOAP_TYPE__ns1__DismissAllRaisedHandRequest, sizeof(_ns1__DismissAllRaisedHandRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__DismissAllRaisedHandRequest * SOAP_FMAC2 soap_instantiate__ns1__DismissAllRaisedHandRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DismissAllRaisedHandRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__DismissAllRaisedHandRequest *p;
	size_t k = sizeof(_ns1__DismissAllRaisedHandRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__DismissAllRaisedHandRequest);
		if (p)
			((_ns1__DismissAllRaisedHandRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__DismissAllRaisedHandRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__DismissAllRaisedHandRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__DismissAllRaisedHandRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__DismissAllRaisedHandRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__DismissAllRaisedHandRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:DismissAllRaisedHandRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DismissAllRaisedHandRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DismissAllRaisedHandRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DismissAllRaisedHandRequest * SOAP_FMAC4 soap_get__ns1__DismissAllRaisedHandRequest(struct soap *soap, _ns1__DismissAllRaisedHandRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DismissAllRaisedHandRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__DismissRaisedHandResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__DismissRaisedHandResponse::OK);
	/* transient soap skipped */
}

void _ns1__DismissRaisedHandResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__DismissRaisedHandResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DismissRaisedHandResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DismissRaisedHandResponse(struct soap *soap, const char *tag, int id, const _ns1__DismissRaisedHandResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DismissRaisedHandResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__DismissRaisedHandResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__DismissRaisedHandResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DismissRaisedHandResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DismissRaisedHandResponse * SOAP_FMAC4 soap_in__ns1__DismissRaisedHandResponse(struct soap *soap, const char *tag, _ns1__DismissRaisedHandResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DismissRaisedHandResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DismissRaisedHandResponse, sizeof(_ns1__DismissRaisedHandResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__DismissRaisedHandResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__DismissRaisedHandResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DismissRaisedHandResponse, SOAP_TYPE__ns1__DismissRaisedHandResponse, sizeof(_ns1__DismissRaisedHandResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__DismissRaisedHandResponse * SOAP_FMAC2 soap_instantiate__ns1__DismissRaisedHandResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DismissRaisedHandResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__DismissRaisedHandResponse *p;
	size_t k = sizeof(_ns1__DismissRaisedHandResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__DismissRaisedHandResponse);
		if (p)
			((_ns1__DismissRaisedHandResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__DismissRaisedHandResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__DismissRaisedHandResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__DismissRaisedHandResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__DismissRaisedHandResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__DismissRaisedHandResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:DismissRaisedHandResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DismissRaisedHandResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DismissRaisedHandResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DismissRaisedHandResponse * SOAP_FMAC4 soap_get__ns1__DismissRaisedHandResponse(struct soap *soap, _ns1__DismissRaisedHandResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DismissRaisedHandResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__DismissRaisedHandRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__DismissRaisedHandRequest::conferenceID);
	soap_default_ns1__EntityID(soap, &this->_ns1__DismissRaisedHandRequest::participantID);
	soap_default_string(soap, &this->_ns1__DismissRaisedHandRequest::moderatorPIN);
	/* transient soap skipped */
}

void _ns1__DismissRaisedHandRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__DismissRaisedHandRequest::conferenceID);
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__DismissRaisedHandRequest::participantID);
	soap_serialize_string(soap, (char*const*)&this->_ns1__DismissRaisedHandRequest::moderatorPIN);
#endif
}

int _ns1__DismissRaisedHandRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DismissRaisedHandRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DismissRaisedHandRequest(struct soap *soap, const char *tag, int id, const _ns1__DismissRaisedHandRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DismissRaisedHandRequest), type))
		return soap->error;
	if (!a->_ns1__DismissRaisedHandRequest::conferenceID)
	{	if (soap_element_nil(soap, "ns1:conferenceID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:conferenceID", -1, (char*const*)&a->_ns1__DismissRaisedHandRequest::conferenceID, ""))
		return soap->error;
	if (!a->_ns1__DismissRaisedHandRequest::participantID)
	{	if (soap_element_nil(soap, "ns1:participantID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:participantID", -1, (char*const*)&a->_ns1__DismissRaisedHandRequest::participantID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:moderatorPIN", -1, (char*const*)&a->_ns1__DismissRaisedHandRequest::moderatorPIN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__DismissRaisedHandRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DismissRaisedHandRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DismissRaisedHandRequest * SOAP_FMAC4 soap_in__ns1__DismissRaisedHandRequest(struct soap *soap, const char *tag, _ns1__DismissRaisedHandRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DismissRaisedHandRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DismissRaisedHandRequest, sizeof(_ns1__DismissRaisedHandRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_conferenceID1 = 1;
	size_t soap_flag_participantID1 = 1;
	size_t soap_flag_moderatorPIN1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_conferenceID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:conferenceID", (char**)&a->_ns1__DismissRaisedHandRequest::conferenceID, "ns1:EntityID"))
				{	soap_flag_conferenceID1--;
					continue;
				}
			if (soap_flag_participantID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:participantID", (char**)&a->_ns1__DismissRaisedHandRequest::participantID, "ns1:EntityID"))
				{	soap_flag_participantID1--;
					continue;
				}
			if (soap_flag_moderatorPIN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:moderatorPIN", (char**)&a->_ns1__DismissRaisedHandRequest::moderatorPIN, "xsd:string"))
				{	soap_flag_moderatorPIN1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_conferenceID1 > 0 || soap_flag_participantID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__DismissRaisedHandRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DismissRaisedHandRequest, SOAP_TYPE__ns1__DismissRaisedHandRequest, sizeof(_ns1__DismissRaisedHandRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__DismissRaisedHandRequest * SOAP_FMAC2 soap_instantiate__ns1__DismissRaisedHandRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DismissRaisedHandRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__DismissRaisedHandRequest *p;
	size_t k = sizeof(_ns1__DismissRaisedHandRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__DismissRaisedHandRequest);
		if (p)
			((_ns1__DismissRaisedHandRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__DismissRaisedHandRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__DismissRaisedHandRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__DismissRaisedHandRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__DismissRaisedHandRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__DismissRaisedHandRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:DismissRaisedHandRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DismissRaisedHandRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DismissRaisedHandRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DismissRaisedHandRequest * SOAP_FMAC4 soap_get__ns1__DismissRaisedHandRequest(struct soap *soap, _ns1__DismissRaisedHandRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DismissRaisedHandRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__UnraiseHandResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__UnraiseHandResponse::OK);
	/* transient soap skipped */
}

void _ns1__UnraiseHandResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__UnraiseHandResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UnraiseHandResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UnraiseHandResponse(struct soap *soap, const char *tag, int id, const _ns1__UnraiseHandResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UnraiseHandResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__UnraiseHandResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__UnraiseHandResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UnraiseHandResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UnraiseHandResponse * SOAP_FMAC4 soap_in__ns1__UnraiseHandResponse(struct soap *soap, const char *tag, _ns1__UnraiseHandResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UnraiseHandResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UnraiseHandResponse, sizeof(_ns1__UnraiseHandResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__UnraiseHandResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__UnraiseHandResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UnraiseHandResponse, SOAP_TYPE__ns1__UnraiseHandResponse, sizeof(_ns1__UnraiseHandResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__UnraiseHandResponse * SOAP_FMAC2 soap_instantiate__ns1__UnraiseHandResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UnraiseHandResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__UnraiseHandResponse *p;
	size_t k = sizeof(_ns1__UnraiseHandResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__UnraiseHandResponse);
		if (p)
			((_ns1__UnraiseHandResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__UnraiseHandResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__UnraiseHandResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__UnraiseHandResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__UnraiseHandResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__UnraiseHandResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:UnraiseHandResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UnraiseHandResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UnraiseHandResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UnraiseHandResponse * SOAP_FMAC4 soap_get__ns1__UnraiseHandResponse(struct soap *soap, _ns1__UnraiseHandResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UnraiseHandResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__RaiseHandResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__RaiseHandResponse::OK);
	/* transient soap skipped */
}

void _ns1__RaiseHandResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__RaiseHandResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RaiseHandResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RaiseHandResponse(struct soap *soap, const char *tag, int id, const _ns1__RaiseHandResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RaiseHandResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__RaiseHandResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__RaiseHandResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RaiseHandResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RaiseHandResponse * SOAP_FMAC4 soap_in__ns1__RaiseHandResponse(struct soap *soap, const char *tag, _ns1__RaiseHandResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RaiseHandResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RaiseHandResponse, sizeof(_ns1__RaiseHandResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__RaiseHandResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__RaiseHandResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RaiseHandResponse, SOAP_TYPE__ns1__RaiseHandResponse, sizeof(_ns1__RaiseHandResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__RaiseHandResponse * SOAP_FMAC2 soap_instantiate__ns1__RaiseHandResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RaiseHandResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__RaiseHandResponse *p;
	size_t k = sizeof(_ns1__RaiseHandResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__RaiseHandResponse);
		if (p)
			((_ns1__RaiseHandResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__RaiseHandResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__RaiseHandResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__RaiseHandResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__RaiseHandResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__RaiseHandResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:RaiseHandResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RaiseHandResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RaiseHandResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RaiseHandResponse * SOAP_FMAC4 soap_get__ns1__RaiseHandResponse(struct soap *soap, _ns1__RaiseHandResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RaiseHandResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__StopLectureModeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__StopLectureModeResponse::OK);
	/* transient soap skipped */
}

void _ns1__StopLectureModeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__StopLectureModeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__StopLectureModeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__StopLectureModeResponse(struct soap *soap, const char *tag, int id, const _ns1__StopLectureModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__StopLectureModeResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__StopLectureModeResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__StopLectureModeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__StopLectureModeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__StopLectureModeResponse * SOAP_FMAC4 soap_in__ns1__StopLectureModeResponse(struct soap *soap, const char *tag, _ns1__StopLectureModeResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__StopLectureModeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__StopLectureModeResponse, sizeof(_ns1__StopLectureModeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__StopLectureModeResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__StopLectureModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__StopLectureModeResponse, SOAP_TYPE__ns1__StopLectureModeResponse, sizeof(_ns1__StopLectureModeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__StopLectureModeResponse * SOAP_FMAC2 soap_instantiate__ns1__StopLectureModeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__StopLectureModeResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__StopLectureModeResponse *p;
	size_t k = sizeof(_ns1__StopLectureModeResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__StopLectureModeResponse);
		if (p)
			((_ns1__StopLectureModeResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__StopLectureModeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__StopLectureModeResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__StopLectureModeResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__StopLectureModeResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__StopLectureModeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:StopLectureModeResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__StopLectureModeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__StopLectureModeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__StopLectureModeResponse * SOAP_FMAC4 soap_get__ns1__StopLectureModeResponse(struct soap *soap, _ns1__StopLectureModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__StopLectureModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__StopLectureModeRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__StopLectureModeRequest::conferenceID);
	soap_default_string(soap, &this->_ns1__StopLectureModeRequest::moderatorPIN);
	/* transient soap skipped */
}

void _ns1__StopLectureModeRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__StopLectureModeRequest::conferenceID);
	soap_serialize_string(soap, (char*const*)&this->_ns1__StopLectureModeRequest::moderatorPIN);
#endif
}

int _ns1__StopLectureModeRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__StopLectureModeRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__StopLectureModeRequest(struct soap *soap, const char *tag, int id, const _ns1__StopLectureModeRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__StopLectureModeRequest), type))
		return soap->error;
	if (!a->_ns1__StopLectureModeRequest::conferenceID)
	{	if (soap_element_nil(soap, "ns1:conferenceID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:conferenceID", -1, (char*const*)&a->_ns1__StopLectureModeRequest::conferenceID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:moderatorPIN", -1, (char*const*)&a->_ns1__StopLectureModeRequest::moderatorPIN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__StopLectureModeRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__StopLectureModeRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__StopLectureModeRequest * SOAP_FMAC4 soap_in__ns1__StopLectureModeRequest(struct soap *soap, const char *tag, _ns1__StopLectureModeRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__StopLectureModeRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__StopLectureModeRequest, sizeof(_ns1__StopLectureModeRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_conferenceID1 = 1;
	size_t soap_flag_moderatorPIN1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_conferenceID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:conferenceID", (char**)&a->_ns1__StopLectureModeRequest::conferenceID, "ns1:EntityID"))
				{	soap_flag_conferenceID1--;
					continue;
				}
			if (soap_flag_moderatorPIN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:moderatorPIN", (char**)&a->_ns1__StopLectureModeRequest::moderatorPIN, "xsd:string"))
				{	soap_flag_moderatorPIN1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_conferenceID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__StopLectureModeRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__StopLectureModeRequest, SOAP_TYPE__ns1__StopLectureModeRequest, sizeof(_ns1__StopLectureModeRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__StopLectureModeRequest * SOAP_FMAC2 soap_instantiate__ns1__StopLectureModeRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__StopLectureModeRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__StopLectureModeRequest *p;
	size_t k = sizeof(_ns1__StopLectureModeRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__StopLectureModeRequest);
		if (p)
			((_ns1__StopLectureModeRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__StopLectureModeRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__StopLectureModeRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__StopLectureModeRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__StopLectureModeRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__StopLectureModeRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:StopLectureModeRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__StopLectureModeRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__StopLectureModeRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__StopLectureModeRequest * SOAP_FMAC4 soap_get__ns1__StopLectureModeRequest(struct soap *soap, _ns1__StopLectureModeRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__StopLectureModeRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__StartLectureModeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__StartLectureModeResponse::OK);
	/* transient soap skipped */
}

void _ns1__StartLectureModeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__StartLectureModeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__StartLectureModeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__StartLectureModeResponse(struct soap *soap, const char *tag, int id, const _ns1__StartLectureModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__StartLectureModeResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__StartLectureModeResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__StartLectureModeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__StartLectureModeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__StartLectureModeResponse * SOAP_FMAC4 soap_in__ns1__StartLectureModeResponse(struct soap *soap, const char *tag, _ns1__StartLectureModeResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__StartLectureModeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__StartLectureModeResponse, sizeof(_ns1__StartLectureModeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__StartLectureModeResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__StartLectureModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__StartLectureModeResponse, SOAP_TYPE__ns1__StartLectureModeResponse, sizeof(_ns1__StartLectureModeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__StartLectureModeResponse * SOAP_FMAC2 soap_instantiate__ns1__StartLectureModeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__StartLectureModeResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__StartLectureModeResponse *p;
	size_t k = sizeof(_ns1__StartLectureModeResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__StartLectureModeResponse);
		if (p)
			((_ns1__StartLectureModeResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__StartLectureModeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__StartLectureModeResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__StartLectureModeResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__StartLectureModeResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__StartLectureModeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:StartLectureModeResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__StartLectureModeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__StartLectureModeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__StartLectureModeResponse * SOAP_FMAC4 soap_get__ns1__StartLectureModeResponse(struct soap *soap, _ns1__StartLectureModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__StartLectureModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__StartLectureModeRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__StartLectureModeRequest::conferenceID);
	soap_default_string(soap, &this->_ns1__StartLectureModeRequest::moderatorPIN);
	/* transient soap skipped */
}

void _ns1__StartLectureModeRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__StartLectureModeRequest::conferenceID);
	soap_serialize_string(soap, (char*const*)&this->_ns1__StartLectureModeRequest::moderatorPIN);
#endif
}

int _ns1__StartLectureModeRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__StartLectureModeRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__StartLectureModeRequest(struct soap *soap, const char *tag, int id, const _ns1__StartLectureModeRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__StartLectureModeRequest), type))
		return soap->error;
	if (!a->_ns1__StartLectureModeRequest::conferenceID)
	{	if (soap_element_nil(soap, "ns1:conferenceID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:conferenceID", -1, (char*const*)&a->_ns1__StartLectureModeRequest::conferenceID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:moderatorPIN", -1, (char*const*)&a->_ns1__StartLectureModeRequest::moderatorPIN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__StartLectureModeRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__StartLectureModeRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__StartLectureModeRequest * SOAP_FMAC4 soap_in__ns1__StartLectureModeRequest(struct soap *soap, const char *tag, _ns1__StartLectureModeRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__StartLectureModeRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__StartLectureModeRequest, sizeof(_ns1__StartLectureModeRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_conferenceID1 = 1;
	size_t soap_flag_moderatorPIN1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_conferenceID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:conferenceID", (char**)&a->_ns1__StartLectureModeRequest::conferenceID, "ns1:EntityID"))
				{	soap_flag_conferenceID1--;
					continue;
				}
			if (soap_flag_moderatorPIN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:moderatorPIN", (char**)&a->_ns1__StartLectureModeRequest::moderatorPIN, "xsd:string"))
				{	soap_flag_moderatorPIN1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_conferenceID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__StartLectureModeRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__StartLectureModeRequest, SOAP_TYPE__ns1__StartLectureModeRequest, sizeof(_ns1__StartLectureModeRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__StartLectureModeRequest * SOAP_FMAC2 soap_instantiate__ns1__StartLectureModeRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__StartLectureModeRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__StartLectureModeRequest *p;
	size_t k = sizeof(_ns1__StartLectureModeRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__StartLectureModeRequest);
		if (p)
			((_ns1__StartLectureModeRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__StartLectureModeRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__StartLectureModeRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__StartLectureModeRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__StartLectureModeRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__StartLectureModeRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:StartLectureModeRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__StartLectureModeRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__StartLectureModeRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__StartLectureModeRequest * SOAP_FMAC4 soap_get__ns1__StartLectureModeRequest(struct soap *soap, _ns1__StartLectureModeRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__StartLectureModeRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getUserAccountTypeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__getUserAccountTypeResponse::userAccountType);
	/* transient soap skipped */
}

void _ns1__getUserAccountTypeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__getUserAccountTypeResponse::userAccountType);
#endif
}

int _ns1__getUserAccountTypeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getUserAccountTypeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getUserAccountTypeResponse(struct soap *soap, const char *tag, int id, const _ns1__getUserAccountTypeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getUserAccountTypeResponse), type))
		return soap->error;
	if (a->userAccountType)
		soap_element_result(soap, "ns1:userAccountType");
	if (!a->_ns1__getUserAccountTypeResponse::userAccountType)
	{	if (soap_element_nil(soap, "ns1:userAccountType"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:userAccountType", -1, (char*const*)&a->_ns1__getUserAccountTypeResponse::userAccountType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getUserAccountTypeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getUserAccountTypeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getUserAccountTypeResponse * SOAP_FMAC4 soap_in__ns1__getUserAccountTypeResponse(struct soap *soap, const char *tag, _ns1__getUserAccountTypeResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getUserAccountTypeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getUserAccountTypeResponse, sizeof(_ns1__getUserAccountTypeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_userAccountType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userAccountType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:userAccountType", (char**)&a->_ns1__getUserAccountTypeResponse::userAccountType, "xsd:string"))
				{	soap_flag_userAccountType1--;
					continue;
				}
			soap_check_result(soap, "ns1:userAccountType");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_userAccountType1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__getUserAccountTypeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getUserAccountTypeResponse, SOAP_TYPE__ns1__getUserAccountTypeResponse, sizeof(_ns1__getUserAccountTypeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getUserAccountTypeResponse * SOAP_FMAC2 soap_instantiate__ns1__getUserAccountTypeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getUserAccountTypeResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getUserAccountTypeResponse *p;
	size_t k = sizeof(_ns1__getUserAccountTypeResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getUserAccountTypeResponse);
		if (p)
			((_ns1__getUserAccountTypeResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getUserAccountTypeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getUserAccountTypeResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getUserAccountTypeResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getUserAccountTypeResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getUserAccountTypeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:getUserAccountTypeResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getUserAccountTypeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getUserAccountTypeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getUserAccountTypeResponse * SOAP_FMAC4 soap_get__ns1__getUserAccountTypeResponse(struct soap *soap, _ns1__getUserAccountTypeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getUserAccountTypeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getUserAccountTypeRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__getUserAccountTypeRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__getUserAccountTypeRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getUserAccountTypeRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getUserAccountTypeRequest(struct soap *soap, const char *tag, int id, const _ns1__getUserAccountTypeRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getUserAccountTypeRequest), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getUserAccountTypeRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getUserAccountTypeRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getUserAccountTypeRequest * SOAP_FMAC4 soap_in__ns1__getUserAccountTypeRequest(struct soap *soap, const char *tag, _ns1__getUserAccountTypeRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getUserAccountTypeRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getUserAccountTypeRequest, sizeof(_ns1__getUserAccountTypeRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getUserAccountTypeRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getUserAccountTypeRequest, SOAP_TYPE__ns1__getUserAccountTypeRequest, sizeof(_ns1__getUserAccountTypeRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getUserAccountTypeRequest * SOAP_FMAC2 soap_instantiate__ns1__getUserAccountTypeRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getUserAccountTypeRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getUserAccountTypeRequest *p;
	size_t k = sizeof(_ns1__getUserAccountTypeRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getUserAccountTypeRequest);
		if (p)
			((_ns1__getUserAccountTypeRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getUserAccountTypeRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getUserAccountTypeRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getUserAccountTypeRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getUserAccountTypeRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getUserAccountTypeRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:getUserAccountTypeRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getUserAccountTypeRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getUserAccountTypeRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getUserAccountTypeRequest * SOAP_FMAC4 soap_get__ns1__getUserAccountTypeRequest(struct soap *soap, _ns1__getUserAccountTypeRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getUserAccountTypeRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getLoginAndWelcomeBannerResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__getLoginAndWelcomeBannerResponse::loginBannerText);
	this->_ns1__getLoginAndWelcomeBannerResponse::WelcomeBannerContent = NULL;
	/* transient soap skipped */
}

void _ns1__getLoginAndWelcomeBannerResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__getLoginAndWelcomeBannerResponse::loginBannerText);
	soap_serialize_PointerTo_ns1__WelcomeBannerContent(soap, &this->_ns1__getLoginAndWelcomeBannerResponse::WelcomeBannerContent);
#endif
}

int _ns1__getLoginAndWelcomeBannerResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getLoginAndWelcomeBannerResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getLoginAndWelcomeBannerResponse(struct soap *soap, const char *tag, int id, const _ns1__getLoginAndWelcomeBannerResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getLoginAndWelcomeBannerResponse), type))
		return soap->error;
	if (a->loginBannerText)
		soap_element_result(soap, "ns1:loginBannerText");
	if (soap_out_string(soap, "ns1:loginBannerText", -1, (char*const*)&a->_ns1__getLoginAndWelcomeBannerResponse::loginBannerText, ""))
		return soap->error;
	if (soap_out_PointerTo_ns1__WelcomeBannerContent(soap, "ns1:WelcomeBannerContent", -1, &a->_ns1__getLoginAndWelcomeBannerResponse::WelcomeBannerContent, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getLoginAndWelcomeBannerResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getLoginAndWelcomeBannerResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getLoginAndWelcomeBannerResponse * SOAP_FMAC4 soap_in__ns1__getLoginAndWelcomeBannerResponse(struct soap *soap, const char *tag, _ns1__getLoginAndWelcomeBannerResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getLoginAndWelcomeBannerResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getLoginAndWelcomeBannerResponse, sizeof(_ns1__getLoginAndWelcomeBannerResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_loginBannerText1 = 1;
	size_t soap_flag_WelcomeBannerContent1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_loginBannerText1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:loginBannerText", (char**)&a->_ns1__getLoginAndWelcomeBannerResponse::loginBannerText, "xsd:string"))
				{	soap_flag_loginBannerText1--;
					continue;
				}
			if (soap_flag_WelcomeBannerContent1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__WelcomeBannerContent(soap, "ns1:WelcomeBannerContent", &a->_ns1__getLoginAndWelcomeBannerResponse::WelcomeBannerContent, ""))
				{	soap_flag_WelcomeBannerContent1--;
					continue;
				}
			soap_check_result(soap, "ns1:loginBannerText");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getLoginAndWelcomeBannerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getLoginAndWelcomeBannerResponse, SOAP_TYPE__ns1__getLoginAndWelcomeBannerResponse, sizeof(_ns1__getLoginAndWelcomeBannerResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getLoginAndWelcomeBannerResponse * SOAP_FMAC2 soap_instantiate__ns1__getLoginAndWelcomeBannerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getLoginAndWelcomeBannerResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getLoginAndWelcomeBannerResponse *p;
	size_t k = sizeof(_ns1__getLoginAndWelcomeBannerResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getLoginAndWelcomeBannerResponse);
		if (p)
			((_ns1__getLoginAndWelcomeBannerResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getLoginAndWelcomeBannerResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getLoginAndWelcomeBannerResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getLoginAndWelcomeBannerResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getLoginAndWelcomeBannerResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getLoginAndWelcomeBannerResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:getLoginAndWelcomeBannerResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getLoginAndWelcomeBannerResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getLoginAndWelcomeBannerResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getLoginAndWelcomeBannerResponse * SOAP_FMAC4 soap_get__ns1__getLoginAndWelcomeBannerResponse(struct soap *soap, _ns1__getLoginAndWelcomeBannerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getLoginAndWelcomeBannerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__getLoginAndWelcomeBannerRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__getLoginAndWelcomeBannerRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__getLoginAndWelcomeBannerRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__getLoginAndWelcomeBannerRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getLoginAndWelcomeBannerRequest(struct soap *soap, const char *tag, int id, const _ns1__getLoginAndWelcomeBannerRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__getLoginAndWelcomeBannerRequest), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__getLoginAndWelcomeBannerRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__getLoginAndWelcomeBannerRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__getLoginAndWelcomeBannerRequest * SOAP_FMAC4 soap_in__ns1__getLoginAndWelcomeBannerRequest(struct soap *soap, const char *tag, _ns1__getLoginAndWelcomeBannerRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__getLoginAndWelcomeBannerRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__getLoginAndWelcomeBannerRequest, sizeof(_ns1__getLoginAndWelcomeBannerRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__getLoginAndWelcomeBannerRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__getLoginAndWelcomeBannerRequest, SOAP_TYPE__ns1__getLoginAndWelcomeBannerRequest, sizeof(_ns1__getLoginAndWelcomeBannerRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__getLoginAndWelcomeBannerRequest * SOAP_FMAC2 soap_instantiate__ns1__getLoginAndWelcomeBannerRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__getLoginAndWelcomeBannerRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__getLoginAndWelcomeBannerRequest *p;
	size_t k = sizeof(_ns1__getLoginAndWelcomeBannerRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__getLoginAndWelcomeBannerRequest);
		if (p)
			((_ns1__getLoginAndWelcomeBannerRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__getLoginAndWelcomeBannerRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__getLoginAndWelcomeBannerRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__getLoginAndWelcomeBannerRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__getLoginAndWelcomeBannerRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__getLoginAndWelcomeBannerRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:getLoginAndWelcomeBannerRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__getLoginAndWelcomeBannerRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__getLoginAndWelcomeBannerRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__getLoginAndWelcomeBannerRequest * SOAP_FMAC4 soap_get__ns1__getLoginAndWelcomeBannerRequest(struct soap *soap, _ns1__getLoginAndWelcomeBannerRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__getLoginAndWelcomeBannerRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__PrefixNotConfiguredFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__PrefixNotConfiguredFault::ErrorMessage);
	/* transient soap skipped */
}

void _ns1__PrefixNotConfiguredFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__PrefixNotConfiguredFault::ErrorMessage);
#endif
}

int _ns1__PrefixNotConfiguredFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__PrefixNotConfiguredFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__PrefixNotConfiguredFault(struct soap *soap, const char *tag, int id, const _ns1__PrefixNotConfiguredFault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__PrefixNotConfiguredFault), type))
		return soap->error;
	if (!a->_ns1__PrefixNotConfiguredFault::ErrorMessage)
	{	if (soap_element_nil(soap, "ns1:ErrorMessage"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:ErrorMessage", -1, (char*const*)&a->_ns1__PrefixNotConfiguredFault::ErrorMessage, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__PrefixNotConfiguredFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__PrefixNotConfiguredFault(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__PrefixNotConfiguredFault * SOAP_FMAC4 soap_in__ns1__PrefixNotConfiguredFault(struct soap *soap, const char *tag, _ns1__PrefixNotConfiguredFault *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__PrefixNotConfiguredFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__PrefixNotConfiguredFault, sizeof(_ns1__PrefixNotConfiguredFault), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ErrorMessage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ErrorMessage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ErrorMessage", (char**)&a->_ns1__PrefixNotConfiguredFault::ErrorMessage, "xsd:string"))
				{	soap_flag_ErrorMessage1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ErrorMessage1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__PrefixNotConfiguredFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__PrefixNotConfiguredFault, SOAP_TYPE__ns1__PrefixNotConfiguredFault, sizeof(_ns1__PrefixNotConfiguredFault), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__PrefixNotConfiguredFault * SOAP_FMAC2 soap_instantiate__ns1__PrefixNotConfiguredFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__PrefixNotConfiguredFault(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__PrefixNotConfiguredFault *p;
	size_t k = sizeof(_ns1__PrefixNotConfiguredFault);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__PrefixNotConfiguredFault);
		if (p)
			((_ns1__PrefixNotConfiguredFault*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__PrefixNotConfiguredFault, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__PrefixNotConfiguredFault*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__PrefixNotConfiguredFault location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__PrefixNotConfiguredFault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__PrefixNotConfiguredFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:PrefixNotConfiguredFault", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__PrefixNotConfiguredFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__PrefixNotConfiguredFault(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__PrefixNotConfiguredFault * SOAP_FMAC4 soap_get__ns1__PrefixNotConfiguredFault(struct soap *soap, _ns1__PrefixNotConfiguredFault *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__PrefixNotConfiguredFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__PortalPrefixResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__PortalPrefixResponse::portalPrefix);
	/* transient soap skipped */
}

void _ns1__PortalPrefixResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__PortalPrefixResponse::portalPrefix);
#endif
}

int _ns1__PortalPrefixResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__PortalPrefixResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__PortalPrefixResponse(struct soap *soap, const char *tag, int id, const _ns1__PortalPrefixResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__PortalPrefixResponse), type))
		return soap->error;
	if (a->portalPrefix)
		soap_element_result(soap, "ns1:portalPrefix");
	if (!a->_ns1__PortalPrefixResponse::portalPrefix)
	{	if (soap_element_nil(soap, "ns1:portalPrefix"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:portalPrefix", -1, (char*const*)&a->_ns1__PortalPrefixResponse::portalPrefix, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__PortalPrefixResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__PortalPrefixResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__PortalPrefixResponse * SOAP_FMAC4 soap_in__ns1__PortalPrefixResponse(struct soap *soap, const char *tag, _ns1__PortalPrefixResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__PortalPrefixResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__PortalPrefixResponse, sizeof(_ns1__PortalPrefixResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_portalPrefix1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_portalPrefix1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:portalPrefix", (char**)&a->_ns1__PortalPrefixResponse::portalPrefix, "xsd:string"))
				{	soap_flag_portalPrefix1--;
					continue;
				}
			soap_check_result(soap, "ns1:portalPrefix");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_portalPrefix1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__PortalPrefixResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__PortalPrefixResponse, SOAP_TYPE__ns1__PortalPrefixResponse, sizeof(_ns1__PortalPrefixResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__PortalPrefixResponse * SOAP_FMAC2 soap_instantiate__ns1__PortalPrefixResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__PortalPrefixResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__PortalPrefixResponse *p;
	size_t k = sizeof(_ns1__PortalPrefixResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__PortalPrefixResponse);
		if (p)
			((_ns1__PortalPrefixResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__PortalPrefixResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__PortalPrefixResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__PortalPrefixResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__PortalPrefixResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__PortalPrefixResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:PortalPrefixResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__PortalPrefixResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__PortalPrefixResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__PortalPrefixResponse * SOAP_FMAC4 soap_get__ns1__PortalPrefixResponse(struct soap *soap, _ns1__PortalPrefixResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__PortalPrefixResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__RoomAccessOptionsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__RoomAccessOptionsResponse::__sizeRoomAccessOption = 0;
	this->_ns1__RoomAccessOptionsResponse::RoomAccessOption = NULL;
	/* transient soap skipped */
}

void _ns1__RoomAccessOptionsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->_ns1__RoomAccessOptionsResponse::RoomAccessOption)
	{	int i;
		for (i = 0; i < (int)this->_ns1__RoomAccessOptionsResponse::__sizeRoomAccessOption; i++)
		{
			soap_serialize_PointerTo_ns1__RoomAccessOption(soap, this->_ns1__RoomAccessOptionsResponse::RoomAccessOption + i);
		}
	}
#endif
}

int _ns1__RoomAccessOptionsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RoomAccessOptionsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RoomAccessOptionsResponse(struct soap *soap, const char *tag, int id, const _ns1__RoomAccessOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RoomAccessOptionsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeRoomAccessOption");
	if (a->_ns1__RoomAccessOptionsResponse::RoomAccessOption)
	{	int i;
		for (i = 0; i < (int)a->_ns1__RoomAccessOptionsResponse::__sizeRoomAccessOption; i++)
			if (soap_out_PointerTo_ns1__RoomAccessOption(soap, "ns1:RoomAccessOption", -1, a->_ns1__RoomAccessOptionsResponse::RoomAccessOption + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *_ns1__RoomAccessOptionsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RoomAccessOptionsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RoomAccessOptionsResponse * SOAP_FMAC4 soap_in__ns1__RoomAccessOptionsResponse(struct soap *soap, const char *tag, _ns1__RoomAccessOptionsResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RoomAccessOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RoomAccessOptionsResponse, sizeof(_ns1__RoomAccessOptionsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	struct soap_blist *soap_blist_RoomAccessOption1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:RoomAccessOption", 1, NULL))
			{	if (a->_ns1__RoomAccessOptionsResponse::RoomAccessOption == NULL)
				{	if (soap_blist_RoomAccessOption1 == NULL)
						soap_blist_RoomAccessOption1 = soap_new_block(soap);
					a->_ns1__RoomAccessOptionsResponse::RoomAccessOption = (_ns1__RoomAccessOption **)soap_push_block_max(soap, soap_blist_RoomAccessOption1, sizeof(_ns1__RoomAccessOption *));
					if (a->_ns1__RoomAccessOptionsResponse::RoomAccessOption == NULL)
						return NULL;
					*a->_ns1__RoomAccessOptionsResponse::RoomAccessOption = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTo_ns1__RoomAccessOption(soap, "ns1:RoomAccessOption", a->_ns1__RoomAccessOptionsResponse::RoomAccessOption, ""))
				{	a->_ns1__RoomAccessOptionsResponse::__sizeRoomAccessOption++;
					a->_ns1__RoomAccessOptionsResponse::RoomAccessOption = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeRoomAccessOption");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__RoomAccessOptionsResponse::RoomAccessOption)
			soap_pop_block(soap, soap_blist_RoomAccessOption1);
		if (a->_ns1__RoomAccessOptionsResponse::__sizeRoomAccessOption)
		{	a->_ns1__RoomAccessOptionsResponse::RoomAccessOption = (_ns1__RoomAccessOption **)soap_save_block(soap, soap_blist_RoomAccessOption1, NULL, 1);
		}
		else
		{	a->_ns1__RoomAccessOptionsResponse::RoomAccessOption = NULL;
			if (soap_blist_RoomAccessOption1)
				soap_end_block(soap, soap_blist_RoomAccessOption1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->_ns1__RoomAccessOptionsResponse::__sizeRoomAccessOption < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__RoomAccessOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RoomAccessOptionsResponse, SOAP_TYPE__ns1__RoomAccessOptionsResponse, sizeof(_ns1__RoomAccessOptionsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__RoomAccessOptionsResponse * SOAP_FMAC2 soap_instantiate__ns1__RoomAccessOptionsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RoomAccessOptionsResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__RoomAccessOptionsResponse *p;
	size_t k = sizeof(_ns1__RoomAccessOptionsResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__RoomAccessOptionsResponse);
		if (p)
			((_ns1__RoomAccessOptionsResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__RoomAccessOptionsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__RoomAccessOptionsResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__RoomAccessOptionsResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__RoomAccessOptionsResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__RoomAccessOptionsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:RoomAccessOptionsResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RoomAccessOptionsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RoomAccessOptionsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RoomAccessOptionsResponse * SOAP_FMAC4 soap_get__ns1__RoomAccessOptionsResponse(struct soap *soap, _ns1__RoomAccessOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RoomAccessOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__RoomAccessOptionsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__RoomAccessOptionsRequest::roomID);
	/* transient soap skipped */
}

void _ns1__RoomAccessOptionsRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__RoomAccessOptionsRequest::roomID);
#endif
}

int _ns1__RoomAccessOptionsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RoomAccessOptionsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RoomAccessOptionsRequest(struct soap *soap, const char *tag, int id, const _ns1__RoomAccessOptionsRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RoomAccessOptionsRequest), type))
		return soap->error;
	if (!a->_ns1__RoomAccessOptionsRequest::roomID)
	{	if (soap_element_nil(soap, "ns1:roomID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:roomID", -1, (char*const*)&a->_ns1__RoomAccessOptionsRequest::roomID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__RoomAccessOptionsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RoomAccessOptionsRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RoomAccessOptionsRequest * SOAP_FMAC4 soap_in__ns1__RoomAccessOptionsRequest(struct soap *soap, const char *tag, _ns1__RoomAccessOptionsRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RoomAccessOptionsRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RoomAccessOptionsRequest, sizeof(_ns1__RoomAccessOptionsRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_roomID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_roomID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:roomID", (char**)&a->_ns1__RoomAccessOptionsRequest::roomID, "ns1:EntityID"))
				{	soap_flag_roomID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_roomID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__RoomAccessOptionsRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RoomAccessOptionsRequest, SOAP_TYPE__ns1__RoomAccessOptionsRequest, sizeof(_ns1__RoomAccessOptionsRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__RoomAccessOptionsRequest * SOAP_FMAC2 soap_instantiate__ns1__RoomAccessOptionsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RoomAccessOptionsRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__RoomAccessOptionsRequest *p;
	size_t k = sizeof(_ns1__RoomAccessOptionsRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__RoomAccessOptionsRequest);
		if (p)
			((_ns1__RoomAccessOptionsRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__RoomAccessOptionsRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__RoomAccessOptionsRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__RoomAccessOptionsRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__RoomAccessOptionsRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__RoomAccessOptionsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:RoomAccessOptionsRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RoomAccessOptionsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RoomAccessOptionsRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RoomAccessOptionsRequest * SOAP_FMAC4 soap_get__ns1__RoomAccessOptionsRequest(struct soap *soap, _ns1__RoomAccessOptionsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RoomAccessOptionsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__RoomAccessOption::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__AccessOptionName(soap, &this->_ns1__RoomAccessOption::accessOption);
	soap_default_string(soap, &this->_ns1__RoomAccessOption::value);
	/* transient soap skipped */
}

void _ns1__RoomAccessOption::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__RoomAccessOption::value);
#endif
}

int _ns1__RoomAccessOption::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RoomAccessOption(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RoomAccessOption(struct soap *soap, const char *tag, int id, const _ns1__RoomAccessOption *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RoomAccessOption), type))
		return soap->error;
	if (soap_out_ns1__AccessOptionName(soap, "ns1:accessOption", -1, &a->_ns1__RoomAccessOption::accessOption, ""))
		return soap->error;
	if (!a->_ns1__RoomAccessOption::value)
	{	if (soap_element_nil(soap, "ns1:value"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:value", -1, (char*const*)&a->_ns1__RoomAccessOption::value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__RoomAccessOption::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RoomAccessOption(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RoomAccessOption * SOAP_FMAC4 soap_in__ns1__RoomAccessOption(struct soap *soap, const char *tag, _ns1__RoomAccessOption *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RoomAccessOption *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RoomAccessOption, sizeof(_ns1__RoomAccessOption), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_accessOption1 = 1;
	size_t soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accessOption1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__AccessOptionName(soap, "ns1:accessOption", &a->_ns1__RoomAccessOption::accessOption, "ns1:AccessOptionName"))
				{	soap_flag_accessOption1--;
					continue;
				}
			if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:value", (char**)&a->_ns1__RoomAccessOption::value, "xsd:string"))
				{	soap_flag_value1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accessOption1 > 0 || soap_flag_value1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__RoomAccessOption *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RoomAccessOption, SOAP_TYPE__ns1__RoomAccessOption, sizeof(_ns1__RoomAccessOption), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__RoomAccessOption * SOAP_FMAC2 soap_instantiate__ns1__RoomAccessOption(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RoomAccessOption(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__RoomAccessOption *p;
	size_t k = sizeof(_ns1__RoomAccessOption);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__RoomAccessOption);
		if (p)
			((_ns1__RoomAccessOption*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__RoomAccessOption, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__RoomAccessOption*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__RoomAccessOption location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__RoomAccessOption, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__RoomAccessOption::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:RoomAccessOption", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RoomAccessOption::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RoomAccessOption(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RoomAccessOption * SOAP_FMAC4 soap_get__ns1__RoomAccessOption(struct soap *soap, _ns1__RoomAccessOption *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RoomAccessOption(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__OnetimeAccessResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->_ns1__OnetimeAccessResponse::url);
	/* transient soap skipped */
}

void _ns1__OnetimeAccessResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&this->_ns1__OnetimeAccessResponse::url);
#endif
}

int _ns1__OnetimeAccessResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__OnetimeAccessResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__OnetimeAccessResponse(struct soap *soap, const char *tag, int id, const _ns1__OnetimeAccessResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__OnetimeAccessResponse), type))
		return soap->error;
	if (a->url)
		soap_element_result(soap, "ns1:url");
	if (!a->_ns1__OnetimeAccessResponse::url)
	{	if (soap_element_nil(soap, "ns1:url"))
			return soap->error;
	}
	else
	if (soap_out_xsd__anyURI(soap, "ns1:url", -1, (char*const*)&a->_ns1__OnetimeAccessResponse::url, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__OnetimeAccessResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__OnetimeAccessResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__OnetimeAccessResponse * SOAP_FMAC4 soap_in__ns1__OnetimeAccessResponse(struct soap *soap, const char *tag, _ns1__OnetimeAccessResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__OnetimeAccessResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__OnetimeAccessResponse, sizeof(_ns1__OnetimeAccessResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_url1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_url1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "ns1:url", (char**)&a->_ns1__OnetimeAccessResponse::url, "xsd:anyURI"))
				{	soap_flag_url1--;
					continue;
				}
			soap_check_result(soap, "ns1:url");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_url1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__OnetimeAccessResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__OnetimeAccessResponse, SOAP_TYPE__ns1__OnetimeAccessResponse, sizeof(_ns1__OnetimeAccessResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__OnetimeAccessResponse * SOAP_FMAC2 soap_instantiate__ns1__OnetimeAccessResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__OnetimeAccessResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__OnetimeAccessResponse *p;
	size_t k = sizeof(_ns1__OnetimeAccessResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__OnetimeAccessResponse);
		if (p)
			((_ns1__OnetimeAccessResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__OnetimeAccessResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__OnetimeAccessResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__OnetimeAccessResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__OnetimeAccessResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__OnetimeAccessResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:OnetimeAccessResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__OnetimeAccessResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__OnetimeAccessResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__OnetimeAccessResponse * SOAP_FMAC4 soap_get__ns1__OnetimeAccessResponse(struct soap *soap, _ns1__OnetimeAccessResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__OnetimeAccessResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__muteVideoClientAllResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__muteVideoClientAllResponse::OK);
	/* transient soap skipped */
}

void _ns1__muteVideoClientAllResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__muteVideoClientAllResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__muteVideoClientAllResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__muteVideoClientAllResponse(struct soap *soap, const char *tag, int id, const _ns1__muteVideoClientAllResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__muteVideoClientAllResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__muteVideoClientAllResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__muteVideoClientAllResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__muteVideoClientAllResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__muteVideoClientAllResponse * SOAP_FMAC4 soap_in__ns1__muteVideoClientAllResponse(struct soap *soap, const char *tag, _ns1__muteVideoClientAllResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__muteVideoClientAllResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__muteVideoClientAllResponse, sizeof(_ns1__muteVideoClientAllResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__muteVideoClientAllResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__muteVideoClientAllResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__muteVideoClientAllResponse, SOAP_TYPE__ns1__muteVideoClientAllResponse, sizeof(_ns1__muteVideoClientAllResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__muteVideoClientAllResponse * SOAP_FMAC2 soap_instantiate__ns1__muteVideoClientAllResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__muteVideoClientAllResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__muteVideoClientAllResponse *p;
	size_t k = sizeof(_ns1__muteVideoClientAllResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__muteVideoClientAllResponse);
		if (p)
			((_ns1__muteVideoClientAllResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__muteVideoClientAllResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__muteVideoClientAllResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__muteVideoClientAllResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__muteVideoClientAllResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__muteVideoClientAllResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:muteVideoClientAllResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__muteVideoClientAllResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__muteVideoClientAllResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__muteVideoClientAllResponse * SOAP_FMAC4 soap_get__ns1__muteVideoClientAllResponse(struct soap *soap, _ns1__muteVideoClientAllResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__muteVideoClientAllResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__muteVideoClientAllRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__muteVideoClientAllRequest::conferenceID);
	soap_default_string(soap, &this->_ns1__muteVideoClientAllRequest::moderatorPIN);
	/* transient soap skipped */
}

void _ns1__muteVideoClientAllRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__muteVideoClientAllRequest::conferenceID);
	soap_serialize_string(soap, (char*const*)&this->_ns1__muteVideoClientAllRequest::moderatorPIN);
#endif
}

int _ns1__muteVideoClientAllRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__muteVideoClientAllRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__muteVideoClientAllRequest(struct soap *soap, const char *tag, int id, const _ns1__muteVideoClientAllRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__muteVideoClientAllRequest), type))
		return soap->error;
	if (!a->_ns1__muteVideoClientAllRequest::conferenceID)
	{	if (soap_element_nil(soap, "ns1:conferenceID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:conferenceID", -1, (char*const*)&a->_ns1__muteVideoClientAllRequest::conferenceID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:moderatorPIN", -1, (char*const*)&a->_ns1__muteVideoClientAllRequest::moderatorPIN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__muteVideoClientAllRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__muteVideoClientAllRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__muteVideoClientAllRequest * SOAP_FMAC4 soap_in__ns1__muteVideoClientAllRequest(struct soap *soap, const char *tag, _ns1__muteVideoClientAllRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__muteVideoClientAllRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__muteVideoClientAllRequest, sizeof(_ns1__muteVideoClientAllRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_conferenceID1 = 1;
	size_t soap_flag_moderatorPIN1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_conferenceID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:conferenceID", (char**)&a->_ns1__muteVideoClientAllRequest::conferenceID, "ns1:EntityID"))
				{	soap_flag_conferenceID1--;
					continue;
				}
			if (soap_flag_moderatorPIN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:moderatorPIN", (char**)&a->_ns1__muteVideoClientAllRequest::moderatorPIN, "xsd:string"))
				{	soap_flag_moderatorPIN1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_conferenceID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__muteVideoClientAllRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__muteVideoClientAllRequest, SOAP_TYPE__ns1__muteVideoClientAllRequest, sizeof(_ns1__muteVideoClientAllRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__muteVideoClientAllRequest * SOAP_FMAC2 soap_instantiate__ns1__muteVideoClientAllRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__muteVideoClientAllRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__muteVideoClientAllRequest *p;
	size_t k = sizeof(_ns1__muteVideoClientAllRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__muteVideoClientAllRequest);
		if (p)
			((_ns1__muteVideoClientAllRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__muteVideoClientAllRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__muteVideoClientAllRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__muteVideoClientAllRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__muteVideoClientAllRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__muteVideoClientAllRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:muteVideoClientAllRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__muteVideoClientAllRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__muteVideoClientAllRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__muteVideoClientAllRequest * SOAP_FMAC4 soap_get__ns1__muteVideoClientAllRequest(struct soap *soap, _ns1__muteVideoClientAllRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__muteVideoClientAllRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__muteVideoServerAllResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__muteVideoServerAllResponse::OK);
	/* transient soap skipped */
}

void _ns1__muteVideoServerAllResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__muteVideoServerAllResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__muteVideoServerAllResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__muteVideoServerAllResponse(struct soap *soap, const char *tag, int id, const _ns1__muteVideoServerAllResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__muteVideoServerAllResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__muteVideoServerAllResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__muteVideoServerAllResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__muteVideoServerAllResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__muteVideoServerAllResponse * SOAP_FMAC4 soap_in__ns1__muteVideoServerAllResponse(struct soap *soap, const char *tag, _ns1__muteVideoServerAllResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__muteVideoServerAllResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__muteVideoServerAllResponse, sizeof(_ns1__muteVideoServerAllResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__muteVideoServerAllResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__muteVideoServerAllResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__muteVideoServerAllResponse, SOAP_TYPE__ns1__muteVideoServerAllResponse, sizeof(_ns1__muteVideoServerAllResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__muteVideoServerAllResponse * SOAP_FMAC2 soap_instantiate__ns1__muteVideoServerAllResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__muteVideoServerAllResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__muteVideoServerAllResponse *p;
	size_t k = sizeof(_ns1__muteVideoServerAllResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__muteVideoServerAllResponse);
		if (p)
			((_ns1__muteVideoServerAllResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__muteVideoServerAllResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__muteVideoServerAllResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__muteVideoServerAllResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__muteVideoServerAllResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__muteVideoServerAllResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:muteVideoServerAllResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__muteVideoServerAllResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__muteVideoServerAllResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__muteVideoServerAllResponse * SOAP_FMAC4 soap_get__ns1__muteVideoServerAllResponse(struct soap *soap, _ns1__muteVideoServerAllResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__muteVideoServerAllResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__muteVideoServerAllRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__muteVideoServerAllRequest::conferenceID);
	soap_default_bool(soap, &this->_ns1__muteVideoServerAllRequest::muteState);
	soap_default_string(soap, &this->_ns1__muteVideoServerAllRequest::moderatorPIN);
	/* transient soap skipped */
}

void _ns1__muteVideoServerAllRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__muteVideoServerAllRequest::conferenceID);
	soap_embedded(soap, &this->_ns1__muteVideoServerAllRequest::muteState, SOAP_TYPE_bool);
	soap_serialize_string(soap, (char*const*)&this->_ns1__muteVideoServerAllRequest::moderatorPIN);
#endif
}

int _ns1__muteVideoServerAllRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__muteVideoServerAllRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__muteVideoServerAllRequest(struct soap *soap, const char *tag, int id, const _ns1__muteVideoServerAllRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__muteVideoServerAllRequest), type))
		return soap->error;
	if (!a->_ns1__muteVideoServerAllRequest::conferenceID)
	{	if (soap_element_nil(soap, "ns1:conferenceID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:conferenceID", -1, (char*const*)&a->_ns1__muteVideoServerAllRequest::conferenceID, ""))
		return soap->error;
	if (soap_out_bool(soap, "ns1:muteState", -1, &a->_ns1__muteVideoServerAllRequest::muteState, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:moderatorPIN", -1, (char*const*)&a->_ns1__muteVideoServerAllRequest::moderatorPIN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__muteVideoServerAllRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__muteVideoServerAllRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__muteVideoServerAllRequest * SOAP_FMAC4 soap_in__ns1__muteVideoServerAllRequest(struct soap *soap, const char *tag, _ns1__muteVideoServerAllRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__muteVideoServerAllRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__muteVideoServerAllRequest, sizeof(_ns1__muteVideoServerAllRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_conferenceID1 = 1;
	size_t soap_flag_muteState1 = 1;
	size_t soap_flag_moderatorPIN1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_conferenceID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:conferenceID", (char**)&a->_ns1__muteVideoServerAllRequest::conferenceID, "ns1:EntityID"))
				{	soap_flag_conferenceID1--;
					continue;
				}
			if (soap_flag_muteState1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:muteState", &a->_ns1__muteVideoServerAllRequest::muteState, "xsd:boolean"))
				{	soap_flag_muteState1--;
					continue;
				}
			if (soap_flag_moderatorPIN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:moderatorPIN", (char**)&a->_ns1__muteVideoServerAllRequest::moderatorPIN, "xsd:string"))
				{	soap_flag_moderatorPIN1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_conferenceID1 > 0 || soap_flag_muteState1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__muteVideoServerAllRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__muteVideoServerAllRequest, SOAP_TYPE__ns1__muteVideoServerAllRequest, sizeof(_ns1__muteVideoServerAllRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__muteVideoServerAllRequest * SOAP_FMAC2 soap_instantiate__ns1__muteVideoServerAllRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__muteVideoServerAllRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__muteVideoServerAllRequest *p;
	size_t k = sizeof(_ns1__muteVideoServerAllRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__muteVideoServerAllRequest);
		if (p)
			((_ns1__muteVideoServerAllRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__muteVideoServerAllRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__muteVideoServerAllRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__muteVideoServerAllRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__muteVideoServerAllRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__muteVideoServerAllRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:muteVideoServerAllRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__muteVideoServerAllRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__muteVideoServerAllRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__muteVideoServerAllRequest * SOAP_FMAC4 soap_get__ns1__muteVideoServerAllRequest(struct soap *soap, _ns1__muteVideoServerAllRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__muteVideoServerAllRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__muteAudioClientAllResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__muteAudioClientAllResponse::OK);
	/* transient soap skipped */
}

void _ns1__muteAudioClientAllResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__muteAudioClientAllResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__muteAudioClientAllResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__muteAudioClientAllResponse(struct soap *soap, const char *tag, int id, const _ns1__muteAudioClientAllResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__muteAudioClientAllResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__muteAudioClientAllResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__muteAudioClientAllResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__muteAudioClientAllResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__muteAudioClientAllResponse * SOAP_FMAC4 soap_in__ns1__muteAudioClientAllResponse(struct soap *soap, const char *tag, _ns1__muteAudioClientAllResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__muteAudioClientAllResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__muteAudioClientAllResponse, sizeof(_ns1__muteAudioClientAllResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__muteAudioClientAllResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__muteAudioClientAllResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__muteAudioClientAllResponse, SOAP_TYPE__ns1__muteAudioClientAllResponse, sizeof(_ns1__muteAudioClientAllResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__muteAudioClientAllResponse * SOAP_FMAC2 soap_instantiate__ns1__muteAudioClientAllResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__muteAudioClientAllResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__muteAudioClientAllResponse *p;
	size_t k = sizeof(_ns1__muteAudioClientAllResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__muteAudioClientAllResponse);
		if (p)
			((_ns1__muteAudioClientAllResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__muteAudioClientAllResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__muteAudioClientAllResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__muteAudioClientAllResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__muteAudioClientAllResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__muteAudioClientAllResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:muteAudioClientAllResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__muteAudioClientAllResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__muteAudioClientAllResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__muteAudioClientAllResponse * SOAP_FMAC4 soap_get__ns1__muteAudioClientAllResponse(struct soap *soap, _ns1__muteAudioClientAllResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__muteAudioClientAllResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__muteAudioClientAllRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__muteAudioClientAllRequest::conferenceID);
	soap_default_string(soap, &this->_ns1__muteAudioClientAllRequest::moderatorPIN);
	/* transient soap skipped */
}

void _ns1__muteAudioClientAllRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__muteAudioClientAllRequest::conferenceID);
	soap_serialize_string(soap, (char*const*)&this->_ns1__muteAudioClientAllRequest::moderatorPIN);
#endif
}

int _ns1__muteAudioClientAllRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__muteAudioClientAllRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__muteAudioClientAllRequest(struct soap *soap, const char *tag, int id, const _ns1__muteAudioClientAllRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__muteAudioClientAllRequest), type))
		return soap->error;
	if (!a->_ns1__muteAudioClientAllRequest::conferenceID)
	{	if (soap_element_nil(soap, "ns1:conferenceID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:conferenceID", -1, (char*const*)&a->_ns1__muteAudioClientAllRequest::conferenceID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:moderatorPIN", -1, (char*const*)&a->_ns1__muteAudioClientAllRequest::moderatorPIN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__muteAudioClientAllRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__muteAudioClientAllRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__muteAudioClientAllRequest * SOAP_FMAC4 soap_in__ns1__muteAudioClientAllRequest(struct soap *soap, const char *tag, _ns1__muteAudioClientAllRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__muteAudioClientAllRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__muteAudioClientAllRequest, sizeof(_ns1__muteAudioClientAllRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_conferenceID1 = 1;
	size_t soap_flag_moderatorPIN1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_conferenceID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:conferenceID", (char**)&a->_ns1__muteAudioClientAllRequest::conferenceID, "ns1:EntityID"))
				{	soap_flag_conferenceID1--;
					continue;
				}
			if (soap_flag_moderatorPIN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:moderatorPIN", (char**)&a->_ns1__muteAudioClientAllRequest::moderatorPIN, "xsd:string"))
				{	soap_flag_moderatorPIN1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_conferenceID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__muteAudioClientAllRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__muteAudioClientAllRequest, SOAP_TYPE__ns1__muteAudioClientAllRequest, sizeof(_ns1__muteAudioClientAllRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__muteAudioClientAllRequest * SOAP_FMAC2 soap_instantiate__ns1__muteAudioClientAllRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__muteAudioClientAllRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__muteAudioClientAllRequest *p;
	size_t k = sizeof(_ns1__muteAudioClientAllRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__muteAudioClientAllRequest);
		if (p)
			((_ns1__muteAudioClientAllRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__muteAudioClientAllRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__muteAudioClientAllRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__muteAudioClientAllRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__muteAudioClientAllRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__muteAudioClientAllRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:muteAudioClientAllRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__muteAudioClientAllRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__muteAudioClientAllRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__muteAudioClientAllRequest * SOAP_FMAC4 soap_get__ns1__muteAudioClientAllRequest(struct soap *soap, _ns1__muteAudioClientAllRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__muteAudioClientAllRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__muteAudioServerAllResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__muteAudioServerAllResponse::OK);
	/* transient soap skipped */
}

void _ns1__muteAudioServerAllResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__muteAudioServerAllResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__muteAudioServerAllResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__muteAudioServerAllResponse(struct soap *soap, const char *tag, int id, const _ns1__muteAudioServerAllResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__muteAudioServerAllResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__muteAudioServerAllResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__muteAudioServerAllResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__muteAudioServerAllResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__muteAudioServerAllResponse * SOAP_FMAC4 soap_in__ns1__muteAudioServerAllResponse(struct soap *soap, const char *tag, _ns1__muteAudioServerAllResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__muteAudioServerAllResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__muteAudioServerAllResponse, sizeof(_ns1__muteAudioServerAllResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__muteAudioServerAllResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__muteAudioServerAllResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__muteAudioServerAllResponse, SOAP_TYPE__ns1__muteAudioServerAllResponse, sizeof(_ns1__muteAudioServerAllResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__muteAudioServerAllResponse * SOAP_FMAC2 soap_instantiate__ns1__muteAudioServerAllResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__muteAudioServerAllResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__muteAudioServerAllResponse *p;
	size_t k = sizeof(_ns1__muteAudioServerAllResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__muteAudioServerAllResponse);
		if (p)
			((_ns1__muteAudioServerAllResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__muteAudioServerAllResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__muteAudioServerAllResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__muteAudioServerAllResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__muteAudioServerAllResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__muteAudioServerAllResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:muteAudioServerAllResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__muteAudioServerAllResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__muteAudioServerAllResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__muteAudioServerAllResponse * SOAP_FMAC4 soap_get__ns1__muteAudioServerAllResponse(struct soap *soap, _ns1__muteAudioServerAllResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__muteAudioServerAllResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__muteAudioServerAllRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__muteAudioServerAllRequest::conferenceID);
	soap_default_bool(soap, &this->_ns1__muteAudioServerAllRequest::muteState);
	soap_default_string(soap, &this->_ns1__muteAudioServerAllRequest::moderatorPIN);
	/* transient soap skipped */
}

void _ns1__muteAudioServerAllRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__muteAudioServerAllRequest::conferenceID);
	soap_embedded(soap, &this->_ns1__muteAudioServerAllRequest::muteState, SOAP_TYPE_bool);
	soap_serialize_string(soap, (char*const*)&this->_ns1__muteAudioServerAllRequest::moderatorPIN);
#endif
}

int _ns1__muteAudioServerAllRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__muteAudioServerAllRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__muteAudioServerAllRequest(struct soap *soap, const char *tag, int id, const _ns1__muteAudioServerAllRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__muteAudioServerAllRequest), type))
		return soap->error;
	if (!a->_ns1__muteAudioServerAllRequest::conferenceID)
	{	if (soap_element_nil(soap, "ns1:conferenceID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:conferenceID", -1, (char*const*)&a->_ns1__muteAudioServerAllRequest::conferenceID, ""))
		return soap->error;
	if (soap_out_bool(soap, "ns1:muteState", -1, &a->_ns1__muteAudioServerAllRequest::muteState, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:moderatorPIN", -1, (char*const*)&a->_ns1__muteAudioServerAllRequest::moderatorPIN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__muteAudioServerAllRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__muteAudioServerAllRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__muteAudioServerAllRequest * SOAP_FMAC4 soap_in__ns1__muteAudioServerAllRequest(struct soap *soap, const char *tag, _ns1__muteAudioServerAllRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__muteAudioServerAllRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__muteAudioServerAllRequest, sizeof(_ns1__muteAudioServerAllRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_conferenceID1 = 1;
	size_t soap_flag_muteState1 = 1;
	size_t soap_flag_moderatorPIN1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_conferenceID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:conferenceID", (char**)&a->_ns1__muteAudioServerAllRequest::conferenceID, "ns1:EntityID"))
				{	soap_flag_conferenceID1--;
					continue;
				}
			if (soap_flag_muteState1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:muteState", &a->_ns1__muteAudioServerAllRequest::muteState, "xsd:boolean"))
				{	soap_flag_muteState1--;
					continue;
				}
			if (soap_flag_moderatorPIN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:moderatorPIN", (char**)&a->_ns1__muteAudioServerAllRequest::moderatorPIN, "xsd:string"))
				{	soap_flag_moderatorPIN1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_conferenceID1 > 0 || soap_flag_muteState1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__muteAudioServerAllRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__muteAudioServerAllRequest, SOAP_TYPE__ns1__muteAudioServerAllRequest, sizeof(_ns1__muteAudioServerAllRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__muteAudioServerAllRequest * SOAP_FMAC2 soap_instantiate__ns1__muteAudioServerAllRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__muteAudioServerAllRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__muteAudioServerAllRequest *p;
	size_t k = sizeof(_ns1__muteAudioServerAllRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__muteAudioServerAllRequest);
		if (p)
			((_ns1__muteAudioServerAllRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__muteAudioServerAllRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__muteAudioServerAllRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__muteAudioServerAllRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__muteAudioServerAllRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__muteAudioServerAllRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:muteAudioServerAllRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__muteAudioServerAllRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__muteAudioServerAllRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__muteAudioServerAllRequest * SOAP_FMAC4 soap_get__ns1__muteAudioServerAllRequest(struct soap *soap, _ns1__muteAudioServerAllRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__muteAudioServerAllRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__disconnectConferenceAllResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__disconnectConferenceAllResponse::OK);
	/* transient soap skipped */
}

void _ns1__disconnectConferenceAllResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__disconnectConferenceAllResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__disconnectConferenceAllResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__disconnectConferenceAllResponse(struct soap *soap, const char *tag, int id, const _ns1__disconnectConferenceAllResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__disconnectConferenceAllResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__disconnectConferenceAllResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__disconnectConferenceAllResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__disconnectConferenceAllResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__disconnectConferenceAllResponse * SOAP_FMAC4 soap_in__ns1__disconnectConferenceAllResponse(struct soap *soap, const char *tag, _ns1__disconnectConferenceAllResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__disconnectConferenceAllResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__disconnectConferenceAllResponse, sizeof(_ns1__disconnectConferenceAllResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__disconnectConferenceAllResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__disconnectConferenceAllResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__disconnectConferenceAllResponse, SOAP_TYPE__ns1__disconnectConferenceAllResponse, sizeof(_ns1__disconnectConferenceAllResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__disconnectConferenceAllResponse * SOAP_FMAC2 soap_instantiate__ns1__disconnectConferenceAllResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__disconnectConferenceAllResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__disconnectConferenceAllResponse *p;
	size_t k = sizeof(_ns1__disconnectConferenceAllResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__disconnectConferenceAllResponse);
		if (p)
			((_ns1__disconnectConferenceAllResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__disconnectConferenceAllResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__disconnectConferenceAllResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__disconnectConferenceAllResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__disconnectConferenceAllResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__disconnectConferenceAllResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:disconnectConferenceAllResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__disconnectConferenceAllResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__disconnectConferenceAllResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__disconnectConferenceAllResponse * SOAP_FMAC4 soap_get__ns1__disconnectConferenceAllResponse(struct soap *soap, _ns1__disconnectConferenceAllResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__disconnectConferenceAllResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__disconnectConferenceAllRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__disconnectConferenceAllRequest::conferenceID);
	soap_default_string(soap, &this->_ns1__disconnectConferenceAllRequest::moderatorPIN);
	/* transient soap skipped */
}

void _ns1__disconnectConferenceAllRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__disconnectConferenceAllRequest::conferenceID);
	soap_serialize_string(soap, (char*const*)&this->_ns1__disconnectConferenceAllRequest::moderatorPIN);
#endif
}

int _ns1__disconnectConferenceAllRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__disconnectConferenceAllRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__disconnectConferenceAllRequest(struct soap *soap, const char *tag, int id, const _ns1__disconnectConferenceAllRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__disconnectConferenceAllRequest), type))
		return soap->error;
	if (!a->_ns1__disconnectConferenceAllRequest::conferenceID)
	{	if (soap_element_nil(soap, "ns1:conferenceID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:conferenceID", -1, (char*const*)&a->_ns1__disconnectConferenceAllRequest::conferenceID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:moderatorPIN", -1, (char*const*)&a->_ns1__disconnectConferenceAllRequest::moderatorPIN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__disconnectConferenceAllRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__disconnectConferenceAllRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__disconnectConferenceAllRequest * SOAP_FMAC4 soap_in__ns1__disconnectConferenceAllRequest(struct soap *soap, const char *tag, _ns1__disconnectConferenceAllRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__disconnectConferenceAllRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__disconnectConferenceAllRequest, sizeof(_ns1__disconnectConferenceAllRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_conferenceID1 = 1;
	size_t soap_flag_moderatorPIN1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_conferenceID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:conferenceID", (char**)&a->_ns1__disconnectConferenceAllRequest::conferenceID, "ns1:EntityID"))
				{	soap_flag_conferenceID1--;
					continue;
				}
			if (soap_flag_moderatorPIN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:moderatorPIN", (char**)&a->_ns1__disconnectConferenceAllRequest::moderatorPIN, "xsd:string"))
				{	soap_flag_moderatorPIN1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_conferenceID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__disconnectConferenceAllRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__disconnectConferenceAllRequest, SOAP_TYPE__ns1__disconnectConferenceAllRequest, sizeof(_ns1__disconnectConferenceAllRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__disconnectConferenceAllRequest * SOAP_FMAC2 soap_instantiate__ns1__disconnectConferenceAllRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__disconnectConferenceAllRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__disconnectConferenceAllRequest *p;
	size_t k = sizeof(_ns1__disconnectConferenceAllRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__disconnectConferenceAllRequest);
		if (p)
			((_ns1__disconnectConferenceAllRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__disconnectConferenceAllRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__disconnectConferenceAllRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__disconnectConferenceAllRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__disconnectConferenceAllRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__disconnectConferenceAllRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:disconnectConferenceAllRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__disconnectConferenceAllRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__disconnectConferenceAllRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__disconnectConferenceAllRequest * SOAP_FMAC4 soap_get__ns1__disconnectConferenceAllRequest(struct soap *soap, _ns1__disconnectConferenceAllRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__disconnectConferenceAllRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__LogoutAllOtherSessionsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__LogoutAllOtherSessionsResponse::OK);
	/* transient soap skipped */
}

void _ns1__LogoutAllOtherSessionsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__LogoutAllOtherSessionsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__LogoutAllOtherSessionsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__LogoutAllOtherSessionsResponse(struct soap *soap, const char *tag, int id, const _ns1__LogoutAllOtherSessionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__LogoutAllOtherSessionsResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__LogoutAllOtherSessionsResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__LogoutAllOtherSessionsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__LogoutAllOtherSessionsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__LogoutAllOtherSessionsResponse * SOAP_FMAC4 soap_in__ns1__LogoutAllOtherSessionsResponse(struct soap *soap, const char *tag, _ns1__LogoutAllOtherSessionsResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__LogoutAllOtherSessionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__LogoutAllOtherSessionsResponse, sizeof(_ns1__LogoutAllOtherSessionsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__LogoutAllOtherSessionsResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__LogoutAllOtherSessionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__LogoutAllOtherSessionsResponse, SOAP_TYPE__ns1__LogoutAllOtherSessionsResponse, sizeof(_ns1__LogoutAllOtherSessionsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__LogoutAllOtherSessionsResponse * SOAP_FMAC2 soap_instantiate__ns1__LogoutAllOtherSessionsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__LogoutAllOtherSessionsResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__LogoutAllOtherSessionsResponse *p;
	size_t k = sizeof(_ns1__LogoutAllOtherSessionsResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__LogoutAllOtherSessionsResponse);
		if (p)
			((_ns1__LogoutAllOtherSessionsResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__LogoutAllOtherSessionsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__LogoutAllOtherSessionsResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__LogoutAllOtherSessionsResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__LogoutAllOtherSessionsResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__LogoutAllOtherSessionsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:LogoutAllOtherSessionsResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__LogoutAllOtherSessionsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__LogoutAllOtherSessionsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__LogoutAllOtherSessionsResponse * SOAP_FMAC4 soap_get__ns1__LogoutAllOtherSessionsResponse(struct soap *soap, _ns1__LogoutAllOtherSessionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__LogoutAllOtherSessionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetActiveSessionsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GetActiveSessionsResponse::count);
	/* transient soap skipped */
}

void _ns1__GetActiveSessionsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns1__GetActiveSessionsResponse::count, SOAP_TYPE_int);
#endif
}

int _ns1__GetActiveSessionsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetActiveSessionsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetActiveSessionsResponse(struct soap *soap, const char *tag, int id, const _ns1__GetActiveSessionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetActiveSessionsResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:count");
	if (soap_out_int(soap, "ns1:count", -1, &a->_ns1__GetActiveSessionsResponse::count, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetActiveSessionsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetActiveSessionsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetActiveSessionsResponse * SOAP_FMAC4 soap_in__ns1__GetActiveSessionsResponse(struct soap *soap, const char *tag, _ns1__GetActiveSessionsResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetActiveSessionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetActiveSessionsResponse, sizeof(_ns1__GetActiveSessionsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_count1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_count1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:count", &a->_ns1__GetActiveSessionsResponse::count, "xsd:int"))
				{	soap_flag_count1--;
					continue;
				}
			soap_check_result(soap, "ns1:count");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_count1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetActiveSessionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetActiveSessionsResponse, SOAP_TYPE__ns1__GetActiveSessionsResponse, sizeof(_ns1__GetActiveSessionsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetActiveSessionsResponse * SOAP_FMAC2 soap_instantiate__ns1__GetActiveSessionsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetActiveSessionsResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetActiveSessionsResponse *p;
	size_t k = sizeof(_ns1__GetActiveSessionsResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetActiveSessionsResponse);
		if (p)
			((_ns1__GetActiveSessionsResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetActiveSessionsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetActiveSessionsResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetActiveSessionsResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetActiveSessionsResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetActiveSessionsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:GetActiveSessionsResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetActiveSessionsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetActiveSessionsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetActiveSessionsResponse * SOAP_FMAC4 soap_get__ns1__GetActiveSessionsResponse(struct soap *soap, _ns1__GetActiveSessionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetActiveSessionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SetEndpointDetailsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__SetEndpointDetailsResponse::OK);
	/* transient soap skipped */
}

void _ns1__SetEndpointDetailsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__SetEndpointDetailsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetEndpointDetailsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetEndpointDetailsResponse(struct soap *soap, const char *tag, int id, const _ns1__SetEndpointDetailsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetEndpointDetailsResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__SetEndpointDetailsResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetEndpointDetailsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetEndpointDetailsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetEndpointDetailsResponse * SOAP_FMAC4 soap_in__ns1__SetEndpointDetailsResponse(struct soap *soap, const char *tag, _ns1__SetEndpointDetailsResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetEndpointDetailsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetEndpointDetailsResponse, sizeof(_ns1__SetEndpointDetailsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__SetEndpointDetailsResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__SetEndpointDetailsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetEndpointDetailsResponse, SOAP_TYPE__ns1__SetEndpointDetailsResponse, sizeof(_ns1__SetEndpointDetailsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SetEndpointDetailsResponse * SOAP_FMAC2 soap_instantiate__ns1__SetEndpointDetailsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetEndpointDetailsResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SetEndpointDetailsResponse *p;
	size_t k = sizeof(_ns1__SetEndpointDetailsResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SetEndpointDetailsResponse);
		if (p)
			((_ns1__SetEndpointDetailsResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SetEndpointDetailsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SetEndpointDetailsResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SetEndpointDetailsResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SetEndpointDetailsResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SetEndpointDetailsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SetEndpointDetailsResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SetEndpointDetailsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetEndpointDetailsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetEndpointDetailsResponse * SOAP_FMAC4 soap_get__ns1__SetEndpointDetailsResponse(struct soap *soap, _ns1__SetEndpointDetailsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetEndpointDetailsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SetEndpointDetailsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__SetEndpointDetailsRequest::EID);
	this->_ns1__SetEndpointDetailsRequest::__sizeEndpointFeature = 0;
	this->_ns1__SetEndpointDetailsRequest::EndpointFeature = NULL;
	soap_default_string(soap, &this->_ns1__SetEndpointDetailsRequest::applicationName);
	soap_default_string(soap, &this->_ns1__SetEndpointDetailsRequest::applicationVersion);
	soap_default_string(soap, &this->_ns1__SetEndpointDetailsRequest::applicationOs);
	soap_default_string(soap, &this->_ns1__SetEndpointDetailsRequest::deviceModel);
	this->_ns1__SetEndpointDetailsRequest::__size = 0;
	this->_ns1__SetEndpointDetailsRequest::__any = NULL;
	/* transient soap skipped */
}

void _ns1__SetEndpointDetailsRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__SetEndpointDetailsRequest::EID);
	if (this->_ns1__SetEndpointDetailsRequest::EndpointFeature)
	{	int i;
		for (i = 0; i < (int)this->_ns1__SetEndpointDetailsRequest::__sizeEndpointFeature; i++)
		{
			soap_serialize_PointerTo_ns1__EndpointFeature(soap, this->_ns1__SetEndpointDetailsRequest::EndpointFeature + i);
		}
	}
	soap_serialize_string(soap, (char*const*)&this->_ns1__SetEndpointDetailsRequest::applicationName);
	soap_serialize_string(soap, (char*const*)&this->_ns1__SetEndpointDetailsRequest::applicationVersion);
	soap_serialize_string(soap, (char*const*)&this->_ns1__SetEndpointDetailsRequest::applicationOs);
	soap_serialize_string(soap, (char*const*)&this->_ns1__SetEndpointDetailsRequest::deviceModel);
#endif
}

int _ns1__SetEndpointDetailsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetEndpointDetailsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetEndpointDetailsRequest(struct soap *soap, const char *tag, int id, const _ns1__SetEndpointDetailsRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetEndpointDetailsRequest), type))
		return soap->error;
	if (!a->_ns1__SetEndpointDetailsRequest::EID)
	{	if (soap_element_nil(soap, "ns1:EID"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:EID", -1, (char*const*)&a->_ns1__SetEndpointDetailsRequest::EID, ""))
		return soap->error;
	if (a->_ns1__SetEndpointDetailsRequest::EndpointFeature)
	{	int i;
		for (i = 0; i < (int)a->_ns1__SetEndpointDetailsRequest::__sizeEndpointFeature; i++)
			if (soap_out_PointerTo_ns1__EndpointFeature(soap, "ns1:EndpointFeature", -1, a->_ns1__SetEndpointDetailsRequest::EndpointFeature + i, ""))
				return soap->error;
	}
	if (soap_out_string(soap, "ns1:applicationName", -1, (char*const*)&a->_ns1__SetEndpointDetailsRequest::applicationName, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:applicationVersion", -1, (char*const*)&a->_ns1__SetEndpointDetailsRequest::applicationVersion, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:applicationOs", -1, (char*const*)&a->_ns1__SetEndpointDetailsRequest::applicationOs, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:deviceModel", -1, (char*const*)&a->_ns1__SetEndpointDetailsRequest::deviceModel, ""))
		return soap->error;
	if (a->_ns1__SetEndpointDetailsRequest::__any)
	{	int i;
		for (i = 0; i < (int)a->_ns1__SetEndpointDetailsRequest::__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->_ns1__SetEndpointDetailsRequest::__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetEndpointDetailsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetEndpointDetailsRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetEndpointDetailsRequest * SOAP_FMAC4 soap_in__ns1__SetEndpointDetailsRequest(struct soap *soap, const char *tag, _ns1__SetEndpointDetailsRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetEndpointDetailsRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetEndpointDetailsRequest, sizeof(_ns1__SetEndpointDetailsRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_EID1 = 1;
	struct soap_blist *soap_blist_EndpointFeature1 = NULL;
	size_t soap_flag_applicationName1 = 1;
	size_t soap_flag_applicationVersion1 = 1;
	size_t soap_flag_applicationOs1 = 1;
	size_t soap_flag_deviceModel1 = 1;
	struct soap_blist *soap_blist___any1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:EID", (char**)&a->_ns1__SetEndpointDetailsRequest::EID, "xsd:string"))
				{	soap_flag_EID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:EndpointFeature", 1, NULL))
			{	if (a->_ns1__SetEndpointDetailsRequest::EndpointFeature == NULL)
				{	if (soap_blist_EndpointFeature1 == NULL)
						soap_blist_EndpointFeature1 = soap_new_block(soap);
					a->_ns1__SetEndpointDetailsRequest::EndpointFeature = (_ns1__EndpointFeature **)soap_push_block_max(soap, soap_blist_EndpointFeature1, sizeof(_ns1__EndpointFeature *));
					if (a->_ns1__SetEndpointDetailsRequest::EndpointFeature == NULL)
						return NULL;
					*a->_ns1__SetEndpointDetailsRequest::EndpointFeature = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTo_ns1__EndpointFeature(soap, "ns1:EndpointFeature", a->_ns1__SetEndpointDetailsRequest::EndpointFeature, ""))
				{	a->_ns1__SetEndpointDetailsRequest::__sizeEndpointFeature++;
					a->_ns1__SetEndpointDetailsRequest::EndpointFeature = NULL;
					continue;
				}
			}
			if (soap_flag_applicationName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:applicationName", (char**)&a->_ns1__SetEndpointDetailsRequest::applicationName, "xsd:string"))
				{	soap_flag_applicationName1--;
					continue;
				}
			if (soap_flag_applicationVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:applicationVersion", (char**)&a->_ns1__SetEndpointDetailsRequest::applicationVersion, "xsd:string"))
				{	soap_flag_applicationVersion1--;
					continue;
				}
			if (soap_flag_applicationOs1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:applicationOs", (char**)&a->_ns1__SetEndpointDetailsRequest::applicationOs, "xsd:string"))
				{	soap_flag_applicationOs1--;
					continue;
				}
			if (soap_flag_deviceModel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:deviceModel", (char**)&a->_ns1__SetEndpointDetailsRequest::deviceModel, "xsd:string"))
				{	soap_flag_deviceModel1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->_ns1__SetEndpointDetailsRequest::__any == NULL)
				{	if (soap_blist___any1 == NULL)
						soap_blist___any1 = soap_new_block(soap);
					a->_ns1__SetEndpointDetailsRequest::__any = (char *)soap_push_block_max(soap, soap_blist___any1, sizeof(char));
					if (a->_ns1__SetEndpointDetailsRequest::__any == NULL)
						return NULL;
					soap_default_byte(soap, a->_ns1__SetEndpointDetailsRequest::__any);
				}
				if (soap_in_byte(soap, "-any", a->_ns1__SetEndpointDetailsRequest::__any, "xsd:byte"))
				{	a->_ns1__SetEndpointDetailsRequest::__size++;
					a->_ns1__SetEndpointDetailsRequest::__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__SetEndpointDetailsRequest::EndpointFeature)
			soap_pop_block(soap, soap_blist_EndpointFeature1);
		if (a->_ns1__SetEndpointDetailsRequest::__sizeEndpointFeature)
		{	a->_ns1__SetEndpointDetailsRequest::EndpointFeature = (_ns1__EndpointFeature **)soap_save_block(soap, soap_blist_EndpointFeature1, NULL, 1);
		}
		else
		{	a->_ns1__SetEndpointDetailsRequest::EndpointFeature = NULL;
			if (soap_blist_EndpointFeature1)
				soap_end_block(soap, soap_blist_EndpointFeature1);
		}
		if (a->_ns1__SetEndpointDetailsRequest::__any)
			soap_pop_block(soap, soap_blist___any1);
		if (a->_ns1__SetEndpointDetailsRequest::__size)
		{	a->_ns1__SetEndpointDetailsRequest::__any = (char *)soap_save_block(soap, soap_blist___any1, NULL, 1);
		}
		else
		{	a->_ns1__SetEndpointDetailsRequest::__any = NULL;
			if (soap_blist___any1)
				soap_end_block(soap, soap_blist___any1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_EID1 > 0 || a->_ns1__SetEndpointDetailsRequest::__sizeEndpointFeature < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__SetEndpointDetailsRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetEndpointDetailsRequest, SOAP_TYPE__ns1__SetEndpointDetailsRequest, sizeof(_ns1__SetEndpointDetailsRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SetEndpointDetailsRequest * SOAP_FMAC2 soap_instantiate__ns1__SetEndpointDetailsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetEndpointDetailsRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SetEndpointDetailsRequest *p;
	size_t k = sizeof(_ns1__SetEndpointDetailsRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SetEndpointDetailsRequest);
		if (p)
			((_ns1__SetEndpointDetailsRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SetEndpointDetailsRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SetEndpointDetailsRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SetEndpointDetailsRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SetEndpointDetailsRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SetEndpointDetailsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SetEndpointDetailsRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SetEndpointDetailsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetEndpointDetailsRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetEndpointDetailsRequest * SOAP_FMAC4 soap_get__ns1__SetEndpointDetailsRequest(struct soap *soap, _ns1__SetEndpointDetailsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetEndpointDetailsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__EndpointFeature::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EndpointFeatureName(soap, &this->_ns1__EndpointFeature::feature);
	soap_default_bool(soap, &this->_ns1__EndpointFeature::enable);
	/* transient soap skipped */
}

void _ns1__EndpointFeature::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EndpointFeatureName(soap, (char*const*)&this->_ns1__EndpointFeature::feature);
	soap_embedded(soap, &this->_ns1__EndpointFeature::enable, SOAP_TYPE_bool);
#endif
}

int _ns1__EndpointFeature::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__EndpointFeature(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__EndpointFeature(struct soap *soap, const char *tag, int id, const _ns1__EndpointFeature *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__EndpointFeature), type))
		return soap->error;
	if (!a->_ns1__EndpointFeature::feature)
	{	if (soap_element_nil(soap, "ns1:feature"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EndpointFeatureName(soap, "ns1:feature", -1, (char*const*)&a->_ns1__EndpointFeature::feature, ""))
		return soap->error;
	if (soap_out_bool(soap, "ns1:enable", -1, &a->_ns1__EndpointFeature::enable, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__EndpointFeature::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__EndpointFeature(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__EndpointFeature * SOAP_FMAC4 soap_in__ns1__EndpointFeature(struct soap *soap, const char *tag, _ns1__EndpointFeature *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__EndpointFeature *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__EndpointFeature, sizeof(_ns1__EndpointFeature), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_feature1 = 1;
	size_t soap_flag_enable1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_feature1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EndpointFeatureName(soap, "ns1:feature", (char**)&a->_ns1__EndpointFeature::feature, "ns1:EndpointFeatureName"))
				{	soap_flag_feature1--;
					continue;
				}
			if (soap_flag_enable1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:enable", &a->_ns1__EndpointFeature::enable, "xsd:boolean"))
				{	soap_flag_enable1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_feature1 > 0 || soap_flag_enable1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__EndpointFeature *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__EndpointFeature, SOAP_TYPE__ns1__EndpointFeature, sizeof(_ns1__EndpointFeature), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__EndpointFeature * SOAP_FMAC2 soap_instantiate__ns1__EndpointFeature(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__EndpointFeature(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__EndpointFeature *p;
	size_t k = sizeof(_ns1__EndpointFeature);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__EndpointFeature);
		if (p)
			((_ns1__EndpointFeature*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__EndpointFeature, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__EndpointFeature*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__EndpointFeature location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__EndpointFeature, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__EndpointFeature::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:EndpointFeature", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__EndpointFeature::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__EndpointFeature(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__EndpointFeature * SOAP_FMAC4 soap_get__ns1__EndpointFeature(struct soap *soap, _ns1__EndpointFeature *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__EndpointFeature(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetPortalFeaturesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetPortalFeaturesResponse::__sizePortalFeature = 0;
	this->_ns1__GetPortalFeaturesResponse::PortalFeature = NULL;
	/* transient soap skipped */
}

void _ns1__GetPortalFeaturesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->_ns1__GetPortalFeaturesResponse::PortalFeature)
	{	int i;
		for (i = 0; i < (int)this->_ns1__GetPortalFeaturesResponse::__sizePortalFeature; i++)
		{
			soap_serialize_PointerTo_ns1__PortalFeature(soap, this->_ns1__GetPortalFeaturesResponse::PortalFeature + i);
		}
	}
#endif
}

int _ns1__GetPortalFeaturesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPortalFeaturesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPortalFeaturesResponse(struct soap *soap, const char *tag, int id, const _ns1__GetPortalFeaturesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPortalFeaturesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizePortalFeature");
	if (a->_ns1__GetPortalFeaturesResponse::PortalFeature)
	{	int i;
		for (i = 0; i < (int)a->_ns1__GetPortalFeaturesResponse::__sizePortalFeature; i++)
			if (soap_out_PointerTo_ns1__PortalFeature(soap, "ns1:PortalFeature", -1, a->_ns1__GetPortalFeaturesResponse::PortalFeature + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPortalFeaturesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPortalFeaturesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPortalFeaturesResponse * SOAP_FMAC4 soap_in__ns1__GetPortalFeaturesResponse(struct soap *soap, const char *tag, _ns1__GetPortalFeaturesResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPortalFeaturesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPortalFeaturesResponse, sizeof(_ns1__GetPortalFeaturesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	struct soap_blist *soap_blist_PortalFeature1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:PortalFeature", 1, NULL))
			{	if (a->_ns1__GetPortalFeaturesResponse::PortalFeature == NULL)
				{	if (soap_blist_PortalFeature1 == NULL)
						soap_blist_PortalFeature1 = soap_new_block(soap);
					a->_ns1__GetPortalFeaturesResponse::PortalFeature = (_ns1__PortalFeature **)soap_push_block_max(soap, soap_blist_PortalFeature1, sizeof(_ns1__PortalFeature *));
					if (a->_ns1__GetPortalFeaturesResponse::PortalFeature == NULL)
						return NULL;
					*a->_ns1__GetPortalFeaturesResponse::PortalFeature = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTo_ns1__PortalFeature(soap, "ns1:PortalFeature", a->_ns1__GetPortalFeaturesResponse::PortalFeature, ""))
				{	a->_ns1__GetPortalFeaturesResponse::__sizePortalFeature++;
					a->_ns1__GetPortalFeaturesResponse::PortalFeature = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizePortalFeature");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__GetPortalFeaturesResponse::PortalFeature)
			soap_pop_block(soap, soap_blist_PortalFeature1);
		if (a->_ns1__GetPortalFeaturesResponse::__sizePortalFeature)
		{	a->_ns1__GetPortalFeaturesResponse::PortalFeature = (_ns1__PortalFeature **)soap_save_block(soap, soap_blist_PortalFeature1, NULL, 1);
		}
		else
		{	a->_ns1__GetPortalFeaturesResponse::PortalFeature = NULL;
			if (soap_blist_PortalFeature1)
				soap_end_block(soap, soap_blist_PortalFeature1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->_ns1__GetPortalFeaturesResponse::__sizePortalFeature < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetPortalFeaturesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPortalFeaturesResponse, SOAP_TYPE__ns1__GetPortalFeaturesResponse, sizeof(_ns1__GetPortalFeaturesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetPortalFeaturesResponse * SOAP_FMAC2 soap_instantiate__ns1__GetPortalFeaturesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPortalFeaturesResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetPortalFeaturesResponse *p;
	size_t k = sizeof(_ns1__GetPortalFeaturesResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetPortalFeaturesResponse);
		if (p)
			((_ns1__GetPortalFeaturesResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetPortalFeaturesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetPortalFeaturesResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetPortalFeaturesResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetPortalFeaturesResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetPortalFeaturesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:GetPortalFeaturesResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPortalFeaturesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPortalFeaturesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPortalFeaturesResponse * SOAP_FMAC4 soap_get__ns1__GetPortalFeaturesResponse(struct soap *soap, _ns1__GetPortalFeaturesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPortalFeaturesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__PortalFeature::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__PortalFeatureName(soap, &this->_ns1__PortalFeature::feature);
	soap_default_bool(soap, &this->_ns1__PortalFeature::enable);
	/* transient soap skipped */
}

void _ns1__PortalFeature::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__PortalFeatureName(soap, (char*const*)&this->_ns1__PortalFeature::feature);
	soap_embedded(soap, &this->_ns1__PortalFeature::enable, SOAP_TYPE_bool);
#endif
}

int _ns1__PortalFeature::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__PortalFeature(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__PortalFeature(struct soap *soap, const char *tag, int id, const _ns1__PortalFeature *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__PortalFeature), type))
		return soap->error;
	if (!a->_ns1__PortalFeature::feature)
	{	if (soap_element_nil(soap, "ns1:feature"))
			return soap->error;
	}
	else
	if (soap_out_ns1__PortalFeatureName(soap, "ns1:feature", -1, (char*const*)&a->_ns1__PortalFeature::feature, ""))
		return soap->error;
	if (soap_out_bool(soap, "ns1:enable", -1, &a->_ns1__PortalFeature::enable, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__PortalFeature::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__PortalFeature(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__PortalFeature * SOAP_FMAC4 soap_in__ns1__PortalFeature(struct soap *soap, const char *tag, _ns1__PortalFeature *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__PortalFeature *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__PortalFeature, sizeof(_ns1__PortalFeature), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_feature1 = 1;
	size_t soap_flag_enable1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_feature1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__PortalFeatureName(soap, "ns1:feature", (char**)&a->_ns1__PortalFeature::feature, "ns1:PortalFeatureName"))
				{	soap_flag_feature1--;
					continue;
				}
			if (soap_flag_enable1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:enable", &a->_ns1__PortalFeature::enable, "xsd:boolean"))
				{	soap_flag_enable1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_feature1 > 0 || soap_flag_enable1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__PortalFeature *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__PortalFeature, SOAP_TYPE__ns1__PortalFeature, sizeof(_ns1__PortalFeature), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__PortalFeature * SOAP_FMAC2 soap_instantiate__ns1__PortalFeature(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__PortalFeature(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__PortalFeature *p;
	size_t k = sizeof(_ns1__PortalFeature);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__PortalFeature);
		if (p)
			((_ns1__PortalFeature*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__PortalFeature, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__PortalFeature*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__PortalFeature location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__PortalFeature, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__PortalFeature::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:PortalFeature", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__PortalFeature::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__PortalFeature(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__PortalFeature * SOAP_FMAC4 soap_get__ns1__PortalFeature(struct soap *soap, _ns1__PortalFeature *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__PortalFeature(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__DeleteScheduledRoomResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__DeleteScheduledRoomResponse::OK);
	/* transient soap skipped */
}

void _ns1__DeleteScheduledRoomResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__DeleteScheduledRoomResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DeleteScheduledRoomResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DeleteScheduledRoomResponse(struct soap *soap, const char *tag, int id, const _ns1__DeleteScheduledRoomResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DeleteScheduledRoomResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__DeleteScheduledRoomResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__DeleteScheduledRoomResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DeleteScheduledRoomResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DeleteScheduledRoomResponse * SOAP_FMAC4 soap_in__ns1__DeleteScheduledRoomResponse(struct soap *soap, const char *tag, _ns1__DeleteScheduledRoomResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DeleteScheduledRoomResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DeleteScheduledRoomResponse, sizeof(_ns1__DeleteScheduledRoomResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__DeleteScheduledRoomResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__DeleteScheduledRoomResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DeleteScheduledRoomResponse, SOAP_TYPE__ns1__DeleteScheduledRoomResponse, sizeof(_ns1__DeleteScheduledRoomResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__DeleteScheduledRoomResponse * SOAP_FMAC2 soap_instantiate__ns1__DeleteScheduledRoomResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DeleteScheduledRoomResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__DeleteScheduledRoomResponse *p;
	size_t k = sizeof(_ns1__DeleteScheduledRoomResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__DeleteScheduledRoomResponse);
		if (p)
			((_ns1__DeleteScheduledRoomResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__DeleteScheduledRoomResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__DeleteScheduledRoomResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__DeleteScheduledRoomResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__DeleteScheduledRoomResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__DeleteScheduledRoomResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:DeleteScheduledRoomResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DeleteScheduledRoomResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DeleteScheduledRoomResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DeleteScheduledRoomResponse * SOAP_FMAC4 soap_get__ns1__DeleteScheduledRoomResponse(struct soap *soap, _ns1__DeleteScheduledRoomResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DeleteScheduledRoomResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__DeleteScheduledRoomRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__DeleteScheduledRoomRequest::extension);
	this->_ns1__DeleteScheduledRoomRequest::pin = NULL;
	/* transient soap skipped */
}

void _ns1__DeleteScheduledRoomRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__DeleteScheduledRoomRequest::extension);
	soap_serialize_PointerTostring(soap, &this->_ns1__DeleteScheduledRoomRequest::pin);
#endif
}

int _ns1__DeleteScheduledRoomRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DeleteScheduledRoomRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DeleteScheduledRoomRequest(struct soap *soap, const char *tag, int id, const _ns1__DeleteScheduledRoomRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DeleteScheduledRoomRequest), type))
		return soap->error;
	if (!a->_ns1__DeleteScheduledRoomRequest::extension)
	{	if (soap_element_nil(soap, "ns1:extension"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:extension", -1, (char*const*)&a->_ns1__DeleteScheduledRoomRequest::extension, ""))
		return soap->error;
	if (soap_out_PointerTostring(soap, "ns1:pin", -1, &a->_ns1__DeleteScheduledRoomRequest::pin, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__DeleteScheduledRoomRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DeleteScheduledRoomRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DeleteScheduledRoomRequest * SOAP_FMAC4 soap_in__ns1__DeleteScheduledRoomRequest(struct soap *soap, const char *tag, _ns1__DeleteScheduledRoomRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DeleteScheduledRoomRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DeleteScheduledRoomRequest, sizeof(_ns1__DeleteScheduledRoomRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_extension1 = 1;
	size_t soap_flag_pin1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_extension1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:extension", (char**)&a->_ns1__DeleteScheduledRoomRequest::extension, "xsd:string"))
				{	soap_flag_extension1--;
					continue;
				}
			if (soap_flag_pin1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "ns1:pin", &a->_ns1__DeleteScheduledRoomRequest::pin, "xsd:string"))
				{	soap_flag_pin1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_extension1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__DeleteScheduledRoomRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DeleteScheduledRoomRequest, SOAP_TYPE__ns1__DeleteScheduledRoomRequest, sizeof(_ns1__DeleteScheduledRoomRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__DeleteScheduledRoomRequest * SOAP_FMAC2 soap_instantiate__ns1__DeleteScheduledRoomRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DeleteScheduledRoomRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__DeleteScheduledRoomRequest *p;
	size_t k = sizeof(_ns1__DeleteScheduledRoomRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__DeleteScheduledRoomRequest);
		if (p)
			((_ns1__DeleteScheduledRoomRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__DeleteScheduledRoomRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__DeleteScheduledRoomRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__DeleteScheduledRoomRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__DeleteScheduledRoomRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__DeleteScheduledRoomRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:DeleteScheduledRoomRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DeleteScheduledRoomRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DeleteScheduledRoomRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DeleteScheduledRoomRequest * SOAP_FMAC4 soap_get__ns1__DeleteScheduledRoomRequest(struct soap *soap, _ns1__DeleteScheduledRoomRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DeleteScheduledRoomRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CreateScheduledRoomResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__CreateScheduledRoomResponse::extension);
	this->_ns1__CreateScheduledRoomResponse::pin = NULL;
	soap_default_string(soap, &this->_ns1__CreateScheduledRoomResponse::inviteContent);
	soap_default_xsd__anyURI(soap, &this->_ns1__CreateScheduledRoomResponse::roomURL);
	soap_default_string(soap, &this->_ns1__CreateScheduledRoomResponse::inviteSubject);
	/* transient soap skipped */
}

void _ns1__CreateScheduledRoomResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__CreateScheduledRoomResponse::extension);
	soap_serialize_PointerTostring(soap, &this->_ns1__CreateScheduledRoomResponse::pin);
	soap_serialize_string(soap, (char*const*)&this->_ns1__CreateScheduledRoomResponse::inviteContent);
	soap_serialize_xsd__anyURI(soap, (char*const*)&this->_ns1__CreateScheduledRoomResponse::roomURL);
	soap_serialize_string(soap, (char*const*)&this->_ns1__CreateScheduledRoomResponse::inviteSubject);
#endif
}

int _ns1__CreateScheduledRoomResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CreateScheduledRoomResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CreateScheduledRoomResponse(struct soap *soap, const char *tag, int id, const _ns1__CreateScheduledRoomResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CreateScheduledRoomResponse), type))
		return soap->error;
	if (a->extension)
		soap_element_result(soap, "ns1:extension");
	if (!a->_ns1__CreateScheduledRoomResponse::extension)
	{	if (soap_element_nil(soap, "ns1:extension"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:extension", -1, (char*const*)&a->_ns1__CreateScheduledRoomResponse::extension, ""))
		return soap->error;
	if (soap_out_PointerTostring(soap, "ns1:pin", -1, &a->_ns1__CreateScheduledRoomResponse::pin, ""))
		return soap->error;
	if (!a->_ns1__CreateScheduledRoomResponse::inviteContent)
	{	if (soap_element_nil(soap, "ns1:inviteContent"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:inviteContent", -1, (char*const*)&a->_ns1__CreateScheduledRoomResponse::inviteContent, ""))
		return soap->error;
	if (!a->_ns1__CreateScheduledRoomResponse::roomURL)
	{	if (soap_element_nil(soap, "ns1:roomURL"))
			return soap->error;
	}
	else
	if (soap_out_xsd__anyURI(soap, "ns1:roomURL", -1, (char*const*)&a->_ns1__CreateScheduledRoomResponse::roomURL, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:inviteSubject", -1, (char*const*)&a->_ns1__CreateScheduledRoomResponse::inviteSubject, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CreateScheduledRoomResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CreateScheduledRoomResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CreateScheduledRoomResponse * SOAP_FMAC4 soap_in__ns1__CreateScheduledRoomResponse(struct soap *soap, const char *tag, _ns1__CreateScheduledRoomResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CreateScheduledRoomResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CreateScheduledRoomResponse, sizeof(_ns1__CreateScheduledRoomResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_extension1 = 1;
	size_t soap_flag_pin1 = 1;
	size_t soap_flag_inviteContent1 = 1;
	size_t soap_flag_roomURL1 = 1;
	size_t soap_flag_inviteSubject1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_extension1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:extension", (char**)&a->_ns1__CreateScheduledRoomResponse::extension, "xsd:string"))
				{	soap_flag_extension1--;
					continue;
				}
			if (soap_flag_pin1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "ns1:pin", &a->_ns1__CreateScheduledRoomResponse::pin, "xsd:string"))
				{	soap_flag_pin1--;
					continue;
				}
			if (soap_flag_inviteContent1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:inviteContent", (char**)&a->_ns1__CreateScheduledRoomResponse::inviteContent, "xsd:string"))
				{	soap_flag_inviteContent1--;
					continue;
				}
			if (soap_flag_roomURL1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "ns1:roomURL", (char**)&a->_ns1__CreateScheduledRoomResponse::roomURL, "xsd:anyURI"))
				{	soap_flag_roomURL1--;
					continue;
				}
			if (soap_flag_inviteSubject1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:inviteSubject", (char**)&a->_ns1__CreateScheduledRoomResponse::inviteSubject, "xsd:string"))
				{	soap_flag_inviteSubject1--;
					continue;
				}
			soap_check_result(soap, "ns1:extension");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_extension1 > 0 || soap_flag_inviteContent1 > 0 || soap_flag_roomURL1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__CreateScheduledRoomResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CreateScheduledRoomResponse, SOAP_TYPE__ns1__CreateScheduledRoomResponse, sizeof(_ns1__CreateScheduledRoomResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CreateScheduledRoomResponse * SOAP_FMAC2 soap_instantiate__ns1__CreateScheduledRoomResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CreateScheduledRoomResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CreateScheduledRoomResponse *p;
	size_t k = sizeof(_ns1__CreateScheduledRoomResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__CreateScheduledRoomResponse);
		if (p)
			((_ns1__CreateScheduledRoomResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__CreateScheduledRoomResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__CreateScheduledRoomResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CreateScheduledRoomResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__CreateScheduledRoomResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__CreateScheduledRoomResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:CreateScheduledRoomResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CreateScheduledRoomResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CreateScheduledRoomResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CreateScheduledRoomResponse * SOAP_FMAC4 soap_get__ns1__CreateScheduledRoomResponse(struct soap *soap, _ns1__CreateScheduledRoomResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CreateScheduledRoomResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CreateScheduledRoomRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__CreateScheduledRoomRequest::recurring = NULL;
	this->_ns1__CreateScheduledRoomRequest::setPIN = NULL;
	/* transient soap skipped */
}

void _ns1__CreateScheduledRoomRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &this->_ns1__CreateScheduledRoomRequest::recurring);
	soap_serialize_PointerTobool(soap, &this->_ns1__CreateScheduledRoomRequest::setPIN);
#endif
}

int _ns1__CreateScheduledRoomRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CreateScheduledRoomRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CreateScheduledRoomRequest(struct soap *soap, const char *tag, int id, const _ns1__CreateScheduledRoomRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CreateScheduledRoomRequest), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:recurring", -1, &a->_ns1__CreateScheduledRoomRequest::recurring, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:setPIN", -1, &a->_ns1__CreateScheduledRoomRequest::setPIN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CreateScheduledRoomRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CreateScheduledRoomRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CreateScheduledRoomRequest * SOAP_FMAC4 soap_in__ns1__CreateScheduledRoomRequest(struct soap *soap, const char *tag, _ns1__CreateScheduledRoomRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CreateScheduledRoomRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CreateScheduledRoomRequest, sizeof(_ns1__CreateScheduledRoomRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_recurring1 = 1;
	size_t soap_flag_setPIN1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recurring1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:recurring", &a->_ns1__CreateScheduledRoomRequest::recurring, "xsd:int"))
				{	soap_flag_recurring1--;
					continue;
				}
			if (soap_flag_setPIN1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns1:setPIN", &a->_ns1__CreateScheduledRoomRequest::setPIN, "xsd:boolean"))
				{	soap_flag_setPIN1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CreateScheduledRoomRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CreateScheduledRoomRequest, SOAP_TYPE__ns1__CreateScheduledRoomRequest, sizeof(_ns1__CreateScheduledRoomRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CreateScheduledRoomRequest * SOAP_FMAC2 soap_instantiate__ns1__CreateScheduledRoomRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CreateScheduledRoomRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CreateScheduledRoomRequest *p;
	size_t k = sizeof(_ns1__CreateScheduledRoomRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__CreateScheduledRoomRequest);
		if (p)
			((_ns1__CreateScheduledRoomRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__CreateScheduledRoomRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__CreateScheduledRoomRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CreateScheduledRoomRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__CreateScheduledRoomRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__CreateScheduledRoomRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:CreateScheduledRoomRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CreateScheduledRoomRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CreateScheduledRoomRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CreateScheduledRoomRequest * SOAP_FMAC4 soap_get__ns1__CreateScheduledRoomRequest(struct soap *soap, _ns1__CreateScheduledRoomRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CreateScheduledRoomRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GenerateAuthTokenResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GenerateAuthTokenResponse::authToken);
	/* transient soap skipped */
}

void _ns1__GenerateAuthTokenResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GenerateAuthTokenResponse::authToken);
#endif
}

int _ns1__GenerateAuthTokenResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GenerateAuthTokenResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GenerateAuthTokenResponse(struct soap *soap, const char *tag, int id, const _ns1__GenerateAuthTokenResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GenerateAuthTokenResponse), type))
		return soap->error;
	if (a->authToken)
		soap_element_result(soap, "ns1:authToken");
	if (!a->_ns1__GenerateAuthTokenResponse::authToken)
	{	if (soap_element_nil(soap, "ns1:authToken"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:authToken", -1, (char*const*)&a->_ns1__GenerateAuthTokenResponse::authToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GenerateAuthTokenResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GenerateAuthTokenResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GenerateAuthTokenResponse * SOAP_FMAC4 soap_in__ns1__GenerateAuthTokenResponse(struct soap *soap, const char *tag, _ns1__GenerateAuthTokenResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GenerateAuthTokenResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GenerateAuthTokenResponse, sizeof(_ns1__GenerateAuthTokenResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_authToken1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:authToken", (char**)&a->_ns1__GenerateAuthTokenResponse::authToken, "xsd:string"))
				{	soap_flag_authToken1--;
					continue;
				}
			soap_check_result(soap, "ns1:authToken");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_authToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GenerateAuthTokenResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GenerateAuthTokenResponse, SOAP_TYPE__ns1__GenerateAuthTokenResponse, sizeof(_ns1__GenerateAuthTokenResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GenerateAuthTokenResponse * SOAP_FMAC2 soap_instantiate__ns1__GenerateAuthTokenResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GenerateAuthTokenResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GenerateAuthTokenResponse *p;
	size_t k = sizeof(_ns1__GenerateAuthTokenResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GenerateAuthTokenResponse);
		if (p)
			((_ns1__GenerateAuthTokenResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GenerateAuthTokenResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GenerateAuthTokenResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GenerateAuthTokenResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GenerateAuthTokenResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GenerateAuthTokenResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:GenerateAuthTokenResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GenerateAuthTokenResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GenerateAuthTokenResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GenerateAuthTokenResponse * SOAP_FMAC4 soap_get__ns1__GenerateAuthTokenResponse(struct soap *soap, _ns1__GenerateAuthTokenResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GenerateAuthTokenResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GenerateAuthTokenRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GenerateAuthTokenRequest::validityTime);
	soap_default_string(soap, &this->_ns1__GenerateAuthTokenRequest::endpointId);
	/* transient soap skipped */
}

void _ns1__GenerateAuthTokenRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns1__GenerateAuthTokenRequest::validityTime, SOAP_TYPE_int);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GenerateAuthTokenRequest::endpointId);
#endif
}

int _ns1__GenerateAuthTokenRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GenerateAuthTokenRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GenerateAuthTokenRequest(struct soap *soap, const char *tag, int id, const _ns1__GenerateAuthTokenRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GenerateAuthTokenRequest), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:validityTime", -1, &a->_ns1__GenerateAuthTokenRequest::validityTime, ""))
		return soap->error;
	if (!a->_ns1__GenerateAuthTokenRequest::endpointId)
	{	if (soap_element_nil(soap, "ns1:endpointId"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:endpointId", -1, (char*const*)&a->_ns1__GenerateAuthTokenRequest::endpointId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GenerateAuthTokenRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GenerateAuthTokenRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GenerateAuthTokenRequest * SOAP_FMAC4 soap_in__ns1__GenerateAuthTokenRequest(struct soap *soap, const char *tag, _ns1__GenerateAuthTokenRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GenerateAuthTokenRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GenerateAuthTokenRequest, sizeof(_ns1__GenerateAuthTokenRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_validityTime1 = 1;
	size_t soap_flag_endpointId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_validityTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:validityTime", &a->_ns1__GenerateAuthTokenRequest::validityTime, "xsd:int"))
				{	soap_flag_validityTime1--;
					continue;
				}
			if (soap_flag_endpointId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:endpointId", (char**)&a->_ns1__GenerateAuthTokenRequest::endpointId, "xsd:string"))
				{	soap_flag_endpointId1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_validityTime1 > 0 || soap_flag_endpointId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GenerateAuthTokenRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GenerateAuthTokenRequest, SOAP_TYPE__ns1__GenerateAuthTokenRequest, sizeof(_ns1__GenerateAuthTokenRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GenerateAuthTokenRequest * SOAP_FMAC2 soap_instantiate__ns1__GenerateAuthTokenRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GenerateAuthTokenRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GenerateAuthTokenRequest *p;
	size_t k = sizeof(_ns1__GenerateAuthTokenRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GenerateAuthTokenRequest);
		if (p)
			((_ns1__GenerateAuthTokenRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GenerateAuthTokenRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GenerateAuthTokenRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GenerateAuthTokenRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GenerateAuthTokenRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GenerateAuthTokenRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:GenerateAuthTokenRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GenerateAuthTokenRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GenerateAuthTokenRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GenerateAuthTokenRequest * SOAP_FMAC4 soap_get__ns1__GenerateAuthTokenRequest(struct soap *soap, _ns1__GenerateAuthTokenRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GenerateAuthTokenRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetConferenceIDResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__GetConferenceIDResponse::conferenceID);
	/* transient soap skipped */
}

void _ns1__GetConferenceIDResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__GetConferenceIDResponse::conferenceID);
#endif
}

int _ns1__GetConferenceIDResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetConferenceIDResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetConferenceIDResponse(struct soap *soap, const char *tag, int id, const _ns1__GetConferenceIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetConferenceIDResponse), type))
		return soap->error;
	if (a->conferenceID)
		soap_element_result(soap, "ns1:conferenceID");
	if (soap_out_ns1__EntityID(soap, "ns1:conferenceID", -1, (char*const*)&a->_ns1__GetConferenceIDResponse::conferenceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetConferenceIDResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetConferenceIDResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetConferenceIDResponse * SOAP_FMAC4 soap_in__ns1__GetConferenceIDResponse(struct soap *soap, const char *tag, _ns1__GetConferenceIDResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetConferenceIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetConferenceIDResponse, sizeof(_ns1__GetConferenceIDResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_conferenceID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_conferenceID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:conferenceID", (char**)&a->_ns1__GetConferenceIDResponse::conferenceID, "ns1:EntityID"))
				{	soap_flag_conferenceID1--;
					continue;
				}
			soap_check_result(soap, "ns1:conferenceID");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetConferenceIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetConferenceIDResponse, SOAP_TYPE__ns1__GetConferenceIDResponse, sizeof(_ns1__GetConferenceIDResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetConferenceIDResponse * SOAP_FMAC2 soap_instantiate__ns1__GetConferenceIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetConferenceIDResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetConferenceIDResponse *p;
	size_t k = sizeof(_ns1__GetConferenceIDResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetConferenceIDResponse);
		if (p)
			((_ns1__GetConferenceIDResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetConferenceIDResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetConferenceIDResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetConferenceIDResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetConferenceIDResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetConferenceIDResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:GetConferenceIDResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetConferenceIDResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetConferenceIDResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetConferenceIDResponse * SOAP_FMAC4 soap_get__ns1__GetConferenceIDResponse(struct soap *soap, _ns1__GetConferenceIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetConferenceIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetConferenceIDRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__GetConferenceIDRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__GetConferenceIDRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetConferenceIDRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetConferenceIDRequest(struct soap *soap, const char *tag, int id, const _ns1__GetConferenceIDRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetConferenceIDRequest), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetConferenceIDRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetConferenceIDRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetConferenceIDRequest * SOAP_FMAC4 soap_in__ns1__GetConferenceIDRequest(struct soap *soap, const char *tag, _ns1__GetConferenceIDRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetConferenceIDRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetConferenceIDRequest, sizeof(_ns1__GetConferenceIDRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetConferenceIDRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetConferenceIDRequest, SOAP_TYPE__ns1__GetConferenceIDRequest, sizeof(_ns1__GetConferenceIDRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetConferenceIDRequest * SOAP_FMAC2 soap_instantiate__ns1__GetConferenceIDRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetConferenceIDRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetConferenceIDRequest *p;
	size_t k = sizeof(_ns1__GetConferenceIDRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetConferenceIDRequest);
		if (p)
			((_ns1__GetConferenceIDRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetConferenceIDRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetConferenceIDRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetConferenceIDRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetConferenceIDRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetConferenceIDRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:GetConferenceIDRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetConferenceIDRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetConferenceIDRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetConferenceIDRequest * SOAP_FMAC4 soap_get__ns1__GetConferenceIDRequest(struct soap *soap, _ns1__GetConferenceIDRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetConferenceIDRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__RemoveModeratorPINResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__RemoveModeratorPINResponse::OK);
	/* transient soap skipped */
}

void _ns1__RemoveModeratorPINResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__RemoveModeratorPINResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RemoveModeratorPINResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RemoveModeratorPINResponse(struct soap *soap, const char *tag, int id, const _ns1__RemoveModeratorPINResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RemoveModeratorPINResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__RemoveModeratorPINResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__RemoveModeratorPINResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RemoveModeratorPINResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RemoveModeratorPINResponse * SOAP_FMAC4 soap_in__ns1__RemoveModeratorPINResponse(struct soap *soap, const char *tag, _ns1__RemoveModeratorPINResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RemoveModeratorPINResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RemoveModeratorPINResponse, sizeof(_ns1__RemoveModeratorPINResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__RemoveModeratorPINResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__RemoveModeratorPINResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RemoveModeratorPINResponse, SOAP_TYPE__ns1__RemoveModeratorPINResponse, sizeof(_ns1__RemoveModeratorPINResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__RemoveModeratorPINResponse * SOAP_FMAC2 soap_instantiate__ns1__RemoveModeratorPINResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RemoveModeratorPINResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__RemoveModeratorPINResponse *p;
	size_t k = sizeof(_ns1__RemoveModeratorPINResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__RemoveModeratorPINResponse);
		if (p)
			((_ns1__RemoveModeratorPINResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__RemoveModeratorPINResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__RemoveModeratorPINResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__RemoveModeratorPINResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__RemoveModeratorPINResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__RemoveModeratorPINResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:RemoveModeratorPINResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RemoveModeratorPINResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RemoveModeratorPINResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RemoveModeratorPINResponse * SOAP_FMAC4 soap_get__ns1__RemoveModeratorPINResponse(struct soap *soap, _ns1__RemoveModeratorPINResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RemoveModeratorPINResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__RemoveModeratorPINRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__RemoveModeratorPINRequest::roomID);
	/* transient soap skipped */
}

void _ns1__RemoveModeratorPINRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__RemoveModeratorPINRequest::roomID);
#endif
}

int _ns1__RemoveModeratorPINRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RemoveModeratorPINRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RemoveModeratorPINRequest(struct soap *soap, const char *tag, int id, const _ns1__RemoveModeratorPINRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RemoveModeratorPINRequest), type))
		return soap->error;
	if (!a->_ns1__RemoveModeratorPINRequest::roomID)
	{	if (soap_element_nil(soap, "ns1:roomID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:roomID", -1, (char*const*)&a->_ns1__RemoveModeratorPINRequest::roomID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__RemoveModeratorPINRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RemoveModeratorPINRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RemoveModeratorPINRequest * SOAP_FMAC4 soap_in__ns1__RemoveModeratorPINRequest(struct soap *soap, const char *tag, _ns1__RemoveModeratorPINRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RemoveModeratorPINRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RemoveModeratorPINRequest, sizeof(_ns1__RemoveModeratorPINRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_roomID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_roomID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:roomID", (char**)&a->_ns1__RemoveModeratorPINRequest::roomID, "ns1:EntityID"))
				{	soap_flag_roomID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_roomID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__RemoveModeratorPINRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RemoveModeratorPINRequest, SOAP_TYPE__ns1__RemoveModeratorPINRequest, sizeof(_ns1__RemoveModeratorPINRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__RemoveModeratorPINRequest * SOAP_FMAC2 soap_instantiate__ns1__RemoveModeratorPINRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RemoveModeratorPINRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__RemoveModeratorPINRequest *p;
	size_t k = sizeof(_ns1__RemoveModeratorPINRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__RemoveModeratorPINRequest);
		if (p)
			((_ns1__RemoveModeratorPINRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__RemoveModeratorPINRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__RemoveModeratorPINRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__RemoveModeratorPINRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__RemoveModeratorPINRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__RemoveModeratorPINRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:RemoveModeratorPINRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RemoveModeratorPINRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RemoveModeratorPINRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RemoveModeratorPINRequest * SOAP_FMAC4 soap_get__ns1__RemoveModeratorPINRequest(struct soap *soap, _ns1__RemoveModeratorPINRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RemoveModeratorPINRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CreateModeratorPINResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__CreateModeratorPINResponse::OK);
	/* transient soap skipped */
}

void _ns1__CreateModeratorPINResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__CreateModeratorPINResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CreateModeratorPINResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CreateModeratorPINResponse(struct soap *soap, const char *tag, int id, const _ns1__CreateModeratorPINResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CreateModeratorPINResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__CreateModeratorPINResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CreateModeratorPINResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CreateModeratorPINResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CreateModeratorPINResponse * SOAP_FMAC4 soap_in__ns1__CreateModeratorPINResponse(struct soap *soap, const char *tag, _ns1__CreateModeratorPINResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CreateModeratorPINResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CreateModeratorPINResponse, sizeof(_ns1__CreateModeratorPINResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__CreateModeratorPINResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__CreateModeratorPINResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CreateModeratorPINResponse, SOAP_TYPE__ns1__CreateModeratorPINResponse, sizeof(_ns1__CreateModeratorPINResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CreateModeratorPINResponse * SOAP_FMAC2 soap_instantiate__ns1__CreateModeratorPINResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CreateModeratorPINResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CreateModeratorPINResponse *p;
	size_t k = sizeof(_ns1__CreateModeratorPINResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__CreateModeratorPINResponse);
		if (p)
			((_ns1__CreateModeratorPINResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__CreateModeratorPINResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__CreateModeratorPINResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CreateModeratorPINResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__CreateModeratorPINResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__CreateModeratorPINResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:CreateModeratorPINResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CreateModeratorPINResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CreateModeratorPINResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CreateModeratorPINResponse * SOAP_FMAC4 soap_get__ns1__CreateModeratorPINResponse(struct soap *soap, _ns1__CreateModeratorPINResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CreateModeratorPINResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CreateModeratorPINRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__CreateModeratorPINRequest::roomID);
	soap_default_string(soap, &this->_ns1__CreateModeratorPINRequest::PIN);
	/* transient soap skipped */
}

void _ns1__CreateModeratorPINRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__CreateModeratorPINRequest::roomID);
	soap_serialize_string(soap, (char*const*)&this->_ns1__CreateModeratorPINRequest::PIN);
#endif
}

int _ns1__CreateModeratorPINRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CreateModeratorPINRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CreateModeratorPINRequest(struct soap *soap, const char *tag, int id, const _ns1__CreateModeratorPINRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CreateModeratorPINRequest), type))
		return soap->error;
	if (!a->_ns1__CreateModeratorPINRequest::roomID)
	{	if (soap_element_nil(soap, "ns1:roomID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:roomID", -1, (char*const*)&a->_ns1__CreateModeratorPINRequest::roomID, ""))
		return soap->error;
	if (!a->_ns1__CreateModeratorPINRequest::PIN)
	{	if (soap_element_nil(soap, "ns1:PIN"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:PIN", -1, (char*const*)&a->_ns1__CreateModeratorPINRequest::PIN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CreateModeratorPINRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CreateModeratorPINRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CreateModeratorPINRequest * SOAP_FMAC4 soap_in__ns1__CreateModeratorPINRequest(struct soap *soap, const char *tag, _ns1__CreateModeratorPINRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CreateModeratorPINRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CreateModeratorPINRequest, sizeof(_ns1__CreateModeratorPINRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_roomID1 = 1;
	size_t soap_flag_PIN1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_roomID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:roomID", (char**)&a->_ns1__CreateModeratorPINRequest::roomID, "ns1:EntityID"))
				{	soap_flag_roomID1--;
					continue;
				}
			if (soap_flag_PIN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:PIN", (char**)&a->_ns1__CreateModeratorPINRequest::PIN, "xsd:string"))
				{	soap_flag_PIN1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_roomID1 > 0 || soap_flag_PIN1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__CreateModeratorPINRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CreateModeratorPINRequest, SOAP_TYPE__ns1__CreateModeratorPINRequest, sizeof(_ns1__CreateModeratorPINRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CreateModeratorPINRequest * SOAP_FMAC2 soap_instantiate__ns1__CreateModeratorPINRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CreateModeratorPINRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CreateModeratorPINRequest *p;
	size_t k = sizeof(_ns1__CreateModeratorPINRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__CreateModeratorPINRequest);
		if (p)
			((_ns1__CreateModeratorPINRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__CreateModeratorPINRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__CreateModeratorPINRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CreateModeratorPINRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__CreateModeratorPINRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__CreateModeratorPINRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:CreateModeratorPINRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CreateModeratorPINRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CreateModeratorPINRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CreateModeratorPINRequest * SOAP_FMAC4 soap_get__ns1__CreateModeratorPINRequest(struct soap *soap, _ns1__CreateModeratorPINRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CreateModeratorPINRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetModeratorURLWithTokenResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetModeratorURLWithTokenResponse::moderatorURL);
	/* transient soap skipped */
}

void _ns1__GetModeratorURLWithTokenResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetModeratorURLWithTokenResponse::moderatorURL);
#endif
}

int _ns1__GetModeratorURLWithTokenResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetModeratorURLWithTokenResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetModeratorURLWithTokenResponse(struct soap *soap, const char *tag, int id, const _ns1__GetModeratorURLWithTokenResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetModeratorURLWithTokenResponse), type))
		return soap->error;
	if (a->moderatorURL)
		soap_element_result(soap, "ns1:moderatorURL");
	if (!a->_ns1__GetModeratorURLWithTokenResponse::moderatorURL)
	{	if (soap_element_nil(soap, "ns1:moderatorURL"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:moderatorURL", -1, (char*const*)&a->_ns1__GetModeratorURLWithTokenResponse::moderatorURL, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetModeratorURLWithTokenResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetModeratorURLWithTokenResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetModeratorURLWithTokenResponse * SOAP_FMAC4 soap_in__ns1__GetModeratorURLWithTokenResponse(struct soap *soap, const char *tag, _ns1__GetModeratorURLWithTokenResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetModeratorURLWithTokenResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetModeratorURLWithTokenResponse, sizeof(_ns1__GetModeratorURLWithTokenResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_moderatorURL1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_moderatorURL1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:moderatorURL", (char**)&a->_ns1__GetModeratorURLWithTokenResponse::moderatorURL, "xsd:string"))
				{	soap_flag_moderatorURL1--;
					continue;
				}
			soap_check_result(soap, "ns1:moderatorURL");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_moderatorURL1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetModeratorURLWithTokenResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetModeratorURLWithTokenResponse, SOAP_TYPE__ns1__GetModeratorURLWithTokenResponse, sizeof(_ns1__GetModeratorURLWithTokenResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetModeratorURLWithTokenResponse * SOAP_FMAC2 soap_instantiate__ns1__GetModeratorURLWithTokenResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetModeratorURLWithTokenResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetModeratorURLWithTokenResponse *p;
	size_t k = sizeof(_ns1__GetModeratorURLWithTokenResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetModeratorURLWithTokenResponse);
		if (p)
			((_ns1__GetModeratorURLWithTokenResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetModeratorURLWithTokenResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetModeratorURLWithTokenResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetModeratorURLWithTokenResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetModeratorURLWithTokenResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetModeratorURLWithTokenResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:GetModeratorURLWithTokenResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetModeratorURLWithTokenResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetModeratorURLWithTokenResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetModeratorURLWithTokenResponse * SOAP_FMAC4 soap_get__ns1__GetModeratorURLWithTokenResponse(struct soap *soap, _ns1__GetModeratorURLWithTokenResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetModeratorURLWithTokenResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetModeratorURLWithTokenRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__GetModeratorURLWithTokenRequest::roomID);
	/* transient soap skipped */
}

void _ns1__GetModeratorURLWithTokenRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__GetModeratorURLWithTokenRequest::roomID);
#endif
}

int _ns1__GetModeratorURLWithTokenRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetModeratorURLWithTokenRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetModeratorURLWithTokenRequest(struct soap *soap, const char *tag, int id, const _ns1__GetModeratorURLWithTokenRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetModeratorURLWithTokenRequest), type))
		return soap->error;
	if (!a->_ns1__GetModeratorURLWithTokenRequest::roomID)
	{	if (soap_element_nil(soap, "ns1:roomID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:roomID", -1, (char*const*)&a->_ns1__GetModeratorURLWithTokenRequest::roomID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetModeratorURLWithTokenRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetModeratorURLWithTokenRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetModeratorURLWithTokenRequest * SOAP_FMAC4 soap_in__ns1__GetModeratorURLWithTokenRequest(struct soap *soap, const char *tag, _ns1__GetModeratorURLWithTokenRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetModeratorURLWithTokenRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetModeratorURLWithTokenRequest, sizeof(_ns1__GetModeratorURLWithTokenRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_roomID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_roomID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:roomID", (char**)&a->_ns1__GetModeratorURLWithTokenRequest::roomID, "ns1:EntityID"))
				{	soap_flag_roomID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_roomID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetModeratorURLWithTokenRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetModeratorURLWithTokenRequest, SOAP_TYPE__ns1__GetModeratorURLWithTokenRequest, sizeof(_ns1__GetModeratorURLWithTokenRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetModeratorURLWithTokenRequest * SOAP_FMAC2 soap_instantiate__ns1__GetModeratorURLWithTokenRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetModeratorURLWithTokenRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetModeratorURLWithTokenRequest *p;
	size_t k = sizeof(_ns1__GetModeratorURLWithTokenRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetModeratorURLWithTokenRequest);
		if (p)
			((_ns1__GetModeratorURLWithTokenRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetModeratorURLWithTokenRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetModeratorURLWithTokenRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetModeratorURLWithTokenRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetModeratorURLWithTokenRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetModeratorURLWithTokenRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:GetModeratorURLWithTokenRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetModeratorURLWithTokenRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetModeratorURLWithTokenRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetModeratorURLWithTokenRequest * SOAP_FMAC4 soap_get__ns1__GetModeratorURLWithTokenRequest(struct soap *soap, _ns1__GetModeratorURLWithTokenRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetModeratorURLWithTokenRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetModeratorURLResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetModeratorURLResponse::moderatorURL);
	this->_ns1__GetModeratorURLResponse::hasModeratorPIN = NULL;
	/* transient soap skipped */
}

void _ns1__GetModeratorURLResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetModeratorURLResponse::moderatorURL);
	soap_serialize_PointerTobool(soap, &this->_ns1__GetModeratorURLResponse::hasModeratorPIN);
#endif
}

int _ns1__GetModeratorURLResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetModeratorURLResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetModeratorURLResponse(struct soap *soap, const char *tag, int id, const _ns1__GetModeratorURLResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetModeratorURLResponse), type))
		return soap->error;
	if (a->moderatorURL)
		soap_element_result(soap, "ns1:moderatorURL");
	if (soap_out_string(soap, "ns1:moderatorURL", -1, (char*const*)&a->_ns1__GetModeratorURLResponse::moderatorURL, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:hasModeratorPIN", -1, &a->_ns1__GetModeratorURLResponse::hasModeratorPIN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetModeratorURLResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetModeratorURLResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetModeratorURLResponse * SOAP_FMAC4 soap_in__ns1__GetModeratorURLResponse(struct soap *soap, const char *tag, _ns1__GetModeratorURLResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetModeratorURLResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetModeratorURLResponse, sizeof(_ns1__GetModeratorURLResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_moderatorURL1 = 1;
	size_t soap_flag_hasModeratorPIN1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_moderatorURL1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:moderatorURL", (char**)&a->_ns1__GetModeratorURLResponse::moderatorURL, "xsd:string"))
				{	soap_flag_moderatorURL1--;
					continue;
				}
			if (soap_flag_hasModeratorPIN1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns1:hasModeratorPIN", &a->_ns1__GetModeratorURLResponse::hasModeratorPIN, "xsd:boolean"))
				{	soap_flag_hasModeratorPIN1--;
					continue;
				}
			soap_check_result(soap, "ns1:moderatorURL");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetModeratorURLResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetModeratorURLResponse, SOAP_TYPE__ns1__GetModeratorURLResponse, sizeof(_ns1__GetModeratorURLResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetModeratorURLResponse * SOAP_FMAC2 soap_instantiate__ns1__GetModeratorURLResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetModeratorURLResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetModeratorURLResponse *p;
	size_t k = sizeof(_ns1__GetModeratorURLResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetModeratorURLResponse);
		if (p)
			((_ns1__GetModeratorURLResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetModeratorURLResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetModeratorURLResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetModeratorURLResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetModeratorURLResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetModeratorURLResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:GetModeratorURLResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetModeratorURLResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetModeratorURLResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetModeratorURLResponse * SOAP_FMAC4 soap_get__ns1__GetModeratorURLResponse(struct soap *soap, _ns1__GetModeratorURLResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetModeratorURLResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetModeratorURLRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__GetModeratorURLRequest::roomID);
	/* transient soap skipped */
}

void _ns1__GetModeratorURLRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__GetModeratorURLRequest::roomID);
#endif
}

int _ns1__GetModeratorURLRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetModeratorURLRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetModeratorURLRequest(struct soap *soap, const char *tag, int id, const _ns1__GetModeratorURLRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetModeratorURLRequest), type))
		return soap->error;
	if (!a->_ns1__GetModeratorURLRequest::roomID)
	{	if (soap_element_nil(soap, "ns1:roomID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:roomID", -1, (char*const*)&a->_ns1__GetModeratorURLRequest::roomID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetModeratorURLRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetModeratorURLRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetModeratorURLRequest * SOAP_FMAC4 soap_in__ns1__GetModeratorURLRequest(struct soap *soap, const char *tag, _ns1__GetModeratorURLRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetModeratorURLRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetModeratorURLRequest, sizeof(_ns1__GetModeratorURLRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_roomID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_roomID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:roomID", (char**)&a->_ns1__GetModeratorURLRequest::roomID, "ns1:EntityID"))
				{	soap_flag_roomID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_roomID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetModeratorURLRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetModeratorURLRequest, SOAP_TYPE__ns1__GetModeratorURLRequest, sizeof(_ns1__GetModeratorURLRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetModeratorURLRequest * SOAP_FMAC2 soap_instantiate__ns1__GetModeratorURLRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetModeratorURLRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetModeratorURLRequest *p;
	size_t k = sizeof(_ns1__GetModeratorURLRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetModeratorURLRequest);
		if (p)
			((_ns1__GetModeratorURLRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetModeratorURLRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetModeratorURLRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetModeratorURLRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetModeratorURLRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetModeratorURLRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:GetModeratorURLRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetModeratorURLRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetModeratorURLRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetModeratorURLRequest * SOAP_FMAC4 soap_get__ns1__GetModeratorURLRequest(struct soap *soap, _ns1__GetModeratorURLRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetModeratorURLRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__RemoveModeratorURLResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__RemoveModeratorURLResponse::OK);
	/* transient soap skipped */
}

void _ns1__RemoveModeratorURLResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__RemoveModeratorURLResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RemoveModeratorURLResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RemoveModeratorURLResponse(struct soap *soap, const char *tag, int id, const _ns1__RemoveModeratorURLResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RemoveModeratorURLResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__RemoveModeratorURLResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__RemoveModeratorURLResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RemoveModeratorURLResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RemoveModeratorURLResponse * SOAP_FMAC4 soap_in__ns1__RemoveModeratorURLResponse(struct soap *soap, const char *tag, _ns1__RemoveModeratorURLResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RemoveModeratorURLResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RemoveModeratorURLResponse, sizeof(_ns1__RemoveModeratorURLResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__RemoveModeratorURLResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__RemoveModeratorURLResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RemoveModeratorURLResponse, SOAP_TYPE__ns1__RemoveModeratorURLResponse, sizeof(_ns1__RemoveModeratorURLResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__RemoveModeratorURLResponse * SOAP_FMAC2 soap_instantiate__ns1__RemoveModeratorURLResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RemoveModeratorURLResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__RemoveModeratorURLResponse *p;
	size_t k = sizeof(_ns1__RemoveModeratorURLResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__RemoveModeratorURLResponse);
		if (p)
			((_ns1__RemoveModeratorURLResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__RemoveModeratorURLResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__RemoveModeratorURLResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__RemoveModeratorURLResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__RemoveModeratorURLResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__RemoveModeratorURLResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:RemoveModeratorURLResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RemoveModeratorURLResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RemoveModeratorURLResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RemoveModeratorURLResponse * SOAP_FMAC4 soap_get__ns1__RemoveModeratorURLResponse(struct soap *soap, _ns1__RemoveModeratorURLResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RemoveModeratorURLResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__RemoveModeratorURLRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__RemoveModeratorURLRequest::roomID);
	/* transient soap skipped */
}

void _ns1__RemoveModeratorURLRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__RemoveModeratorURLRequest::roomID);
#endif
}

int _ns1__RemoveModeratorURLRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RemoveModeratorURLRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RemoveModeratorURLRequest(struct soap *soap, const char *tag, int id, const _ns1__RemoveModeratorURLRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RemoveModeratorURLRequest), type))
		return soap->error;
	if (!a->_ns1__RemoveModeratorURLRequest::roomID)
	{	if (soap_element_nil(soap, "ns1:roomID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:roomID", -1, (char*const*)&a->_ns1__RemoveModeratorURLRequest::roomID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__RemoveModeratorURLRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RemoveModeratorURLRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RemoveModeratorURLRequest * SOAP_FMAC4 soap_in__ns1__RemoveModeratorURLRequest(struct soap *soap, const char *tag, _ns1__RemoveModeratorURLRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RemoveModeratorURLRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RemoveModeratorURLRequest, sizeof(_ns1__RemoveModeratorURLRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_roomID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_roomID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:roomID", (char**)&a->_ns1__RemoveModeratorURLRequest::roomID, "ns1:EntityID"))
				{	soap_flag_roomID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_roomID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__RemoveModeratorURLRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RemoveModeratorURLRequest, SOAP_TYPE__ns1__RemoveModeratorURLRequest, sizeof(_ns1__RemoveModeratorURLRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__RemoveModeratorURLRequest * SOAP_FMAC2 soap_instantiate__ns1__RemoveModeratorURLRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RemoveModeratorURLRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__RemoveModeratorURLRequest *p;
	size_t k = sizeof(_ns1__RemoveModeratorURLRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__RemoveModeratorURLRequest);
		if (p)
			((_ns1__RemoveModeratorURLRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__RemoveModeratorURLRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__RemoveModeratorURLRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__RemoveModeratorURLRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__RemoveModeratorURLRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__RemoveModeratorURLRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:RemoveModeratorURLRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RemoveModeratorURLRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RemoveModeratorURLRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RemoveModeratorURLRequest * SOAP_FMAC4 soap_get__ns1__RemoveModeratorURLRequest(struct soap *soap, _ns1__RemoveModeratorURLRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RemoveModeratorURLRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CreateModeratorURLResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__CreateModeratorURLResponse::OK);
	/* transient soap skipped */
}

void _ns1__CreateModeratorURLResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__CreateModeratorURLResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CreateModeratorURLResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CreateModeratorURLResponse(struct soap *soap, const char *tag, int id, const _ns1__CreateModeratorURLResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CreateModeratorURLResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__CreateModeratorURLResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CreateModeratorURLResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CreateModeratorURLResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CreateModeratorURLResponse * SOAP_FMAC4 soap_in__ns1__CreateModeratorURLResponse(struct soap *soap, const char *tag, _ns1__CreateModeratorURLResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CreateModeratorURLResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CreateModeratorURLResponse, sizeof(_ns1__CreateModeratorURLResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__CreateModeratorURLResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__CreateModeratorURLResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CreateModeratorURLResponse, SOAP_TYPE__ns1__CreateModeratorURLResponse, sizeof(_ns1__CreateModeratorURLResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CreateModeratorURLResponse * SOAP_FMAC2 soap_instantiate__ns1__CreateModeratorURLResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CreateModeratorURLResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CreateModeratorURLResponse *p;
	size_t k = sizeof(_ns1__CreateModeratorURLResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__CreateModeratorURLResponse);
		if (p)
			((_ns1__CreateModeratorURLResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__CreateModeratorURLResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__CreateModeratorURLResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CreateModeratorURLResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__CreateModeratorURLResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__CreateModeratorURLResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:CreateModeratorURLResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CreateModeratorURLResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CreateModeratorURLResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CreateModeratorURLResponse * SOAP_FMAC4 soap_get__ns1__CreateModeratorURLResponse(struct soap *soap, _ns1__CreateModeratorURLResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CreateModeratorURLResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CreateModeratorURLRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__CreateModeratorURLRequest::roomID);
	/* transient soap skipped */
}

void _ns1__CreateModeratorURLRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__CreateModeratorURLRequest::roomID);
#endif
}

int _ns1__CreateModeratorURLRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CreateModeratorURLRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CreateModeratorURLRequest(struct soap *soap, const char *tag, int id, const _ns1__CreateModeratorURLRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CreateModeratorURLRequest), type))
		return soap->error;
	if (!a->_ns1__CreateModeratorURLRequest::roomID)
	{	if (soap_element_nil(soap, "ns1:roomID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:roomID", -1, (char*const*)&a->_ns1__CreateModeratorURLRequest::roomID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CreateModeratorURLRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CreateModeratorURLRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CreateModeratorURLRequest * SOAP_FMAC4 soap_in__ns1__CreateModeratorURLRequest(struct soap *soap, const char *tag, _ns1__CreateModeratorURLRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CreateModeratorURLRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CreateModeratorURLRequest, sizeof(_ns1__CreateModeratorURLRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_roomID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_roomID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:roomID", (char**)&a->_ns1__CreateModeratorURLRequest::roomID, "ns1:EntityID"))
				{	soap_flag_roomID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_roomID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__CreateModeratorURLRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CreateModeratorURLRequest, SOAP_TYPE__ns1__CreateModeratorURLRequest, sizeof(_ns1__CreateModeratorURLRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CreateModeratorURLRequest * SOAP_FMAC2 soap_instantiate__ns1__CreateModeratorURLRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CreateModeratorURLRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CreateModeratorURLRequest *p;
	size_t k = sizeof(_ns1__CreateModeratorURLRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__CreateModeratorURLRequest);
		if (p)
			((_ns1__CreateModeratorURLRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__CreateModeratorURLRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__CreateModeratorURLRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CreateModeratorURLRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__CreateModeratorURLRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__CreateModeratorURLRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:CreateModeratorURLRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CreateModeratorURLRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CreateModeratorURLRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CreateModeratorURLRequest * SOAP_FMAC4 soap_get__ns1__CreateModeratorURLRequest(struct soap *soap, _ns1__CreateModeratorURLRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CreateModeratorURLRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__RemoveRoomProfileResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__RemoveRoomProfileResponse::OK);
	/* transient soap skipped */
}

void _ns1__RemoveRoomProfileResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__RemoveRoomProfileResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RemoveRoomProfileResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RemoveRoomProfileResponse(struct soap *soap, const char *tag, int id, const _ns1__RemoveRoomProfileResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RemoveRoomProfileResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__RemoveRoomProfileResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__RemoveRoomProfileResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RemoveRoomProfileResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RemoveRoomProfileResponse * SOAP_FMAC4 soap_in__ns1__RemoveRoomProfileResponse(struct soap *soap, const char *tag, _ns1__RemoveRoomProfileResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RemoveRoomProfileResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RemoveRoomProfileResponse, sizeof(_ns1__RemoveRoomProfileResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__RemoveRoomProfileResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__RemoveRoomProfileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RemoveRoomProfileResponse, SOAP_TYPE__ns1__RemoveRoomProfileResponse, sizeof(_ns1__RemoveRoomProfileResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__RemoveRoomProfileResponse * SOAP_FMAC2 soap_instantiate__ns1__RemoveRoomProfileResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RemoveRoomProfileResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__RemoveRoomProfileResponse *p;
	size_t k = sizeof(_ns1__RemoveRoomProfileResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__RemoveRoomProfileResponse);
		if (p)
			((_ns1__RemoveRoomProfileResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__RemoveRoomProfileResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__RemoveRoomProfileResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__RemoveRoomProfileResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__RemoveRoomProfileResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__RemoveRoomProfileResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:RemoveRoomProfileResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RemoveRoomProfileResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RemoveRoomProfileResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RemoveRoomProfileResponse * SOAP_FMAC4 soap_get__ns1__RemoveRoomProfileResponse(struct soap *soap, _ns1__RemoveRoomProfileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RemoveRoomProfileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__RemoveRoomProfileRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__RemoveRoomProfileRequest::roomID);
	/* transient soap skipped */
}

void _ns1__RemoveRoomProfileRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__RemoveRoomProfileRequest::roomID);
#endif
}

int _ns1__RemoveRoomProfileRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RemoveRoomProfileRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RemoveRoomProfileRequest(struct soap *soap, const char *tag, int id, const _ns1__RemoveRoomProfileRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RemoveRoomProfileRequest), type))
		return soap->error;
	if (!a->_ns1__RemoveRoomProfileRequest::roomID)
	{	if (soap_element_nil(soap, "ns1:roomID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:roomID", -1, (char*const*)&a->_ns1__RemoveRoomProfileRequest::roomID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__RemoveRoomProfileRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RemoveRoomProfileRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RemoveRoomProfileRequest * SOAP_FMAC4 soap_in__ns1__RemoveRoomProfileRequest(struct soap *soap, const char *tag, _ns1__RemoveRoomProfileRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RemoveRoomProfileRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RemoveRoomProfileRequest, sizeof(_ns1__RemoveRoomProfileRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_roomID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_roomID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:roomID", (char**)&a->_ns1__RemoveRoomProfileRequest::roomID, "ns1:EntityID"))
				{	soap_flag_roomID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_roomID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__RemoveRoomProfileRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RemoveRoomProfileRequest, SOAP_TYPE__ns1__RemoveRoomProfileRequest, sizeof(_ns1__RemoveRoomProfileRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__RemoveRoomProfileRequest * SOAP_FMAC2 soap_instantiate__ns1__RemoveRoomProfileRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RemoveRoomProfileRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__RemoveRoomProfileRequest *p;
	size_t k = sizeof(_ns1__RemoveRoomProfileRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__RemoveRoomProfileRequest);
		if (p)
			((_ns1__RemoveRoomProfileRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__RemoveRoomProfileRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__RemoveRoomProfileRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__RemoveRoomProfileRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__RemoveRoomProfileRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__RemoveRoomProfileRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:RemoveRoomProfileRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RemoveRoomProfileRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RemoveRoomProfileRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RemoveRoomProfileRequest * SOAP_FMAC4 soap_get__ns1__RemoveRoomProfileRequest(struct soap *soap, _ns1__RemoveRoomProfileRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RemoveRoomProfileRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SetRoomProfileResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__SetRoomProfileResponse::OK);
	/* transient soap skipped */
}

void _ns1__SetRoomProfileResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__SetRoomProfileResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetRoomProfileResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetRoomProfileResponse(struct soap *soap, const char *tag, int id, const _ns1__SetRoomProfileResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetRoomProfileResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__SetRoomProfileResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetRoomProfileResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetRoomProfileResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetRoomProfileResponse * SOAP_FMAC4 soap_in__ns1__SetRoomProfileResponse(struct soap *soap, const char *tag, _ns1__SetRoomProfileResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetRoomProfileResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetRoomProfileResponse, sizeof(_ns1__SetRoomProfileResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__SetRoomProfileResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__SetRoomProfileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetRoomProfileResponse, SOAP_TYPE__ns1__SetRoomProfileResponse, sizeof(_ns1__SetRoomProfileResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SetRoomProfileResponse * SOAP_FMAC2 soap_instantiate__ns1__SetRoomProfileResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetRoomProfileResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SetRoomProfileResponse *p;
	size_t k = sizeof(_ns1__SetRoomProfileResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SetRoomProfileResponse);
		if (p)
			((_ns1__SetRoomProfileResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SetRoomProfileResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SetRoomProfileResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SetRoomProfileResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SetRoomProfileResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SetRoomProfileResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SetRoomProfileResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SetRoomProfileResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetRoomProfileResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetRoomProfileResponse * SOAP_FMAC4 soap_get__ns1__SetRoomProfileResponse(struct soap *soap, _ns1__SetRoomProfileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetRoomProfileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SetRoomProfileRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__SetRoomProfileRequest::roomID);
	soap_default_string(soap, &this->_ns1__SetRoomProfileRequest::roomProfileName);
	/* transient soap skipped */
}

void _ns1__SetRoomProfileRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__SetRoomProfileRequest::roomID);
	soap_serialize_string(soap, (char*const*)&this->_ns1__SetRoomProfileRequest::roomProfileName);
#endif
}

int _ns1__SetRoomProfileRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetRoomProfileRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetRoomProfileRequest(struct soap *soap, const char *tag, int id, const _ns1__SetRoomProfileRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetRoomProfileRequest), type))
		return soap->error;
	if (!a->_ns1__SetRoomProfileRequest::roomID)
	{	if (soap_element_nil(soap, "ns1:roomID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:roomID", -1, (char*const*)&a->_ns1__SetRoomProfileRequest::roomID, ""))
		return soap->error;
	if (!a->_ns1__SetRoomProfileRequest::roomProfileName)
	{	if (soap_element_nil(soap, "ns1:roomProfileName"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:roomProfileName", -1, (char*const*)&a->_ns1__SetRoomProfileRequest::roomProfileName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetRoomProfileRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetRoomProfileRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetRoomProfileRequest * SOAP_FMAC4 soap_in__ns1__SetRoomProfileRequest(struct soap *soap, const char *tag, _ns1__SetRoomProfileRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetRoomProfileRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetRoomProfileRequest, sizeof(_ns1__SetRoomProfileRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_roomID1 = 1;
	size_t soap_flag_roomProfileName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_roomID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:roomID", (char**)&a->_ns1__SetRoomProfileRequest::roomID, "ns1:EntityID"))
				{	soap_flag_roomID1--;
					continue;
				}
			if (soap_flag_roomProfileName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:roomProfileName", (char**)&a->_ns1__SetRoomProfileRequest::roomProfileName, "xsd:string"))
				{	soap_flag_roomProfileName1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_roomID1 > 0 || soap_flag_roomProfileName1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__SetRoomProfileRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetRoomProfileRequest, SOAP_TYPE__ns1__SetRoomProfileRequest, sizeof(_ns1__SetRoomProfileRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SetRoomProfileRequest * SOAP_FMAC2 soap_instantiate__ns1__SetRoomProfileRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetRoomProfileRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SetRoomProfileRequest *p;
	size_t k = sizeof(_ns1__SetRoomProfileRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SetRoomProfileRequest);
		if (p)
			((_ns1__SetRoomProfileRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SetRoomProfileRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SetRoomProfileRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SetRoomProfileRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SetRoomProfileRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SetRoomProfileRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SetRoomProfileRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SetRoomProfileRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetRoomProfileRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetRoomProfileRequest * SOAP_FMAC4 soap_get__ns1__SetRoomProfileRequest(struct soap *soap, _ns1__SetRoomProfileRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetRoomProfileRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetRoomProfileResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetRoomProfileResponse::roomProfile = NULL;
	/* transient soap skipped */
}

void _ns1__GetRoomProfileResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__RoomProfile(soap, &this->_ns1__GetRoomProfileResponse::roomProfile);
#endif
}

int _ns1__GetRoomProfileResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetRoomProfileResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetRoomProfileResponse(struct soap *soap, const char *tag, int id, const _ns1__GetRoomProfileResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetRoomProfileResponse), type))
		return soap->error;
	if (a->roomProfile)
		soap_element_result(soap, "ns1:roomProfile");
	if (!a->_ns1__GetRoomProfileResponse::roomProfile)
	{	if (soap_element_nil(soap, "ns1:roomProfile"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__RoomProfile(soap, "ns1:roomProfile", -1, &a->_ns1__GetRoomProfileResponse::roomProfile, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetRoomProfileResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetRoomProfileResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetRoomProfileResponse * SOAP_FMAC4 soap_in__ns1__GetRoomProfileResponse(struct soap *soap, const char *tag, _ns1__GetRoomProfileResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetRoomProfileResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetRoomProfileResponse, sizeof(_ns1__GetRoomProfileResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_roomProfile1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_roomProfile1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RoomProfile(soap, "ns1:roomProfile", &a->_ns1__GetRoomProfileResponse::roomProfile, "ns1:RoomProfile"))
				{	soap_flag_roomProfile1--;
					continue;
				}
			soap_check_result(soap, "ns1:roomProfile");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_roomProfile1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetRoomProfileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetRoomProfileResponse, SOAP_TYPE__ns1__GetRoomProfileResponse, sizeof(_ns1__GetRoomProfileResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetRoomProfileResponse * SOAP_FMAC2 soap_instantiate__ns1__GetRoomProfileResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetRoomProfileResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetRoomProfileResponse *p;
	size_t k = sizeof(_ns1__GetRoomProfileResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetRoomProfileResponse);
		if (p)
			((_ns1__GetRoomProfileResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetRoomProfileResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetRoomProfileResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetRoomProfileResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetRoomProfileResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetRoomProfileResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:GetRoomProfileResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetRoomProfileResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetRoomProfileResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetRoomProfileResponse * SOAP_FMAC4 soap_get__ns1__GetRoomProfileResponse(struct soap *soap, _ns1__GetRoomProfileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetRoomProfileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetRoomProfileRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__GetRoomProfileRequest::roomID);
	/* transient soap skipped */
}

void _ns1__GetRoomProfileRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__GetRoomProfileRequest::roomID);
#endif
}

int _ns1__GetRoomProfileRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetRoomProfileRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetRoomProfileRequest(struct soap *soap, const char *tag, int id, const _ns1__GetRoomProfileRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetRoomProfileRequest), type))
		return soap->error;
	if (!a->_ns1__GetRoomProfileRequest::roomID)
	{	if (soap_element_nil(soap, "ns1:roomID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:roomID", -1, (char*const*)&a->_ns1__GetRoomProfileRequest::roomID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetRoomProfileRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetRoomProfileRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetRoomProfileRequest * SOAP_FMAC4 soap_in__ns1__GetRoomProfileRequest(struct soap *soap, const char *tag, _ns1__GetRoomProfileRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetRoomProfileRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetRoomProfileRequest, sizeof(_ns1__GetRoomProfileRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_roomID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_roomID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:roomID", (char**)&a->_ns1__GetRoomProfileRequest::roomID, "ns1:EntityID"))
				{	soap_flag_roomID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_roomID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetRoomProfileRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetRoomProfileRequest, SOAP_TYPE__ns1__GetRoomProfileRequest, sizeof(_ns1__GetRoomProfileRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetRoomProfileRequest * SOAP_FMAC2 soap_instantiate__ns1__GetRoomProfileRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetRoomProfileRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetRoomProfileRequest *p;
	size_t k = sizeof(_ns1__GetRoomProfileRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetRoomProfileRequest);
		if (p)
			((_ns1__GetRoomProfileRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetRoomProfileRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetRoomProfileRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetRoomProfileRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetRoomProfileRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetRoomProfileRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:GetRoomProfileRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetRoomProfileRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetRoomProfileRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetRoomProfileRequest * SOAP_FMAC4 soap_get__ns1__GetRoomProfileRequest(struct soap *soap, _ns1__GetRoomProfileRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetRoomProfileRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetRoomProfilesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GetRoomProfilesResponse::total);
	this->_ns1__GetRoomProfilesResponse::__sizeroomProfile = 0;
	this->_ns1__GetRoomProfilesResponse::roomProfile = NULL;
	/* transient soap skipped */
}

void _ns1__GetRoomProfilesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns1__GetRoomProfilesResponse::total, SOAP_TYPE_int);
	if (this->_ns1__GetRoomProfilesResponse::roomProfile)
	{	int i;
		for (i = 0; i < (int)this->_ns1__GetRoomProfilesResponse::__sizeroomProfile; i++)
		{
			soap_serialize_PointerTons1__RoomProfile(soap, this->_ns1__GetRoomProfilesResponse::roomProfile + i);
		}
	}
#endif
}

int _ns1__GetRoomProfilesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetRoomProfilesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetRoomProfilesResponse(struct soap *soap, const char *tag, int id, const _ns1__GetRoomProfilesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetRoomProfilesResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:total");
	if (soap_out_int(soap, "ns1:total", -1, &a->_ns1__GetRoomProfilesResponse::total, ""))
		return soap->error;
	if (a->_ns1__GetRoomProfilesResponse::roomProfile)
	{	int i;
		for (i = 0; i < (int)a->_ns1__GetRoomProfilesResponse::__sizeroomProfile; i++)
			if (soap_out_PointerTons1__RoomProfile(soap, "ns1:roomProfile", -1, a->_ns1__GetRoomProfilesResponse::roomProfile + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetRoomProfilesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetRoomProfilesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetRoomProfilesResponse * SOAP_FMAC4 soap_in__ns1__GetRoomProfilesResponse(struct soap *soap, const char *tag, _ns1__GetRoomProfilesResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetRoomProfilesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetRoomProfilesResponse, sizeof(_ns1__GetRoomProfilesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_total1 = 1;
	struct soap_blist *soap_blist_roomProfile1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_total1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:total", &a->_ns1__GetRoomProfilesResponse::total, "xsd:int"))
				{	soap_flag_total1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:roomProfile", 1, NULL))
			{	if (a->_ns1__GetRoomProfilesResponse::roomProfile == NULL)
				{	if (soap_blist_roomProfile1 == NULL)
						soap_blist_roomProfile1 = soap_new_block(soap);
					a->_ns1__GetRoomProfilesResponse::roomProfile = (ns1__RoomProfile **)soap_push_block_max(soap, soap_blist_roomProfile1, sizeof(ns1__RoomProfile *));
					if (a->_ns1__GetRoomProfilesResponse::roomProfile == NULL)
						return NULL;
					*a->_ns1__GetRoomProfilesResponse::roomProfile = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__RoomProfile(soap, "ns1:roomProfile", a->_ns1__GetRoomProfilesResponse::roomProfile, "ns1:RoomProfile"))
				{	a->_ns1__GetRoomProfilesResponse::__sizeroomProfile++;
					a->_ns1__GetRoomProfilesResponse::roomProfile = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:total");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__GetRoomProfilesResponse::roomProfile)
			soap_pop_block(soap, soap_blist_roomProfile1);
		if (a->_ns1__GetRoomProfilesResponse::__sizeroomProfile)
		{	a->_ns1__GetRoomProfilesResponse::roomProfile = (ns1__RoomProfile **)soap_save_block(soap, soap_blist_roomProfile1, NULL, 1);
		}
		else
		{	a->_ns1__GetRoomProfilesResponse::roomProfile = NULL;
			if (soap_blist_roomProfile1)
				soap_end_block(soap, soap_blist_roomProfile1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_total1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetRoomProfilesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetRoomProfilesResponse, SOAP_TYPE__ns1__GetRoomProfilesResponse, sizeof(_ns1__GetRoomProfilesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetRoomProfilesResponse * SOAP_FMAC2 soap_instantiate__ns1__GetRoomProfilesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetRoomProfilesResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetRoomProfilesResponse *p;
	size_t k = sizeof(_ns1__GetRoomProfilesResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetRoomProfilesResponse);
		if (p)
			((_ns1__GetRoomProfilesResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetRoomProfilesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetRoomProfilesResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetRoomProfilesResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetRoomProfilesResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetRoomProfilesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:GetRoomProfilesResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetRoomProfilesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetRoomProfilesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetRoomProfilesResponse * SOAP_FMAC4 soap_get__ns1__GetRoomProfilesResponse(struct soap *soap, _ns1__GetRoomProfilesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetRoomProfilesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetInviteContentResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetInviteContentResponse::content);
	soap_default_string(soap, &this->_ns1__GetInviteContentResponse::subject);
	/* transient soap skipped */
}

void _ns1__GetInviteContentResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetInviteContentResponse::content);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetInviteContentResponse::subject);
#endif
}

int _ns1__GetInviteContentResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetInviteContentResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetInviteContentResponse(struct soap *soap, const char *tag, int id, const _ns1__GetInviteContentResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetInviteContentResponse), type))
		return soap->error;
	if (a->content)
		soap_element_result(soap, "ns1:content");
	if (!a->_ns1__GetInviteContentResponse::content)
	{	if (soap_element_nil(soap, "ns1:content"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:content", -1, (char*const*)&a->_ns1__GetInviteContentResponse::content, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:subject", -1, (char*const*)&a->_ns1__GetInviteContentResponse::subject, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetInviteContentResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetInviteContentResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetInviteContentResponse * SOAP_FMAC4 soap_in__ns1__GetInviteContentResponse(struct soap *soap, const char *tag, _ns1__GetInviteContentResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetInviteContentResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetInviteContentResponse, sizeof(_ns1__GetInviteContentResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_content1 = 1;
	size_t soap_flag_subject1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_content1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:content", (char**)&a->_ns1__GetInviteContentResponse::content, "xsd:string"))
				{	soap_flag_content1--;
					continue;
				}
			if (soap_flag_subject1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:subject", (char**)&a->_ns1__GetInviteContentResponse::subject, "xsd:string"))
				{	soap_flag_subject1--;
					continue;
				}
			soap_check_result(soap, "ns1:content");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_content1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetInviteContentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetInviteContentResponse, SOAP_TYPE__ns1__GetInviteContentResponse, sizeof(_ns1__GetInviteContentResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetInviteContentResponse * SOAP_FMAC2 soap_instantiate__ns1__GetInviteContentResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetInviteContentResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetInviteContentResponse *p;
	size_t k = sizeof(_ns1__GetInviteContentResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetInviteContentResponse);
		if (p)
			((_ns1__GetInviteContentResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetInviteContentResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetInviteContentResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetInviteContentResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetInviteContentResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetInviteContentResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:GetInviteContentResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetInviteContentResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetInviteContentResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetInviteContentResponse * SOAP_FMAC4 soap_get__ns1__GetInviteContentResponse(struct soap *soap, _ns1__GetInviteContentResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetInviteContentResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetInviteContentRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__GetInviteContentRequest::roomID);
	/* transient soap skipped */
}

void _ns1__GetInviteContentRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__GetInviteContentRequest::roomID);
#endif
}

int _ns1__GetInviteContentRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetInviteContentRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetInviteContentRequest(struct soap *soap, const char *tag, int id, const _ns1__GetInviteContentRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetInviteContentRequest), type))
		return soap->error;
	if (soap_out_ns1__EntityID(soap, "ns1:roomID", -1, (char*const*)&a->_ns1__GetInviteContentRequest::roomID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetInviteContentRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetInviteContentRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetInviteContentRequest * SOAP_FMAC4 soap_in__ns1__GetInviteContentRequest(struct soap *soap, const char *tag, _ns1__GetInviteContentRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetInviteContentRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetInviteContentRequest, sizeof(_ns1__GetInviteContentRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_roomID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_roomID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:roomID", (char**)&a->_ns1__GetInviteContentRequest::roomID, "ns1:EntityID"))
				{	soap_flag_roomID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetInviteContentRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetInviteContentRequest, SOAP_TYPE__ns1__GetInviteContentRequest, sizeof(_ns1__GetInviteContentRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetInviteContentRequest * SOAP_FMAC2 soap_instantiate__ns1__GetInviteContentRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetInviteContentRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetInviteContentRequest *p;
	size_t k = sizeof(_ns1__GetInviteContentRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetInviteContentRequest);
		if (p)
			((_ns1__GetInviteContentRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetInviteContentRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetInviteContentRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetInviteContentRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetInviteContentRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetInviteContentRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:GetInviteContentRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetInviteContentRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetInviteContentRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetInviteContentRequest * SOAP_FMAC4 soap_get__ns1__GetInviteContentRequest(struct soap *soap, _ns1__GetInviteContentRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetInviteContentRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetEntityByRoomKeyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetEntityByRoomKeyResponse::Entity = NULL;
	/* transient soap skipped */
}

void _ns1__GetEntityByRoomKeyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Entity(soap, &this->_ns1__GetEntityByRoomKeyResponse::Entity);
#endif
}

int _ns1__GetEntityByRoomKeyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetEntityByRoomKeyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetEntityByRoomKeyResponse(struct soap *soap, const char *tag, int id, const _ns1__GetEntityByRoomKeyResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetEntityByRoomKeyResponse), type))
		return soap->error;
	if (a->Entity)
		soap_element_result(soap, "ns1:Entity");
	if (!a->_ns1__GetEntityByRoomKeyResponse::Entity)
	{	if (soap_element_nil(soap, "ns1:Entity"))
			return soap->error;
	}
	else
	if (soap_out_PointerTo_ns1__Entity(soap, "ns1:Entity", -1, &a->_ns1__GetEntityByRoomKeyResponse::Entity, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetEntityByRoomKeyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetEntityByRoomKeyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetEntityByRoomKeyResponse * SOAP_FMAC4 soap_in__ns1__GetEntityByRoomKeyResponse(struct soap *soap, const char *tag, _ns1__GetEntityByRoomKeyResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetEntityByRoomKeyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetEntityByRoomKeyResponse, sizeof(_ns1__GetEntityByRoomKeyResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Entity1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Entity1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Entity(soap, "ns1:Entity", &a->_ns1__GetEntityByRoomKeyResponse::Entity, ""))
				{	soap_flag_Entity1--;
					continue;
				}
			soap_check_result(soap, "ns1:Entity");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Entity1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetEntityByRoomKeyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetEntityByRoomKeyResponse, SOAP_TYPE__ns1__GetEntityByRoomKeyResponse, sizeof(_ns1__GetEntityByRoomKeyResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetEntityByRoomKeyResponse * SOAP_FMAC2 soap_instantiate__ns1__GetEntityByRoomKeyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetEntityByRoomKeyResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetEntityByRoomKeyResponse *p;
	size_t k = sizeof(_ns1__GetEntityByRoomKeyResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetEntityByRoomKeyResponse);
		if (p)
			((_ns1__GetEntityByRoomKeyResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetEntityByRoomKeyResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetEntityByRoomKeyResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetEntityByRoomKeyResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetEntityByRoomKeyResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetEntityByRoomKeyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:GetEntityByRoomKeyResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetEntityByRoomKeyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetEntityByRoomKeyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetEntityByRoomKeyResponse * SOAP_FMAC4 soap_get__ns1__GetEntityByRoomKeyResponse(struct soap *soap, _ns1__GetEntityByRoomKeyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetEntityByRoomKeyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetEntityByRoomKeyRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetEntityByRoomKeyRequest::roomKey);
	/* transient soap skipped */
}

void _ns1__GetEntityByRoomKeyRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetEntityByRoomKeyRequest::roomKey);
#endif
}

int _ns1__GetEntityByRoomKeyRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetEntityByRoomKeyRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetEntityByRoomKeyRequest(struct soap *soap, const char *tag, int id, const _ns1__GetEntityByRoomKeyRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetEntityByRoomKeyRequest), type))
		return soap->error;
	if (!a->_ns1__GetEntityByRoomKeyRequest::roomKey)
	{	if (soap_element_nil(soap, "ns1:roomKey"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:roomKey", -1, (char*const*)&a->_ns1__GetEntityByRoomKeyRequest::roomKey, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetEntityByRoomKeyRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetEntityByRoomKeyRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetEntityByRoomKeyRequest * SOAP_FMAC4 soap_in__ns1__GetEntityByRoomKeyRequest(struct soap *soap, const char *tag, _ns1__GetEntityByRoomKeyRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetEntityByRoomKeyRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetEntityByRoomKeyRequest, sizeof(_ns1__GetEntityByRoomKeyRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_roomKey1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_roomKey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:roomKey", (char**)&a->_ns1__GetEntityByRoomKeyRequest::roomKey, "xsd:string"))
				{	soap_flag_roomKey1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_roomKey1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetEntityByRoomKeyRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetEntityByRoomKeyRequest, SOAP_TYPE__ns1__GetEntityByRoomKeyRequest, sizeof(_ns1__GetEntityByRoomKeyRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetEntityByRoomKeyRequest * SOAP_FMAC2 soap_instantiate__ns1__GetEntityByRoomKeyRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetEntityByRoomKeyRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetEntityByRoomKeyRequest *p;
	size_t k = sizeof(_ns1__GetEntityByRoomKeyRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetEntityByRoomKeyRequest);
		if (p)
			((_ns1__GetEntityByRoomKeyRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetEntityByRoomKeyRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetEntityByRoomKeyRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetEntityByRoomKeyRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetEntityByRoomKeyRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetEntityByRoomKeyRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:GetEntityByRoomKeyRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetEntityByRoomKeyRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetEntityByRoomKeyRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetEntityByRoomKeyRequest * SOAP_FMAC4 soap_get__ns1__GetEntityByRoomKeyRequest(struct soap *soap, _ns1__GetEntityByRoomKeyRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetEntityByRoomKeyRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetUserNameResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetUserNameResponse::realUserName);
	/* transient soap skipped */
}

void _ns1__GetUserNameResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetUserNameResponse::realUserName);
#endif
}

int _ns1__GetUserNameResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetUserNameResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetUserNameResponse(struct soap *soap, const char *tag, int id, const _ns1__GetUserNameResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetUserNameResponse), type))
		return soap->error;
	if (a->realUserName)
		soap_element_result(soap, "ns1:realUserName");
	if (!a->_ns1__GetUserNameResponse::realUserName)
	{	if (soap_element_nil(soap, "ns1:realUserName"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:realUserName", -1, (char*const*)&a->_ns1__GetUserNameResponse::realUserName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetUserNameResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetUserNameResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetUserNameResponse * SOAP_FMAC4 soap_in__ns1__GetUserNameResponse(struct soap *soap, const char *tag, _ns1__GetUserNameResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetUserNameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetUserNameResponse, sizeof(_ns1__GetUserNameResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_realUserName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_realUserName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:realUserName", (char**)&a->_ns1__GetUserNameResponse::realUserName, "xsd:string"))
				{	soap_flag_realUserName1--;
					continue;
				}
			soap_check_result(soap, "ns1:realUserName");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_realUserName1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetUserNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetUserNameResponse, SOAP_TYPE__ns1__GetUserNameResponse, sizeof(_ns1__GetUserNameResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetUserNameResponse * SOAP_FMAC2 soap_instantiate__ns1__GetUserNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetUserNameResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetUserNameResponse *p;
	size_t k = sizeof(_ns1__GetUserNameResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetUserNameResponse);
		if (p)
			((_ns1__GetUserNameResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetUserNameResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetUserNameResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetUserNameResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetUserNameResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetUserNameResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:GetUserNameResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetUserNameResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetUserNameResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetUserNameResponse * SOAP_FMAC4 soap_get__ns1__GetUserNameResponse(struct soap *soap, _ns1__GetUserNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetUserNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetUserNameRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__GetUserNameRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__GetUserNameRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetUserNameRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetUserNameRequest(struct soap *soap, const char *tag, int id, const _ns1__GetUserNameRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetUserNameRequest), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetUserNameRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetUserNameRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetUserNameRequest * SOAP_FMAC4 soap_in__ns1__GetUserNameRequest(struct soap *soap, const char *tag, _ns1__GetUserNameRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetUserNameRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetUserNameRequest, sizeof(_ns1__GetUserNameRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetUserNameRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetUserNameRequest, SOAP_TYPE__ns1__GetUserNameRequest, sizeof(_ns1__GetUserNameRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetUserNameRequest * SOAP_FMAC2 soap_instantiate__ns1__GetUserNameRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetUserNameRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetUserNameRequest *p;
	size_t k = sizeof(_ns1__GetUserNameRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetUserNameRequest);
		if (p)
			((_ns1__GetUserNameRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetUserNameRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetUserNameRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetUserNameRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetUserNameRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetUserNameRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:GetUserNameRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetUserNameRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetUserNameRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetUserNameRequest * SOAP_FMAC4 soap_get__ns1__GetUserNameRequest(struct soap *soap, _ns1__GetUserNameRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetUserNameRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetWebcastURLResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetWebcastURLResponse::webCastURL);
	this->_ns1__GetWebcastURLResponse::hasWebCastPIN = NULL;
	/* transient soap skipped */
}

void _ns1__GetWebcastURLResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetWebcastURLResponse::webCastURL);
	soap_serialize_PointerTobool(soap, &this->_ns1__GetWebcastURLResponse::hasWebCastPIN);
#endif
}

int _ns1__GetWebcastURLResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetWebcastURLResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetWebcastURLResponse(struct soap *soap, const char *tag, int id, const _ns1__GetWebcastURLResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetWebcastURLResponse), type))
		return soap->error;
	if (a->webCastURL)
		soap_element_result(soap, "ns1:webCastURL");
	if (soap_out_string(soap, "ns1:webCastURL", -1, (char*const*)&a->_ns1__GetWebcastURLResponse::webCastURL, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:hasWebCastPIN", -1, &a->_ns1__GetWebcastURLResponse::hasWebCastPIN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetWebcastURLResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetWebcastURLResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetWebcastURLResponse * SOAP_FMAC4 soap_in__ns1__GetWebcastURLResponse(struct soap *soap, const char *tag, _ns1__GetWebcastURLResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetWebcastURLResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetWebcastURLResponse, sizeof(_ns1__GetWebcastURLResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_webCastURL1 = 1;
	size_t soap_flag_hasWebCastPIN1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_webCastURL1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:webCastURL", (char**)&a->_ns1__GetWebcastURLResponse::webCastURL, "xsd:string"))
				{	soap_flag_webCastURL1--;
					continue;
				}
			if (soap_flag_hasWebCastPIN1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns1:hasWebCastPIN", &a->_ns1__GetWebcastURLResponse::hasWebCastPIN, "xsd:boolean"))
				{	soap_flag_hasWebCastPIN1--;
					continue;
				}
			soap_check_result(soap, "ns1:webCastURL");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetWebcastURLResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetWebcastURLResponse, SOAP_TYPE__ns1__GetWebcastURLResponse, sizeof(_ns1__GetWebcastURLResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetWebcastURLResponse * SOAP_FMAC2 soap_instantiate__ns1__GetWebcastURLResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetWebcastURLResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetWebcastURLResponse *p;
	size_t k = sizeof(_ns1__GetWebcastURLResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetWebcastURLResponse);
		if (p)
			((_ns1__GetWebcastURLResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetWebcastURLResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetWebcastURLResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetWebcastURLResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetWebcastURLResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetWebcastURLResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:GetWebcastURLResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetWebcastURLResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetWebcastURLResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetWebcastURLResponse * SOAP_FMAC4 soap_get__ns1__GetWebcastURLResponse(struct soap *soap, _ns1__GetWebcastURLResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetWebcastURLResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetWebcastURLRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__GetWebcastURLRequest::roomID);
	/* transient soap skipped */
}

void _ns1__GetWebcastURLRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__GetWebcastURLRequest::roomID);
#endif
}

int _ns1__GetWebcastURLRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetWebcastURLRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetWebcastURLRequest(struct soap *soap, const char *tag, int id, const _ns1__GetWebcastURLRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetWebcastURLRequest), type))
		return soap->error;
	if (!a->_ns1__GetWebcastURLRequest::roomID)
	{	if (soap_element_nil(soap, "ns1:roomID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:roomID", -1, (char*const*)&a->_ns1__GetWebcastURLRequest::roomID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetWebcastURLRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetWebcastURLRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetWebcastURLRequest * SOAP_FMAC4 soap_in__ns1__GetWebcastURLRequest(struct soap *soap, const char *tag, _ns1__GetWebcastURLRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetWebcastURLRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetWebcastURLRequest, sizeof(_ns1__GetWebcastURLRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_roomID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_roomID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:roomID", (char**)&a->_ns1__GetWebcastURLRequest::roomID, "ns1:EntityID"))
				{	soap_flag_roomID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_roomID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetWebcastURLRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetWebcastURLRequest, SOAP_TYPE__ns1__GetWebcastURLRequest, sizeof(_ns1__GetWebcastURLRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetWebcastURLRequest * SOAP_FMAC2 soap_instantiate__ns1__GetWebcastURLRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetWebcastURLRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetWebcastURLRequest *p;
	size_t k = sizeof(_ns1__GetWebcastURLRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetWebcastURLRequest);
		if (p)
			((_ns1__GetWebcastURLRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetWebcastURLRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetWebcastURLRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetWebcastURLRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetWebcastURLRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetWebcastURLRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:GetWebcastURLRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetWebcastURLRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetWebcastURLRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetWebcastURLRequest * SOAP_FMAC4 soap_get__ns1__GetWebcastURLRequest(struct soap *soap, _ns1__GetWebcastURLRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetWebcastURLRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__RemoveWebcastPINResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__RemoveWebcastPINResponse::OK);
	/* transient soap skipped */
}

void _ns1__RemoveWebcastPINResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__RemoveWebcastPINResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RemoveWebcastPINResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RemoveWebcastPINResponse(struct soap *soap, const char *tag, int id, const _ns1__RemoveWebcastPINResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RemoveWebcastPINResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__RemoveWebcastPINResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__RemoveWebcastPINResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RemoveWebcastPINResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RemoveWebcastPINResponse * SOAP_FMAC4 soap_in__ns1__RemoveWebcastPINResponse(struct soap *soap, const char *tag, _ns1__RemoveWebcastPINResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RemoveWebcastPINResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RemoveWebcastPINResponse, sizeof(_ns1__RemoveWebcastPINResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__RemoveWebcastPINResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__RemoveWebcastPINResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RemoveWebcastPINResponse, SOAP_TYPE__ns1__RemoveWebcastPINResponse, sizeof(_ns1__RemoveWebcastPINResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__RemoveWebcastPINResponse * SOAP_FMAC2 soap_instantiate__ns1__RemoveWebcastPINResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RemoveWebcastPINResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__RemoveWebcastPINResponse *p;
	size_t k = sizeof(_ns1__RemoveWebcastPINResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__RemoveWebcastPINResponse);
		if (p)
			((_ns1__RemoveWebcastPINResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__RemoveWebcastPINResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__RemoveWebcastPINResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__RemoveWebcastPINResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__RemoveWebcastPINResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__RemoveWebcastPINResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:RemoveWebcastPINResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RemoveWebcastPINResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RemoveWebcastPINResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RemoveWebcastPINResponse * SOAP_FMAC4 soap_get__ns1__RemoveWebcastPINResponse(struct soap *soap, _ns1__RemoveWebcastPINResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RemoveWebcastPINResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__RemoveWebcastPINRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__RemoveWebcastPINRequest::roomID);
	/* transient soap skipped */
}

void _ns1__RemoveWebcastPINRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__RemoveWebcastPINRequest::roomID);
#endif
}

int _ns1__RemoveWebcastPINRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RemoveWebcastPINRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RemoveWebcastPINRequest(struct soap *soap, const char *tag, int id, const _ns1__RemoveWebcastPINRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RemoveWebcastPINRequest), type))
		return soap->error;
	if (!a->_ns1__RemoveWebcastPINRequest::roomID)
	{	if (soap_element_nil(soap, "ns1:roomID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:roomID", -1, (char*const*)&a->_ns1__RemoveWebcastPINRequest::roomID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__RemoveWebcastPINRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RemoveWebcastPINRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RemoveWebcastPINRequest * SOAP_FMAC4 soap_in__ns1__RemoveWebcastPINRequest(struct soap *soap, const char *tag, _ns1__RemoveWebcastPINRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RemoveWebcastPINRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RemoveWebcastPINRequest, sizeof(_ns1__RemoveWebcastPINRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_roomID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_roomID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:roomID", (char**)&a->_ns1__RemoveWebcastPINRequest::roomID, "ns1:EntityID"))
				{	soap_flag_roomID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_roomID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__RemoveWebcastPINRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RemoveWebcastPINRequest, SOAP_TYPE__ns1__RemoveWebcastPINRequest, sizeof(_ns1__RemoveWebcastPINRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__RemoveWebcastPINRequest * SOAP_FMAC2 soap_instantiate__ns1__RemoveWebcastPINRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RemoveWebcastPINRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__RemoveWebcastPINRequest *p;
	size_t k = sizeof(_ns1__RemoveWebcastPINRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__RemoveWebcastPINRequest);
		if (p)
			((_ns1__RemoveWebcastPINRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__RemoveWebcastPINRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__RemoveWebcastPINRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__RemoveWebcastPINRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__RemoveWebcastPINRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__RemoveWebcastPINRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:RemoveWebcastPINRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RemoveWebcastPINRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RemoveWebcastPINRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RemoveWebcastPINRequest * SOAP_FMAC4 soap_get__ns1__RemoveWebcastPINRequest(struct soap *soap, _ns1__RemoveWebcastPINRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RemoveWebcastPINRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__RemoveWebcastURLResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__RemoveWebcastURLResponse::OK);
	/* transient soap skipped */
}

void _ns1__RemoveWebcastURLResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__RemoveWebcastURLResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RemoveWebcastURLResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RemoveWebcastURLResponse(struct soap *soap, const char *tag, int id, const _ns1__RemoveWebcastURLResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RemoveWebcastURLResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__RemoveWebcastURLResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__RemoveWebcastURLResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RemoveWebcastURLResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RemoveWebcastURLResponse * SOAP_FMAC4 soap_in__ns1__RemoveWebcastURLResponse(struct soap *soap, const char *tag, _ns1__RemoveWebcastURLResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RemoveWebcastURLResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RemoveWebcastURLResponse, sizeof(_ns1__RemoveWebcastURLResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__RemoveWebcastURLResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__RemoveWebcastURLResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RemoveWebcastURLResponse, SOAP_TYPE__ns1__RemoveWebcastURLResponse, sizeof(_ns1__RemoveWebcastURLResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__RemoveWebcastURLResponse * SOAP_FMAC2 soap_instantiate__ns1__RemoveWebcastURLResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RemoveWebcastURLResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__RemoveWebcastURLResponse *p;
	size_t k = sizeof(_ns1__RemoveWebcastURLResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__RemoveWebcastURLResponse);
		if (p)
			((_ns1__RemoveWebcastURLResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__RemoveWebcastURLResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__RemoveWebcastURLResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__RemoveWebcastURLResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__RemoveWebcastURLResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__RemoveWebcastURLResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:RemoveWebcastURLResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RemoveWebcastURLResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RemoveWebcastURLResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RemoveWebcastURLResponse * SOAP_FMAC4 soap_get__ns1__RemoveWebcastURLResponse(struct soap *soap, _ns1__RemoveWebcastURLResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RemoveWebcastURLResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__RemoveWebcastURLRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__RemoveWebcastURLRequest::roomID);
	/* transient soap skipped */
}

void _ns1__RemoveWebcastURLRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__RemoveWebcastURLRequest::roomID);
#endif
}

int _ns1__RemoveWebcastURLRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RemoveWebcastURLRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RemoveWebcastURLRequest(struct soap *soap, const char *tag, int id, const _ns1__RemoveWebcastURLRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RemoveWebcastURLRequest), type))
		return soap->error;
	if (!a->_ns1__RemoveWebcastURLRequest::roomID)
	{	if (soap_element_nil(soap, "ns1:roomID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:roomID", -1, (char*const*)&a->_ns1__RemoveWebcastURLRequest::roomID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__RemoveWebcastURLRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RemoveWebcastURLRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RemoveWebcastURLRequest * SOAP_FMAC4 soap_in__ns1__RemoveWebcastURLRequest(struct soap *soap, const char *tag, _ns1__RemoveWebcastURLRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RemoveWebcastURLRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RemoveWebcastURLRequest, sizeof(_ns1__RemoveWebcastURLRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_roomID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_roomID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:roomID", (char**)&a->_ns1__RemoveWebcastURLRequest::roomID, "ns1:EntityID"))
				{	soap_flag_roomID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_roomID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__RemoveWebcastURLRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RemoveWebcastURLRequest, SOAP_TYPE__ns1__RemoveWebcastURLRequest, sizeof(_ns1__RemoveWebcastURLRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__RemoveWebcastURLRequest * SOAP_FMAC2 soap_instantiate__ns1__RemoveWebcastURLRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RemoveWebcastURLRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__RemoveWebcastURLRequest *p;
	size_t k = sizeof(_ns1__RemoveWebcastURLRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__RemoveWebcastURLRequest);
		if (p)
			((_ns1__RemoveWebcastURLRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__RemoveWebcastURLRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__RemoveWebcastURLRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__RemoveWebcastURLRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__RemoveWebcastURLRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__RemoveWebcastURLRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:RemoveWebcastURLRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RemoveWebcastURLRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RemoveWebcastURLRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RemoveWebcastURLRequest * SOAP_FMAC4 soap_get__ns1__RemoveWebcastURLRequest(struct soap *soap, _ns1__RemoveWebcastURLRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RemoveWebcastURLRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CreateWebcastPINResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__CreateWebcastPINResponse::OK);
	/* transient soap skipped */
}

void _ns1__CreateWebcastPINResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__CreateWebcastPINResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CreateWebcastPINResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CreateWebcastPINResponse(struct soap *soap, const char *tag, int id, const _ns1__CreateWebcastPINResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CreateWebcastPINResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__CreateWebcastPINResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CreateWebcastPINResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CreateWebcastPINResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CreateWebcastPINResponse * SOAP_FMAC4 soap_in__ns1__CreateWebcastPINResponse(struct soap *soap, const char *tag, _ns1__CreateWebcastPINResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CreateWebcastPINResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CreateWebcastPINResponse, sizeof(_ns1__CreateWebcastPINResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__CreateWebcastPINResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__CreateWebcastPINResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CreateWebcastPINResponse, SOAP_TYPE__ns1__CreateWebcastPINResponse, sizeof(_ns1__CreateWebcastPINResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CreateWebcastPINResponse * SOAP_FMAC2 soap_instantiate__ns1__CreateWebcastPINResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CreateWebcastPINResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CreateWebcastPINResponse *p;
	size_t k = sizeof(_ns1__CreateWebcastPINResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__CreateWebcastPINResponse);
		if (p)
			((_ns1__CreateWebcastPINResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__CreateWebcastPINResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__CreateWebcastPINResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CreateWebcastPINResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__CreateWebcastPINResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__CreateWebcastPINResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:CreateWebcastPINResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CreateWebcastPINResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CreateWebcastPINResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CreateWebcastPINResponse * SOAP_FMAC4 soap_get__ns1__CreateWebcastPINResponse(struct soap *soap, _ns1__CreateWebcastPINResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CreateWebcastPINResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CreateWebcastPINRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__CreateWebcastPINRequest::roomID);
	soap_default_string(soap, &this->_ns1__CreateWebcastPINRequest::PIN);
	/* transient soap skipped */
}

void _ns1__CreateWebcastPINRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__CreateWebcastPINRequest::roomID);
	soap_serialize_string(soap, (char*const*)&this->_ns1__CreateWebcastPINRequest::PIN);
#endif
}

int _ns1__CreateWebcastPINRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CreateWebcastPINRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CreateWebcastPINRequest(struct soap *soap, const char *tag, int id, const _ns1__CreateWebcastPINRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CreateWebcastPINRequest), type))
		return soap->error;
	if (!a->_ns1__CreateWebcastPINRequest::roomID)
	{	if (soap_element_nil(soap, "ns1:roomID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:roomID", -1, (char*const*)&a->_ns1__CreateWebcastPINRequest::roomID, ""))
		return soap->error;
	if (!a->_ns1__CreateWebcastPINRequest::PIN)
	{	if (soap_element_nil(soap, "ns1:PIN"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:PIN", -1, (char*const*)&a->_ns1__CreateWebcastPINRequest::PIN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CreateWebcastPINRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CreateWebcastPINRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CreateWebcastPINRequest * SOAP_FMAC4 soap_in__ns1__CreateWebcastPINRequest(struct soap *soap, const char *tag, _ns1__CreateWebcastPINRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CreateWebcastPINRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CreateWebcastPINRequest, sizeof(_ns1__CreateWebcastPINRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_roomID1 = 1;
	size_t soap_flag_PIN1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_roomID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:roomID", (char**)&a->_ns1__CreateWebcastPINRequest::roomID, "ns1:EntityID"))
				{	soap_flag_roomID1--;
					continue;
				}
			if (soap_flag_PIN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:PIN", (char**)&a->_ns1__CreateWebcastPINRequest::PIN, "xsd:string"))
				{	soap_flag_PIN1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_roomID1 > 0 || soap_flag_PIN1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__CreateWebcastPINRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CreateWebcastPINRequest, SOAP_TYPE__ns1__CreateWebcastPINRequest, sizeof(_ns1__CreateWebcastPINRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CreateWebcastPINRequest * SOAP_FMAC2 soap_instantiate__ns1__CreateWebcastPINRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CreateWebcastPINRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CreateWebcastPINRequest *p;
	size_t k = sizeof(_ns1__CreateWebcastPINRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__CreateWebcastPINRequest);
		if (p)
			((_ns1__CreateWebcastPINRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__CreateWebcastPINRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__CreateWebcastPINRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CreateWebcastPINRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__CreateWebcastPINRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__CreateWebcastPINRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:CreateWebcastPINRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CreateWebcastPINRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CreateWebcastPINRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CreateWebcastPINRequest * SOAP_FMAC4 soap_get__ns1__CreateWebcastPINRequest(struct soap *soap, _ns1__CreateWebcastPINRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CreateWebcastPINRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CreateWebcastURLResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__CreateWebcastURLResponse::OK);
	/* transient soap skipped */
}

void _ns1__CreateWebcastURLResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__CreateWebcastURLResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CreateWebcastURLResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CreateWebcastURLResponse(struct soap *soap, const char *tag, int id, const _ns1__CreateWebcastURLResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CreateWebcastURLResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__CreateWebcastURLResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CreateWebcastURLResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CreateWebcastURLResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CreateWebcastURLResponse * SOAP_FMAC4 soap_in__ns1__CreateWebcastURLResponse(struct soap *soap, const char *tag, _ns1__CreateWebcastURLResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CreateWebcastURLResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CreateWebcastURLResponse, sizeof(_ns1__CreateWebcastURLResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__CreateWebcastURLResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__CreateWebcastURLResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CreateWebcastURLResponse, SOAP_TYPE__ns1__CreateWebcastURLResponse, sizeof(_ns1__CreateWebcastURLResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CreateWebcastURLResponse * SOAP_FMAC2 soap_instantiate__ns1__CreateWebcastURLResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CreateWebcastURLResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CreateWebcastURLResponse *p;
	size_t k = sizeof(_ns1__CreateWebcastURLResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__CreateWebcastURLResponse);
		if (p)
			((_ns1__CreateWebcastURLResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__CreateWebcastURLResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__CreateWebcastURLResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CreateWebcastURLResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__CreateWebcastURLResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__CreateWebcastURLResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:CreateWebcastURLResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CreateWebcastURLResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CreateWebcastURLResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CreateWebcastURLResponse * SOAP_FMAC4 soap_get__ns1__CreateWebcastURLResponse(struct soap *soap, _ns1__CreateWebcastURLResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CreateWebcastURLResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CreateWebcastURLRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__CreateWebcastURLRequest::roomID);
	/* transient soap skipped */
}

void _ns1__CreateWebcastURLRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__CreateWebcastURLRequest::roomID);
#endif
}

int _ns1__CreateWebcastURLRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CreateWebcastURLRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CreateWebcastURLRequest(struct soap *soap, const char *tag, int id, const _ns1__CreateWebcastURLRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CreateWebcastURLRequest), type))
		return soap->error;
	if (!a->_ns1__CreateWebcastURLRequest::roomID)
	{	if (soap_element_nil(soap, "ns1:roomID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:roomID", -1, (char*const*)&a->_ns1__CreateWebcastURLRequest::roomID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CreateWebcastURLRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CreateWebcastURLRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CreateWebcastURLRequest * SOAP_FMAC4 soap_in__ns1__CreateWebcastURLRequest(struct soap *soap, const char *tag, _ns1__CreateWebcastURLRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CreateWebcastURLRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CreateWebcastURLRequest, sizeof(_ns1__CreateWebcastURLRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_roomID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_roomID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:roomID", (char**)&a->_ns1__CreateWebcastURLRequest::roomID, "ns1:EntityID"))
				{	soap_flag_roomID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_roomID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__CreateWebcastURLRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CreateWebcastURLRequest, SOAP_TYPE__ns1__CreateWebcastURLRequest, sizeof(_ns1__CreateWebcastURLRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CreateWebcastURLRequest * SOAP_FMAC2 soap_instantiate__ns1__CreateWebcastURLRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CreateWebcastURLRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CreateWebcastURLRequest *p;
	size_t k = sizeof(_ns1__CreateWebcastURLRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__CreateWebcastURLRequest);
		if (p)
			((_ns1__CreateWebcastURLRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__CreateWebcastURLRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__CreateWebcastURLRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CreateWebcastURLRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__CreateWebcastURLRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__CreateWebcastURLRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:CreateWebcastURLRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CreateWebcastURLRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CreateWebcastURLRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CreateWebcastURLRequest * SOAP_FMAC4 soap_get__ns1__CreateWebcastURLRequest(struct soap *soap, _ns1__CreateWebcastURLRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CreateWebcastURLRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__StopRecordingResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__StopRecordingResponse::OK);
	/* transient soap skipped */
}

void _ns1__StopRecordingResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__StopRecordingResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__StopRecordingResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__StopRecordingResponse(struct soap *soap, const char *tag, int id, const _ns1__StopRecordingResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__StopRecordingResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__StopRecordingResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__StopRecordingResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__StopRecordingResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__StopRecordingResponse * SOAP_FMAC4 soap_in__ns1__StopRecordingResponse(struct soap *soap, const char *tag, _ns1__StopRecordingResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__StopRecordingResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__StopRecordingResponse, sizeof(_ns1__StopRecordingResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__StopRecordingResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__StopRecordingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__StopRecordingResponse, SOAP_TYPE__ns1__StopRecordingResponse, sizeof(_ns1__StopRecordingResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__StopRecordingResponse * SOAP_FMAC2 soap_instantiate__ns1__StopRecordingResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__StopRecordingResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__StopRecordingResponse *p;
	size_t k = sizeof(_ns1__StopRecordingResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__StopRecordingResponse);
		if (p)
			((_ns1__StopRecordingResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__StopRecordingResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__StopRecordingResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__StopRecordingResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__StopRecordingResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__StopRecordingResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:StopRecordingResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__StopRecordingResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__StopRecordingResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__StopRecordingResponse * SOAP_FMAC4 soap_get__ns1__StopRecordingResponse(struct soap *soap, _ns1__StopRecordingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__StopRecordingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__StopRecordingRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__StopRecordingRequest::conferenceID);
	soap_default_int(soap, &this->_ns1__StopRecordingRequest::recorderID);
	soap_default_string(soap, &this->_ns1__StopRecordingRequest::moderatorPIN);
	/* transient soap skipped */
}

void _ns1__StopRecordingRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__StopRecordingRequest::conferenceID);
	soap_embedded(soap, &this->_ns1__StopRecordingRequest::recorderID, SOAP_TYPE_int);
	soap_serialize_string(soap, (char*const*)&this->_ns1__StopRecordingRequest::moderatorPIN);
#endif
}

int _ns1__StopRecordingRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__StopRecordingRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__StopRecordingRequest(struct soap *soap, const char *tag, int id, const _ns1__StopRecordingRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__StopRecordingRequest), type))
		return soap->error;
	if (!a->_ns1__StopRecordingRequest::conferenceID)
	{	if (soap_element_nil(soap, "ns1:conferenceID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:conferenceID", -1, (char*const*)&a->_ns1__StopRecordingRequest::conferenceID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:recorderID", -1, &a->_ns1__StopRecordingRequest::recorderID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:moderatorPIN", -1, (char*const*)&a->_ns1__StopRecordingRequest::moderatorPIN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__StopRecordingRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__StopRecordingRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__StopRecordingRequest * SOAP_FMAC4 soap_in__ns1__StopRecordingRequest(struct soap *soap, const char *tag, _ns1__StopRecordingRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__StopRecordingRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__StopRecordingRequest, sizeof(_ns1__StopRecordingRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_conferenceID1 = 1;
	size_t soap_flag_recorderID1 = 1;
	size_t soap_flag_moderatorPIN1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_conferenceID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:conferenceID", (char**)&a->_ns1__StopRecordingRequest::conferenceID, "ns1:EntityID"))
				{	soap_flag_conferenceID1--;
					continue;
				}
			if (soap_flag_recorderID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:recorderID", &a->_ns1__StopRecordingRequest::recorderID, "xsd:int"))
				{	soap_flag_recorderID1--;
					continue;
				}
			if (soap_flag_moderatorPIN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:moderatorPIN", (char**)&a->_ns1__StopRecordingRequest::moderatorPIN, "xsd:string"))
				{	soap_flag_moderatorPIN1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_conferenceID1 > 0 || soap_flag_recorderID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__StopRecordingRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__StopRecordingRequest, SOAP_TYPE__ns1__StopRecordingRequest, sizeof(_ns1__StopRecordingRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__StopRecordingRequest * SOAP_FMAC2 soap_instantiate__ns1__StopRecordingRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__StopRecordingRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__StopRecordingRequest *p;
	size_t k = sizeof(_ns1__StopRecordingRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__StopRecordingRequest);
		if (p)
			((_ns1__StopRecordingRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__StopRecordingRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__StopRecordingRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__StopRecordingRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__StopRecordingRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__StopRecordingRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:StopRecordingRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__StopRecordingRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__StopRecordingRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__StopRecordingRequest * SOAP_FMAC4 soap_get__ns1__StopRecordingRequest(struct soap *soap, _ns1__StopRecordingRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__StopRecordingRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ResumeRecordingResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__ResumeRecordingResponse::OK);
	/* transient soap skipped */
}

void _ns1__ResumeRecordingResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__ResumeRecordingResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ResumeRecordingResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ResumeRecordingResponse(struct soap *soap, const char *tag, int id, const _ns1__ResumeRecordingResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ResumeRecordingResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__ResumeRecordingResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ResumeRecordingResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ResumeRecordingResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ResumeRecordingResponse * SOAP_FMAC4 soap_in__ns1__ResumeRecordingResponse(struct soap *soap, const char *tag, _ns1__ResumeRecordingResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ResumeRecordingResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ResumeRecordingResponse, sizeof(_ns1__ResumeRecordingResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__ResumeRecordingResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__ResumeRecordingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ResumeRecordingResponse, SOAP_TYPE__ns1__ResumeRecordingResponse, sizeof(_ns1__ResumeRecordingResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ResumeRecordingResponse * SOAP_FMAC2 soap_instantiate__ns1__ResumeRecordingResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ResumeRecordingResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ResumeRecordingResponse *p;
	size_t k = sizeof(_ns1__ResumeRecordingResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__ResumeRecordingResponse);
		if (p)
			((_ns1__ResumeRecordingResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__ResumeRecordingResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__ResumeRecordingResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ResumeRecordingResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__ResumeRecordingResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__ResumeRecordingResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:ResumeRecordingResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ResumeRecordingResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ResumeRecordingResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ResumeRecordingResponse * SOAP_FMAC4 soap_get__ns1__ResumeRecordingResponse(struct soap *soap, _ns1__ResumeRecordingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ResumeRecordingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ResumeRecordingRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__ResumeRecordingRequest::conferenceID);
	soap_default_int(soap, &this->_ns1__ResumeRecordingRequest::recorderID);
	soap_default_string(soap, &this->_ns1__ResumeRecordingRequest::moderatorPIN);
	/* transient soap skipped */
}

void _ns1__ResumeRecordingRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__ResumeRecordingRequest::conferenceID);
	soap_embedded(soap, &this->_ns1__ResumeRecordingRequest::recorderID, SOAP_TYPE_int);
	soap_serialize_string(soap, (char*const*)&this->_ns1__ResumeRecordingRequest::moderatorPIN);
#endif
}

int _ns1__ResumeRecordingRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ResumeRecordingRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ResumeRecordingRequest(struct soap *soap, const char *tag, int id, const _ns1__ResumeRecordingRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ResumeRecordingRequest), type))
		return soap->error;
	if (!a->_ns1__ResumeRecordingRequest::conferenceID)
	{	if (soap_element_nil(soap, "ns1:conferenceID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:conferenceID", -1, (char*const*)&a->_ns1__ResumeRecordingRequest::conferenceID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:recorderID", -1, &a->_ns1__ResumeRecordingRequest::recorderID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:moderatorPIN", -1, (char*const*)&a->_ns1__ResumeRecordingRequest::moderatorPIN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ResumeRecordingRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ResumeRecordingRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ResumeRecordingRequest * SOAP_FMAC4 soap_in__ns1__ResumeRecordingRequest(struct soap *soap, const char *tag, _ns1__ResumeRecordingRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ResumeRecordingRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ResumeRecordingRequest, sizeof(_ns1__ResumeRecordingRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_conferenceID1 = 1;
	size_t soap_flag_recorderID1 = 1;
	size_t soap_flag_moderatorPIN1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_conferenceID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:conferenceID", (char**)&a->_ns1__ResumeRecordingRequest::conferenceID, "ns1:EntityID"))
				{	soap_flag_conferenceID1--;
					continue;
				}
			if (soap_flag_recorderID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:recorderID", &a->_ns1__ResumeRecordingRequest::recorderID, "xsd:int"))
				{	soap_flag_recorderID1--;
					continue;
				}
			if (soap_flag_moderatorPIN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:moderatorPIN", (char**)&a->_ns1__ResumeRecordingRequest::moderatorPIN, "xsd:string"))
				{	soap_flag_moderatorPIN1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_conferenceID1 > 0 || soap_flag_recorderID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__ResumeRecordingRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ResumeRecordingRequest, SOAP_TYPE__ns1__ResumeRecordingRequest, sizeof(_ns1__ResumeRecordingRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ResumeRecordingRequest * SOAP_FMAC2 soap_instantiate__ns1__ResumeRecordingRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ResumeRecordingRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ResumeRecordingRequest *p;
	size_t k = sizeof(_ns1__ResumeRecordingRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__ResumeRecordingRequest);
		if (p)
			((_ns1__ResumeRecordingRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__ResumeRecordingRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__ResumeRecordingRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ResumeRecordingRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__ResumeRecordingRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__ResumeRecordingRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:ResumeRecordingRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ResumeRecordingRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ResumeRecordingRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ResumeRecordingRequest * SOAP_FMAC4 soap_get__ns1__ResumeRecordingRequest(struct soap *soap, _ns1__ResumeRecordingRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ResumeRecordingRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__PauseRecordingResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__PauseRecordingResponse::OK);
	/* transient soap skipped */
}

void _ns1__PauseRecordingResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__PauseRecordingResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__PauseRecordingResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__PauseRecordingResponse(struct soap *soap, const char *tag, int id, const _ns1__PauseRecordingResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__PauseRecordingResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__PauseRecordingResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__PauseRecordingResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__PauseRecordingResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__PauseRecordingResponse * SOAP_FMAC4 soap_in__ns1__PauseRecordingResponse(struct soap *soap, const char *tag, _ns1__PauseRecordingResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__PauseRecordingResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__PauseRecordingResponse, sizeof(_ns1__PauseRecordingResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__PauseRecordingResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__PauseRecordingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__PauseRecordingResponse, SOAP_TYPE__ns1__PauseRecordingResponse, sizeof(_ns1__PauseRecordingResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__PauseRecordingResponse * SOAP_FMAC2 soap_instantiate__ns1__PauseRecordingResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__PauseRecordingResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__PauseRecordingResponse *p;
	size_t k = sizeof(_ns1__PauseRecordingResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__PauseRecordingResponse);
		if (p)
			((_ns1__PauseRecordingResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__PauseRecordingResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__PauseRecordingResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__PauseRecordingResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__PauseRecordingResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__PauseRecordingResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:PauseRecordingResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__PauseRecordingResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__PauseRecordingResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__PauseRecordingResponse * SOAP_FMAC4 soap_get__ns1__PauseRecordingResponse(struct soap *soap, _ns1__PauseRecordingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__PauseRecordingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__PauseRecordingRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__PauseRecordingRequest::conferenceID);
	soap_default_int(soap, &this->_ns1__PauseRecordingRequest::recorderID);
	soap_default_string(soap, &this->_ns1__PauseRecordingRequest::moderatorPIN);
	/* transient soap skipped */
}

void _ns1__PauseRecordingRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__PauseRecordingRequest::conferenceID);
	soap_embedded(soap, &this->_ns1__PauseRecordingRequest::recorderID, SOAP_TYPE_int);
	soap_serialize_string(soap, (char*const*)&this->_ns1__PauseRecordingRequest::moderatorPIN);
#endif
}

int _ns1__PauseRecordingRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__PauseRecordingRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__PauseRecordingRequest(struct soap *soap, const char *tag, int id, const _ns1__PauseRecordingRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__PauseRecordingRequest), type))
		return soap->error;
	if (!a->_ns1__PauseRecordingRequest::conferenceID)
	{	if (soap_element_nil(soap, "ns1:conferenceID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:conferenceID", -1, (char*const*)&a->_ns1__PauseRecordingRequest::conferenceID, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:recorderID", -1, &a->_ns1__PauseRecordingRequest::recorderID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:moderatorPIN", -1, (char*const*)&a->_ns1__PauseRecordingRequest::moderatorPIN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__PauseRecordingRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__PauseRecordingRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__PauseRecordingRequest * SOAP_FMAC4 soap_in__ns1__PauseRecordingRequest(struct soap *soap, const char *tag, _ns1__PauseRecordingRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__PauseRecordingRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__PauseRecordingRequest, sizeof(_ns1__PauseRecordingRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_conferenceID1 = 1;
	size_t soap_flag_recorderID1 = 1;
	size_t soap_flag_moderatorPIN1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_conferenceID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:conferenceID", (char**)&a->_ns1__PauseRecordingRequest::conferenceID, "ns1:EntityID"))
				{	soap_flag_conferenceID1--;
					continue;
				}
			if (soap_flag_recorderID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:recorderID", &a->_ns1__PauseRecordingRequest::recorderID, "xsd:int"))
				{	soap_flag_recorderID1--;
					continue;
				}
			if (soap_flag_moderatorPIN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:moderatorPIN", (char**)&a->_ns1__PauseRecordingRequest::moderatorPIN, "xsd:string"))
				{	soap_flag_moderatorPIN1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_conferenceID1 > 0 || soap_flag_recorderID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__PauseRecordingRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__PauseRecordingRequest, SOAP_TYPE__ns1__PauseRecordingRequest, sizeof(_ns1__PauseRecordingRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__PauseRecordingRequest * SOAP_FMAC2 soap_instantiate__ns1__PauseRecordingRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__PauseRecordingRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__PauseRecordingRequest *p;
	size_t k = sizeof(_ns1__PauseRecordingRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__PauseRecordingRequest);
		if (p)
			((_ns1__PauseRecordingRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__PauseRecordingRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__PauseRecordingRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__PauseRecordingRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__PauseRecordingRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__PauseRecordingRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:PauseRecordingRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__PauseRecordingRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__PauseRecordingRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__PauseRecordingRequest * SOAP_FMAC4 soap_get__ns1__PauseRecordingRequest(struct soap *soap, _ns1__PauseRecordingRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__PauseRecordingRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetPortalVersionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetPortalVersionResponse::portalVersion);
	/* transient soap skipped */
}

void _ns1__GetPortalVersionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetPortalVersionResponse::portalVersion);
#endif
}

int _ns1__GetPortalVersionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPortalVersionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPortalVersionResponse(struct soap *soap, const char *tag, int id, const _ns1__GetPortalVersionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPortalVersionResponse), type))
		return soap->error;
	if (a->portalVersion)
		soap_element_result(soap, "ns1:portalVersion");
	if (!a->_ns1__GetPortalVersionResponse::portalVersion)
	{	if (soap_element_nil(soap, "ns1:portalVersion"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:portalVersion", -1, (char*const*)&a->_ns1__GetPortalVersionResponse::portalVersion, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPortalVersionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPortalVersionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPortalVersionResponse * SOAP_FMAC4 soap_in__ns1__GetPortalVersionResponse(struct soap *soap, const char *tag, _ns1__GetPortalVersionResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPortalVersionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPortalVersionResponse, sizeof(_ns1__GetPortalVersionResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_portalVersion1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_portalVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:portalVersion", (char**)&a->_ns1__GetPortalVersionResponse::portalVersion, "xsd:string"))
				{	soap_flag_portalVersion1--;
					continue;
				}
			soap_check_result(soap, "ns1:portalVersion");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_portalVersion1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetPortalVersionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPortalVersionResponse, SOAP_TYPE__ns1__GetPortalVersionResponse, sizeof(_ns1__GetPortalVersionResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetPortalVersionResponse * SOAP_FMAC2 soap_instantiate__ns1__GetPortalVersionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPortalVersionResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetPortalVersionResponse *p;
	size_t k = sizeof(_ns1__GetPortalVersionResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetPortalVersionResponse);
		if (p)
			((_ns1__GetPortalVersionResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetPortalVersionResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetPortalVersionResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetPortalVersionResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetPortalVersionResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetPortalVersionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:GetPortalVersionResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPortalVersionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPortalVersionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPortalVersionResponse * SOAP_FMAC4 soap_get__ns1__GetPortalVersionResponse(struct soap *soap, _ns1__GetPortalVersionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPortalVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetPortalVersionRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__GetPortalVersionRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__GetPortalVersionRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPortalVersionRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPortalVersionRequest(struct soap *soap, const char *tag, int id, const _ns1__GetPortalVersionRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPortalVersionRequest), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPortalVersionRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPortalVersionRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPortalVersionRequest * SOAP_FMAC4 soap_in__ns1__GetPortalVersionRequest(struct soap *soap, const char *tag, _ns1__GetPortalVersionRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPortalVersionRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPortalVersionRequest, sizeof(_ns1__GetPortalVersionRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPortalVersionRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPortalVersionRequest, SOAP_TYPE__ns1__GetPortalVersionRequest, sizeof(_ns1__GetPortalVersionRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetPortalVersionRequest * SOAP_FMAC2 soap_instantiate__ns1__GetPortalVersionRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPortalVersionRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetPortalVersionRequest *p;
	size_t k = sizeof(_ns1__GetPortalVersionRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetPortalVersionRequest);
		if (p)
			((_ns1__GetPortalVersionRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetPortalVersionRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetPortalVersionRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetPortalVersionRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetPortalVersionRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetPortalVersionRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:GetPortalVersionRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPortalVersionRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPortalVersionRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPortalVersionRequest * SOAP_FMAC4 soap_get__ns1__GetPortalVersionRequest(struct soap *soap, _ns1__GetPortalVersionRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPortalVersionRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__StartRecordingResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__StartRecordingResponse::OK);
	/* transient soap skipped */
}

void _ns1__StartRecordingResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__StartRecordingResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__StartRecordingResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__StartRecordingResponse(struct soap *soap, const char *tag, int id, const _ns1__StartRecordingResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__StartRecordingResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__StartRecordingResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__StartRecordingResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__StartRecordingResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__StartRecordingResponse * SOAP_FMAC4 soap_in__ns1__StartRecordingResponse(struct soap *soap, const char *tag, _ns1__StartRecordingResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__StartRecordingResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__StartRecordingResponse, sizeof(_ns1__StartRecordingResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__StartRecordingResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__StartRecordingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__StartRecordingResponse, SOAP_TYPE__ns1__StartRecordingResponse, sizeof(_ns1__StartRecordingResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__StartRecordingResponse * SOAP_FMAC2 soap_instantiate__ns1__StartRecordingResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__StartRecordingResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__StartRecordingResponse *p;
	size_t k = sizeof(_ns1__StartRecordingResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__StartRecordingResponse);
		if (p)
			((_ns1__StartRecordingResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__StartRecordingResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__StartRecordingResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__StartRecordingResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__StartRecordingResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__StartRecordingResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:StartRecordingResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__StartRecordingResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__StartRecordingResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__StartRecordingResponse * SOAP_FMAC4 soap_get__ns1__StartRecordingResponse(struct soap *soap, _ns1__StartRecordingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__StartRecordingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__StartRecordingRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__StartRecordingRequest::conferenceID);
	soap_default_string(soap, &this->_ns1__StartRecordingRequest::recorderPrefix);
	soap_default_bool(soap, &this->_ns1__StartRecordingRequest::webcast);
	soap_default_string(soap, &this->_ns1__StartRecordingRequest::moderatorPIN);
	/* transient soap skipped */
}

void _ns1__StartRecordingRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__StartRecordingRequest::conferenceID);
	soap_serialize_string(soap, (char*const*)&this->_ns1__StartRecordingRequest::recorderPrefix);
	soap_embedded(soap, &this->_ns1__StartRecordingRequest::webcast, SOAP_TYPE_bool);
	soap_serialize_string(soap, (char*const*)&this->_ns1__StartRecordingRequest::moderatorPIN);
#endif
}

int _ns1__StartRecordingRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__StartRecordingRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__StartRecordingRequest(struct soap *soap, const char *tag, int id, const _ns1__StartRecordingRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__StartRecordingRequest), type))
		return soap->error;
	if (!a->_ns1__StartRecordingRequest::conferenceID)
	{	if (soap_element_nil(soap, "ns1:conferenceID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:conferenceID", -1, (char*const*)&a->_ns1__StartRecordingRequest::conferenceID, ""))
		return soap->error;
	if (!a->_ns1__StartRecordingRequest::recorderPrefix)
	{	if (soap_element_nil(soap, "ns1:recorderPrefix"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:recorderPrefix", -1, (char*const*)&a->_ns1__StartRecordingRequest::recorderPrefix, ""))
		return soap->error;
	if (soap_out_bool(soap, "ns1:webcast", -1, &a->_ns1__StartRecordingRequest::webcast, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:moderatorPIN", -1, (char*const*)&a->_ns1__StartRecordingRequest::moderatorPIN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__StartRecordingRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__StartRecordingRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__StartRecordingRequest * SOAP_FMAC4 soap_in__ns1__StartRecordingRequest(struct soap *soap, const char *tag, _ns1__StartRecordingRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__StartRecordingRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__StartRecordingRequest, sizeof(_ns1__StartRecordingRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_conferenceID1 = 1;
	size_t soap_flag_recorderPrefix1 = 1;
	size_t soap_flag_webcast1 = 1;
	size_t soap_flag_moderatorPIN1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_conferenceID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:conferenceID", (char**)&a->_ns1__StartRecordingRequest::conferenceID, "ns1:EntityID"))
				{	soap_flag_conferenceID1--;
					continue;
				}
			if (soap_flag_recorderPrefix1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:recorderPrefix", (char**)&a->_ns1__StartRecordingRequest::recorderPrefix, "xsd:string"))
				{	soap_flag_recorderPrefix1--;
					continue;
				}
			if (soap_flag_webcast1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:webcast", &a->_ns1__StartRecordingRequest::webcast, "xsd:boolean"))
				{	soap_flag_webcast1--;
					continue;
				}
			if (soap_flag_moderatorPIN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:moderatorPIN", (char**)&a->_ns1__StartRecordingRequest::moderatorPIN, "xsd:string"))
				{	soap_flag_moderatorPIN1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_conferenceID1 > 0 || soap_flag_recorderPrefix1 > 0 || soap_flag_webcast1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__StartRecordingRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__StartRecordingRequest, SOAP_TYPE__ns1__StartRecordingRequest, sizeof(_ns1__StartRecordingRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__StartRecordingRequest * SOAP_FMAC2 soap_instantiate__ns1__StartRecordingRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__StartRecordingRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__StartRecordingRequest *p;
	size_t k = sizeof(_ns1__StartRecordingRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__StartRecordingRequest);
		if (p)
			((_ns1__StartRecordingRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__StartRecordingRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__StartRecordingRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__StartRecordingRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__StartRecordingRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__StartRecordingRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:StartRecordingRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__StartRecordingRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__StartRecordingRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__StartRecordingRequest * SOAP_FMAC4 soap_get__ns1__StartRecordingRequest(struct soap *soap, _ns1__StartRecordingRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__StartRecordingRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetRecordingProfilesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GetRecordingProfilesResponse::total);
	this->_ns1__GetRecordingProfilesResponse::__sizerecorder = 0;
	this->_ns1__GetRecordingProfilesResponse::recorder = NULL;
	/* transient soap skipped */
}

void _ns1__GetRecordingProfilesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns1__GetRecordingProfilesResponse::total, SOAP_TYPE_int);
	if (this->_ns1__GetRecordingProfilesResponse::recorder)
	{	int i;
		for (i = 0; i < (int)this->_ns1__GetRecordingProfilesResponse::__sizerecorder; i++)
		{
			soap_serialize_PointerTons1__Recorder(soap, this->_ns1__GetRecordingProfilesResponse::recorder + i);
		}
	}
#endif
}

int _ns1__GetRecordingProfilesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetRecordingProfilesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetRecordingProfilesResponse(struct soap *soap, const char *tag, int id, const _ns1__GetRecordingProfilesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetRecordingProfilesResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:total");
	if (soap_out_int(soap, "ns1:total", -1, &a->_ns1__GetRecordingProfilesResponse::total, ""))
		return soap->error;
	if (a->_ns1__GetRecordingProfilesResponse::recorder)
	{	int i;
		for (i = 0; i < (int)a->_ns1__GetRecordingProfilesResponse::__sizerecorder; i++)
			if (soap_out_PointerTons1__Recorder(soap, "ns1:recorder", -1, a->_ns1__GetRecordingProfilesResponse::recorder + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetRecordingProfilesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetRecordingProfilesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetRecordingProfilesResponse * SOAP_FMAC4 soap_in__ns1__GetRecordingProfilesResponse(struct soap *soap, const char *tag, _ns1__GetRecordingProfilesResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetRecordingProfilesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetRecordingProfilesResponse, sizeof(_ns1__GetRecordingProfilesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_total1 = 1;
	struct soap_blist *soap_blist_recorder1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_total1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:total", &a->_ns1__GetRecordingProfilesResponse::total, "xsd:int"))
				{	soap_flag_total1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:recorder", 1, NULL))
			{	if (a->_ns1__GetRecordingProfilesResponse::recorder == NULL)
				{	if (soap_blist_recorder1 == NULL)
						soap_blist_recorder1 = soap_new_block(soap);
					a->_ns1__GetRecordingProfilesResponse::recorder = (ns1__Recorder **)soap_push_block_max(soap, soap_blist_recorder1, sizeof(ns1__Recorder *));
					if (a->_ns1__GetRecordingProfilesResponse::recorder == NULL)
						return NULL;
					*a->_ns1__GetRecordingProfilesResponse::recorder = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__Recorder(soap, "ns1:recorder", a->_ns1__GetRecordingProfilesResponse::recorder, "ns1:Recorder"))
				{	a->_ns1__GetRecordingProfilesResponse::__sizerecorder++;
					a->_ns1__GetRecordingProfilesResponse::recorder = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:total");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__GetRecordingProfilesResponse::recorder)
			soap_pop_block(soap, soap_blist_recorder1);
		if (a->_ns1__GetRecordingProfilesResponse::__sizerecorder)
		{	a->_ns1__GetRecordingProfilesResponse::recorder = (ns1__Recorder **)soap_save_block(soap, soap_blist_recorder1, NULL, 1);
		}
		else
		{	a->_ns1__GetRecordingProfilesResponse::recorder = NULL;
			if (soap_blist_recorder1)
				soap_end_block(soap, soap_blist_recorder1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_total1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetRecordingProfilesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetRecordingProfilesResponse, SOAP_TYPE__ns1__GetRecordingProfilesResponse, sizeof(_ns1__GetRecordingProfilesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetRecordingProfilesResponse * SOAP_FMAC2 soap_instantiate__ns1__GetRecordingProfilesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetRecordingProfilesResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetRecordingProfilesResponse *p;
	size_t k = sizeof(_ns1__GetRecordingProfilesResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetRecordingProfilesResponse);
		if (p)
			((_ns1__GetRecordingProfilesResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetRecordingProfilesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetRecordingProfilesResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetRecordingProfilesResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetRecordingProfilesResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetRecordingProfilesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:GetRecordingProfilesResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetRecordingProfilesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetRecordingProfilesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetRecordingProfilesResponse * SOAP_FMAC4 soap_get__ns1__GetRecordingProfilesResponse(struct soap *soap, _ns1__GetRecordingProfilesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetRecordingProfilesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetRecordingProfilesRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__GetRecordingProfilesRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__GetRecordingProfilesRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetRecordingProfilesRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetRecordingProfilesRequest(struct soap *soap, const char *tag, int id, const _ns1__GetRecordingProfilesRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetRecordingProfilesRequest), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetRecordingProfilesRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetRecordingProfilesRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetRecordingProfilesRequest * SOAP_FMAC4 soap_in__ns1__GetRecordingProfilesRequest(struct soap *soap, const char *tag, _ns1__GetRecordingProfilesRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetRecordingProfilesRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetRecordingProfilesRequest, sizeof(_ns1__GetRecordingProfilesRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetRecordingProfilesRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetRecordingProfilesRequest, SOAP_TYPE__ns1__GetRecordingProfilesRequest, sizeof(_ns1__GetRecordingProfilesRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetRecordingProfilesRequest * SOAP_FMAC2 soap_instantiate__ns1__GetRecordingProfilesRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetRecordingProfilesRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetRecordingProfilesRequest *p;
	size_t k = sizeof(_ns1__GetRecordingProfilesRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetRecordingProfilesRequest);
		if (p)
			((_ns1__GetRecordingProfilesRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetRecordingProfilesRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetRecordingProfilesRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetRecordingProfilesRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetRecordingProfilesRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetRecordingProfilesRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:GetRecordingProfilesRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetRecordingProfilesRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetRecordingProfilesRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetRecordingProfilesRequest * SOAP_FMAC4 soap_get__ns1__GetRecordingProfilesRequest(struct soap *soap, _ns1__GetRecordingProfilesRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetRecordingProfilesRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SetMemberModeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__SetMemberModeResponse::OK);
	/* transient soap skipped */
}

void _ns1__SetMemberModeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__SetMemberModeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetMemberModeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetMemberModeResponse(struct soap *soap, const char *tag, int id, const _ns1__SetMemberModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetMemberModeResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__SetMemberModeResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetMemberModeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetMemberModeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetMemberModeResponse * SOAP_FMAC4 soap_in__ns1__SetMemberModeResponse(struct soap *soap, const char *tag, _ns1__SetMemberModeResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetMemberModeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetMemberModeResponse, sizeof(_ns1__SetMemberModeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__SetMemberModeResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__SetMemberModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetMemberModeResponse, SOAP_TYPE__ns1__SetMemberModeResponse, sizeof(_ns1__SetMemberModeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SetMemberModeResponse * SOAP_FMAC2 soap_instantiate__ns1__SetMemberModeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetMemberModeResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SetMemberModeResponse *p;
	size_t k = sizeof(_ns1__SetMemberModeResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SetMemberModeResponse);
		if (p)
			((_ns1__SetMemberModeResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SetMemberModeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SetMemberModeResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SetMemberModeResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SetMemberModeResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SetMemberModeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SetMemberModeResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SetMemberModeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetMemberModeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetMemberModeResponse * SOAP_FMAC4 soap_get__ns1__SetMemberModeResponse(struct soap *soap, _ns1__SetMemberModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetMemberModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SetMemberModeRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__MemberMode(soap, &this->_ns1__SetMemberModeRequest::MemberMode);
	/* transient soap skipped */
}

void _ns1__SetMemberModeRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns1__SetMemberModeRequest::MemberMode, SOAP_TYPE__ns1__MemberMode);
#endif
}

int _ns1__SetMemberModeRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetMemberModeRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetMemberModeRequest(struct soap *soap, const char *tag, int id, const _ns1__SetMemberModeRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetMemberModeRequest), type))
		return soap->error;
	if (soap_out__ns1__MemberMode(soap, "ns1:MemberMode", -1, &a->_ns1__SetMemberModeRequest::MemberMode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetMemberModeRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetMemberModeRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetMemberModeRequest * SOAP_FMAC4 soap_in__ns1__SetMemberModeRequest(struct soap *soap, const char *tag, _ns1__SetMemberModeRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetMemberModeRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetMemberModeRequest, sizeof(_ns1__SetMemberModeRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MemberMode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MemberMode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__MemberMode(soap, "ns1:MemberMode", &a->_ns1__SetMemberModeRequest::MemberMode, "ns1:MemberMode"))
				{	soap_flag_MemberMode1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MemberMode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__SetMemberModeRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetMemberModeRequest, SOAP_TYPE__ns1__SetMemberModeRequest, sizeof(_ns1__SetMemberModeRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SetMemberModeRequest * SOAP_FMAC2 soap_instantiate__ns1__SetMemberModeRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetMemberModeRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SetMemberModeRequest *p;
	size_t k = sizeof(_ns1__SetMemberModeRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SetMemberModeRequest);
		if (p)
			((_ns1__SetMemberModeRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SetMemberModeRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SetMemberModeRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SetMemberModeRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SetMemberModeRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SetMemberModeRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SetMemberModeRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SetMemberModeRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetMemberModeRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetMemberModeRequest * SOAP_FMAC4 soap_get__ns1__SetMemberModeRequest(struct soap *soap, _ns1__SetMemberModeRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetMemberModeRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__UnlockRoomResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__UnlockRoomResponse::OK);
	/* transient soap skipped */
}

void _ns1__UnlockRoomResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__UnlockRoomResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UnlockRoomResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UnlockRoomResponse(struct soap *soap, const char *tag, int id, const _ns1__UnlockRoomResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UnlockRoomResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__UnlockRoomResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__UnlockRoomResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UnlockRoomResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UnlockRoomResponse * SOAP_FMAC4 soap_in__ns1__UnlockRoomResponse(struct soap *soap, const char *tag, _ns1__UnlockRoomResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UnlockRoomResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UnlockRoomResponse, sizeof(_ns1__UnlockRoomResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__UnlockRoomResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__UnlockRoomResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UnlockRoomResponse, SOAP_TYPE__ns1__UnlockRoomResponse, sizeof(_ns1__UnlockRoomResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__UnlockRoomResponse * SOAP_FMAC2 soap_instantiate__ns1__UnlockRoomResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UnlockRoomResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__UnlockRoomResponse *p;
	size_t k = sizeof(_ns1__UnlockRoomResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__UnlockRoomResponse);
		if (p)
			((_ns1__UnlockRoomResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__UnlockRoomResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__UnlockRoomResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__UnlockRoomResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__UnlockRoomResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__UnlockRoomResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:UnlockRoomResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UnlockRoomResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UnlockRoomResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UnlockRoomResponse * SOAP_FMAC4 soap_get__ns1__UnlockRoomResponse(struct soap *soap, _ns1__UnlockRoomResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UnlockRoomResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__UnlockRoomRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__UnlockRoomRequest::roomID);
	soap_default_string(soap, &this->_ns1__UnlockRoomRequest::moderatorPIN);
	/* transient soap skipped */
}

void _ns1__UnlockRoomRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__UnlockRoomRequest::roomID);
	soap_serialize_string(soap, (char*const*)&this->_ns1__UnlockRoomRequest::moderatorPIN);
#endif
}

int _ns1__UnlockRoomRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UnlockRoomRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UnlockRoomRequest(struct soap *soap, const char *tag, int id, const _ns1__UnlockRoomRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UnlockRoomRequest), type))
		return soap->error;
	if (!a->_ns1__UnlockRoomRequest::roomID)
	{	if (soap_element_nil(soap, "ns1:roomID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:roomID", -1, (char*const*)&a->_ns1__UnlockRoomRequest::roomID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:moderatorPIN", -1, (char*const*)&a->_ns1__UnlockRoomRequest::moderatorPIN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__UnlockRoomRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UnlockRoomRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UnlockRoomRequest * SOAP_FMAC4 soap_in__ns1__UnlockRoomRequest(struct soap *soap, const char *tag, _ns1__UnlockRoomRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UnlockRoomRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UnlockRoomRequest, sizeof(_ns1__UnlockRoomRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_roomID1 = 1;
	size_t soap_flag_moderatorPIN1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_roomID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:roomID", (char**)&a->_ns1__UnlockRoomRequest::roomID, "ns1:EntityID"))
				{	soap_flag_roomID1--;
					continue;
				}
			if (soap_flag_moderatorPIN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:moderatorPIN", (char**)&a->_ns1__UnlockRoomRequest::moderatorPIN, "xsd:string"))
				{	soap_flag_moderatorPIN1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_roomID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__UnlockRoomRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UnlockRoomRequest, SOAP_TYPE__ns1__UnlockRoomRequest, sizeof(_ns1__UnlockRoomRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__UnlockRoomRequest * SOAP_FMAC2 soap_instantiate__ns1__UnlockRoomRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UnlockRoomRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__UnlockRoomRequest *p;
	size_t k = sizeof(_ns1__UnlockRoomRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__UnlockRoomRequest);
		if (p)
			((_ns1__UnlockRoomRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__UnlockRoomRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__UnlockRoomRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__UnlockRoomRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__UnlockRoomRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__UnlockRoomRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:UnlockRoomRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UnlockRoomRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UnlockRoomRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UnlockRoomRequest * SOAP_FMAC4 soap_get__ns1__UnlockRoomRequest(struct soap *soap, _ns1__UnlockRoomRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UnlockRoomRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__LockRoomResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__LockRoomResponse::OK);
	/* transient soap skipped */
}

void _ns1__LockRoomResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__LockRoomResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__LockRoomResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__LockRoomResponse(struct soap *soap, const char *tag, int id, const _ns1__LockRoomResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__LockRoomResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__LockRoomResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__LockRoomResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__LockRoomResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__LockRoomResponse * SOAP_FMAC4 soap_in__ns1__LockRoomResponse(struct soap *soap, const char *tag, _ns1__LockRoomResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__LockRoomResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__LockRoomResponse, sizeof(_ns1__LockRoomResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__LockRoomResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__LockRoomResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__LockRoomResponse, SOAP_TYPE__ns1__LockRoomResponse, sizeof(_ns1__LockRoomResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__LockRoomResponse * SOAP_FMAC2 soap_instantiate__ns1__LockRoomResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__LockRoomResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__LockRoomResponse *p;
	size_t k = sizeof(_ns1__LockRoomResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__LockRoomResponse);
		if (p)
			((_ns1__LockRoomResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__LockRoomResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__LockRoomResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__LockRoomResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__LockRoomResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__LockRoomResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:LockRoomResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__LockRoomResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__LockRoomResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__LockRoomResponse * SOAP_FMAC4 soap_get__ns1__LockRoomResponse(struct soap *soap, _ns1__LockRoomResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__LockRoomResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__LockRoomRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__LockRoomRequest::roomID);
	soap_default_string(soap, &this->_ns1__LockRoomRequest::moderatorPIN);
	/* transient soap skipped */
}

void _ns1__LockRoomRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__LockRoomRequest::roomID);
	soap_serialize_string(soap, (char*const*)&this->_ns1__LockRoomRequest::moderatorPIN);
#endif
}

int _ns1__LockRoomRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__LockRoomRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__LockRoomRequest(struct soap *soap, const char *tag, int id, const _ns1__LockRoomRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__LockRoomRequest), type))
		return soap->error;
	if (!a->_ns1__LockRoomRequest::roomID)
	{	if (soap_element_nil(soap, "ns1:roomID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:roomID", -1, (char*const*)&a->_ns1__LockRoomRequest::roomID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:moderatorPIN", -1, (char*const*)&a->_ns1__LockRoomRequest::moderatorPIN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__LockRoomRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__LockRoomRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__LockRoomRequest * SOAP_FMAC4 soap_in__ns1__LockRoomRequest(struct soap *soap, const char *tag, _ns1__LockRoomRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__LockRoomRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__LockRoomRequest, sizeof(_ns1__LockRoomRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_roomID1 = 1;
	size_t soap_flag_moderatorPIN1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_roomID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:roomID", (char**)&a->_ns1__LockRoomRequest::roomID, "ns1:EntityID"))
				{	soap_flag_roomID1--;
					continue;
				}
			if (soap_flag_moderatorPIN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:moderatorPIN", (char**)&a->_ns1__LockRoomRequest::moderatorPIN, "xsd:string"))
				{	soap_flag_moderatorPIN1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_roomID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__LockRoomRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__LockRoomRequest, SOAP_TYPE__ns1__LockRoomRequest, sizeof(_ns1__LockRoomRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__LockRoomRequest * SOAP_FMAC2 soap_instantiate__ns1__LockRoomRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__LockRoomRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__LockRoomRequest *p;
	size_t k = sizeof(_ns1__LockRoomRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__LockRoomRequest);
		if (p)
			((_ns1__LockRoomRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__LockRoomRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__LockRoomRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__LockRoomRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__LockRoomRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__LockRoomRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:LockRoomRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__LockRoomRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__LockRoomRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__LockRoomRequest * SOAP_FMAC4 soap_get__ns1__LockRoomRequest(struct soap *soap, _ns1__LockRoomRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__LockRoomRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__UpdateLanguageResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__UpdateLanguageResponse::OK);
	/* transient soap skipped */
}

void _ns1__UpdateLanguageResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__UpdateLanguageResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdateLanguageResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdateLanguageResponse(struct soap *soap, const char *tag, int id, const _ns1__UpdateLanguageResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdateLanguageResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__UpdateLanguageResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdateLanguageResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdateLanguageResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdateLanguageResponse * SOAP_FMAC4 soap_in__ns1__UpdateLanguageResponse(struct soap *soap, const char *tag, _ns1__UpdateLanguageResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdateLanguageResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdateLanguageResponse, sizeof(_ns1__UpdateLanguageResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__UpdateLanguageResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__UpdateLanguageResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdateLanguageResponse, SOAP_TYPE__ns1__UpdateLanguageResponse, sizeof(_ns1__UpdateLanguageResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__UpdateLanguageResponse * SOAP_FMAC2 soap_instantiate__ns1__UpdateLanguageResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdateLanguageResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__UpdateLanguageResponse *p;
	size_t k = sizeof(_ns1__UpdateLanguageResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__UpdateLanguageResponse);
		if (p)
			((_ns1__UpdateLanguageResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__UpdateLanguageResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__UpdateLanguageResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__UpdateLanguageResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__UpdateLanguageResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__UpdateLanguageResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:UpdateLanguageResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdateLanguageResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdateLanguageResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdateLanguageResponse * SOAP_FMAC4 soap_get__ns1__UpdateLanguageResponse(struct soap *soap, _ns1__UpdateLanguageResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdateLanguageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__UpdateLanguageRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__Language(soap, &this->_ns1__UpdateLanguageRequest::Language);
	/* transient soap skipped */
}

void _ns1__UpdateLanguageRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns1__UpdateLanguageRequest::Language, SOAP_TYPE__ns1__Language);
#endif
}

int _ns1__UpdateLanguageRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdateLanguageRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdateLanguageRequest(struct soap *soap, const char *tag, int id, const _ns1__UpdateLanguageRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdateLanguageRequest), type))
		return soap->error;
	if (soap_out__ns1__Language(soap, "ns1:Language", -1, &a->_ns1__UpdateLanguageRequest::Language, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdateLanguageRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdateLanguageRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdateLanguageRequest * SOAP_FMAC4 soap_in__ns1__UpdateLanguageRequest(struct soap *soap, const char *tag, _ns1__UpdateLanguageRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdateLanguageRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdateLanguageRequest, sizeof(_ns1__UpdateLanguageRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Language1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Language1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__Language(soap, "ns1:Language", &a->_ns1__UpdateLanguageRequest::Language, "ns1:Language"))
				{	soap_flag_Language1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Language1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__UpdateLanguageRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdateLanguageRequest, SOAP_TYPE__ns1__UpdateLanguageRequest, sizeof(_ns1__UpdateLanguageRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__UpdateLanguageRequest * SOAP_FMAC2 soap_instantiate__ns1__UpdateLanguageRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdateLanguageRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__UpdateLanguageRequest *p;
	size_t k = sizeof(_ns1__UpdateLanguageRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__UpdateLanguageRequest);
		if (p)
			((_ns1__UpdateLanguageRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__UpdateLanguageRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__UpdateLanguageRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__UpdateLanguageRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__UpdateLanguageRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__UpdateLanguageRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:UpdateLanguageRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdateLanguageRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdateLanguageRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdateLanguageRequest * SOAP_FMAC4 soap_get__ns1__UpdateLanguageRequest(struct soap *soap, _ns1__UpdateLanguageRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdateLanguageRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__UpdatePasswordResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__UpdatePasswordResponse::OK);
	/* transient soap skipped */
}

void _ns1__UpdatePasswordResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__UpdatePasswordResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdatePasswordResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdatePasswordResponse(struct soap *soap, const char *tag, int id, const _ns1__UpdatePasswordResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdatePasswordResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__UpdatePasswordResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdatePasswordResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdatePasswordResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdatePasswordResponse * SOAP_FMAC4 soap_in__ns1__UpdatePasswordResponse(struct soap *soap, const char *tag, _ns1__UpdatePasswordResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdatePasswordResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdatePasswordResponse, sizeof(_ns1__UpdatePasswordResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__UpdatePasswordResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__UpdatePasswordResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdatePasswordResponse, SOAP_TYPE__ns1__UpdatePasswordResponse, sizeof(_ns1__UpdatePasswordResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__UpdatePasswordResponse * SOAP_FMAC2 soap_instantiate__ns1__UpdatePasswordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdatePasswordResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__UpdatePasswordResponse *p;
	size_t k = sizeof(_ns1__UpdatePasswordResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__UpdatePasswordResponse);
		if (p)
			((_ns1__UpdatePasswordResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__UpdatePasswordResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__UpdatePasswordResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__UpdatePasswordResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__UpdatePasswordResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__UpdatePasswordResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:UpdatePasswordResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdatePasswordResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdatePasswordResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdatePasswordResponse * SOAP_FMAC4 soap_get__ns1__UpdatePasswordResponse(struct soap *soap, _ns1__UpdatePasswordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdatePasswordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__UpdatePasswordRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__UpdatePasswordRequest::password);
	/* transient soap skipped */
}

void _ns1__UpdatePasswordRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__UpdatePasswordRequest::password);
#endif
}

int _ns1__UpdatePasswordRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdatePasswordRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdatePasswordRequest(struct soap *soap, const char *tag, int id, const _ns1__UpdatePasswordRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdatePasswordRequest), type))
		return soap->error;
	if (!a->_ns1__UpdatePasswordRequest::password)
	{	if (soap_element_nil(soap, "ns1:password"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:password", -1, (char*const*)&a->_ns1__UpdatePasswordRequest::password, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdatePasswordRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdatePasswordRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdatePasswordRequest * SOAP_FMAC4 soap_in__ns1__UpdatePasswordRequest(struct soap *soap, const char *tag, _ns1__UpdatePasswordRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdatePasswordRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdatePasswordRequest, sizeof(_ns1__UpdatePasswordRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:password", (char**)&a->_ns1__UpdatePasswordRequest::password, "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_password1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__UpdatePasswordRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdatePasswordRequest, SOAP_TYPE__ns1__UpdatePasswordRequest, sizeof(_ns1__UpdatePasswordRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__UpdatePasswordRequest * SOAP_FMAC2 soap_instantiate__ns1__UpdatePasswordRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdatePasswordRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__UpdatePasswordRequest *p;
	size_t k = sizeof(_ns1__UpdatePasswordRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__UpdatePasswordRequest);
		if (p)
			((_ns1__UpdatePasswordRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__UpdatePasswordRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__UpdatePasswordRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__UpdatePasswordRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__UpdatePasswordRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__UpdatePasswordRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:UpdatePasswordRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdatePasswordRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdatePasswordRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdatePasswordRequest * SOAP_FMAC4 soap_get__ns1__UpdatePasswordRequest(struct soap *soap, _ns1__UpdatePasswordRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdatePasswordRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__RemoveRoomPINResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__RemoveRoomPINResponse::OK);
	/* transient soap skipped */
}

void _ns1__RemoveRoomPINResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__RemoveRoomPINResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RemoveRoomPINResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RemoveRoomPINResponse(struct soap *soap, const char *tag, int id, const _ns1__RemoveRoomPINResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RemoveRoomPINResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__RemoveRoomPINResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__RemoveRoomPINResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RemoveRoomPINResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RemoveRoomPINResponse * SOAP_FMAC4 soap_in__ns1__RemoveRoomPINResponse(struct soap *soap, const char *tag, _ns1__RemoveRoomPINResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RemoveRoomPINResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RemoveRoomPINResponse, sizeof(_ns1__RemoveRoomPINResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__RemoveRoomPINResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__RemoveRoomPINResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RemoveRoomPINResponse, SOAP_TYPE__ns1__RemoveRoomPINResponse, sizeof(_ns1__RemoveRoomPINResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__RemoveRoomPINResponse * SOAP_FMAC2 soap_instantiate__ns1__RemoveRoomPINResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RemoveRoomPINResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__RemoveRoomPINResponse *p;
	size_t k = sizeof(_ns1__RemoveRoomPINResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__RemoveRoomPINResponse);
		if (p)
			((_ns1__RemoveRoomPINResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__RemoveRoomPINResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__RemoveRoomPINResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__RemoveRoomPINResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__RemoveRoomPINResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__RemoveRoomPINResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:RemoveRoomPINResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RemoveRoomPINResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RemoveRoomPINResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RemoveRoomPINResponse * SOAP_FMAC4 soap_get__ns1__RemoveRoomPINResponse(struct soap *soap, _ns1__RemoveRoomPINResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RemoveRoomPINResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__RemoveRoomPINRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__RemoveRoomPINRequest::roomID);
	/* transient soap skipped */
}

void _ns1__RemoveRoomPINRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__RemoveRoomPINRequest::roomID);
#endif
}

int _ns1__RemoveRoomPINRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RemoveRoomPINRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RemoveRoomPINRequest(struct soap *soap, const char *tag, int id, const _ns1__RemoveRoomPINRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RemoveRoomPINRequest), type))
		return soap->error;
	if (!a->_ns1__RemoveRoomPINRequest::roomID)
	{	if (soap_element_nil(soap, "ns1:roomID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:roomID", -1, (char*const*)&a->_ns1__RemoveRoomPINRequest::roomID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__RemoveRoomPINRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RemoveRoomPINRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RemoveRoomPINRequest * SOAP_FMAC4 soap_in__ns1__RemoveRoomPINRequest(struct soap *soap, const char *tag, _ns1__RemoveRoomPINRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RemoveRoomPINRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RemoveRoomPINRequest, sizeof(_ns1__RemoveRoomPINRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_roomID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_roomID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:roomID", (char**)&a->_ns1__RemoveRoomPINRequest::roomID, "ns1:EntityID"))
				{	soap_flag_roomID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_roomID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__RemoveRoomPINRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RemoveRoomPINRequest, SOAP_TYPE__ns1__RemoveRoomPINRequest, sizeof(_ns1__RemoveRoomPINRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__RemoveRoomPINRequest * SOAP_FMAC2 soap_instantiate__ns1__RemoveRoomPINRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RemoveRoomPINRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__RemoveRoomPINRequest *p;
	size_t k = sizeof(_ns1__RemoveRoomPINRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__RemoveRoomPINRequest);
		if (p)
			((_ns1__RemoveRoomPINRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__RemoveRoomPINRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__RemoveRoomPINRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__RemoveRoomPINRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__RemoveRoomPINRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__RemoveRoomPINRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:RemoveRoomPINRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RemoveRoomPINRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RemoveRoomPINRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RemoveRoomPINRequest * SOAP_FMAC4 soap_get__ns1__RemoveRoomPINRequest(struct soap *soap, _ns1__RemoveRoomPINRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RemoveRoomPINRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CreateRoomPINResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__CreateRoomPINResponse::OK);
	/* transient soap skipped */
}

void _ns1__CreateRoomPINResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__CreateRoomPINResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CreateRoomPINResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CreateRoomPINResponse(struct soap *soap, const char *tag, int id, const _ns1__CreateRoomPINResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CreateRoomPINResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__CreateRoomPINResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CreateRoomPINResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CreateRoomPINResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CreateRoomPINResponse * SOAP_FMAC4 soap_in__ns1__CreateRoomPINResponse(struct soap *soap, const char *tag, _ns1__CreateRoomPINResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CreateRoomPINResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CreateRoomPINResponse, sizeof(_ns1__CreateRoomPINResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__CreateRoomPINResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__CreateRoomPINResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CreateRoomPINResponse, SOAP_TYPE__ns1__CreateRoomPINResponse, sizeof(_ns1__CreateRoomPINResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CreateRoomPINResponse * SOAP_FMAC2 soap_instantiate__ns1__CreateRoomPINResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CreateRoomPINResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CreateRoomPINResponse *p;
	size_t k = sizeof(_ns1__CreateRoomPINResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__CreateRoomPINResponse);
		if (p)
			((_ns1__CreateRoomPINResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__CreateRoomPINResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__CreateRoomPINResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CreateRoomPINResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__CreateRoomPINResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__CreateRoomPINResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:CreateRoomPINResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CreateRoomPINResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CreateRoomPINResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CreateRoomPINResponse * SOAP_FMAC4 soap_get__ns1__CreateRoomPINResponse(struct soap *soap, _ns1__CreateRoomPINResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CreateRoomPINResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CreateRoomPINRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__CreateRoomPINRequest::roomID);
	soap_default_string(soap, &this->_ns1__CreateRoomPINRequest::PIN);
	/* transient soap skipped */
}

void _ns1__CreateRoomPINRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__CreateRoomPINRequest::roomID);
	soap_serialize_string(soap, (char*const*)&this->_ns1__CreateRoomPINRequest::PIN);
#endif
}

int _ns1__CreateRoomPINRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CreateRoomPINRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CreateRoomPINRequest(struct soap *soap, const char *tag, int id, const _ns1__CreateRoomPINRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CreateRoomPINRequest), type))
		return soap->error;
	if (!a->_ns1__CreateRoomPINRequest::roomID)
	{	if (soap_element_nil(soap, "ns1:roomID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:roomID", -1, (char*const*)&a->_ns1__CreateRoomPINRequest::roomID, ""))
		return soap->error;
	if (!a->_ns1__CreateRoomPINRequest::PIN)
	{	if (soap_element_nil(soap, "ns1:PIN"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:PIN", -1, (char*const*)&a->_ns1__CreateRoomPINRequest::PIN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CreateRoomPINRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CreateRoomPINRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CreateRoomPINRequest * SOAP_FMAC4 soap_in__ns1__CreateRoomPINRequest(struct soap *soap, const char *tag, _ns1__CreateRoomPINRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CreateRoomPINRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CreateRoomPINRequest, sizeof(_ns1__CreateRoomPINRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_roomID1 = 1;
	size_t soap_flag_PIN1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_roomID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:roomID", (char**)&a->_ns1__CreateRoomPINRequest::roomID, "ns1:EntityID"))
				{	soap_flag_roomID1--;
					continue;
				}
			if (soap_flag_PIN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:PIN", (char**)&a->_ns1__CreateRoomPINRequest::PIN, "xsd:string"))
				{	soap_flag_PIN1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_roomID1 > 0 || soap_flag_PIN1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__CreateRoomPINRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CreateRoomPINRequest, SOAP_TYPE__ns1__CreateRoomPINRequest, sizeof(_ns1__CreateRoomPINRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CreateRoomPINRequest * SOAP_FMAC2 soap_instantiate__ns1__CreateRoomPINRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CreateRoomPINRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CreateRoomPINRequest *p;
	size_t k = sizeof(_ns1__CreateRoomPINRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__CreateRoomPINRequest);
		if (p)
			((_ns1__CreateRoomPINRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__CreateRoomPINRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__CreateRoomPINRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CreateRoomPINRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__CreateRoomPINRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__CreateRoomPINRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:CreateRoomPINRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CreateRoomPINRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CreateRoomPINRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CreateRoomPINRequest * SOAP_FMAC4 soap_get__ns1__CreateRoomPINRequest(struct soap *soap, _ns1__CreateRoomPINRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CreateRoomPINRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__RemoveRoomURLResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__RemoveRoomURLResponse::OK);
	/* transient soap skipped */
}

void _ns1__RemoveRoomURLResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__RemoveRoomURLResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RemoveRoomURLResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RemoveRoomURLResponse(struct soap *soap, const char *tag, int id, const _ns1__RemoveRoomURLResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RemoveRoomURLResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__RemoveRoomURLResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__RemoveRoomURLResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RemoveRoomURLResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RemoveRoomURLResponse * SOAP_FMAC4 soap_in__ns1__RemoveRoomURLResponse(struct soap *soap, const char *tag, _ns1__RemoveRoomURLResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RemoveRoomURLResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RemoveRoomURLResponse, sizeof(_ns1__RemoveRoomURLResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__RemoveRoomURLResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__RemoveRoomURLResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RemoveRoomURLResponse, SOAP_TYPE__ns1__RemoveRoomURLResponse, sizeof(_ns1__RemoveRoomURLResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__RemoveRoomURLResponse * SOAP_FMAC2 soap_instantiate__ns1__RemoveRoomURLResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RemoveRoomURLResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__RemoveRoomURLResponse *p;
	size_t k = sizeof(_ns1__RemoveRoomURLResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__RemoveRoomURLResponse);
		if (p)
			((_ns1__RemoveRoomURLResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__RemoveRoomURLResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__RemoveRoomURLResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__RemoveRoomURLResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__RemoveRoomURLResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__RemoveRoomURLResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:RemoveRoomURLResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RemoveRoomURLResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RemoveRoomURLResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RemoveRoomURLResponse * SOAP_FMAC4 soap_get__ns1__RemoveRoomURLResponse(struct soap *soap, _ns1__RemoveRoomURLResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RemoveRoomURLResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__RemoveRoomURLRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__RemoveRoomURLRequest::roomID);
	/* transient soap skipped */
}

void _ns1__RemoveRoomURLRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__RemoveRoomURLRequest::roomID);
#endif
}

int _ns1__RemoveRoomURLRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RemoveRoomURLRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RemoveRoomURLRequest(struct soap *soap, const char *tag, int id, const _ns1__RemoveRoomURLRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RemoveRoomURLRequest), type))
		return soap->error;
	if (!a->_ns1__RemoveRoomURLRequest::roomID)
	{	if (soap_element_nil(soap, "ns1:roomID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:roomID", -1, (char*const*)&a->_ns1__RemoveRoomURLRequest::roomID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__RemoveRoomURLRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RemoveRoomURLRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RemoveRoomURLRequest * SOAP_FMAC4 soap_in__ns1__RemoveRoomURLRequest(struct soap *soap, const char *tag, _ns1__RemoveRoomURLRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RemoveRoomURLRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RemoveRoomURLRequest, sizeof(_ns1__RemoveRoomURLRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_roomID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_roomID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:roomID", (char**)&a->_ns1__RemoveRoomURLRequest::roomID, "ns1:EntityID"))
				{	soap_flag_roomID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_roomID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__RemoveRoomURLRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RemoveRoomURLRequest, SOAP_TYPE__ns1__RemoveRoomURLRequest, sizeof(_ns1__RemoveRoomURLRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__RemoveRoomURLRequest * SOAP_FMAC2 soap_instantiate__ns1__RemoveRoomURLRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RemoveRoomURLRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__RemoveRoomURLRequest *p;
	size_t k = sizeof(_ns1__RemoveRoomURLRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__RemoveRoomURLRequest);
		if (p)
			((_ns1__RemoveRoomURLRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__RemoveRoomURLRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__RemoveRoomURLRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__RemoveRoomURLRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__RemoveRoomURLRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__RemoveRoomURLRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:RemoveRoomURLRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RemoveRoomURLRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RemoveRoomURLRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RemoveRoomURLRequest * SOAP_FMAC4 soap_get__ns1__RemoveRoomURLRequest(struct soap *soap, _ns1__RemoveRoomURLRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RemoveRoomURLRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CreateRoomURLResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__CreateRoomURLResponse::OK);
	/* transient soap skipped */
}

void _ns1__CreateRoomURLResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__CreateRoomURLResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CreateRoomURLResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CreateRoomURLResponse(struct soap *soap, const char *tag, int id, const _ns1__CreateRoomURLResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CreateRoomURLResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__CreateRoomURLResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CreateRoomURLResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CreateRoomURLResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CreateRoomURLResponse * SOAP_FMAC4 soap_in__ns1__CreateRoomURLResponse(struct soap *soap, const char *tag, _ns1__CreateRoomURLResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CreateRoomURLResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CreateRoomURLResponse, sizeof(_ns1__CreateRoomURLResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__CreateRoomURLResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__CreateRoomURLResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CreateRoomURLResponse, SOAP_TYPE__ns1__CreateRoomURLResponse, sizeof(_ns1__CreateRoomURLResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CreateRoomURLResponse * SOAP_FMAC2 soap_instantiate__ns1__CreateRoomURLResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CreateRoomURLResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CreateRoomURLResponse *p;
	size_t k = sizeof(_ns1__CreateRoomURLResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__CreateRoomURLResponse);
		if (p)
			((_ns1__CreateRoomURLResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__CreateRoomURLResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__CreateRoomURLResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CreateRoomURLResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__CreateRoomURLResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__CreateRoomURLResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:CreateRoomURLResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CreateRoomURLResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CreateRoomURLResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CreateRoomURLResponse * SOAP_FMAC4 soap_get__ns1__CreateRoomURLResponse(struct soap *soap, _ns1__CreateRoomURLResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CreateRoomURLResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CreateRoomURLRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__CreateRoomURLRequest::roomID);
	/* transient soap skipped */
}

void _ns1__CreateRoomURLRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__CreateRoomURLRequest::roomID);
#endif
}

int _ns1__CreateRoomURLRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CreateRoomURLRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CreateRoomURLRequest(struct soap *soap, const char *tag, int id, const _ns1__CreateRoomURLRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CreateRoomURLRequest), type))
		return soap->error;
	if (!a->_ns1__CreateRoomURLRequest::roomID)
	{	if (soap_element_nil(soap, "ns1:roomID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:roomID", -1, (char*const*)&a->_ns1__CreateRoomURLRequest::roomID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CreateRoomURLRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CreateRoomURLRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CreateRoomURLRequest * SOAP_FMAC4 soap_in__ns1__CreateRoomURLRequest(struct soap *soap, const char *tag, _ns1__CreateRoomURLRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CreateRoomURLRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CreateRoomURLRequest, sizeof(_ns1__CreateRoomURLRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_roomID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_roomID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:roomID", (char**)&a->_ns1__CreateRoomURLRequest::roomID, "ns1:EntityID"))
				{	soap_flag_roomID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_roomID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__CreateRoomURLRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CreateRoomURLRequest, SOAP_TYPE__ns1__CreateRoomURLRequest, sizeof(_ns1__CreateRoomURLRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CreateRoomURLRequest * SOAP_FMAC2 soap_instantiate__ns1__CreateRoomURLRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CreateRoomURLRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CreateRoomURLRequest *p;
	size_t k = sizeof(_ns1__CreateRoomURLRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__CreateRoomURLRequest);
		if (p)
			((_ns1__CreateRoomURLRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__CreateRoomURLRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__CreateRoomURLRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CreateRoomURLRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__CreateRoomURLRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__CreateRoomURLRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:CreateRoomURLRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CreateRoomURLRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CreateRoomURLRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CreateRoomURLRequest * SOAP_FMAC4 soap_get__ns1__CreateRoomURLRequest(struct soap *soap, _ns1__CreateRoomURLRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CreateRoomURLRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__DeleteRoomResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__DeleteRoomResponse::OK);
	/* transient soap skipped */
}

void _ns1__DeleteRoomResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__DeleteRoomResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DeleteRoomResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DeleteRoomResponse(struct soap *soap, const char *tag, int id, const _ns1__DeleteRoomResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DeleteRoomResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__DeleteRoomResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__DeleteRoomResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DeleteRoomResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DeleteRoomResponse * SOAP_FMAC4 soap_in__ns1__DeleteRoomResponse(struct soap *soap, const char *tag, _ns1__DeleteRoomResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DeleteRoomResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DeleteRoomResponse, sizeof(_ns1__DeleteRoomResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__DeleteRoomResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__DeleteRoomResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DeleteRoomResponse, SOAP_TYPE__ns1__DeleteRoomResponse, sizeof(_ns1__DeleteRoomResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__DeleteRoomResponse * SOAP_FMAC2 soap_instantiate__ns1__DeleteRoomResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DeleteRoomResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__DeleteRoomResponse *p;
	size_t k = sizeof(_ns1__DeleteRoomResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__DeleteRoomResponse);
		if (p)
			((_ns1__DeleteRoomResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__DeleteRoomResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__DeleteRoomResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__DeleteRoomResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__DeleteRoomResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__DeleteRoomResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:DeleteRoomResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DeleteRoomResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DeleteRoomResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DeleteRoomResponse * SOAP_FMAC4 soap_get__ns1__DeleteRoomResponse(struct soap *soap, _ns1__DeleteRoomResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DeleteRoomResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__DeleteRoomRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__DeleteRoomRequest::roomID);
	/* transient soap skipped */
}

void _ns1__DeleteRoomRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__DeleteRoomRequest::roomID);
#endif
}

int _ns1__DeleteRoomRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DeleteRoomRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DeleteRoomRequest(struct soap *soap, const char *tag, int id, const _ns1__DeleteRoomRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DeleteRoomRequest), type))
		return soap->error;
	if (!a->_ns1__DeleteRoomRequest::roomID)
	{	if (soap_element_nil(soap, "ns1:roomID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:roomID", -1, (char*const*)&a->_ns1__DeleteRoomRequest::roomID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__DeleteRoomRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DeleteRoomRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DeleteRoomRequest * SOAP_FMAC4 soap_in__ns1__DeleteRoomRequest(struct soap *soap, const char *tag, _ns1__DeleteRoomRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DeleteRoomRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DeleteRoomRequest, sizeof(_ns1__DeleteRoomRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_roomID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_roomID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:roomID", (char**)&a->_ns1__DeleteRoomRequest::roomID, "ns1:EntityID"))
				{	soap_flag_roomID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_roomID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__DeleteRoomRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DeleteRoomRequest, SOAP_TYPE__ns1__DeleteRoomRequest, sizeof(_ns1__DeleteRoomRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__DeleteRoomRequest * SOAP_FMAC2 soap_instantiate__ns1__DeleteRoomRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DeleteRoomRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__DeleteRoomRequest *p;
	size_t k = sizeof(_ns1__DeleteRoomRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__DeleteRoomRequest);
		if (p)
			((_ns1__DeleteRoomRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__DeleteRoomRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__DeleteRoomRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__DeleteRoomRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__DeleteRoomRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__DeleteRoomRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:DeleteRoomRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DeleteRoomRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DeleteRoomRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DeleteRoomRequest * SOAP_FMAC4 soap_get__ns1__DeleteRoomRequest(struct soap *soap, _ns1__DeleteRoomRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DeleteRoomRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CreateRoomResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__CreateRoomResponse::Entity = NULL;
	/* transient soap skipped */
}

void _ns1__CreateRoomResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Entity(soap, &this->_ns1__CreateRoomResponse::Entity);
#endif
}

int _ns1__CreateRoomResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CreateRoomResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CreateRoomResponse(struct soap *soap, const char *tag, int id, const _ns1__CreateRoomResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CreateRoomResponse), type))
		return soap->error;
	if (a->Entity)
		soap_element_result(soap, "ns1:Entity");
	if (!a->_ns1__CreateRoomResponse::Entity)
	{	if (soap_element_nil(soap, "ns1:Entity"))
			return soap->error;
	}
	else
	if (soap_out_PointerTo_ns1__Entity(soap, "ns1:Entity", -1, &a->_ns1__CreateRoomResponse::Entity, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CreateRoomResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CreateRoomResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CreateRoomResponse * SOAP_FMAC4 soap_in__ns1__CreateRoomResponse(struct soap *soap, const char *tag, _ns1__CreateRoomResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CreateRoomResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CreateRoomResponse, sizeof(_ns1__CreateRoomResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Entity1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Entity1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Entity(soap, "ns1:Entity", &a->_ns1__CreateRoomResponse::Entity, ""))
				{	soap_flag_Entity1--;
					continue;
				}
			soap_check_result(soap, "ns1:Entity");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Entity1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__CreateRoomResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CreateRoomResponse, SOAP_TYPE__ns1__CreateRoomResponse, sizeof(_ns1__CreateRoomResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CreateRoomResponse * SOAP_FMAC2 soap_instantiate__ns1__CreateRoomResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CreateRoomResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CreateRoomResponse *p;
	size_t k = sizeof(_ns1__CreateRoomResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__CreateRoomResponse);
		if (p)
			((_ns1__CreateRoomResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__CreateRoomResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__CreateRoomResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CreateRoomResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__CreateRoomResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__CreateRoomResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:CreateRoomResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CreateRoomResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CreateRoomResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CreateRoomResponse * SOAP_FMAC4 soap_get__ns1__CreateRoomResponse(struct soap *soap, _ns1__CreateRoomResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CreateRoomResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CreateRoomRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__CreateRoomRequest::name);
	soap_default_string(soap, &this->_ns1__CreateRoomRequest::extension);
	/* transient soap skipped */
}

void _ns1__CreateRoomRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__CreateRoomRequest::name);
	soap_serialize_string(soap, (char*const*)&this->_ns1__CreateRoomRequest::extension);
#endif
}

int _ns1__CreateRoomRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CreateRoomRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CreateRoomRequest(struct soap *soap, const char *tag, int id, const _ns1__CreateRoomRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CreateRoomRequest), type))
		return soap->error;
	if (!a->_ns1__CreateRoomRequest::name)
	{	if (soap_element_nil(soap, "ns1:name"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:name", -1, (char*const*)&a->_ns1__CreateRoomRequest::name, ""))
		return soap->error;
	if (!a->_ns1__CreateRoomRequest::extension)
	{	if (soap_element_nil(soap, "ns1:extension"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:extension", -1, (char*const*)&a->_ns1__CreateRoomRequest::extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CreateRoomRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CreateRoomRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CreateRoomRequest * SOAP_FMAC4 soap_in__ns1__CreateRoomRequest(struct soap *soap, const char *tag, _ns1__CreateRoomRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CreateRoomRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CreateRoomRequest, sizeof(_ns1__CreateRoomRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_name1 = 1;
	size_t soap_flag_extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:name", (char**)&a->_ns1__CreateRoomRequest::name, "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_extension1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:extension", (char**)&a->_ns1__CreateRoomRequest::extension, "xsd:string"))
				{	soap_flag_extension1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 > 0 || soap_flag_extension1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__CreateRoomRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CreateRoomRequest, SOAP_TYPE__ns1__CreateRoomRequest, sizeof(_ns1__CreateRoomRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CreateRoomRequest * SOAP_FMAC2 soap_instantiate__ns1__CreateRoomRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CreateRoomRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CreateRoomRequest *p;
	size_t k = sizeof(_ns1__CreateRoomRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__CreateRoomRequest);
		if (p)
			((_ns1__CreateRoomRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__CreateRoomRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__CreateRoomRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CreateRoomRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__CreateRoomRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__CreateRoomRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:CreateRoomRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CreateRoomRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CreateRoomRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CreateRoomRequest * SOAP_FMAC4 soap_get__ns1__CreateRoomRequest(struct soap *soap, _ns1__CreateRoomRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CreateRoomRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__MyAccountResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__MyAccountResponse::Entity = NULL;
	/* transient soap skipped */
}

void _ns1__MyAccountResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Entity(soap, &this->_ns1__MyAccountResponse::Entity);
#endif
}

int _ns1__MyAccountResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__MyAccountResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__MyAccountResponse(struct soap *soap, const char *tag, int id, const _ns1__MyAccountResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__MyAccountResponse), type))
		return soap->error;
	if (a->Entity)
		soap_element_result(soap, "ns1:Entity");
	if (!a->_ns1__MyAccountResponse::Entity)
	{	if (soap_element_nil(soap, "ns1:Entity"))
			return soap->error;
	}
	else
	if (soap_out_PointerTo_ns1__Entity(soap, "ns1:Entity", -1, &a->_ns1__MyAccountResponse::Entity, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__MyAccountResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__MyAccountResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__MyAccountResponse * SOAP_FMAC4 soap_in__ns1__MyAccountResponse(struct soap *soap, const char *tag, _ns1__MyAccountResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__MyAccountResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__MyAccountResponse, sizeof(_ns1__MyAccountResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Entity1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Entity1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Entity(soap, "ns1:Entity", &a->_ns1__MyAccountResponse::Entity, ""))
				{	soap_flag_Entity1--;
					continue;
				}
			soap_check_result(soap, "ns1:Entity");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Entity1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__MyAccountResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__MyAccountResponse, SOAP_TYPE__ns1__MyAccountResponse, sizeof(_ns1__MyAccountResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__MyAccountResponse * SOAP_FMAC2 soap_instantiate__ns1__MyAccountResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__MyAccountResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__MyAccountResponse *p;
	size_t k = sizeof(_ns1__MyAccountResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__MyAccountResponse);
		if (p)
			((_ns1__MyAccountResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__MyAccountResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__MyAccountResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__MyAccountResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__MyAccountResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__MyAccountResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:MyAccountResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__MyAccountResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__MyAccountResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__MyAccountResponse * SOAP_FMAC4 soap_get__ns1__MyAccountResponse(struct soap *soap, _ns1__MyAccountResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__MyAccountResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__MyAccountRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__MyAccountRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__MyAccountRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__MyAccountRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__MyAccountRequest(struct soap *soap, const char *tag, int id, const _ns1__MyAccountRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__MyAccountRequest), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__MyAccountRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__MyAccountRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__MyAccountRequest * SOAP_FMAC4 soap_in__ns1__MyAccountRequest(struct soap *soap, const char *tag, _ns1__MyAccountRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__MyAccountRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__MyAccountRequest, sizeof(_ns1__MyAccountRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__MyAccountRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__MyAccountRequest, SOAP_TYPE__ns1__MyAccountRequest, sizeof(_ns1__MyAccountRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__MyAccountRequest * SOAP_FMAC2 soap_instantiate__ns1__MyAccountRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__MyAccountRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__MyAccountRequest *p;
	size_t k = sizeof(_ns1__MyAccountRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__MyAccountRequest);
		if (p)
			((_ns1__MyAccountRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__MyAccountRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__MyAccountRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__MyAccountRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__MyAccountRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__MyAccountRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:MyAccountRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__MyAccountRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__MyAccountRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__MyAccountRequest * SOAP_FMAC4 soap_get__ns1__MyAccountRequest(struct soap *soap, _ns1__MyAccountRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__MyAccountRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__StopVideoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__StopVideoResponse::OK);
	/* transient soap skipped */
}

void _ns1__StopVideoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__StopVideoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__StopVideoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__StopVideoResponse(struct soap *soap, const char *tag, int id, const _ns1__StopVideoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__StopVideoResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__StopVideoResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__StopVideoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__StopVideoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__StopVideoResponse * SOAP_FMAC4 soap_in__ns1__StopVideoResponse(struct soap *soap, const char *tag, _ns1__StopVideoResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__StopVideoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__StopVideoResponse, sizeof(_ns1__StopVideoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__StopVideoResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__StopVideoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__StopVideoResponse, SOAP_TYPE__ns1__StopVideoResponse, sizeof(_ns1__StopVideoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__StopVideoResponse * SOAP_FMAC2 soap_instantiate__ns1__StopVideoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__StopVideoResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__StopVideoResponse *p;
	size_t k = sizeof(_ns1__StopVideoResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__StopVideoResponse);
		if (p)
			((_ns1__StopVideoResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__StopVideoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__StopVideoResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__StopVideoResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__StopVideoResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__StopVideoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:StopVideoResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__StopVideoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__StopVideoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__StopVideoResponse * SOAP_FMAC4 soap_get__ns1__StopVideoResponse(struct soap *soap, _ns1__StopVideoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__StopVideoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__StopVideoRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__StopVideoRequest::conferenceID);
	soap_default_ns1__EntityID(soap, &this->_ns1__StopVideoRequest::participantID);
	soap_default_string(soap, &this->_ns1__StopVideoRequest::moderatorPIN);
	/* transient soap skipped */
}

void _ns1__StopVideoRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__StopVideoRequest::conferenceID);
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__StopVideoRequest::participantID);
	soap_serialize_string(soap, (char*const*)&this->_ns1__StopVideoRequest::moderatorPIN);
#endif
}

int _ns1__StopVideoRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__StopVideoRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__StopVideoRequest(struct soap *soap, const char *tag, int id, const _ns1__StopVideoRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__StopVideoRequest), type))
		return soap->error;
	if (!a->_ns1__StopVideoRequest::conferenceID)
	{	if (soap_element_nil(soap, "ns1:conferenceID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:conferenceID", -1, (char*const*)&a->_ns1__StopVideoRequest::conferenceID, ""))
		return soap->error;
	if (!a->_ns1__StopVideoRequest::participantID)
	{	if (soap_element_nil(soap, "ns1:participantID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:participantID", -1, (char*const*)&a->_ns1__StopVideoRequest::participantID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:moderatorPIN", -1, (char*const*)&a->_ns1__StopVideoRequest::moderatorPIN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__StopVideoRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__StopVideoRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__StopVideoRequest * SOAP_FMAC4 soap_in__ns1__StopVideoRequest(struct soap *soap, const char *tag, _ns1__StopVideoRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__StopVideoRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__StopVideoRequest, sizeof(_ns1__StopVideoRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_conferenceID1 = 1;
	size_t soap_flag_participantID1 = 1;
	size_t soap_flag_moderatorPIN1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_conferenceID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:conferenceID", (char**)&a->_ns1__StopVideoRequest::conferenceID, "ns1:EntityID"))
				{	soap_flag_conferenceID1--;
					continue;
				}
			if (soap_flag_participantID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:participantID", (char**)&a->_ns1__StopVideoRequest::participantID, "ns1:EntityID"))
				{	soap_flag_participantID1--;
					continue;
				}
			if (soap_flag_moderatorPIN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:moderatorPIN", (char**)&a->_ns1__StopVideoRequest::moderatorPIN, "xsd:string"))
				{	soap_flag_moderatorPIN1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_conferenceID1 > 0 || soap_flag_participantID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__StopVideoRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__StopVideoRequest, SOAP_TYPE__ns1__StopVideoRequest, sizeof(_ns1__StopVideoRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__StopVideoRequest * SOAP_FMAC2 soap_instantiate__ns1__StopVideoRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__StopVideoRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__StopVideoRequest *p;
	size_t k = sizeof(_ns1__StopVideoRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__StopVideoRequest);
		if (p)
			((_ns1__StopVideoRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__StopVideoRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__StopVideoRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__StopVideoRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__StopVideoRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__StopVideoRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:StopVideoRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__StopVideoRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__StopVideoRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__StopVideoRequest * SOAP_FMAC4 soap_get__ns1__StopVideoRequest(struct soap *soap, _ns1__StopVideoRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__StopVideoRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__StartVideoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__StartVideoResponse::OK);
	/* transient soap skipped */
}

void _ns1__StartVideoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__StartVideoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__StartVideoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__StartVideoResponse(struct soap *soap, const char *tag, int id, const _ns1__StartVideoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__StartVideoResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__StartVideoResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__StartVideoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__StartVideoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__StartVideoResponse * SOAP_FMAC4 soap_in__ns1__StartVideoResponse(struct soap *soap, const char *tag, _ns1__StartVideoResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__StartVideoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__StartVideoResponse, sizeof(_ns1__StartVideoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__StartVideoResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__StartVideoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__StartVideoResponse, SOAP_TYPE__ns1__StartVideoResponse, sizeof(_ns1__StartVideoResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__StartVideoResponse * SOAP_FMAC2 soap_instantiate__ns1__StartVideoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__StartVideoResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__StartVideoResponse *p;
	size_t k = sizeof(_ns1__StartVideoResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__StartVideoResponse);
		if (p)
			((_ns1__StartVideoResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__StartVideoResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__StartVideoResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__StartVideoResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__StartVideoResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__StartVideoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:StartVideoResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__StartVideoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__StartVideoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__StartVideoResponse * SOAP_FMAC4 soap_get__ns1__StartVideoResponse(struct soap *soap, _ns1__StartVideoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__StartVideoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__StartVideoRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__StartVideoRequest::conferenceID);
	soap_default_ns1__EntityID(soap, &this->_ns1__StartVideoRequest::participantID);
	soap_default_string(soap, &this->_ns1__StartVideoRequest::moderatorPIN);
	/* transient soap skipped */
}

void _ns1__StartVideoRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__StartVideoRequest::conferenceID);
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__StartVideoRequest::participantID);
	soap_serialize_string(soap, (char*const*)&this->_ns1__StartVideoRequest::moderatorPIN);
#endif
}

int _ns1__StartVideoRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__StartVideoRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__StartVideoRequest(struct soap *soap, const char *tag, int id, const _ns1__StartVideoRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__StartVideoRequest), type))
		return soap->error;
	if (!a->_ns1__StartVideoRequest::conferenceID)
	{	if (soap_element_nil(soap, "ns1:conferenceID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:conferenceID", -1, (char*const*)&a->_ns1__StartVideoRequest::conferenceID, ""))
		return soap->error;
	if (!a->_ns1__StartVideoRequest::participantID)
	{	if (soap_element_nil(soap, "ns1:participantID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:participantID", -1, (char*const*)&a->_ns1__StartVideoRequest::participantID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:moderatorPIN", -1, (char*const*)&a->_ns1__StartVideoRequest::moderatorPIN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__StartVideoRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__StartVideoRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__StartVideoRequest * SOAP_FMAC4 soap_in__ns1__StartVideoRequest(struct soap *soap, const char *tag, _ns1__StartVideoRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__StartVideoRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__StartVideoRequest, sizeof(_ns1__StartVideoRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_conferenceID1 = 1;
	size_t soap_flag_participantID1 = 1;
	size_t soap_flag_moderatorPIN1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_conferenceID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:conferenceID", (char**)&a->_ns1__StartVideoRequest::conferenceID, "ns1:EntityID"))
				{	soap_flag_conferenceID1--;
					continue;
				}
			if (soap_flag_participantID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:participantID", (char**)&a->_ns1__StartVideoRequest::participantID, "ns1:EntityID"))
				{	soap_flag_participantID1--;
					continue;
				}
			if (soap_flag_moderatorPIN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:moderatorPIN", (char**)&a->_ns1__StartVideoRequest::moderatorPIN, "xsd:string"))
				{	soap_flag_moderatorPIN1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_conferenceID1 > 0 || soap_flag_participantID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__StartVideoRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__StartVideoRequest, SOAP_TYPE__ns1__StartVideoRequest, sizeof(_ns1__StartVideoRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__StartVideoRequest * SOAP_FMAC2 soap_instantiate__ns1__StartVideoRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__StartVideoRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__StartVideoRequest *p;
	size_t k = sizeof(_ns1__StartVideoRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__StartVideoRequest);
		if (p)
			((_ns1__StartVideoRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__StartVideoRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__StartVideoRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__StartVideoRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__StartVideoRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__StartVideoRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:StartVideoRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__StartVideoRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__StartVideoRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__StartVideoRequest * SOAP_FMAC4 soap_get__ns1__StartVideoRequest(struct soap *soap, _ns1__StartVideoRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__StartVideoRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__UnmuteAudioResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__UnmuteAudioResponse::OK);
	/* transient soap skipped */
}

void _ns1__UnmuteAudioResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__UnmuteAudioResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UnmuteAudioResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UnmuteAudioResponse(struct soap *soap, const char *tag, int id, const _ns1__UnmuteAudioResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UnmuteAudioResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__UnmuteAudioResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__UnmuteAudioResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UnmuteAudioResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UnmuteAudioResponse * SOAP_FMAC4 soap_in__ns1__UnmuteAudioResponse(struct soap *soap, const char *tag, _ns1__UnmuteAudioResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UnmuteAudioResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UnmuteAudioResponse, sizeof(_ns1__UnmuteAudioResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__UnmuteAudioResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__UnmuteAudioResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UnmuteAudioResponse, SOAP_TYPE__ns1__UnmuteAudioResponse, sizeof(_ns1__UnmuteAudioResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__UnmuteAudioResponse * SOAP_FMAC2 soap_instantiate__ns1__UnmuteAudioResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UnmuteAudioResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__UnmuteAudioResponse *p;
	size_t k = sizeof(_ns1__UnmuteAudioResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__UnmuteAudioResponse);
		if (p)
			((_ns1__UnmuteAudioResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__UnmuteAudioResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__UnmuteAudioResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__UnmuteAudioResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__UnmuteAudioResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__UnmuteAudioResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:UnmuteAudioResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UnmuteAudioResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UnmuteAudioResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UnmuteAudioResponse * SOAP_FMAC4 soap_get__ns1__UnmuteAudioResponse(struct soap *soap, _ns1__UnmuteAudioResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UnmuteAudioResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__UnmuteAudioRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__UnmuteAudioRequest::conferenceID);
	soap_default_ns1__EntityID(soap, &this->_ns1__UnmuteAudioRequest::participantID);
	soap_default_string(soap, &this->_ns1__UnmuteAudioRequest::moderatorPIN);
	/* transient soap skipped */
}

void _ns1__UnmuteAudioRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__UnmuteAudioRequest::conferenceID);
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__UnmuteAudioRequest::participantID);
	soap_serialize_string(soap, (char*const*)&this->_ns1__UnmuteAudioRequest::moderatorPIN);
#endif
}

int _ns1__UnmuteAudioRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UnmuteAudioRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UnmuteAudioRequest(struct soap *soap, const char *tag, int id, const _ns1__UnmuteAudioRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UnmuteAudioRequest), type))
		return soap->error;
	if (!a->_ns1__UnmuteAudioRequest::conferenceID)
	{	if (soap_element_nil(soap, "ns1:conferenceID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:conferenceID", -1, (char*const*)&a->_ns1__UnmuteAudioRequest::conferenceID, ""))
		return soap->error;
	if (!a->_ns1__UnmuteAudioRequest::participantID)
	{	if (soap_element_nil(soap, "ns1:participantID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:participantID", -1, (char*const*)&a->_ns1__UnmuteAudioRequest::participantID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:moderatorPIN", -1, (char*const*)&a->_ns1__UnmuteAudioRequest::moderatorPIN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__UnmuteAudioRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UnmuteAudioRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UnmuteAudioRequest * SOAP_FMAC4 soap_in__ns1__UnmuteAudioRequest(struct soap *soap, const char *tag, _ns1__UnmuteAudioRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UnmuteAudioRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UnmuteAudioRequest, sizeof(_ns1__UnmuteAudioRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_conferenceID1 = 1;
	size_t soap_flag_participantID1 = 1;
	size_t soap_flag_moderatorPIN1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_conferenceID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:conferenceID", (char**)&a->_ns1__UnmuteAudioRequest::conferenceID, "ns1:EntityID"))
				{	soap_flag_conferenceID1--;
					continue;
				}
			if (soap_flag_participantID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:participantID", (char**)&a->_ns1__UnmuteAudioRequest::participantID, "ns1:EntityID"))
				{	soap_flag_participantID1--;
					continue;
				}
			if (soap_flag_moderatorPIN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:moderatorPIN", (char**)&a->_ns1__UnmuteAudioRequest::moderatorPIN, "xsd:string"))
				{	soap_flag_moderatorPIN1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_conferenceID1 > 0 || soap_flag_participantID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__UnmuteAudioRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UnmuteAudioRequest, SOAP_TYPE__ns1__UnmuteAudioRequest, sizeof(_ns1__UnmuteAudioRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__UnmuteAudioRequest * SOAP_FMAC2 soap_instantiate__ns1__UnmuteAudioRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UnmuteAudioRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__UnmuteAudioRequest *p;
	size_t k = sizeof(_ns1__UnmuteAudioRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__UnmuteAudioRequest);
		if (p)
			((_ns1__UnmuteAudioRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__UnmuteAudioRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__UnmuteAudioRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__UnmuteAudioRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__UnmuteAudioRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__UnmuteAudioRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:UnmuteAudioRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UnmuteAudioRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UnmuteAudioRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UnmuteAudioRequest * SOAP_FMAC4 soap_get__ns1__UnmuteAudioRequest(struct soap *soap, _ns1__UnmuteAudioRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UnmuteAudioRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__MuteAudioResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__MuteAudioResponse::OK);
	/* transient soap skipped */
}

void _ns1__MuteAudioResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__MuteAudioResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__MuteAudioResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__MuteAudioResponse(struct soap *soap, const char *tag, int id, const _ns1__MuteAudioResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__MuteAudioResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__MuteAudioResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__MuteAudioResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__MuteAudioResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__MuteAudioResponse * SOAP_FMAC4 soap_in__ns1__MuteAudioResponse(struct soap *soap, const char *tag, _ns1__MuteAudioResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__MuteAudioResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__MuteAudioResponse, sizeof(_ns1__MuteAudioResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__MuteAudioResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__MuteAudioResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__MuteAudioResponse, SOAP_TYPE__ns1__MuteAudioResponse, sizeof(_ns1__MuteAudioResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__MuteAudioResponse * SOAP_FMAC2 soap_instantiate__ns1__MuteAudioResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__MuteAudioResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__MuteAudioResponse *p;
	size_t k = sizeof(_ns1__MuteAudioResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__MuteAudioResponse);
		if (p)
			((_ns1__MuteAudioResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__MuteAudioResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__MuteAudioResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__MuteAudioResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__MuteAudioResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__MuteAudioResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:MuteAudioResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__MuteAudioResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__MuteAudioResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__MuteAudioResponse * SOAP_FMAC4 soap_get__ns1__MuteAudioResponse(struct soap *soap, _ns1__MuteAudioResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__MuteAudioResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__MuteAudioRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__MuteAudioRequest::conferenceID);
	soap_default_ns1__EntityID(soap, &this->_ns1__MuteAudioRequest::participantID);
	soap_default_string(soap, &this->_ns1__MuteAudioRequest::moderatorPIN);
	/* transient soap skipped */
}

void _ns1__MuteAudioRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__MuteAudioRequest::conferenceID);
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__MuteAudioRequest::participantID);
	soap_serialize_string(soap, (char*const*)&this->_ns1__MuteAudioRequest::moderatorPIN);
#endif
}

int _ns1__MuteAudioRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__MuteAudioRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__MuteAudioRequest(struct soap *soap, const char *tag, int id, const _ns1__MuteAudioRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__MuteAudioRequest), type))
		return soap->error;
	if (!a->_ns1__MuteAudioRequest::conferenceID)
	{	if (soap_element_nil(soap, "ns1:conferenceID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:conferenceID", -1, (char*const*)&a->_ns1__MuteAudioRequest::conferenceID, ""))
		return soap->error;
	if (!a->_ns1__MuteAudioRequest::participantID)
	{	if (soap_element_nil(soap, "ns1:participantID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:participantID", -1, (char*const*)&a->_ns1__MuteAudioRequest::participantID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:moderatorPIN", -1, (char*const*)&a->_ns1__MuteAudioRequest::moderatorPIN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__MuteAudioRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__MuteAudioRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__MuteAudioRequest * SOAP_FMAC4 soap_in__ns1__MuteAudioRequest(struct soap *soap, const char *tag, _ns1__MuteAudioRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__MuteAudioRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__MuteAudioRequest, sizeof(_ns1__MuteAudioRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_conferenceID1 = 1;
	size_t soap_flag_participantID1 = 1;
	size_t soap_flag_moderatorPIN1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_conferenceID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:conferenceID", (char**)&a->_ns1__MuteAudioRequest::conferenceID, "ns1:EntityID"))
				{	soap_flag_conferenceID1--;
					continue;
				}
			if (soap_flag_participantID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:participantID", (char**)&a->_ns1__MuteAudioRequest::participantID, "ns1:EntityID"))
				{	soap_flag_participantID1--;
					continue;
				}
			if (soap_flag_moderatorPIN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:moderatorPIN", (char**)&a->_ns1__MuteAudioRequest::moderatorPIN, "xsd:string"))
				{	soap_flag_moderatorPIN1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_conferenceID1 > 0 || soap_flag_participantID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__MuteAudioRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__MuteAudioRequest, SOAP_TYPE__ns1__MuteAudioRequest, sizeof(_ns1__MuteAudioRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__MuteAudioRequest * SOAP_FMAC2 soap_instantiate__ns1__MuteAudioRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__MuteAudioRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__MuteAudioRequest *p;
	size_t k = sizeof(_ns1__MuteAudioRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__MuteAudioRequest);
		if (p)
			((_ns1__MuteAudioRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__MuteAudioRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__MuteAudioRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__MuteAudioRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__MuteAudioRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__MuteAudioRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:MuteAudioRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__MuteAudioRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__MuteAudioRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__MuteAudioRequest * SOAP_FMAC4 soap_get__ns1__MuteAudioRequest(struct soap *soap, _ns1__MuteAudioRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__MuteAudioRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__LeaveConferenceResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__LeaveConferenceResponse::OK);
	/* transient soap skipped */
}

void _ns1__LeaveConferenceResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__LeaveConferenceResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__LeaveConferenceResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__LeaveConferenceResponse(struct soap *soap, const char *tag, int id, const _ns1__LeaveConferenceResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__LeaveConferenceResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__LeaveConferenceResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__LeaveConferenceResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__LeaveConferenceResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__LeaveConferenceResponse * SOAP_FMAC4 soap_in__ns1__LeaveConferenceResponse(struct soap *soap, const char *tag, _ns1__LeaveConferenceResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__LeaveConferenceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__LeaveConferenceResponse, sizeof(_ns1__LeaveConferenceResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__LeaveConferenceResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__LeaveConferenceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__LeaveConferenceResponse, SOAP_TYPE__ns1__LeaveConferenceResponse, sizeof(_ns1__LeaveConferenceResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__LeaveConferenceResponse * SOAP_FMAC2 soap_instantiate__ns1__LeaveConferenceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__LeaveConferenceResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__LeaveConferenceResponse *p;
	size_t k = sizeof(_ns1__LeaveConferenceResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__LeaveConferenceResponse);
		if (p)
			((_ns1__LeaveConferenceResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__LeaveConferenceResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__LeaveConferenceResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__LeaveConferenceResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__LeaveConferenceResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__LeaveConferenceResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:LeaveConferenceResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__LeaveConferenceResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__LeaveConferenceResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__LeaveConferenceResponse * SOAP_FMAC4 soap_get__ns1__LeaveConferenceResponse(struct soap *soap, _ns1__LeaveConferenceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__LeaveConferenceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__LeaveConferenceRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__LeaveConferenceRequest::conferenceID);
	soap_default_ns1__EntityID(soap, &this->_ns1__LeaveConferenceRequest::participantID);
	soap_default_string(soap, &this->_ns1__LeaveConferenceRequest::moderatorPIN);
	/* transient soap skipped */
}

void _ns1__LeaveConferenceRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__LeaveConferenceRequest::conferenceID);
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__LeaveConferenceRequest::participantID);
	soap_serialize_string(soap, (char*const*)&this->_ns1__LeaveConferenceRequest::moderatorPIN);
#endif
}

int _ns1__LeaveConferenceRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__LeaveConferenceRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__LeaveConferenceRequest(struct soap *soap, const char *tag, int id, const _ns1__LeaveConferenceRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__LeaveConferenceRequest), type))
		return soap->error;
	if (!a->_ns1__LeaveConferenceRequest::conferenceID)
	{	if (soap_element_nil(soap, "ns1:conferenceID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:conferenceID", -1, (char*const*)&a->_ns1__LeaveConferenceRequest::conferenceID, ""))
		return soap->error;
	if (!a->_ns1__LeaveConferenceRequest::participantID)
	{	if (soap_element_nil(soap, "ns1:participantID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:participantID", -1, (char*const*)&a->_ns1__LeaveConferenceRequest::participantID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:moderatorPIN", -1, (char*const*)&a->_ns1__LeaveConferenceRequest::moderatorPIN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__LeaveConferenceRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__LeaveConferenceRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__LeaveConferenceRequest * SOAP_FMAC4 soap_in__ns1__LeaveConferenceRequest(struct soap *soap, const char *tag, _ns1__LeaveConferenceRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__LeaveConferenceRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__LeaveConferenceRequest, sizeof(_ns1__LeaveConferenceRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_conferenceID1 = 1;
	size_t soap_flag_participantID1 = 1;
	size_t soap_flag_moderatorPIN1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_conferenceID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:conferenceID", (char**)&a->_ns1__LeaveConferenceRequest::conferenceID, "ns1:EntityID"))
				{	soap_flag_conferenceID1--;
					continue;
				}
			if (soap_flag_participantID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:participantID", (char**)&a->_ns1__LeaveConferenceRequest::participantID, "ns1:EntityID"))
				{	soap_flag_participantID1--;
					continue;
				}
			if (soap_flag_moderatorPIN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:moderatorPIN", (char**)&a->_ns1__LeaveConferenceRequest::moderatorPIN, "xsd:string"))
				{	soap_flag_moderatorPIN1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_conferenceID1 > 0 || soap_flag_participantID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__LeaveConferenceRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__LeaveConferenceRequest, SOAP_TYPE__ns1__LeaveConferenceRequest, sizeof(_ns1__LeaveConferenceRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__LeaveConferenceRequest * SOAP_FMAC2 soap_instantiate__ns1__LeaveConferenceRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__LeaveConferenceRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__LeaveConferenceRequest *p;
	size_t k = sizeof(_ns1__LeaveConferenceRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__LeaveConferenceRequest);
		if (p)
			((_ns1__LeaveConferenceRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__LeaveConferenceRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__LeaveConferenceRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__LeaveConferenceRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__LeaveConferenceRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__LeaveConferenceRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:LeaveConferenceRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__LeaveConferenceRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__LeaveConferenceRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__LeaveConferenceRequest * SOAP_FMAC4 soap_get__ns1__LeaveConferenceRequest(struct soap *soap, _ns1__LeaveConferenceRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__LeaveConferenceRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetLectureModeParticipantsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GetLectureModeParticipantsResponse::total);
	this->_ns1__GetLectureModeParticipantsResponse::recorderID = NULL;
	soap_default_string(soap, &this->_ns1__GetLectureModeParticipantsResponse::recorderName);
	this->_ns1__GetLectureModeParticipantsResponse::paused = NULL;
	this->_ns1__GetLectureModeParticipantsResponse::webcast = NULL;
	this->_ns1__GetLectureModeParticipantsResponse::lectureMode = NULL;
	this->_ns1__GetLectureModeParticipantsResponse::__sizeLectureModeParticipant = 0;
	this->_ns1__GetLectureModeParticipantsResponse::LectureModeParticipant = NULL;
	/* transient soap skipped */
}

void _ns1__GetLectureModeParticipantsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns1__GetLectureModeParticipantsResponse::total, SOAP_TYPE_int);
	soap_serialize_PointerToint(soap, &this->_ns1__GetLectureModeParticipantsResponse::recorderID);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetLectureModeParticipantsResponse::recorderName);
	soap_serialize_PointerTobool(soap, &this->_ns1__GetLectureModeParticipantsResponse::paused);
	soap_serialize_PointerTobool(soap, &this->_ns1__GetLectureModeParticipantsResponse::webcast);
	soap_serialize_PointerTobool(soap, &this->_ns1__GetLectureModeParticipantsResponse::lectureMode);
	if (this->_ns1__GetLectureModeParticipantsResponse::LectureModeParticipant)
	{	int i;
		for (i = 0; i < (int)this->_ns1__GetLectureModeParticipantsResponse::__sizeLectureModeParticipant; i++)
		{
			soap_serialize_PointerTo_ns1__LectureModeParticipant(soap, this->_ns1__GetLectureModeParticipantsResponse::LectureModeParticipant + i);
		}
	}
#endif
}

int _ns1__GetLectureModeParticipantsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetLectureModeParticipantsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetLectureModeParticipantsResponse(struct soap *soap, const char *tag, int id, const _ns1__GetLectureModeParticipantsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetLectureModeParticipantsResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:total");
	if (soap_out_int(soap, "ns1:total", -1, &a->_ns1__GetLectureModeParticipantsResponse::total, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:recorderID", -1, &a->_ns1__GetLectureModeParticipantsResponse::recorderID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:recorderName", -1, (char*const*)&a->_ns1__GetLectureModeParticipantsResponse::recorderName, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:paused", -1, &a->_ns1__GetLectureModeParticipantsResponse::paused, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:webcast", -1, &a->_ns1__GetLectureModeParticipantsResponse::webcast, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:lectureMode", -1, &a->_ns1__GetLectureModeParticipantsResponse::lectureMode, ""))
		return soap->error;
	if (a->_ns1__GetLectureModeParticipantsResponse::LectureModeParticipant)
	{	int i;
		for (i = 0; i < (int)a->_ns1__GetLectureModeParticipantsResponse::__sizeLectureModeParticipant; i++)
			if (soap_out_PointerTo_ns1__LectureModeParticipant(soap, "ns1:LectureModeParticipant", -1, a->_ns1__GetLectureModeParticipantsResponse::LectureModeParticipant + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetLectureModeParticipantsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetLectureModeParticipantsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetLectureModeParticipantsResponse * SOAP_FMAC4 soap_in__ns1__GetLectureModeParticipantsResponse(struct soap *soap, const char *tag, _ns1__GetLectureModeParticipantsResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetLectureModeParticipantsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetLectureModeParticipantsResponse, sizeof(_ns1__GetLectureModeParticipantsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_total1 = 1;
	size_t soap_flag_recorderID1 = 1;
	size_t soap_flag_recorderName1 = 1;
	size_t soap_flag_paused1 = 1;
	size_t soap_flag_webcast1 = 1;
	size_t soap_flag_lectureMode1 = 1;
	struct soap_blist *soap_blist_LectureModeParticipant1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_total1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:total", &a->_ns1__GetLectureModeParticipantsResponse::total, "xsd:int"))
				{	soap_flag_total1--;
					continue;
				}
			if (soap_flag_recorderID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:recorderID", &a->_ns1__GetLectureModeParticipantsResponse::recorderID, "xsd:int"))
				{	soap_flag_recorderID1--;
					continue;
				}
			if (soap_flag_recorderName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:recorderName", (char**)&a->_ns1__GetLectureModeParticipantsResponse::recorderName, "xsd:string"))
				{	soap_flag_recorderName1--;
					continue;
				}
			if (soap_flag_paused1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns1:paused", &a->_ns1__GetLectureModeParticipantsResponse::paused, "xsd:boolean"))
				{	soap_flag_paused1--;
					continue;
				}
			if (soap_flag_webcast1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns1:webcast", &a->_ns1__GetLectureModeParticipantsResponse::webcast, "xsd:boolean"))
				{	soap_flag_webcast1--;
					continue;
				}
			if (soap_flag_lectureMode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns1:lectureMode", &a->_ns1__GetLectureModeParticipantsResponse::lectureMode, "xsd:boolean"))
				{	soap_flag_lectureMode1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:LectureModeParticipant", 1, NULL))
			{	if (a->_ns1__GetLectureModeParticipantsResponse::LectureModeParticipant == NULL)
				{	if (soap_blist_LectureModeParticipant1 == NULL)
						soap_blist_LectureModeParticipant1 = soap_new_block(soap);
					a->_ns1__GetLectureModeParticipantsResponse::LectureModeParticipant = (_ns1__LectureModeParticipant **)soap_push_block_max(soap, soap_blist_LectureModeParticipant1, sizeof(_ns1__LectureModeParticipant *));
					if (a->_ns1__GetLectureModeParticipantsResponse::LectureModeParticipant == NULL)
						return NULL;
					*a->_ns1__GetLectureModeParticipantsResponse::LectureModeParticipant = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTo_ns1__LectureModeParticipant(soap, "ns1:LectureModeParticipant", a->_ns1__GetLectureModeParticipantsResponse::LectureModeParticipant, ""))
				{	a->_ns1__GetLectureModeParticipantsResponse::__sizeLectureModeParticipant++;
					a->_ns1__GetLectureModeParticipantsResponse::LectureModeParticipant = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:total");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__GetLectureModeParticipantsResponse::LectureModeParticipant)
			soap_pop_block(soap, soap_blist_LectureModeParticipant1);
		if (a->_ns1__GetLectureModeParticipantsResponse::__sizeLectureModeParticipant)
		{	a->_ns1__GetLectureModeParticipantsResponse::LectureModeParticipant = (_ns1__LectureModeParticipant **)soap_save_block(soap, soap_blist_LectureModeParticipant1, NULL, 1);
		}
		else
		{	a->_ns1__GetLectureModeParticipantsResponse::LectureModeParticipant = NULL;
			if (soap_blist_LectureModeParticipant1)
				soap_end_block(soap, soap_blist_LectureModeParticipant1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_total1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetLectureModeParticipantsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetLectureModeParticipantsResponse, SOAP_TYPE__ns1__GetLectureModeParticipantsResponse, sizeof(_ns1__GetLectureModeParticipantsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetLectureModeParticipantsResponse * SOAP_FMAC2 soap_instantiate__ns1__GetLectureModeParticipantsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetLectureModeParticipantsResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetLectureModeParticipantsResponse *p;
	size_t k = sizeof(_ns1__GetLectureModeParticipantsResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetLectureModeParticipantsResponse);
		if (p)
			((_ns1__GetLectureModeParticipantsResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetLectureModeParticipantsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetLectureModeParticipantsResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetLectureModeParticipantsResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetLectureModeParticipantsResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetLectureModeParticipantsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:GetLectureModeParticipantsResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetLectureModeParticipantsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetLectureModeParticipantsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetLectureModeParticipantsResponse * SOAP_FMAC4 soap_get__ns1__GetLectureModeParticipantsResponse(struct soap *soap, _ns1__GetLectureModeParticipantsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetLectureModeParticipantsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetLectureModeParticipantsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__GetLectureModeParticipantsRequest::conferenceID);
	this->_ns1__GetLectureModeParticipantsRequest::Filter = NULL;
	soap_default_string(soap, &this->_ns1__GetLectureModeParticipantsRequest::moderatorPIN);
	/* transient soap skipped */
}

void _ns1__GetLectureModeParticipantsRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__GetLectureModeParticipantsRequest::conferenceID);
	soap_serialize_PointerTo_ns1__Filter(soap, &this->_ns1__GetLectureModeParticipantsRequest::Filter);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetLectureModeParticipantsRequest::moderatorPIN);
#endif
}

int _ns1__GetLectureModeParticipantsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetLectureModeParticipantsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetLectureModeParticipantsRequest(struct soap *soap, const char *tag, int id, const _ns1__GetLectureModeParticipantsRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetLectureModeParticipantsRequest), type))
		return soap->error;
	if (!a->_ns1__GetLectureModeParticipantsRequest::conferenceID)
	{	if (soap_element_nil(soap, "ns1:conferenceID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:conferenceID", -1, (char*const*)&a->_ns1__GetLectureModeParticipantsRequest::conferenceID, ""))
		return soap->error;
	if (soap_out_PointerTo_ns1__Filter(soap, "ns1:Filter", -1, &a->_ns1__GetLectureModeParticipantsRequest::Filter, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:moderatorPIN", -1, (char*const*)&a->_ns1__GetLectureModeParticipantsRequest::moderatorPIN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetLectureModeParticipantsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetLectureModeParticipantsRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetLectureModeParticipantsRequest * SOAP_FMAC4 soap_in__ns1__GetLectureModeParticipantsRequest(struct soap *soap, const char *tag, _ns1__GetLectureModeParticipantsRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetLectureModeParticipantsRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetLectureModeParticipantsRequest, sizeof(_ns1__GetLectureModeParticipantsRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_conferenceID1 = 1;
	size_t soap_flag_Filter1 = 1;
	size_t soap_flag_moderatorPIN1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_conferenceID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:conferenceID", (char**)&a->_ns1__GetLectureModeParticipantsRequest::conferenceID, "ns1:EntityID"))
				{	soap_flag_conferenceID1--;
					continue;
				}
			if (soap_flag_Filter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Filter(soap, "ns1:Filter", &a->_ns1__GetLectureModeParticipantsRequest::Filter, ""))
				{	soap_flag_Filter1--;
					continue;
				}
			if (soap_flag_moderatorPIN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:moderatorPIN", (char**)&a->_ns1__GetLectureModeParticipantsRequest::moderatorPIN, "xsd:string"))
				{	soap_flag_moderatorPIN1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_conferenceID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetLectureModeParticipantsRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetLectureModeParticipantsRequest, SOAP_TYPE__ns1__GetLectureModeParticipantsRequest, sizeof(_ns1__GetLectureModeParticipantsRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetLectureModeParticipantsRequest * SOAP_FMAC2 soap_instantiate__ns1__GetLectureModeParticipantsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetLectureModeParticipantsRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetLectureModeParticipantsRequest *p;
	size_t k = sizeof(_ns1__GetLectureModeParticipantsRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetLectureModeParticipantsRequest);
		if (p)
			((_ns1__GetLectureModeParticipantsRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetLectureModeParticipantsRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetLectureModeParticipantsRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetLectureModeParticipantsRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetLectureModeParticipantsRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetLectureModeParticipantsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:GetLectureModeParticipantsRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetLectureModeParticipantsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetLectureModeParticipantsRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetLectureModeParticipantsRequest * SOAP_FMAC4 soap_get__ns1__GetLectureModeParticipantsRequest(struct soap *soap, _ns1__GetLectureModeParticipantsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetLectureModeParticipantsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetParticipantsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GetParticipantsResponse::total);
	this->_ns1__GetParticipantsResponse::recorderID = NULL;
	soap_default_string(soap, &this->_ns1__GetParticipantsResponse::recorderName);
	this->_ns1__GetParticipantsResponse::paused = NULL;
	this->_ns1__GetParticipantsResponse::webcast = NULL;
	this->_ns1__GetParticipantsResponse::__sizeEntity = 0;
	this->_ns1__GetParticipantsResponse::Entity = NULL;
	/* transient soap skipped */
}

void _ns1__GetParticipantsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns1__GetParticipantsResponse::total, SOAP_TYPE_int);
	soap_serialize_PointerToint(soap, &this->_ns1__GetParticipantsResponse::recorderID);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetParticipantsResponse::recorderName);
	soap_serialize_PointerTobool(soap, &this->_ns1__GetParticipantsResponse::paused);
	soap_serialize_PointerTobool(soap, &this->_ns1__GetParticipantsResponse::webcast);
	if (this->_ns1__GetParticipantsResponse::Entity)
	{	int i;
		for (i = 0; i < (int)this->_ns1__GetParticipantsResponse::__sizeEntity; i++)
		{
			soap_serialize_PointerTo_ns1__Entity(soap, this->_ns1__GetParticipantsResponse::Entity + i);
		}
	}
#endif
}

int _ns1__GetParticipantsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetParticipantsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetParticipantsResponse(struct soap *soap, const char *tag, int id, const _ns1__GetParticipantsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetParticipantsResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:total");
	if (soap_out_int(soap, "ns1:total", -1, &a->_ns1__GetParticipantsResponse::total, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:recorderID", -1, &a->_ns1__GetParticipantsResponse::recorderID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:recorderName", -1, (char*const*)&a->_ns1__GetParticipantsResponse::recorderName, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:paused", -1, &a->_ns1__GetParticipantsResponse::paused, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:webcast", -1, &a->_ns1__GetParticipantsResponse::webcast, ""))
		return soap->error;
	if (a->_ns1__GetParticipantsResponse::Entity)
	{	int i;
		for (i = 0; i < (int)a->_ns1__GetParticipantsResponse::__sizeEntity; i++)
			if (soap_out_PointerTo_ns1__Entity(soap, "ns1:Entity", -1, a->_ns1__GetParticipantsResponse::Entity + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetParticipantsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetParticipantsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetParticipantsResponse * SOAP_FMAC4 soap_in__ns1__GetParticipantsResponse(struct soap *soap, const char *tag, _ns1__GetParticipantsResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetParticipantsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetParticipantsResponse, sizeof(_ns1__GetParticipantsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_total1 = 1;
	size_t soap_flag_recorderID1 = 1;
	size_t soap_flag_recorderName1 = 1;
	size_t soap_flag_paused1 = 1;
	size_t soap_flag_webcast1 = 1;
	struct soap_blist *soap_blist_Entity1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_total1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:total", &a->_ns1__GetParticipantsResponse::total, "xsd:int"))
				{	soap_flag_total1--;
					continue;
				}
			if (soap_flag_recorderID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:recorderID", &a->_ns1__GetParticipantsResponse::recorderID, "xsd:int"))
				{	soap_flag_recorderID1--;
					continue;
				}
			if (soap_flag_recorderName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:recorderName", (char**)&a->_ns1__GetParticipantsResponse::recorderName, "xsd:string"))
				{	soap_flag_recorderName1--;
					continue;
				}
			if (soap_flag_paused1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns1:paused", &a->_ns1__GetParticipantsResponse::paused, "xsd:boolean"))
				{	soap_flag_paused1--;
					continue;
				}
			if (soap_flag_webcast1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns1:webcast", &a->_ns1__GetParticipantsResponse::webcast, "xsd:boolean"))
				{	soap_flag_webcast1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Entity", 1, NULL))
			{	if (a->_ns1__GetParticipantsResponse::Entity == NULL)
				{	if (soap_blist_Entity1 == NULL)
						soap_blist_Entity1 = soap_new_block(soap);
					a->_ns1__GetParticipantsResponse::Entity = (_ns1__Entity **)soap_push_block_max(soap, soap_blist_Entity1, sizeof(_ns1__Entity *));
					if (a->_ns1__GetParticipantsResponse::Entity == NULL)
						return NULL;
					*a->_ns1__GetParticipantsResponse::Entity = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTo_ns1__Entity(soap, "ns1:Entity", a->_ns1__GetParticipantsResponse::Entity, ""))
				{	a->_ns1__GetParticipantsResponse::__sizeEntity++;
					a->_ns1__GetParticipantsResponse::Entity = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:total");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__GetParticipantsResponse::Entity)
			soap_pop_block(soap, soap_blist_Entity1);
		if (a->_ns1__GetParticipantsResponse::__sizeEntity)
		{	a->_ns1__GetParticipantsResponse::Entity = (_ns1__Entity **)soap_save_block(soap, soap_blist_Entity1, NULL, 1);
		}
		else
		{	a->_ns1__GetParticipantsResponse::Entity = NULL;
			if (soap_blist_Entity1)
				soap_end_block(soap, soap_blist_Entity1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_total1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetParticipantsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetParticipantsResponse, SOAP_TYPE__ns1__GetParticipantsResponse, sizeof(_ns1__GetParticipantsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetParticipantsResponse * SOAP_FMAC2 soap_instantiate__ns1__GetParticipantsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetParticipantsResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetParticipantsResponse *p;
	size_t k = sizeof(_ns1__GetParticipantsResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetParticipantsResponse);
		if (p)
			((_ns1__GetParticipantsResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetParticipantsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetParticipantsResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetParticipantsResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetParticipantsResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetParticipantsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:GetParticipantsResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetParticipantsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetParticipantsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetParticipantsResponse * SOAP_FMAC4 soap_get__ns1__GetParticipantsResponse(struct soap *soap, _ns1__GetParticipantsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetParticipantsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetParticipantsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__GetParticipantsRequest::conferenceID);
	this->_ns1__GetParticipantsRequest::Filter = NULL;
	soap_default_string(soap, &this->_ns1__GetParticipantsRequest::moderatorPIN);
	/* transient soap skipped */
}

void _ns1__GetParticipantsRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__GetParticipantsRequest::conferenceID);
	soap_serialize_PointerTo_ns1__Filter(soap, &this->_ns1__GetParticipantsRequest::Filter);
	soap_serialize_string(soap, (char*const*)&this->_ns1__GetParticipantsRequest::moderatorPIN);
#endif
}

int _ns1__GetParticipantsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetParticipantsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetParticipantsRequest(struct soap *soap, const char *tag, int id, const _ns1__GetParticipantsRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetParticipantsRequest), type))
		return soap->error;
	if (!a->_ns1__GetParticipantsRequest::conferenceID)
	{	if (soap_element_nil(soap, "ns1:conferenceID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:conferenceID", -1, (char*const*)&a->_ns1__GetParticipantsRequest::conferenceID, ""))
		return soap->error;
	if (soap_out_PointerTo_ns1__Filter(soap, "ns1:Filter", -1, &a->_ns1__GetParticipantsRequest::Filter, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:moderatorPIN", -1, (char*const*)&a->_ns1__GetParticipantsRequest::moderatorPIN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetParticipantsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetParticipantsRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetParticipantsRequest * SOAP_FMAC4 soap_in__ns1__GetParticipantsRequest(struct soap *soap, const char *tag, _ns1__GetParticipantsRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetParticipantsRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetParticipantsRequest, sizeof(_ns1__GetParticipantsRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_conferenceID1 = 1;
	size_t soap_flag_Filter1 = 1;
	size_t soap_flag_moderatorPIN1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_conferenceID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:conferenceID", (char**)&a->_ns1__GetParticipantsRequest::conferenceID, "ns1:EntityID"))
				{	soap_flag_conferenceID1--;
					continue;
				}
			if (soap_flag_Filter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Filter(soap, "ns1:Filter", &a->_ns1__GetParticipantsRequest::Filter, ""))
				{	soap_flag_Filter1--;
					continue;
				}
			if (soap_flag_moderatorPIN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:moderatorPIN", (char**)&a->_ns1__GetParticipantsRequest::moderatorPIN, "xsd:string"))
				{	soap_flag_moderatorPIN1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_conferenceID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetParticipantsRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetParticipantsRequest, SOAP_TYPE__ns1__GetParticipantsRequest, sizeof(_ns1__GetParticipantsRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetParticipantsRequest * SOAP_FMAC2 soap_instantiate__ns1__GetParticipantsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetParticipantsRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetParticipantsRequest *p;
	size_t k = sizeof(_ns1__GetParticipantsRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetParticipantsRequest);
		if (p)
			((_ns1__GetParticipantsRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetParticipantsRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetParticipantsRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetParticipantsRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetParticipantsRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetParticipantsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:GetParticipantsRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetParticipantsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetParticipantsRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetParticipantsRequest * SOAP_FMAC4 soap_get__ns1__GetParticipantsRequest(struct soap *soap, _ns1__GetParticipantsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetParticipantsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__DirectCallResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__DirectCallResponse::OK);
	/* transient soap skipped */
}

void _ns1__DirectCallResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__DirectCallResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DirectCallResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DirectCallResponse(struct soap *soap, const char *tag, int id, const _ns1__DirectCallResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DirectCallResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__DirectCallResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__DirectCallResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DirectCallResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DirectCallResponse * SOAP_FMAC4 soap_in__ns1__DirectCallResponse(struct soap *soap, const char *tag, _ns1__DirectCallResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DirectCallResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DirectCallResponse, sizeof(_ns1__DirectCallResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__DirectCallResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__DirectCallResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DirectCallResponse, SOAP_TYPE__ns1__DirectCallResponse, sizeof(_ns1__DirectCallResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__DirectCallResponse * SOAP_FMAC2 soap_instantiate__ns1__DirectCallResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DirectCallResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__DirectCallResponse *p;
	size_t k = sizeof(_ns1__DirectCallResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__DirectCallResponse);
		if (p)
			((_ns1__DirectCallResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__DirectCallResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__DirectCallResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__DirectCallResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__DirectCallResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__DirectCallResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:DirectCallResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DirectCallResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DirectCallResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DirectCallResponse * SOAP_FMAC4 soap_get__ns1__DirectCallResponse(struct soap *soap, _ns1__DirectCallResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DirectCallResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__DirectCallRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__DirectCallRequest::__union_DirectCallRequest = -1;
	/* transient soap skipped */
}

void _ns1__DirectCallRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ns1__union_DirectCallRequest(soap, this->_ns1__DirectCallRequest::__union_DirectCallRequest, &this->_ns1__DirectCallRequest::union_DirectCallRequest);
#endif
}

int _ns1__DirectCallRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DirectCallRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DirectCallRequest(struct soap *soap, const char *tag, int id, const _ns1__DirectCallRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DirectCallRequest), type))
		return soap->error;
	if (soap_out__ns1__union_DirectCallRequest(soap, a->_ns1__DirectCallRequest::__union_DirectCallRequest, &a->_ns1__DirectCallRequest::union_DirectCallRequest))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__DirectCallRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DirectCallRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DirectCallRequest * SOAP_FMAC4 soap_in__ns1__DirectCallRequest(struct soap *soap, const char *tag, _ns1__DirectCallRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DirectCallRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DirectCallRequest, sizeof(_ns1__DirectCallRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && !*soap->href))
	{
		if (!soap_in__ns1__union_DirectCallRequest(soap, &a->__union_DirectCallRequest, &a->union_DirectCallRequest))
			return NULL;
		if (tag && *tag != '-')
		{	soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_TAG_MISMATCH || soap_element_end_in(soap, tag))
				return NULL;
		}
	}
	else
	{	a = (_ns1__DirectCallRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DirectCallRequest, SOAP_TYPE__ns1__DirectCallRequest, sizeof(_ns1__DirectCallRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__DirectCallRequest * SOAP_FMAC2 soap_instantiate__ns1__DirectCallRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DirectCallRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__DirectCallRequest *p;
	size_t k = sizeof(_ns1__DirectCallRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__DirectCallRequest);
		if (p)
			((_ns1__DirectCallRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__DirectCallRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__DirectCallRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__DirectCallRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__DirectCallRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__DirectCallRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:DirectCallRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DirectCallRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DirectCallRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DirectCallRequest * SOAP_FMAC4 soap_get__ns1__DirectCallRequest(struct soap *soap, _ns1__DirectCallRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DirectCallRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__JoinIPCConferenceResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__JoinIPCConferenceResponse::OK);
	/* transient soap skipped */
}

void _ns1__JoinIPCConferenceResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__JoinIPCConferenceResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__JoinIPCConferenceResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__JoinIPCConferenceResponse(struct soap *soap, const char *tag, int id, const _ns1__JoinIPCConferenceResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__JoinIPCConferenceResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__JoinIPCConferenceResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__JoinIPCConferenceResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__JoinIPCConferenceResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__JoinIPCConferenceResponse * SOAP_FMAC4 soap_in__ns1__JoinIPCConferenceResponse(struct soap *soap, const char *tag, _ns1__JoinIPCConferenceResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__JoinIPCConferenceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__JoinIPCConferenceResponse, sizeof(_ns1__JoinIPCConferenceResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__JoinIPCConferenceResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__JoinIPCConferenceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__JoinIPCConferenceResponse, SOAP_TYPE__ns1__JoinIPCConferenceResponse, sizeof(_ns1__JoinIPCConferenceResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__JoinIPCConferenceResponse * SOAP_FMAC2 soap_instantiate__ns1__JoinIPCConferenceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__JoinIPCConferenceResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__JoinIPCConferenceResponse *p;
	size_t k = sizeof(_ns1__JoinIPCConferenceResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__JoinIPCConferenceResponse);
		if (p)
			((_ns1__JoinIPCConferenceResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__JoinIPCConferenceResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__JoinIPCConferenceResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__JoinIPCConferenceResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__JoinIPCConferenceResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__JoinIPCConferenceResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:JoinIPCConferenceResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__JoinIPCConferenceResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__JoinIPCConferenceResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__JoinIPCConferenceResponse * SOAP_FMAC4 soap_get__ns1__JoinIPCConferenceResponse(struct soap *soap, _ns1__JoinIPCConferenceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__JoinIPCConferenceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__JoinIPCConferenceRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__JoinIPCConferenceRequest::local_part);
	soap_default_string(soap, &this->_ns1__JoinIPCConferenceRequest::domain);
	soap_default_string(soap, &this->_ns1__JoinIPCConferenceRequest::PIN);
	soap_default_string(soap, &this->_ns1__JoinIPCConferenceRequest::referenceNumber);
	/* transient soap skipped */
}

void _ns1__JoinIPCConferenceRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__JoinIPCConferenceRequest::local_part);
	soap_serialize_string(soap, (char*const*)&this->_ns1__JoinIPCConferenceRequest::domain);
	soap_serialize_string(soap, (char*const*)&this->_ns1__JoinIPCConferenceRequest::PIN);
	soap_serialize_string(soap, (char*const*)&this->_ns1__JoinIPCConferenceRequest::referenceNumber);
#endif
}

int _ns1__JoinIPCConferenceRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__JoinIPCConferenceRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__JoinIPCConferenceRequest(struct soap *soap, const char *tag, int id, const _ns1__JoinIPCConferenceRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__JoinIPCConferenceRequest), type))
		return soap->error;
	if (!a->_ns1__JoinIPCConferenceRequest::local_part)
	{	if (soap_element_nil(soap, "ns1:local-part"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:local-part", -1, (char*const*)&a->_ns1__JoinIPCConferenceRequest::local_part, ""))
		return soap->error;
	if (!a->_ns1__JoinIPCConferenceRequest::domain)
	{	if (soap_element_nil(soap, "ns1:domain"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:domain", -1, (char*const*)&a->_ns1__JoinIPCConferenceRequest::domain, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:PIN", -1, (char*const*)&a->_ns1__JoinIPCConferenceRequest::PIN, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:referenceNumber", -1, (char*const*)&a->_ns1__JoinIPCConferenceRequest::referenceNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__JoinIPCConferenceRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__JoinIPCConferenceRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__JoinIPCConferenceRequest * SOAP_FMAC4 soap_in__ns1__JoinIPCConferenceRequest(struct soap *soap, const char *tag, _ns1__JoinIPCConferenceRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__JoinIPCConferenceRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__JoinIPCConferenceRequest, sizeof(_ns1__JoinIPCConferenceRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_local_part1 = 1;
	size_t soap_flag_domain1 = 1;
	size_t soap_flag_PIN1 = 1;
	size_t soap_flag_referenceNumber1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_local_part1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:local-part", (char**)&a->_ns1__JoinIPCConferenceRequest::local_part, "xsd:string"))
				{	soap_flag_local_part1--;
					continue;
				}
			if (soap_flag_domain1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:domain", (char**)&a->_ns1__JoinIPCConferenceRequest::domain, "xsd:string"))
				{	soap_flag_domain1--;
					continue;
				}
			if (soap_flag_PIN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:PIN", (char**)&a->_ns1__JoinIPCConferenceRequest::PIN, "xsd:string"))
				{	soap_flag_PIN1--;
					continue;
				}
			if (soap_flag_referenceNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:referenceNumber", (char**)&a->_ns1__JoinIPCConferenceRequest::referenceNumber, "xsd:string"))
				{	soap_flag_referenceNumber1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_local_part1 > 0 || soap_flag_domain1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__JoinIPCConferenceRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__JoinIPCConferenceRequest, SOAP_TYPE__ns1__JoinIPCConferenceRequest, sizeof(_ns1__JoinIPCConferenceRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__JoinIPCConferenceRequest * SOAP_FMAC2 soap_instantiate__ns1__JoinIPCConferenceRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__JoinIPCConferenceRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__JoinIPCConferenceRequest *p;
	size_t k = sizeof(_ns1__JoinIPCConferenceRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__JoinIPCConferenceRequest);
		if (p)
			((_ns1__JoinIPCConferenceRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__JoinIPCConferenceRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__JoinIPCConferenceRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__JoinIPCConferenceRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__JoinIPCConferenceRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__JoinIPCConferenceRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:JoinIPCConferenceRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__JoinIPCConferenceRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__JoinIPCConferenceRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__JoinIPCConferenceRequest * SOAP_FMAC4 soap_get__ns1__JoinIPCConferenceRequest(struct soap *soap, _ns1__JoinIPCConferenceRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__JoinIPCConferenceRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__JoinConferenceResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__JoinConferenceResponse::OK);
	/* transient soap skipped */
}

void _ns1__JoinConferenceResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__JoinConferenceResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__JoinConferenceResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__JoinConferenceResponse(struct soap *soap, const char *tag, int id, const _ns1__JoinConferenceResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__JoinConferenceResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__JoinConferenceResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__JoinConferenceResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__JoinConferenceResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__JoinConferenceResponse * SOAP_FMAC4 soap_in__ns1__JoinConferenceResponse(struct soap *soap, const char *tag, _ns1__JoinConferenceResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__JoinConferenceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__JoinConferenceResponse, sizeof(_ns1__JoinConferenceResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__JoinConferenceResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__JoinConferenceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__JoinConferenceResponse, SOAP_TYPE__ns1__JoinConferenceResponse, sizeof(_ns1__JoinConferenceResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__JoinConferenceResponse * SOAP_FMAC2 soap_instantiate__ns1__JoinConferenceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__JoinConferenceResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__JoinConferenceResponse *p;
	size_t k = sizeof(_ns1__JoinConferenceResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__JoinConferenceResponse);
		if (p)
			((_ns1__JoinConferenceResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__JoinConferenceResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__JoinConferenceResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__JoinConferenceResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__JoinConferenceResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__JoinConferenceResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:JoinConferenceResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__JoinConferenceResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__JoinConferenceResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__JoinConferenceResponse * SOAP_FMAC4 soap_get__ns1__JoinConferenceResponse(struct soap *soap, _ns1__JoinConferenceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__JoinConferenceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__JoinConferenceRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__JoinConferenceRequest::__union_JoinConferenceRequest = -1;
	soap_default_string(soap, &this->_ns1__JoinConferenceRequest::PIN);
	soap_default_string(soap, &this->_ns1__JoinConferenceRequest::referenceNumber);
	/* transient soap skipped */
}

void _ns1__JoinConferenceRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ns1__union_JoinConferenceRequest(soap, this->_ns1__JoinConferenceRequest::__union_JoinConferenceRequest, &this->_ns1__JoinConferenceRequest::union_JoinConferenceRequest);
	soap_serialize_string(soap, (char*const*)&this->_ns1__JoinConferenceRequest::PIN);
	soap_serialize_string(soap, (char*const*)&this->_ns1__JoinConferenceRequest::referenceNumber);
#endif
}

int _ns1__JoinConferenceRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__JoinConferenceRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__JoinConferenceRequest(struct soap *soap, const char *tag, int id, const _ns1__JoinConferenceRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__JoinConferenceRequest), type))
		return soap->error;
	if (soap_out__ns1__union_JoinConferenceRequest(soap, a->_ns1__JoinConferenceRequest::__union_JoinConferenceRequest, &a->_ns1__JoinConferenceRequest::union_JoinConferenceRequest))
		return soap->error;
	if (soap_out_string(soap, "ns1:PIN", -1, (char*const*)&a->_ns1__JoinConferenceRequest::PIN, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:referenceNumber", -1, (char*const*)&a->_ns1__JoinConferenceRequest::referenceNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__JoinConferenceRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__JoinConferenceRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__JoinConferenceRequest * SOAP_FMAC4 soap_in__ns1__JoinConferenceRequest(struct soap *soap, const char *tag, _ns1__JoinConferenceRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__JoinConferenceRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__JoinConferenceRequest, sizeof(_ns1__JoinConferenceRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_union_JoinConferenceRequest1 = 1;
	size_t soap_flag_PIN1 = 1;
	size_t soap_flag_referenceNumber1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_union_JoinConferenceRequest1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__union_JoinConferenceRequest(soap, &a->_ns1__JoinConferenceRequest::__union_JoinConferenceRequest, &a->_ns1__JoinConferenceRequest::union_JoinConferenceRequest))
				{	soap_flag_union_JoinConferenceRequest1 = 0;
					continue;
				}
			if (soap_flag_PIN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:PIN", (char**)&a->_ns1__JoinConferenceRequest::PIN, "xsd:string"))
				{	soap_flag_PIN1--;
					continue;
				}
			if (soap_flag_referenceNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:referenceNumber", (char**)&a->_ns1__JoinConferenceRequest::referenceNumber, "xsd:string"))
				{	soap_flag_referenceNumber1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_union_JoinConferenceRequest1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__JoinConferenceRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__JoinConferenceRequest, SOAP_TYPE__ns1__JoinConferenceRequest, sizeof(_ns1__JoinConferenceRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__JoinConferenceRequest * SOAP_FMAC2 soap_instantiate__ns1__JoinConferenceRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__JoinConferenceRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__JoinConferenceRequest *p;
	size_t k = sizeof(_ns1__JoinConferenceRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__JoinConferenceRequest);
		if (p)
			((_ns1__JoinConferenceRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__JoinConferenceRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__JoinConferenceRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__JoinConferenceRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__JoinConferenceRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__JoinConferenceRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:JoinConferenceRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__JoinConferenceRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__JoinConferenceRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__JoinConferenceRequest * SOAP_FMAC4 soap_get__ns1__JoinConferenceRequest(struct soap *soap, _ns1__JoinConferenceRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__JoinConferenceRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CancelOutboundCallResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__CancelOutboundCallResponse::OK);
	/* transient soap skipped */
}

void _ns1__CancelOutboundCallResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__CancelOutboundCallResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CancelOutboundCallResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CancelOutboundCallResponse(struct soap *soap, const char *tag, int id, const _ns1__CancelOutboundCallResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CancelOutboundCallResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__CancelOutboundCallResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CancelOutboundCallResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CancelOutboundCallResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CancelOutboundCallResponse * SOAP_FMAC4 soap_in__ns1__CancelOutboundCallResponse(struct soap *soap, const char *tag, _ns1__CancelOutboundCallResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CancelOutboundCallResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CancelOutboundCallResponse, sizeof(_ns1__CancelOutboundCallResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__CancelOutboundCallResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__CancelOutboundCallResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CancelOutboundCallResponse, SOAP_TYPE__ns1__CancelOutboundCallResponse, sizeof(_ns1__CancelOutboundCallResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CancelOutboundCallResponse * SOAP_FMAC2 soap_instantiate__ns1__CancelOutboundCallResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CancelOutboundCallResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CancelOutboundCallResponse *p;
	size_t k = sizeof(_ns1__CancelOutboundCallResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__CancelOutboundCallResponse);
		if (p)
			((_ns1__CancelOutboundCallResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__CancelOutboundCallResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__CancelOutboundCallResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CancelOutboundCallResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__CancelOutboundCallResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__CancelOutboundCallResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:CancelOutboundCallResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CancelOutboundCallResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CancelOutboundCallResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CancelOutboundCallResponse * SOAP_FMAC4 soap_get__ns1__CancelOutboundCallResponse(struct soap *soap, _ns1__CancelOutboundCallResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CancelOutboundCallResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CancelOutboundCallRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__CancelOutboundCallRequest::conferenceID);
	soap_default_ns1__EntityID(soap, &this->_ns1__CancelOutboundCallRequest::entityID);
	soap_default_string(soap, &this->_ns1__CancelOutboundCallRequest::moderatorPIN);
	/* transient soap skipped */
}

void _ns1__CancelOutboundCallRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__CancelOutboundCallRequest::conferenceID);
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__CancelOutboundCallRequest::entityID);
	soap_serialize_string(soap, (char*const*)&this->_ns1__CancelOutboundCallRequest::moderatorPIN);
#endif
}

int _ns1__CancelOutboundCallRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CancelOutboundCallRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CancelOutboundCallRequest(struct soap *soap, const char *tag, int id, const _ns1__CancelOutboundCallRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CancelOutboundCallRequest), type))
		return soap->error;
	if (!a->_ns1__CancelOutboundCallRequest::conferenceID)
	{	if (soap_element_nil(soap, "ns1:conferenceID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:conferenceID", -1, (char*const*)&a->_ns1__CancelOutboundCallRequest::conferenceID, ""))
		return soap->error;
	if (!a->_ns1__CancelOutboundCallRequest::entityID)
	{	if (soap_element_nil(soap, "ns1:entityID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:entityID", -1, (char*const*)&a->_ns1__CancelOutboundCallRequest::entityID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:moderatorPIN", -1, (char*const*)&a->_ns1__CancelOutboundCallRequest::moderatorPIN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CancelOutboundCallRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CancelOutboundCallRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CancelOutboundCallRequest * SOAP_FMAC4 soap_in__ns1__CancelOutboundCallRequest(struct soap *soap, const char *tag, _ns1__CancelOutboundCallRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CancelOutboundCallRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CancelOutboundCallRequest, sizeof(_ns1__CancelOutboundCallRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_conferenceID1 = 1;
	size_t soap_flag_entityID1 = 1;
	size_t soap_flag_moderatorPIN1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_conferenceID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:conferenceID", (char**)&a->_ns1__CancelOutboundCallRequest::conferenceID, "ns1:EntityID"))
				{	soap_flag_conferenceID1--;
					continue;
				}
			if (soap_flag_entityID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:entityID", (char**)&a->_ns1__CancelOutboundCallRequest::entityID, "ns1:EntityID"))
				{	soap_flag_entityID1--;
					continue;
				}
			if (soap_flag_moderatorPIN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:moderatorPIN", (char**)&a->_ns1__CancelOutboundCallRequest::moderatorPIN, "xsd:string"))
				{	soap_flag_moderatorPIN1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_conferenceID1 > 0 || soap_flag_entityID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__CancelOutboundCallRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CancelOutboundCallRequest, SOAP_TYPE__ns1__CancelOutboundCallRequest, sizeof(_ns1__CancelOutboundCallRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CancelOutboundCallRequest * SOAP_FMAC2 soap_instantiate__ns1__CancelOutboundCallRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CancelOutboundCallRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CancelOutboundCallRequest *p;
	size_t k = sizeof(_ns1__CancelOutboundCallRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__CancelOutboundCallRequest);
		if (p)
			((_ns1__CancelOutboundCallRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__CancelOutboundCallRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__CancelOutboundCallRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CancelOutboundCallRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__CancelOutboundCallRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__CancelOutboundCallRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:CancelOutboundCallRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CancelOutboundCallRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CancelOutboundCallRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CancelOutboundCallRequest * SOAP_FMAC4 soap_get__ns1__CancelOutboundCallRequest(struct soap *soap, _ns1__CancelOutboundCallRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CancelOutboundCallRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InviteToConferenceResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__InviteToConferenceResponse::OK);
	/* transient soap skipped */
}

void _ns1__InviteToConferenceResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__InviteToConferenceResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InviteToConferenceResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InviteToConferenceResponse(struct soap *soap, const char *tag, int id, const _ns1__InviteToConferenceResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InviteToConferenceResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__InviteToConferenceResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InviteToConferenceResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InviteToConferenceResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InviteToConferenceResponse * SOAP_FMAC4 soap_in__ns1__InviteToConferenceResponse(struct soap *soap, const char *tag, _ns1__InviteToConferenceResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InviteToConferenceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InviteToConferenceResponse, sizeof(_ns1__InviteToConferenceResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__InviteToConferenceResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__InviteToConferenceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InviteToConferenceResponse, SOAP_TYPE__ns1__InviteToConferenceResponse, sizeof(_ns1__InviteToConferenceResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InviteToConferenceResponse * SOAP_FMAC2 soap_instantiate__ns1__InviteToConferenceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InviteToConferenceResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InviteToConferenceResponse *p;
	size_t k = sizeof(_ns1__InviteToConferenceResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InviteToConferenceResponse);
		if (p)
			((_ns1__InviteToConferenceResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InviteToConferenceResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InviteToConferenceResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InviteToConferenceResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InviteToConferenceResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InviteToConferenceResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:InviteToConferenceResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InviteToConferenceResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InviteToConferenceResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InviteToConferenceResponse * SOAP_FMAC4 soap_get__ns1__InviteToConferenceResponse(struct soap *soap, _ns1__InviteToConferenceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InviteToConferenceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InviteToConferenceRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__InviteToConferenceRequest::conferenceID);
	this->_ns1__InviteToConferenceRequest::__union_InviteToConferenceRequest = -1;
	soap_default_string(soap, &this->_ns1__InviteToConferenceRequest::moderatorPIN);
	/* transient soap skipped */
}

void _ns1__InviteToConferenceRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__InviteToConferenceRequest::conferenceID);
	soap_serialize__ns1__union_InviteToConferenceRequest(soap, this->_ns1__InviteToConferenceRequest::__union_InviteToConferenceRequest, &this->_ns1__InviteToConferenceRequest::union_InviteToConferenceRequest);
	soap_serialize_string(soap, (char*const*)&this->_ns1__InviteToConferenceRequest::moderatorPIN);
#endif
}

int _ns1__InviteToConferenceRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InviteToConferenceRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InviteToConferenceRequest(struct soap *soap, const char *tag, int id, const _ns1__InviteToConferenceRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InviteToConferenceRequest), type))
		return soap->error;
	if (!a->_ns1__InviteToConferenceRequest::conferenceID)
	{	if (soap_element_nil(soap, "ns1:conferenceID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:conferenceID", -1, (char*const*)&a->_ns1__InviteToConferenceRequest::conferenceID, ""))
		return soap->error;
	if (soap_out__ns1__union_InviteToConferenceRequest(soap, a->_ns1__InviteToConferenceRequest::__union_InviteToConferenceRequest, &a->_ns1__InviteToConferenceRequest::union_InviteToConferenceRequest))
		return soap->error;
	if (soap_out_string(soap, "ns1:moderatorPIN", -1, (char*const*)&a->_ns1__InviteToConferenceRequest::moderatorPIN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InviteToConferenceRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InviteToConferenceRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InviteToConferenceRequest * SOAP_FMAC4 soap_in__ns1__InviteToConferenceRequest(struct soap *soap, const char *tag, _ns1__InviteToConferenceRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InviteToConferenceRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InviteToConferenceRequest, sizeof(_ns1__InviteToConferenceRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_conferenceID1 = 1;
	size_t soap_flag_union_InviteToConferenceRequest1 = 1;
	size_t soap_flag_moderatorPIN1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_conferenceID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:conferenceID", (char**)&a->_ns1__InviteToConferenceRequest::conferenceID, "ns1:EntityID"))
				{	soap_flag_conferenceID1--;
					continue;
				}
			if (soap_flag_union_InviteToConferenceRequest1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__union_InviteToConferenceRequest(soap, &a->_ns1__InviteToConferenceRequest::__union_InviteToConferenceRequest, &a->_ns1__InviteToConferenceRequest::union_InviteToConferenceRequest))
				{	soap_flag_union_InviteToConferenceRequest1 = 0;
					continue;
				}
			if (soap_flag_moderatorPIN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:moderatorPIN", (char**)&a->_ns1__InviteToConferenceRequest::moderatorPIN, "xsd:string"))
				{	soap_flag_moderatorPIN1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_conferenceID1 > 0 || soap_flag_union_InviteToConferenceRequest1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__InviteToConferenceRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InviteToConferenceRequest, SOAP_TYPE__ns1__InviteToConferenceRequest, sizeof(_ns1__InviteToConferenceRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InviteToConferenceRequest * SOAP_FMAC2 soap_instantiate__ns1__InviteToConferenceRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InviteToConferenceRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InviteToConferenceRequest *p;
	size_t k = sizeof(_ns1__InviteToConferenceRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InviteToConferenceRequest);
		if (p)
			((_ns1__InviteToConferenceRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InviteToConferenceRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InviteToConferenceRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InviteToConferenceRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InviteToConferenceRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InviteToConferenceRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:InviteToConferenceRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InviteToConferenceRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InviteToConferenceRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InviteToConferenceRequest * SOAP_FMAC4 soap_get__ns1__InviteToConferenceRequest(struct soap *soap, _ns1__InviteToConferenceRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InviteToConferenceRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetEntityByEntityIDResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__GetEntityByEntityIDResponse::total);
	this->_ns1__GetEntityByEntityIDResponse::__sizeEntity = 0;
	this->_ns1__GetEntityByEntityIDResponse::Entity = NULL;
	/* transient soap skipped */
}

void _ns1__GetEntityByEntityIDResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns1__GetEntityByEntityIDResponse::total, SOAP_TYPE_int);
	if (this->_ns1__GetEntityByEntityIDResponse::Entity)
	{	int i;
		for (i = 0; i < (int)this->_ns1__GetEntityByEntityIDResponse::__sizeEntity; i++)
		{
			soap_serialize_PointerTo_ns1__Entity(soap, this->_ns1__GetEntityByEntityIDResponse::Entity + i);
		}
	}
#endif
}

int _ns1__GetEntityByEntityIDResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetEntityByEntityIDResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetEntityByEntityIDResponse(struct soap *soap, const char *tag, int id, const _ns1__GetEntityByEntityIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetEntityByEntityIDResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:total");
	if (soap_out_int(soap, "ns1:total", -1, &a->_ns1__GetEntityByEntityIDResponse::total, ""))
		return soap->error;
	if (a->_ns1__GetEntityByEntityIDResponse::Entity)
	{	int i;
		for (i = 0; i < (int)a->_ns1__GetEntityByEntityIDResponse::__sizeEntity; i++)
			if (soap_out_PointerTo_ns1__Entity(soap, "ns1:Entity", -1, a->_ns1__GetEntityByEntityIDResponse::Entity + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetEntityByEntityIDResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetEntityByEntityIDResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetEntityByEntityIDResponse * SOAP_FMAC4 soap_in__ns1__GetEntityByEntityIDResponse(struct soap *soap, const char *tag, _ns1__GetEntityByEntityIDResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetEntityByEntityIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetEntityByEntityIDResponse, sizeof(_ns1__GetEntityByEntityIDResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_total1 = 1;
	struct soap_blist *soap_blist_Entity1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_total1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:total", &a->_ns1__GetEntityByEntityIDResponse::total, "xsd:int"))
				{	soap_flag_total1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Entity", 1, NULL))
			{	if (a->_ns1__GetEntityByEntityIDResponse::Entity == NULL)
				{	if (soap_blist_Entity1 == NULL)
						soap_blist_Entity1 = soap_new_block(soap);
					a->_ns1__GetEntityByEntityIDResponse::Entity = (_ns1__Entity **)soap_push_block_max(soap, soap_blist_Entity1, sizeof(_ns1__Entity *));
					if (a->_ns1__GetEntityByEntityIDResponse::Entity == NULL)
						return NULL;
					*a->_ns1__GetEntityByEntityIDResponse::Entity = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTo_ns1__Entity(soap, "ns1:Entity", a->_ns1__GetEntityByEntityIDResponse::Entity, ""))
				{	a->_ns1__GetEntityByEntityIDResponse::__sizeEntity++;
					a->_ns1__GetEntityByEntityIDResponse::Entity = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:total");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__GetEntityByEntityIDResponse::Entity)
			soap_pop_block(soap, soap_blist_Entity1);
		if (a->_ns1__GetEntityByEntityIDResponse::__sizeEntity)
		{	a->_ns1__GetEntityByEntityIDResponse::Entity = (_ns1__Entity **)soap_save_block(soap, soap_blist_Entity1, NULL, 1);
		}
		else
		{	a->_ns1__GetEntityByEntityIDResponse::Entity = NULL;
			if (soap_blist_Entity1)
				soap_end_block(soap, soap_blist_Entity1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_total1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetEntityByEntityIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetEntityByEntityIDResponse, SOAP_TYPE__ns1__GetEntityByEntityIDResponse, sizeof(_ns1__GetEntityByEntityIDResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetEntityByEntityIDResponse * SOAP_FMAC2 soap_instantiate__ns1__GetEntityByEntityIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetEntityByEntityIDResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetEntityByEntityIDResponse *p;
	size_t k = sizeof(_ns1__GetEntityByEntityIDResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetEntityByEntityIDResponse);
		if (p)
			((_ns1__GetEntityByEntityIDResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetEntityByEntityIDResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetEntityByEntityIDResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetEntityByEntityIDResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetEntityByEntityIDResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetEntityByEntityIDResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:GetEntityByEntityIDResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetEntityByEntityIDResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetEntityByEntityIDResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetEntityByEntityIDResponse * SOAP_FMAC4 soap_get__ns1__GetEntityByEntityIDResponse(struct soap *soap, _ns1__GetEntityByEntityIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetEntityByEntityIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetEntityByEntityIDRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetEntityByEntityIDRequest::__sizeentityID = 0;
	this->_ns1__GetEntityByEntityIDRequest::entityID = NULL;
	/* transient soap skipped */
}

void _ns1__GetEntityByEntityIDRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->_ns1__GetEntityByEntityIDRequest::entityID)
	{	int i;
		for (i = 0; i < (int)this->_ns1__GetEntityByEntityIDRequest::__sizeentityID; i++)
		{
			soap_serialize_ns1__EntityID(soap, (char*const*)(this->_ns1__GetEntityByEntityIDRequest::entityID + i));
		}
	}
#endif
}

int _ns1__GetEntityByEntityIDRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetEntityByEntityIDRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetEntityByEntityIDRequest(struct soap *soap, const char *tag, int id, const _ns1__GetEntityByEntityIDRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetEntityByEntityIDRequest), type))
		return soap->error;
	if (a->_ns1__GetEntityByEntityIDRequest::entityID)
	{	int i;
		for (i = 0; i < (int)a->_ns1__GetEntityByEntityIDRequest::__sizeentityID; i++)
			soap_out_string(soap, "ns1:entityID", -1, (char*const*)(a->_ns1__GetEntityByEntityIDRequest::entityID + i), "");
	}
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetEntityByEntityIDRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetEntityByEntityIDRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetEntityByEntityIDRequest * SOAP_FMAC4 soap_in__ns1__GetEntityByEntityIDRequest(struct soap *soap, const char *tag, _ns1__GetEntityByEntityIDRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetEntityByEntityIDRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetEntityByEntityIDRequest, sizeof(_ns1__GetEntityByEntityIDRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	struct soap_blist *soap_blist_entityID1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:entityID", 1, NULL))
			{	if (a->_ns1__GetEntityByEntityIDRequest::entityID == NULL)
				{	if (soap_blist_entityID1 == NULL)
						soap_blist_entityID1 = soap_new_block(soap);
					a->_ns1__GetEntityByEntityIDRequest::entityID = (char **)soap_push_block_max(soap, soap_blist_entityID1, sizeof(char *));
					if (a->_ns1__GetEntityByEntityIDRequest::entityID == NULL)
						return NULL;
					*a->_ns1__GetEntityByEntityIDRequest::entityID = NULL;
				}
				soap_revert(soap);
				if (soap_in_ns1__EntityID(soap, "ns1:entityID", (char**)a->_ns1__GetEntityByEntityIDRequest::entityID, "ns1:EntityID"))
				{	a->_ns1__GetEntityByEntityIDRequest::__sizeentityID++;
					a->_ns1__GetEntityByEntityIDRequest::entityID = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__GetEntityByEntityIDRequest::entityID)
			soap_pop_block(soap, soap_blist_entityID1);
		if (a->_ns1__GetEntityByEntityIDRequest::__sizeentityID)
		{	a->_ns1__GetEntityByEntityIDRequest::entityID = (char **)soap_save_block(soap, soap_blist_entityID1, NULL, 1);
		}
		else
		{	a->_ns1__GetEntityByEntityIDRequest::entityID = NULL;
			if (soap_blist_entityID1)
				soap_end_block(soap, soap_blist_entityID1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->_ns1__GetEntityByEntityIDRequest::__sizeentityID < 1 || a->_ns1__GetEntityByEntityIDRequest::__sizeentityID > 200))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetEntityByEntityIDRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetEntityByEntityIDRequest, SOAP_TYPE__ns1__GetEntityByEntityIDRequest, sizeof(_ns1__GetEntityByEntityIDRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetEntityByEntityIDRequest * SOAP_FMAC2 soap_instantiate__ns1__GetEntityByEntityIDRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetEntityByEntityIDRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetEntityByEntityIDRequest *p;
	size_t k = sizeof(_ns1__GetEntityByEntityIDRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetEntityByEntityIDRequest);
		if (p)
			((_ns1__GetEntityByEntityIDRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetEntityByEntityIDRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetEntityByEntityIDRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetEntityByEntityIDRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetEntityByEntityIDRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetEntityByEntityIDRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:GetEntityByEntityIDRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetEntityByEntityIDRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetEntityByEntityIDRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetEntityByEntityIDRequest * SOAP_FMAC4 soap_get__ns1__GetEntityByEntityIDRequest(struct soap *soap, _ns1__GetEntityByEntityIDRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetEntityByEntityIDRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SearchByEmailResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__SearchByEmailResponse::total);
	this->_ns1__SearchByEmailResponse::__sizeEntity = 0;
	this->_ns1__SearchByEmailResponse::Entity = NULL;
	/* transient soap skipped */
}

void _ns1__SearchByEmailResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns1__SearchByEmailResponse::total, SOAP_TYPE_int);
	if (this->_ns1__SearchByEmailResponse::Entity)
	{	int i;
		for (i = 0; i < (int)this->_ns1__SearchByEmailResponse::__sizeEntity; i++)
		{
			soap_serialize_PointerTo_ns1__Entity(soap, this->_ns1__SearchByEmailResponse::Entity + i);
		}
	}
#endif
}

int _ns1__SearchByEmailResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SearchByEmailResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SearchByEmailResponse(struct soap *soap, const char *tag, int id, const _ns1__SearchByEmailResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SearchByEmailResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:total");
	if (soap_out_int(soap, "ns1:total", -1, &a->_ns1__SearchByEmailResponse::total, ""))
		return soap->error;
	if (a->_ns1__SearchByEmailResponse::Entity)
	{	int i;
		for (i = 0; i < (int)a->_ns1__SearchByEmailResponse::__sizeEntity; i++)
			if (soap_out_PointerTo_ns1__Entity(soap, "ns1:Entity", -1, a->_ns1__SearchByEmailResponse::Entity + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *_ns1__SearchByEmailResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SearchByEmailResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SearchByEmailResponse * SOAP_FMAC4 soap_in__ns1__SearchByEmailResponse(struct soap *soap, const char *tag, _ns1__SearchByEmailResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SearchByEmailResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SearchByEmailResponse, sizeof(_ns1__SearchByEmailResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_total1 = 1;
	struct soap_blist *soap_blist_Entity1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_total1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:total", &a->_ns1__SearchByEmailResponse::total, "xsd:int"))
				{	soap_flag_total1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Entity", 1, NULL))
			{	if (a->_ns1__SearchByEmailResponse::Entity == NULL)
				{	if (soap_blist_Entity1 == NULL)
						soap_blist_Entity1 = soap_new_block(soap);
					a->_ns1__SearchByEmailResponse::Entity = (_ns1__Entity **)soap_push_block_max(soap, soap_blist_Entity1, sizeof(_ns1__Entity *));
					if (a->_ns1__SearchByEmailResponse::Entity == NULL)
						return NULL;
					*a->_ns1__SearchByEmailResponse::Entity = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTo_ns1__Entity(soap, "ns1:Entity", a->_ns1__SearchByEmailResponse::Entity, ""))
				{	a->_ns1__SearchByEmailResponse::__sizeEntity++;
					a->_ns1__SearchByEmailResponse::Entity = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:total");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__SearchByEmailResponse::Entity)
			soap_pop_block(soap, soap_blist_Entity1);
		if (a->_ns1__SearchByEmailResponse::__sizeEntity)
		{	a->_ns1__SearchByEmailResponse::Entity = (_ns1__Entity **)soap_save_block(soap, soap_blist_Entity1, NULL, 1);
		}
		else
		{	a->_ns1__SearchByEmailResponse::Entity = NULL;
			if (soap_blist_Entity1)
				soap_end_block(soap, soap_blist_Entity1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_total1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__SearchByEmailResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SearchByEmailResponse, SOAP_TYPE__ns1__SearchByEmailResponse, sizeof(_ns1__SearchByEmailResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SearchByEmailResponse * SOAP_FMAC2 soap_instantiate__ns1__SearchByEmailResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SearchByEmailResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SearchByEmailResponse *p;
	size_t k = sizeof(_ns1__SearchByEmailResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SearchByEmailResponse);
		if (p)
			((_ns1__SearchByEmailResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SearchByEmailResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SearchByEmailResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SearchByEmailResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SearchByEmailResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SearchByEmailResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SearchByEmailResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SearchByEmailResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SearchByEmailResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SearchByEmailResponse * SOAP_FMAC4 soap_get__ns1__SearchByEmailResponse(struct soap *soap, _ns1__SearchByEmailResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SearchByEmailResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SearchByEmailRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__SearchByEmailRequest::emailAddress);
	this->_ns1__SearchByEmailRequest::Filter = NULL;
	/* transient soap skipped */
}

void _ns1__SearchByEmailRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__SearchByEmailRequest::emailAddress);
	soap_serialize_PointerTo_ns1__Filter(soap, &this->_ns1__SearchByEmailRequest::Filter);
#endif
}

int _ns1__SearchByEmailRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SearchByEmailRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SearchByEmailRequest(struct soap *soap, const char *tag, int id, const _ns1__SearchByEmailRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SearchByEmailRequest), type))
		return soap->error;
	if (!a->_ns1__SearchByEmailRequest::emailAddress)
	{	if (soap_element_nil(soap, "ns1:emailAddress"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:emailAddress", -1, (char*const*)&a->_ns1__SearchByEmailRequest::emailAddress, ""))
		return soap->error;
	if (soap_out_PointerTo_ns1__Filter(soap, "ns1:Filter", -1, &a->_ns1__SearchByEmailRequest::Filter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SearchByEmailRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SearchByEmailRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SearchByEmailRequest * SOAP_FMAC4 soap_in__ns1__SearchByEmailRequest(struct soap *soap, const char *tag, _ns1__SearchByEmailRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SearchByEmailRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SearchByEmailRequest, sizeof(_ns1__SearchByEmailRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_emailAddress1 = 1;
	size_t soap_flag_Filter1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_emailAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:emailAddress", (char**)&a->_ns1__SearchByEmailRequest::emailAddress, "xsd:string"))
				{	soap_flag_emailAddress1--;
					continue;
				}
			if (soap_flag_Filter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Filter(soap, "ns1:Filter", &a->_ns1__SearchByEmailRequest::Filter, ""))
				{	soap_flag_Filter1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_emailAddress1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__SearchByEmailRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SearchByEmailRequest, SOAP_TYPE__ns1__SearchByEmailRequest, sizeof(_ns1__SearchByEmailRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SearchByEmailRequest * SOAP_FMAC2 soap_instantiate__ns1__SearchByEmailRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SearchByEmailRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SearchByEmailRequest *p;
	size_t k = sizeof(_ns1__SearchByEmailRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SearchByEmailRequest);
		if (p)
			((_ns1__SearchByEmailRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SearchByEmailRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SearchByEmailRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SearchByEmailRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SearchByEmailRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SearchByEmailRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SearchByEmailRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SearchByEmailRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SearchByEmailRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SearchByEmailRequest * SOAP_FMAC4 soap_get__ns1__SearchByEmailRequest(struct soap *soap, _ns1__SearchByEmailRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SearchByEmailRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SearchByEntityIDResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__SearchByEntityIDResponse::total);
	this->_ns1__SearchByEntityIDResponse::__sizeEntity = 0;
	this->_ns1__SearchByEntityIDResponse::Entity = NULL;
	/* transient soap skipped */
}

void _ns1__SearchByEntityIDResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns1__SearchByEntityIDResponse::total, SOAP_TYPE_int);
	if (this->_ns1__SearchByEntityIDResponse::Entity)
	{	int i;
		for (i = 0; i < (int)this->_ns1__SearchByEntityIDResponse::__sizeEntity; i++)
		{
			soap_serialize_PointerTo_ns1__Entity(soap, this->_ns1__SearchByEntityIDResponse::Entity + i);
		}
	}
#endif
}

int _ns1__SearchByEntityIDResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SearchByEntityIDResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SearchByEntityIDResponse(struct soap *soap, const char *tag, int id, const _ns1__SearchByEntityIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SearchByEntityIDResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:total");
	if (soap_out_int(soap, "ns1:total", -1, &a->_ns1__SearchByEntityIDResponse::total, ""))
		return soap->error;
	if (a->_ns1__SearchByEntityIDResponse::Entity)
	{	int i;
		for (i = 0; i < (int)a->_ns1__SearchByEntityIDResponse::__sizeEntity; i++)
			if (soap_out_PointerTo_ns1__Entity(soap, "ns1:Entity", -1, a->_ns1__SearchByEntityIDResponse::Entity + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *_ns1__SearchByEntityIDResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SearchByEntityIDResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SearchByEntityIDResponse * SOAP_FMAC4 soap_in__ns1__SearchByEntityIDResponse(struct soap *soap, const char *tag, _ns1__SearchByEntityIDResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SearchByEntityIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SearchByEntityIDResponse, sizeof(_ns1__SearchByEntityIDResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_total1 = 1;
	struct soap_blist *soap_blist_Entity1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_total1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:total", &a->_ns1__SearchByEntityIDResponse::total, "xsd:int"))
				{	soap_flag_total1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Entity", 1, NULL))
			{	if (a->_ns1__SearchByEntityIDResponse::Entity == NULL)
				{	if (soap_blist_Entity1 == NULL)
						soap_blist_Entity1 = soap_new_block(soap);
					a->_ns1__SearchByEntityIDResponse::Entity = (_ns1__Entity **)soap_push_block_max(soap, soap_blist_Entity1, sizeof(_ns1__Entity *));
					if (a->_ns1__SearchByEntityIDResponse::Entity == NULL)
						return NULL;
					*a->_ns1__SearchByEntityIDResponse::Entity = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTo_ns1__Entity(soap, "ns1:Entity", a->_ns1__SearchByEntityIDResponse::Entity, ""))
				{	a->_ns1__SearchByEntityIDResponse::__sizeEntity++;
					a->_ns1__SearchByEntityIDResponse::Entity = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:total");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__SearchByEntityIDResponse::Entity)
			soap_pop_block(soap, soap_blist_Entity1);
		if (a->_ns1__SearchByEntityIDResponse::__sizeEntity)
		{	a->_ns1__SearchByEntityIDResponse::Entity = (_ns1__Entity **)soap_save_block(soap, soap_blist_Entity1, NULL, 1);
		}
		else
		{	a->_ns1__SearchByEntityIDResponse::Entity = NULL;
			if (soap_blist_Entity1)
				soap_end_block(soap, soap_blist_Entity1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_total1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__SearchByEntityIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SearchByEntityIDResponse, SOAP_TYPE__ns1__SearchByEntityIDResponse, sizeof(_ns1__SearchByEntityIDResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SearchByEntityIDResponse * SOAP_FMAC2 soap_instantiate__ns1__SearchByEntityIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SearchByEntityIDResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SearchByEntityIDResponse *p;
	size_t k = sizeof(_ns1__SearchByEntityIDResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SearchByEntityIDResponse);
		if (p)
			((_ns1__SearchByEntityIDResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SearchByEntityIDResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SearchByEntityIDResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SearchByEntityIDResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SearchByEntityIDResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SearchByEntityIDResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SearchByEntityIDResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SearchByEntityIDResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SearchByEntityIDResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SearchByEntityIDResponse * SOAP_FMAC4 soap_get__ns1__SearchByEntityIDResponse(struct soap *soap, _ns1__SearchByEntityIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SearchByEntityIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SearchByEntityIDRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__SearchByEntityIDRequest::entityID);
	this->_ns1__SearchByEntityIDRequest::Filter = NULL;
	/* transient soap skipped */
}

void _ns1__SearchByEntityIDRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__SearchByEntityIDRequest::entityID);
	soap_serialize_PointerTo_ns1__Filter(soap, &this->_ns1__SearchByEntityIDRequest::Filter);
#endif
}

int _ns1__SearchByEntityIDRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SearchByEntityIDRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SearchByEntityIDRequest(struct soap *soap, const char *tag, int id, const _ns1__SearchByEntityIDRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SearchByEntityIDRequest), type))
		return soap->error;
	if (!a->_ns1__SearchByEntityIDRequest::entityID)
	{	if (soap_element_nil(soap, "ns1:entityID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:entityID", -1, (char*const*)&a->_ns1__SearchByEntityIDRequest::entityID, ""))
		return soap->error;
	if (soap_out_PointerTo_ns1__Filter(soap, "ns1:Filter", -1, &a->_ns1__SearchByEntityIDRequest::Filter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SearchByEntityIDRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SearchByEntityIDRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SearchByEntityIDRequest * SOAP_FMAC4 soap_in__ns1__SearchByEntityIDRequest(struct soap *soap, const char *tag, _ns1__SearchByEntityIDRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SearchByEntityIDRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SearchByEntityIDRequest, sizeof(_ns1__SearchByEntityIDRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_entityID1 = 1;
	size_t soap_flag_Filter1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_entityID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:entityID", (char**)&a->_ns1__SearchByEntityIDRequest::entityID, "ns1:EntityID"))
				{	soap_flag_entityID1--;
					continue;
				}
			if (soap_flag_Filter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Filter(soap, "ns1:Filter", &a->_ns1__SearchByEntityIDRequest::Filter, ""))
				{	soap_flag_Filter1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_entityID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__SearchByEntityIDRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SearchByEntityIDRequest, SOAP_TYPE__ns1__SearchByEntityIDRequest, sizeof(_ns1__SearchByEntityIDRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SearchByEntityIDRequest * SOAP_FMAC2 soap_instantiate__ns1__SearchByEntityIDRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SearchByEntityIDRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SearchByEntityIDRequest *p;
	size_t k = sizeof(_ns1__SearchByEntityIDRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SearchByEntityIDRequest);
		if (p)
			((_ns1__SearchByEntityIDRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SearchByEntityIDRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SearchByEntityIDRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SearchByEntityIDRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SearchByEntityIDRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SearchByEntityIDRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SearchByEntityIDRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SearchByEntityIDRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SearchByEntityIDRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SearchByEntityIDRequest * SOAP_FMAC4 soap_get__ns1__SearchByEntityIDRequest(struct soap *soap, _ns1__SearchByEntityIDRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SearchByEntityIDRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SearchResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__SearchResponse::total);
	this->_ns1__SearchResponse::__sizeEntity = 0;
	this->_ns1__SearchResponse::Entity = NULL;
	/* transient soap skipped */
}

void _ns1__SearchResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns1__SearchResponse::total, SOAP_TYPE_int);
	if (this->_ns1__SearchResponse::Entity)
	{	int i;
		for (i = 0; i < (int)this->_ns1__SearchResponse::__sizeEntity; i++)
		{
			soap_serialize_PointerTo_ns1__Entity(soap, this->_ns1__SearchResponse::Entity + i);
		}
	}
#endif
}

int _ns1__SearchResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SearchResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SearchResponse(struct soap *soap, const char *tag, int id, const _ns1__SearchResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SearchResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:total");
	if (soap_out_int(soap, "ns1:total", -1, &a->_ns1__SearchResponse::total, ""))
		return soap->error;
	if (a->_ns1__SearchResponse::Entity)
	{	int i;
		for (i = 0; i < (int)a->_ns1__SearchResponse::__sizeEntity; i++)
			if (soap_out_PointerTo_ns1__Entity(soap, "ns1:Entity", -1, a->_ns1__SearchResponse::Entity + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *_ns1__SearchResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SearchResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SearchResponse * SOAP_FMAC4 soap_in__ns1__SearchResponse(struct soap *soap, const char *tag, _ns1__SearchResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SearchResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SearchResponse, sizeof(_ns1__SearchResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_total1 = 1;
	struct soap_blist *soap_blist_Entity1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_total1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:total", &a->_ns1__SearchResponse::total, "xsd:int"))
				{	soap_flag_total1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Entity", 1, NULL))
			{	if (a->_ns1__SearchResponse::Entity == NULL)
				{	if (soap_blist_Entity1 == NULL)
						soap_blist_Entity1 = soap_new_block(soap);
					a->_ns1__SearchResponse::Entity = (_ns1__Entity **)soap_push_block_max(soap, soap_blist_Entity1, sizeof(_ns1__Entity *));
					if (a->_ns1__SearchResponse::Entity == NULL)
						return NULL;
					*a->_ns1__SearchResponse::Entity = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTo_ns1__Entity(soap, "ns1:Entity", a->_ns1__SearchResponse::Entity, ""))
				{	a->_ns1__SearchResponse::__sizeEntity++;
					a->_ns1__SearchResponse::Entity = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:total");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__SearchResponse::Entity)
			soap_pop_block(soap, soap_blist_Entity1);
		if (a->_ns1__SearchResponse::__sizeEntity)
		{	a->_ns1__SearchResponse::Entity = (_ns1__Entity **)soap_save_block(soap, soap_blist_Entity1, NULL, 1);
		}
		else
		{	a->_ns1__SearchResponse::Entity = NULL;
			if (soap_blist_Entity1)
				soap_end_block(soap, soap_blist_Entity1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_total1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__SearchResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SearchResponse, SOAP_TYPE__ns1__SearchResponse, sizeof(_ns1__SearchResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SearchResponse * SOAP_FMAC2 soap_instantiate__ns1__SearchResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SearchResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SearchResponse *p;
	size_t k = sizeof(_ns1__SearchResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SearchResponse);
		if (p)
			((_ns1__SearchResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SearchResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SearchResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SearchResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SearchResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SearchResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SearchResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SearchResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SearchResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SearchResponse * SOAP_FMAC4 soap_get__ns1__SearchResponse(struct soap *soap, _ns1__SearchResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SearchResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SearchRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SearchRequest::Filter = NULL;
	/* transient soap skipped */
}

void _ns1__SearchRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Filter(soap, &this->_ns1__SearchRequest::Filter);
#endif
}

int _ns1__SearchRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SearchRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SearchRequest(struct soap *soap, const char *tag, int id, const _ns1__SearchRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SearchRequest), type))
		return soap->error;
	if (!a->_ns1__SearchRequest::Filter)
	{	if (soap_element_nil(soap, "ns1:Filter"))
			return soap->error;
	}
	else
	if (soap_out_PointerTo_ns1__Filter(soap, "ns1:Filter", -1, &a->_ns1__SearchRequest::Filter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SearchRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SearchRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SearchRequest * SOAP_FMAC4 soap_in__ns1__SearchRequest(struct soap *soap, const char *tag, _ns1__SearchRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SearchRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SearchRequest, sizeof(_ns1__SearchRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Filter1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Filter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Filter(soap, "ns1:Filter", &a->_ns1__SearchRequest::Filter, ""))
				{	soap_flag_Filter1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Filter1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__SearchRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SearchRequest, SOAP_TYPE__ns1__SearchRequest, sizeof(_ns1__SearchRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SearchRequest * SOAP_FMAC2 soap_instantiate__ns1__SearchRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SearchRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SearchRequest *p;
	size_t k = sizeof(_ns1__SearchRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SearchRequest);
		if (p)
			((_ns1__SearchRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SearchRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SearchRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SearchRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SearchRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SearchRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SearchRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SearchRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SearchRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SearchRequest * SOAP_FMAC4 soap_get__ns1__SearchRequest(struct soap *soap, _ns1__SearchRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SearchRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__RemoveFromMyContactsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__RemoveFromMyContactsResponse::OK);
	/* transient soap skipped */
}

void _ns1__RemoveFromMyContactsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__RemoveFromMyContactsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RemoveFromMyContactsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RemoveFromMyContactsResponse(struct soap *soap, const char *tag, int id, const _ns1__RemoveFromMyContactsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RemoveFromMyContactsResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__RemoveFromMyContactsResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__RemoveFromMyContactsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RemoveFromMyContactsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RemoveFromMyContactsResponse * SOAP_FMAC4 soap_in__ns1__RemoveFromMyContactsResponse(struct soap *soap, const char *tag, _ns1__RemoveFromMyContactsResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RemoveFromMyContactsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RemoveFromMyContactsResponse, sizeof(_ns1__RemoveFromMyContactsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__RemoveFromMyContactsResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__RemoveFromMyContactsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RemoveFromMyContactsResponse, SOAP_TYPE__ns1__RemoveFromMyContactsResponse, sizeof(_ns1__RemoveFromMyContactsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__RemoveFromMyContactsResponse * SOAP_FMAC2 soap_instantiate__ns1__RemoveFromMyContactsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RemoveFromMyContactsResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__RemoveFromMyContactsResponse *p;
	size_t k = sizeof(_ns1__RemoveFromMyContactsResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__RemoveFromMyContactsResponse);
		if (p)
			((_ns1__RemoveFromMyContactsResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__RemoveFromMyContactsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__RemoveFromMyContactsResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__RemoveFromMyContactsResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__RemoveFromMyContactsResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__RemoveFromMyContactsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:RemoveFromMyContactsResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RemoveFromMyContactsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RemoveFromMyContactsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RemoveFromMyContactsResponse * SOAP_FMAC4 soap_get__ns1__RemoveFromMyContactsResponse(struct soap *soap, _ns1__RemoveFromMyContactsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RemoveFromMyContactsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__RemoveFromMyContactsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__RemoveFromMyContactsRequest::entityID);
	/* transient soap skipped */
}

void _ns1__RemoveFromMyContactsRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__RemoveFromMyContactsRequest::entityID);
#endif
}

int _ns1__RemoveFromMyContactsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RemoveFromMyContactsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RemoveFromMyContactsRequest(struct soap *soap, const char *tag, int id, const _ns1__RemoveFromMyContactsRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RemoveFromMyContactsRequest), type))
		return soap->error;
	if (!a->_ns1__RemoveFromMyContactsRequest::entityID)
	{	if (soap_element_nil(soap, "ns1:entityID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:entityID", -1, (char*const*)&a->_ns1__RemoveFromMyContactsRequest::entityID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__RemoveFromMyContactsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RemoveFromMyContactsRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RemoveFromMyContactsRequest * SOAP_FMAC4 soap_in__ns1__RemoveFromMyContactsRequest(struct soap *soap, const char *tag, _ns1__RemoveFromMyContactsRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RemoveFromMyContactsRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RemoveFromMyContactsRequest, sizeof(_ns1__RemoveFromMyContactsRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_entityID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_entityID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:entityID", (char**)&a->_ns1__RemoveFromMyContactsRequest::entityID, "ns1:EntityID"))
				{	soap_flag_entityID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_entityID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__RemoveFromMyContactsRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RemoveFromMyContactsRequest, SOAP_TYPE__ns1__RemoveFromMyContactsRequest, sizeof(_ns1__RemoveFromMyContactsRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__RemoveFromMyContactsRequest * SOAP_FMAC2 soap_instantiate__ns1__RemoveFromMyContactsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RemoveFromMyContactsRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__RemoveFromMyContactsRequest *p;
	size_t k = sizeof(_ns1__RemoveFromMyContactsRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__RemoveFromMyContactsRequest);
		if (p)
			((_ns1__RemoveFromMyContactsRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__RemoveFromMyContactsRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__RemoveFromMyContactsRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__RemoveFromMyContactsRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__RemoveFromMyContactsRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__RemoveFromMyContactsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:RemoveFromMyContactsRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RemoveFromMyContactsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RemoveFromMyContactsRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RemoveFromMyContactsRequest * SOAP_FMAC4 soap_get__ns1__RemoveFromMyContactsRequest(struct soap *soap, _ns1__RemoveFromMyContactsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RemoveFromMyContactsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__AddToMyContactsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__AddToMyContactsResponse::OK);
	/* transient soap skipped */
}

void _ns1__AddToMyContactsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__AddToMyContactsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AddToMyContactsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AddToMyContactsResponse(struct soap *soap, const char *tag, int id, const _ns1__AddToMyContactsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__AddToMyContactsResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__AddToMyContactsResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__AddToMyContactsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__AddToMyContactsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AddToMyContactsResponse * SOAP_FMAC4 soap_in__ns1__AddToMyContactsResponse(struct soap *soap, const char *tag, _ns1__AddToMyContactsResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AddToMyContactsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__AddToMyContactsResponse, sizeof(_ns1__AddToMyContactsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__AddToMyContactsResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__AddToMyContactsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__AddToMyContactsResponse, SOAP_TYPE__ns1__AddToMyContactsResponse, sizeof(_ns1__AddToMyContactsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__AddToMyContactsResponse * SOAP_FMAC2 soap_instantiate__ns1__AddToMyContactsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__AddToMyContactsResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__AddToMyContactsResponse *p;
	size_t k = sizeof(_ns1__AddToMyContactsResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__AddToMyContactsResponse);
		if (p)
			((_ns1__AddToMyContactsResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__AddToMyContactsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__AddToMyContactsResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__AddToMyContactsResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__AddToMyContactsResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__AddToMyContactsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:AddToMyContactsResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__AddToMyContactsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AddToMyContactsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AddToMyContactsResponse * SOAP_FMAC4 soap_get__ns1__AddToMyContactsResponse(struct soap *soap, _ns1__AddToMyContactsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AddToMyContactsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__AddToMyContactsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__AddToMyContactsRequest::entityID);
	/* transient soap skipped */
}

void _ns1__AddToMyContactsRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__AddToMyContactsRequest::entityID);
#endif
}

int _ns1__AddToMyContactsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AddToMyContactsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AddToMyContactsRequest(struct soap *soap, const char *tag, int id, const _ns1__AddToMyContactsRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__AddToMyContactsRequest), type))
		return soap->error;
	if (!a->_ns1__AddToMyContactsRequest::entityID)
	{	if (soap_element_nil(soap, "ns1:entityID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:entityID", -1, (char*const*)&a->_ns1__AddToMyContactsRequest::entityID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__AddToMyContactsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__AddToMyContactsRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AddToMyContactsRequest * SOAP_FMAC4 soap_in__ns1__AddToMyContactsRequest(struct soap *soap, const char *tag, _ns1__AddToMyContactsRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AddToMyContactsRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__AddToMyContactsRequest, sizeof(_ns1__AddToMyContactsRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_entityID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_entityID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:entityID", (char**)&a->_ns1__AddToMyContactsRequest::entityID, "ns1:EntityID"))
				{	soap_flag_entityID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_entityID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__AddToMyContactsRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__AddToMyContactsRequest, SOAP_TYPE__ns1__AddToMyContactsRequest, sizeof(_ns1__AddToMyContactsRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__AddToMyContactsRequest * SOAP_FMAC2 soap_instantiate__ns1__AddToMyContactsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__AddToMyContactsRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__AddToMyContactsRequest *p;
	size_t k = sizeof(_ns1__AddToMyContactsRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__AddToMyContactsRequest);
		if (p)
			((_ns1__AddToMyContactsRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__AddToMyContactsRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__AddToMyContactsRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__AddToMyContactsRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__AddToMyContactsRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__AddToMyContactsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:AddToMyContactsRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__AddToMyContactsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AddToMyContactsRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AddToMyContactsRequest * SOAP_FMAC4 soap_get__ns1__AddToMyContactsRequest(struct soap *soap, _ns1__AddToMyContactsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AddToMyContactsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SearchMyContactsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__SearchMyContactsResponse::total);
	this->_ns1__SearchMyContactsResponse::__sizeEntity = 0;
	this->_ns1__SearchMyContactsResponse::Entity = NULL;
	/* transient soap skipped */
}

void _ns1__SearchMyContactsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns1__SearchMyContactsResponse::total, SOAP_TYPE_int);
	if (this->_ns1__SearchMyContactsResponse::Entity)
	{	int i;
		for (i = 0; i < (int)this->_ns1__SearchMyContactsResponse::__sizeEntity; i++)
		{
			soap_serialize_PointerTo_ns1__Entity(soap, this->_ns1__SearchMyContactsResponse::Entity + i);
		}
	}
#endif
}

int _ns1__SearchMyContactsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SearchMyContactsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SearchMyContactsResponse(struct soap *soap, const char *tag, int id, const _ns1__SearchMyContactsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SearchMyContactsResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:total");
	if (soap_out_int(soap, "ns1:total", -1, &a->_ns1__SearchMyContactsResponse::total, ""))
		return soap->error;
	if (a->_ns1__SearchMyContactsResponse::Entity)
	{	int i;
		for (i = 0; i < (int)a->_ns1__SearchMyContactsResponse::__sizeEntity; i++)
			if (soap_out_PointerTo_ns1__Entity(soap, "ns1:Entity", -1, a->_ns1__SearchMyContactsResponse::Entity + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *_ns1__SearchMyContactsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SearchMyContactsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SearchMyContactsResponse * SOAP_FMAC4 soap_in__ns1__SearchMyContactsResponse(struct soap *soap, const char *tag, _ns1__SearchMyContactsResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SearchMyContactsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SearchMyContactsResponse, sizeof(_ns1__SearchMyContactsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_total1 = 1;
	struct soap_blist *soap_blist_Entity1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_total1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:total", &a->_ns1__SearchMyContactsResponse::total, "xsd:int"))
				{	soap_flag_total1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Entity", 1, NULL))
			{	if (a->_ns1__SearchMyContactsResponse::Entity == NULL)
				{	if (soap_blist_Entity1 == NULL)
						soap_blist_Entity1 = soap_new_block(soap);
					a->_ns1__SearchMyContactsResponse::Entity = (_ns1__Entity **)soap_push_block_max(soap, soap_blist_Entity1, sizeof(_ns1__Entity *));
					if (a->_ns1__SearchMyContactsResponse::Entity == NULL)
						return NULL;
					*a->_ns1__SearchMyContactsResponse::Entity = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTo_ns1__Entity(soap, "ns1:Entity", a->_ns1__SearchMyContactsResponse::Entity, ""))
				{	a->_ns1__SearchMyContactsResponse::__sizeEntity++;
					a->_ns1__SearchMyContactsResponse::Entity = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns1:total");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__SearchMyContactsResponse::Entity)
			soap_pop_block(soap, soap_blist_Entity1);
		if (a->_ns1__SearchMyContactsResponse::__sizeEntity)
		{	a->_ns1__SearchMyContactsResponse::Entity = (_ns1__Entity **)soap_save_block(soap, soap_blist_Entity1, NULL, 1);
		}
		else
		{	a->_ns1__SearchMyContactsResponse::Entity = NULL;
			if (soap_blist_Entity1)
				soap_end_block(soap, soap_blist_Entity1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_total1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__SearchMyContactsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SearchMyContactsResponse, SOAP_TYPE__ns1__SearchMyContactsResponse, sizeof(_ns1__SearchMyContactsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SearchMyContactsResponse * SOAP_FMAC2 soap_instantiate__ns1__SearchMyContactsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SearchMyContactsResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SearchMyContactsResponse *p;
	size_t k = sizeof(_ns1__SearchMyContactsResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SearchMyContactsResponse);
		if (p)
			((_ns1__SearchMyContactsResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SearchMyContactsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SearchMyContactsResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SearchMyContactsResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SearchMyContactsResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SearchMyContactsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SearchMyContactsResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SearchMyContactsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SearchMyContactsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SearchMyContactsResponse * SOAP_FMAC4 soap_get__ns1__SearchMyContactsResponse(struct soap *soap, _ns1__SearchMyContactsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SearchMyContactsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SearchMyContactsRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SearchMyContactsRequest::Filter = NULL;
	/* transient soap skipped */
}

void _ns1__SearchMyContactsRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Filter(soap, &this->_ns1__SearchMyContactsRequest::Filter);
#endif
}

int _ns1__SearchMyContactsRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SearchMyContactsRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SearchMyContactsRequest(struct soap *soap, const char *tag, int id, const _ns1__SearchMyContactsRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SearchMyContactsRequest), type))
		return soap->error;
	if (soap_out_PointerTo_ns1__Filter(soap, "ns1:Filter", -1, &a->_ns1__SearchMyContactsRequest::Filter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SearchMyContactsRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SearchMyContactsRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SearchMyContactsRequest * SOAP_FMAC4 soap_in__ns1__SearchMyContactsRequest(struct soap *soap, const char *tag, _ns1__SearchMyContactsRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SearchMyContactsRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SearchMyContactsRequest, sizeof(_ns1__SearchMyContactsRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Filter1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Filter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Filter(soap, "ns1:Filter", &a->_ns1__SearchMyContactsRequest::Filter, ""))
				{	soap_flag_Filter1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SearchMyContactsRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SearchMyContactsRequest, SOAP_TYPE__ns1__SearchMyContactsRequest, sizeof(_ns1__SearchMyContactsRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SearchMyContactsRequest * SOAP_FMAC2 soap_instantiate__ns1__SearchMyContactsRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SearchMyContactsRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SearchMyContactsRequest *p;
	size_t k = sizeof(_ns1__SearchMyContactsRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SearchMyContactsRequest);
		if (p)
			((_ns1__SearchMyContactsRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SearchMyContactsRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SearchMyContactsRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SearchMyContactsRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SearchMyContactsRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SearchMyContactsRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SearchMyContactsRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SearchMyContactsRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SearchMyContactsRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SearchMyContactsRequest * SOAP_FMAC4 soap_get__ns1__SearchMyContactsRequest(struct soap *soap, _ns1__SearchMyContactsRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SearchMyContactsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__MyEndpointStatusResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__MemberStatus(soap, &this->_ns1__MyEndpointStatusResponse::MemberStatus);
	/* transient soap skipped */
}

void _ns1__MyEndpointStatusResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns1__MyEndpointStatusResponse::MemberStatus, SOAP_TYPE__ns1__MemberStatus);
#endif
}

int _ns1__MyEndpointStatusResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__MyEndpointStatusResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__MyEndpointStatusResponse(struct soap *soap, const char *tag, int id, const _ns1__MyEndpointStatusResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__MyEndpointStatusResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:MemberStatus");
	if (soap_out__ns1__MemberStatus(soap, "ns1:MemberStatus", -1, &a->_ns1__MyEndpointStatusResponse::MemberStatus, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__MyEndpointStatusResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__MyEndpointStatusResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__MyEndpointStatusResponse * SOAP_FMAC4 soap_in__ns1__MyEndpointStatusResponse(struct soap *soap, const char *tag, _ns1__MyEndpointStatusResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__MyEndpointStatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__MyEndpointStatusResponse, sizeof(_ns1__MyEndpointStatusResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MemberStatus1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MemberStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__MemberStatus(soap, "ns1:MemberStatus", &a->_ns1__MyEndpointStatusResponse::MemberStatus, "ns1:MemberStatus"))
				{	soap_flag_MemberStatus1--;
					continue;
				}
			soap_check_result(soap, "ns1:MemberStatus");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MemberStatus1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__MyEndpointStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__MyEndpointStatusResponse, SOAP_TYPE__ns1__MyEndpointStatusResponse, sizeof(_ns1__MyEndpointStatusResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__MyEndpointStatusResponse * SOAP_FMAC2 soap_instantiate__ns1__MyEndpointStatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__MyEndpointStatusResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__MyEndpointStatusResponse *p;
	size_t k = sizeof(_ns1__MyEndpointStatusResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__MyEndpointStatusResponse);
		if (p)
			((_ns1__MyEndpointStatusResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__MyEndpointStatusResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__MyEndpointStatusResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__MyEndpointStatusResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__MyEndpointStatusResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__MyEndpointStatusResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:MyEndpointStatusResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__MyEndpointStatusResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__MyEndpointStatusResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__MyEndpointStatusResponse * SOAP_FMAC4 soap_get__ns1__MyEndpointStatusResponse(struct soap *soap, _ns1__MyEndpointStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__MyEndpointStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__MyEndpointStatusRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__MyEndpointStatusRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__MyEndpointStatusRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__MyEndpointStatusRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__MyEndpointStatusRequest(struct soap *soap, const char *tag, int id, const _ns1__MyEndpointStatusRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__MyEndpointStatusRequest), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__MyEndpointStatusRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__MyEndpointStatusRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__MyEndpointStatusRequest * SOAP_FMAC4 soap_in__ns1__MyEndpointStatusRequest(struct soap *soap, const char *tag, _ns1__MyEndpointStatusRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__MyEndpointStatusRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__MyEndpointStatusRequest, sizeof(_ns1__MyEndpointStatusRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__MyEndpointStatusRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__MyEndpointStatusRequest, SOAP_TYPE__ns1__MyEndpointStatusRequest, sizeof(_ns1__MyEndpointStatusRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__MyEndpointStatusRequest * SOAP_FMAC2 soap_instantiate__ns1__MyEndpointStatusRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__MyEndpointStatusRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__MyEndpointStatusRequest *p;
	size_t k = sizeof(_ns1__MyEndpointStatusRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__MyEndpointStatusRequest);
		if (p)
			((_ns1__MyEndpointStatusRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__MyEndpointStatusRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__MyEndpointStatusRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__MyEndpointStatusRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__MyEndpointStatusRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__MyEndpointStatusRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:MyEndpointStatusRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__MyEndpointStatusRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__MyEndpointStatusRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__MyEndpointStatusRequest * SOAP_FMAC4 soap_get__ns1__MyEndpointStatusRequest(struct soap *soap, _ns1__MyEndpointStatusRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__MyEndpointStatusRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__LogOutResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns1__OK(soap, &this->_ns1__LogOutResponse::OK);
	/* transient soap skipped */
}

void _ns1__LogOutResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__LogOutResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__LogOutResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__LogOutResponse(struct soap *soap, const char *tag, int id, const _ns1__LogOutResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__LogOutResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OK");
	if (soap_out__ns1__OK(soap, "ns1:OK", -1, &a->_ns1__LogOutResponse::OK, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__LogOutResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__LogOutResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__LogOutResponse * SOAP_FMAC4 soap_in__ns1__LogOutResponse(struct soap *soap, const char *tag, _ns1__LogOutResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__LogOutResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__LogOutResponse, sizeof(_ns1__LogOutResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OK1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OK1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__OK(soap, "ns1:OK", &a->_ns1__LogOutResponse::OK, "ns1:OK"))
				{	soap_flag_OK1--;
					continue;
				}
			soap_check_result(soap, "ns1:OK");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OK1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__LogOutResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__LogOutResponse, SOAP_TYPE__ns1__LogOutResponse, sizeof(_ns1__LogOutResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__LogOutResponse * SOAP_FMAC2 soap_instantiate__ns1__LogOutResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__LogOutResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__LogOutResponse *p;
	size_t k = sizeof(_ns1__LogOutResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__LogOutResponse);
		if (p)
			((_ns1__LogOutResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__LogOutResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__LogOutResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__LogOutResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__LogOutResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__LogOutResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:LogOutResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__LogOutResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__LogOutResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__LogOutResponse * SOAP_FMAC4 soap_get__ns1__LogOutResponse(struct soap *soap, _ns1__LogOutResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__LogOutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__LogOutRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__LogOutRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__LogOutRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__LogOutRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__LogOutRequest(struct soap *soap, const char *tag, int id, const _ns1__LogOutRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__LogOutRequest), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__LogOutRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__LogOutRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__LogOutRequest * SOAP_FMAC4 soap_in__ns1__LogOutRequest(struct soap *soap, const char *tag, _ns1__LogOutRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__LogOutRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__LogOutRequest, sizeof(_ns1__LogOutRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__LogOutRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__LogOutRequest, SOAP_TYPE__ns1__LogOutRequest, sizeof(_ns1__LogOutRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__LogOutRequest * SOAP_FMAC2 soap_instantiate__ns1__LogOutRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__LogOutRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__LogOutRequest *p;
	size_t k = sizeof(_ns1__LogOutRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__LogOutRequest);
		if (p)
			((_ns1__LogOutRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__LogOutRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__LogOutRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__LogOutRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__LogOutRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__LogOutRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:LogOutRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__LogOutRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__LogOutRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__LogOutRequest * SOAP_FMAC4 soap_get__ns1__LogOutRequest(struct soap *soap, _ns1__LogOutRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__LogOutRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__LinkEndpointResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__LinkEndpointResponse::Entity = NULL;
	/* transient soap skipped */
}

void _ns1__LinkEndpointResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Entity(soap, &this->_ns1__LinkEndpointResponse::Entity);
#endif
}

int _ns1__LinkEndpointResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__LinkEndpointResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__LinkEndpointResponse(struct soap *soap, const char *tag, int id, const _ns1__LinkEndpointResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__LinkEndpointResponse), type))
		return soap->error;
	if (a->Entity)
		soap_element_result(soap, "ns1:Entity");
	if (!a->_ns1__LinkEndpointResponse::Entity)
	{	if (soap_element_nil(soap, "ns1:Entity"))
			return soap->error;
	}
	else
	if (soap_out_PointerTo_ns1__Entity(soap, "ns1:Entity", -1, &a->_ns1__LinkEndpointResponse::Entity, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__LinkEndpointResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__LinkEndpointResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__LinkEndpointResponse * SOAP_FMAC4 soap_in__ns1__LinkEndpointResponse(struct soap *soap, const char *tag, _ns1__LinkEndpointResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__LinkEndpointResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__LinkEndpointResponse, sizeof(_ns1__LinkEndpointResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Entity1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Entity1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Entity(soap, "ns1:Entity", &a->_ns1__LinkEndpointResponse::Entity, ""))
				{	soap_flag_Entity1--;
					continue;
				}
			soap_check_result(soap, "ns1:Entity");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Entity1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__LinkEndpointResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__LinkEndpointResponse, SOAP_TYPE__ns1__LinkEndpointResponse, sizeof(_ns1__LinkEndpointResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__LinkEndpointResponse * SOAP_FMAC2 soap_instantiate__ns1__LinkEndpointResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__LinkEndpointResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__LinkEndpointResponse *p;
	size_t k = sizeof(_ns1__LinkEndpointResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__LinkEndpointResponse);
		if (p)
			((_ns1__LinkEndpointResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__LinkEndpointResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__LinkEndpointResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__LinkEndpointResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__LinkEndpointResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__LinkEndpointResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:LinkEndpointResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__LinkEndpointResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__LinkEndpointResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__LinkEndpointResponse * SOAP_FMAC4 soap_get__ns1__LinkEndpointResponse(struct soap *soap, _ns1__LinkEndpointResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__LinkEndpointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__LinkEndpointRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__LinkEndpointRequest::EID);
	soap_default_string(soap, &this->_ns1__LinkEndpointRequest::vrIP);
	soap_default_string(soap, &this->_ns1__LinkEndpointRequest::clientType);
	soap_default_string(soap, &this->_ns1__LinkEndpointRequest::applicationName);
	soap_default_string(soap, &this->_ns1__LinkEndpointRequest::applicationVersion);
	soap_default_string(soap, &this->_ns1__LinkEndpointRequest::applicationOs);
	soap_default_string(soap, &this->_ns1__LinkEndpointRequest::deviceModel);
	this->_ns1__LinkEndpointRequest::pak2 = NULL;
	/* transient soap skipped */
}

void _ns1__LinkEndpointRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__LinkEndpointRequest::EID);
	soap_serialize_string(soap, (char*const*)&this->_ns1__LinkEndpointRequest::vrIP);
	soap_serialize_string(soap, (char*const*)&this->_ns1__LinkEndpointRequest::clientType);
	soap_serialize_string(soap, (char*const*)&this->_ns1__LinkEndpointRequest::applicationName);
	soap_serialize_string(soap, (char*const*)&this->_ns1__LinkEndpointRequest::applicationVersion);
	soap_serialize_string(soap, (char*const*)&this->_ns1__LinkEndpointRequest::applicationOs);
	soap_serialize_string(soap, (char*const*)&this->_ns1__LinkEndpointRequest::deviceModel);
	soap_serialize_PointerTobool(soap, &this->_ns1__LinkEndpointRequest::pak2);
#endif
}

int _ns1__LinkEndpointRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__LinkEndpointRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__LinkEndpointRequest(struct soap *soap, const char *tag, int id, const _ns1__LinkEndpointRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__LinkEndpointRequest), type))
		return soap->error;
	if (!a->_ns1__LinkEndpointRequest::EID)
	{	if (soap_element_nil(soap, "ns1:EID"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:EID", -1, (char*const*)&a->_ns1__LinkEndpointRequest::EID, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:vrIP", -1, (char*const*)&a->_ns1__LinkEndpointRequest::vrIP, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:clientType", -1, (char*const*)&a->_ns1__LinkEndpointRequest::clientType, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:applicationName", -1, (char*const*)&a->_ns1__LinkEndpointRequest::applicationName, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:applicationVersion", -1, (char*const*)&a->_ns1__LinkEndpointRequest::applicationVersion, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:applicationOs", -1, (char*const*)&a->_ns1__LinkEndpointRequest::applicationOs, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:deviceModel", -1, (char*const*)&a->_ns1__LinkEndpointRequest::deviceModel, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:pak2", -1, &a->_ns1__LinkEndpointRequest::pak2, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__LinkEndpointRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__LinkEndpointRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__LinkEndpointRequest * SOAP_FMAC4 soap_in__ns1__LinkEndpointRequest(struct soap *soap, const char *tag, _ns1__LinkEndpointRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__LinkEndpointRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__LinkEndpointRequest, sizeof(_ns1__LinkEndpointRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_EID1 = 1;
	size_t soap_flag_vrIP1 = 1;
	size_t soap_flag_clientType1 = 1;
	size_t soap_flag_applicationName1 = 1;
	size_t soap_flag_applicationVersion1 = 1;
	size_t soap_flag_applicationOs1 = 1;
	size_t soap_flag_deviceModel1 = 1;
	size_t soap_flag_pak21 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:EID", (char**)&a->_ns1__LinkEndpointRequest::EID, "xsd:string"))
				{	soap_flag_EID1--;
					continue;
				}
			if (soap_flag_vrIP1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:vrIP", (char**)&a->_ns1__LinkEndpointRequest::vrIP, "xsd:string"))
				{	soap_flag_vrIP1--;
					continue;
				}
			if (soap_flag_clientType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:clientType", (char**)&a->_ns1__LinkEndpointRequest::clientType, "xsd:string"))
				{	soap_flag_clientType1--;
					continue;
				}
			if (soap_flag_applicationName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:applicationName", (char**)&a->_ns1__LinkEndpointRequest::applicationName, "xsd:string"))
				{	soap_flag_applicationName1--;
					continue;
				}
			if (soap_flag_applicationVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:applicationVersion", (char**)&a->_ns1__LinkEndpointRequest::applicationVersion, "xsd:string"))
				{	soap_flag_applicationVersion1--;
					continue;
				}
			if (soap_flag_applicationOs1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:applicationOs", (char**)&a->_ns1__LinkEndpointRequest::applicationOs, "xsd:string"))
				{	soap_flag_applicationOs1--;
					continue;
				}
			if (soap_flag_deviceModel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:deviceModel", (char**)&a->_ns1__LinkEndpointRequest::deviceModel, "xsd:string"))
				{	soap_flag_deviceModel1--;
					continue;
				}
			if (soap_flag_pak21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns1:pak2", &a->_ns1__LinkEndpointRequest::pak2, "xsd:boolean"))
				{	soap_flag_pak21--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_EID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__LinkEndpointRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__LinkEndpointRequest, SOAP_TYPE__ns1__LinkEndpointRequest, sizeof(_ns1__LinkEndpointRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__LinkEndpointRequest * SOAP_FMAC2 soap_instantiate__ns1__LinkEndpointRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__LinkEndpointRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__LinkEndpointRequest *p;
	size_t k = sizeof(_ns1__LinkEndpointRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__LinkEndpointRequest);
		if (p)
			((_ns1__LinkEndpointRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__LinkEndpointRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__LinkEndpointRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__LinkEndpointRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__LinkEndpointRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__LinkEndpointRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:LinkEndpointRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__LinkEndpointRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__LinkEndpointRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__LinkEndpointRequest * SOAP_FMAC4 soap_get__ns1__LinkEndpointRequest(struct soap *soap, _ns1__LinkEndpointRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__LinkEndpointRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__LogInResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__LogInResponse::pak);
	soap_default_string(soap, &this->_ns1__LogInResponse::vmaddress);
	soap_default_string(soap, &this->_ns1__LogInResponse::proxyaddress);
	soap_default_string(soap, &this->_ns1__LogInResponse::loctag);
	soap_default_string(soap, &this->_ns1__LogInResponse::pak2);
	/* transient soap skipped */
}

void _ns1__LogInResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__LogInResponse::pak);
	soap_serialize_string(soap, (char*const*)&this->_ns1__LogInResponse::vmaddress);
	soap_serialize_string(soap, (char*const*)&this->_ns1__LogInResponse::proxyaddress);
	soap_serialize_string(soap, (char*const*)&this->_ns1__LogInResponse::loctag);
	soap_serialize_string(soap, (char*const*)&this->_ns1__LogInResponse::pak2);
#endif
}

int _ns1__LogInResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__LogInResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__LogInResponse(struct soap *soap, const char *tag, int id, const _ns1__LogInResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__LogInResponse), type))
		return soap->error;
	if (a->pak)
		soap_element_result(soap, "ns1:pak");
	if (!a->_ns1__LogInResponse::pak)
	{	if (soap_element_nil(soap, "ns1:pak"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:pak", -1, (char*const*)&a->_ns1__LogInResponse::pak, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:vmaddress", -1, (char*const*)&a->_ns1__LogInResponse::vmaddress, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:proxyaddress", -1, (char*const*)&a->_ns1__LogInResponse::proxyaddress, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:loctag", -1, (char*const*)&a->_ns1__LogInResponse::loctag, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:pak2", -1, (char*const*)&a->_ns1__LogInResponse::pak2, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__LogInResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__LogInResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__LogInResponse * SOAP_FMAC4 soap_in__ns1__LogInResponse(struct soap *soap, const char *tag, _ns1__LogInResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__LogInResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__LogInResponse, sizeof(_ns1__LogInResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_pak1 = 1;
	size_t soap_flag_vmaddress1 = 1;
	size_t soap_flag_proxyaddress1 = 1;
	size_t soap_flag_loctag1 = 1;
	size_t soap_flag_pak21 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pak1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:pak", (char**)&a->_ns1__LogInResponse::pak, "xsd:string"))
				{	soap_flag_pak1--;
					continue;
				}
			if (soap_flag_vmaddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:vmaddress", (char**)&a->_ns1__LogInResponse::vmaddress, "xsd:string"))
				{	soap_flag_vmaddress1--;
					continue;
				}
			if (soap_flag_proxyaddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:proxyaddress", (char**)&a->_ns1__LogInResponse::proxyaddress, "xsd:string"))
				{	soap_flag_proxyaddress1--;
					continue;
				}
			if (soap_flag_loctag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:loctag", (char**)&a->_ns1__LogInResponse::loctag, "xsd:string"))
				{	soap_flag_loctag1--;
					continue;
				}
			if (soap_flag_pak21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:pak2", (char**)&a->_ns1__LogInResponse::pak2, "xsd:string"))
				{	soap_flag_pak21--;
					continue;
				}
			soap_check_result(soap, "ns1:pak");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pak1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__LogInResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__LogInResponse, SOAP_TYPE__ns1__LogInResponse, sizeof(_ns1__LogInResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__LogInResponse * SOAP_FMAC2 soap_instantiate__ns1__LogInResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__LogInResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__LogInResponse *p;
	size_t k = sizeof(_ns1__LogInResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__LogInResponse);
		if (p)
			((_ns1__LogInResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__LogInResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__LogInResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__LogInResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__LogInResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__LogInResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:LogInResponse", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__LogInResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__LogInResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__LogInResponse * SOAP_FMAC4 soap_get__ns1__LogInResponse(struct soap *soap, _ns1__LogInResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__LogInResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__LogInRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__LogInRequest::ClientType = NULL;
	/* transient soap skipped */
}

void _ns1__LogInRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ClientType(soap, &this->_ns1__LogInRequest::ClientType);
#endif
}

int _ns1__LogInRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__LogInRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__LogInRequest(struct soap *soap, const char *tag, int id, const _ns1__LogInRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__LogInRequest), type))
		return soap->error;
	if (soap_out_PointerTo_ns1__ClientType(soap, "ns1:ClientType", -1, &a->_ns1__LogInRequest::ClientType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__LogInRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__LogInRequest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__LogInRequest * SOAP_FMAC4 soap_in__ns1__LogInRequest(struct soap *soap, const char *tag, _ns1__LogInRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__LogInRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__LogInRequest, sizeof(_ns1__LogInRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ClientType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ClientType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__ClientType(soap, "ns1:ClientType", &a->_ns1__LogInRequest::ClientType, "ns1:ClientType"))
				{	soap_flag_ClientType1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__LogInRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__LogInRequest, SOAP_TYPE__ns1__LogInRequest, sizeof(_ns1__LogInRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__LogInRequest * SOAP_FMAC2 soap_instantiate__ns1__LogInRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__LogInRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__LogInRequest *p;
	size_t k = sizeof(_ns1__LogInRequest);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__LogInRequest);
		if (p)
			((_ns1__LogInRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__LogInRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__LogInRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__LogInRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__LogInRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__LogInRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:LogInRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__LogInRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__LogInRequest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__LogInRequest * SOAP_FMAC4 soap_get__ns1__LogInRequest(struct soap *soap, _ns1__LogInRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__LogInRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__WelcomeBannerContent::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__WelcomeBannerContent::welcomeBannerText);
	this->_ns1__WelcomeBannerContent::__sizeLoginAttempt = 0;
	this->_ns1__WelcomeBannerContent::LoginAttempt = NULL;
	this->_ns1__WelcomeBannerContent::welcomeBannerPasswordExpiryDate = NULL;
	/* transient soap skipped */
}

void _ns1__WelcomeBannerContent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__WelcomeBannerContent::welcomeBannerText);
	if (this->_ns1__WelcomeBannerContent::LoginAttempt)
	{	int i;
		for (i = 0; i < (int)this->_ns1__WelcomeBannerContent::__sizeLoginAttempt; i++)
		{
			soap_serialize_PointerTo_ns1__LoginAttempt(soap, this->_ns1__WelcomeBannerContent::LoginAttempt + i);
		}
	}
	soap_serialize_PointerTodateTime(soap, &this->_ns1__WelcomeBannerContent::welcomeBannerPasswordExpiryDate);
#endif
}

int _ns1__WelcomeBannerContent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__WelcomeBannerContent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__WelcomeBannerContent(struct soap *soap, const char *tag, int id, const _ns1__WelcomeBannerContent *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__WelcomeBannerContent), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:welcomeBannerText", -1, (char*const*)&a->_ns1__WelcomeBannerContent::welcomeBannerText, ""))
		return soap->error;
	if (a->_ns1__WelcomeBannerContent::LoginAttempt)
	{	int i;
		for (i = 0; i < (int)a->_ns1__WelcomeBannerContent::__sizeLoginAttempt; i++)
			if (soap_out_PointerTo_ns1__LoginAttempt(soap, "ns1:LoginAttempt", -1, a->_ns1__WelcomeBannerContent::LoginAttempt + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTodateTime(soap, "ns1:welcomeBannerPasswordExpiryDate", -1, &a->_ns1__WelcomeBannerContent::welcomeBannerPasswordExpiryDate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__WelcomeBannerContent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__WelcomeBannerContent(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__WelcomeBannerContent * SOAP_FMAC4 soap_in__ns1__WelcomeBannerContent(struct soap *soap, const char *tag, _ns1__WelcomeBannerContent *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__WelcomeBannerContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__WelcomeBannerContent, sizeof(_ns1__WelcomeBannerContent), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_welcomeBannerText1 = 1;
	struct soap_blist *soap_blist_LoginAttempt1 = NULL;
	size_t soap_flag_welcomeBannerPasswordExpiryDate1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_welcomeBannerText1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:welcomeBannerText", (char**)&a->_ns1__WelcomeBannerContent::welcomeBannerText, "xsd:string"))
				{	soap_flag_welcomeBannerText1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:LoginAttempt", 1, NULL))
			{	if (a->_ns1__WelcomeBannerContent::LoginAttempt == NULL)
				{	if (soap_blist_LoginAttempt1 == NULL)
						soap_blist_LoginAttempt1 = soap_new_block(soap);
					a->_ns1__WelcomeBannerContent::LoginAttempt = (_ns1__LoginAttempt **)soap_push_block_max(soap, soap_blist_LoginAttempt1, sizeof(_ns1__LoginAttempt *));
					if (a->_ns1__WelcomeBannerContent::LoginAttempt == NULL)
						return NULL;
					*a->_ns1__WelcomeBannerContent::LoginAttempt = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTo_ns1__LoginAttempt(soap, "ns1:LoginAttempt", a->_ns1__WelcomeBannerContent::LoginAttempt, ""))
				{	a->_ns1__WelcomeBannerContent::__sizeLoginAttempt++;
					a->_ns1__WelcomeBannerContent::LoginAttempt = NULL;
					continue;
				}
			}
			if (soap_flag_welcomeBannerPasswordExpiryDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodateTime(soap, "ns1:welcomeBannerPasswordExpiryDate", &a->_ns1__WelcomeBannerContent::welcomeBannerPasswordExpiryDate, "xsd:dateTime"))
				{	soap_flag_welcomeBannerPasswordExpiryDate1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__WelcomeBannerContent::LoginAttempt)
			soap_pop_block(soap, soap_blist_LoginAttempt1);
		if (a->_ns1__WelcomeBannerContent::__sizeLoginAttempt)
		{	a->_ns1__WelcomeBannerContent::LoginAttempt = (_ns1__LoginAttempt **)soap_save_block(soap, soap_blist_LoginAttempt1, NULL, 1);
		}
		else
		{	a->_ns1__WelcomeBannerContent::LoginAttempt = NULL;
			if (soap_blist_LoginAttempt1)
				soap_end_block(soap, soap_blist_LoginAttempt1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__WelcomeBannerContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__WelcomeBannerContent, SOAP_TYPE__ns1__WelcomeBannerContent, sizeof(_ns1__WelcomeBannerContent), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__WelcomeBannerContent * SOAP_FMAC2 soap_instantiate__ns1__WelcomeBannerContent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__WelcomeBannerContent(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__WelcomeBannerContent *p;
	size_t k = sizeof(_ns1__WelcomeBannerContent);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__WelcomeBannerContent);
		if (p)
			((_ns1__WelcomeBannerContent*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__WelcomeBannerContent, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__WelcomeBannerContent*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__WelcomeBannerContent location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__WelcomeBannerContent, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__WelcomeBannerContent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:WelcomeBannerContent", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__WelcomeBannerContent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__WelcomeBannerContent(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__WelcomeBannerContent * SOAP_FMAC4 soap_get__ns1__WelcomeBannerContent(struct soap *soap, _ns1__WelcomeBannerContent *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__WelcomeBannerContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__LoginAttempt::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__LoginAttempt::result);
	soap_default_string(soap, &this->_ns1__LoginAttempt::sourceIPAddress);
	soap_default_dateTime(soap, &this->_ns1__LoginAttempt::attemptTime);
	/* transient soap skipped */
}

void _ns1__LoginAttempt::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__LoginAttempt::result);
	soap_serialize_string(soap, (char*const*)&this->_ns1__LoginAttempt::sourceIPAddress);
	soap_embedded(soap, &this->_ns1__LoginAttempt::attemptTime, SOAP_TYPE_dateTime);
#endif
}

int _ns1__LoginAttempt::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__LoginAttempt(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__LoginAttempt(struct soap *soap, const char *tag, int id, const _ns1__LoginAttempt *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__LoginAttempt), type))
		return soap->error;
	if (!a->_ns1__LoginAttempt::result)
	{	if (soap_element_nil(soap, "ns1:result"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:result", -1, (char*const*)&a->_ns1__LoginAttempt::result, ""))
		return soap->error;
	if (!a->_ns1__LoginAttempt::sourceIPAddress)
	{	if (soap_element_nil(soap, "ns1:sourceIPAddress"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:sourceIPAddress", -1, (char*const*)&a->_ns1__LoginAttempt::sourceIPAddress, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:attemptTime", -1, &a->_ns1__LoginAttempt::attemptTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__LoginAttempt::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__LoginAttempt(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__LoginAttempt * SOAP_FMAC4 soap_in__ns1__LoginAttempt(struct soap *soap, const char *tag, _ns1__LoginAttempt *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__LoginAttempt *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__LoginAttempt, sizeof(_ns1__LoginAttempt), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_result1 = 1;
	size_t soap_flag_sourceIPAddress1 = 1;
	size_t soap_flag_attemptTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:result", (char**)&a->_ns1__LoginAttempt::result, "xsd:string"))
				{	soap_flag_result1--;
					continue;
				}
			if (soap_flag_sourceIPAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sourceIPAddress", (char**)&a->_ns1__LoginAttempt::sourceIPAddress, "xsd:string"))
				{	soap_flag_sourceIPAddress1--;
					continue;
				}
			if (soap_flag_attemptTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "ns1:attemptTime", &a->_ns1__LoginAttempt::attemptTime, "xsd:dateTime"))
				{	soap_flag_attemptTime1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result1 > 0 || soap_flag_sourceIPAddress1 > 0 || soap_flag_attemptTime1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__LoginAttempt *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__LoginAttempt, SOAP_TYPE__ns1__LoginAttempt, sizeof(_ns1__LoginAttempt), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__LoginAttempt * SOAP_FMAC2 soap_instantiate__ns1__LoginAttempt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__LoginAttempt(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__LoginAttempt *p;
	size_t k = sizeof(_ns1__LoginAttempt);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__LoginAttempt);
		if (p)
			((_ns1__LoginAttempt*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__LoginAttempt, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__LoginAttempt*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__LoginAttempt location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__LoginAttempt, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__LoginAttempt::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:LoginAttempt", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__LoginAttempt::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__LoginAttempt(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__LoginAttempt * SOAP_FMAC4 soap_get__ns1__LoginAttempt(struct soap *soap, _ns1__LoginAttempt *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__LoginAttempt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__LectureModeParticipant::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__LectureModeParticipant::entityID);
	soap_default_ns1__EntityID(soap, &this->_ns1__LectureModeParticipant::participantID);
	soap_default__ns1__EntityType(soap, &this->_ns1__LectureModeParticipant::EntityType);
	soap_default_string(soap, &this->_ns1__LectureModeParticipant::displayName);
	soap_default_string(soap, &this->_ns1__LectureModeParticipant::extension);
	this->_ns1__LectureModeParticipant::audio = NULL;
	this->_ns1__LectureModeParticipant::video = NULL;
	this->_ns1__LectureModeParticipant::appshare = NULL;
	this->_ns1__LectureModeParticipant::handRaised = NULL;
	this->_ns1__LectureModeParticipant::presenter = NULL;
	/* transient soap skipped */
}

void _ns1__LectureModeParticipant::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__LectureModeParticipant::entityID);
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__LectureModeParticipant::participantID);
	soap_embedded(soap, &this->_ns1__LectureModeParticipant::EntityType, SOAP_TYPE__ns1__EntityType);
	soap_serialize_string(soap, (char*const*)&this->_ns1__LectureModeParticipant::displayName);
	soap_serialize_string(soap, (char*const*)&this->_ns1__LectureModeParticipant::extension);
	soap_serialize_PointerTobool(soap, &this->_ns1__LectureModeParticipant::audio);
	soap_serialize_PointerTobool(soap, &this->_ns1__LectureModeParticipant::video);
	soap_serialize_PointerTobool(soap, &this->_ns1__LectureModeParticipant::appshare);
	soap_serialize_PointerTobool(soap, &this->_ns1__LectureModeParticipant::handRaised);
	soap_serialize_PointerTobool(soap, &this->_ns1__LectureModeParticipant::presenter);
#endif
}

int _ns1__LectureModeParticipant::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__LectureModeParticipant(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__LectureModeParticipant(struct soap *soap, const char *tag, int id, const _ns1__LectureModeParticipant *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__LectureModeParticipant), type))
		return soap->error;
	if (!a->_ns1__LectureModeParticipant::entityID)
	{	if (soap_element_nil(soap, "ns1:entityID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:entityID", -1, (char*const*)&a->_ns1__LectureModeParticipant::entityID, ""))
		return soap->error;
	if (!a->_ns1__LectureModeParticipant::participantID)
	{	if (soap_element_nil(soap, "ns1:participantID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:participantID", -1, (char*const*)&a->_ns1__LectureModeParticipant::participantID, ""))
		return soap->error;
	if (soap_out__ns1__EntityType(soap, "ns1:EntityType", -1, &a->_ns1__LectureModeParticipant::EntityType, ""))
		return soap->error;
	if (!a->_ns1__LectureModeParticipant::displayName)
	{	if (soap_element_nil(soap, "ns1:displayName"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:displayName", -1, (char*const*)&a->_ns1__LectureModeParticipant::displayName, ""))
		return soap->error;
	if (!a->_ns1__LectureModeParticipant::extension)
	{	if (soap_element_nil(soap, "ns1:extension"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:extension", -1, (char*const*)&a->_ns1__LectureModeParticipant::extension, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:audio", -1, &a->_ns1__LectureModeParticipant::audio, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:video", -1, &a->_ns1__LectureModeParticipant::video, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:appshare", -1, &a->_ns1__LectureModeParticipant::appshare, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:handRaised", -1, &a->_ns1__LectureModeParticipant::handRaised, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:presenter", -1, &a->_ns1__LectureModeParticipant::presenter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__LectureModeParticipant::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__LectureModeParticipant(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__LectureModeParticipant * SOAP_FMAC4 soap_in__ns1__LectureModeParticipant(struct soap *soap, const char *tag, _ns1__LectureModeParticipant *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__LectureModeParticipant *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__LectureModeParticipant, sizeof(_ns1__LectureModeParticipant), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_entityID1 = 1;
	size_t soap_flag_participantID1 = 1;
	size_t soap_flag_EntityType1 = 1;
	size_t soap_flag_displayName1 = 1;
	size_t soap_flag_extension1 = 1;
	size_t soap_flag_audio1 = 1;
	size_t soap_flag_video1 = 1;
	size_t soap_flag_appshare1 = 1;
	size_t soap_flag_handRaised1 = 1;
	size_t soap_flag_presenter1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_entityID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:entityID", (char**)&a->_ns1__LectureModeParticipant::entityID, "ns1:EntityID"))
				{	soap_flag_entityID1--;
					continue;
				}
			if (soap_flag_participantID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:participantID", (char**)&a->_ns1__LectureModeParticipant::participantID, "ns1:EntityID"))
				{	soap_flag_participantID1--;
					continue;
				}
			if (soap_flag_EntityType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__EntityType(soap, "ns1:EntityType", &a->_ns1__LectureModeParticipant::EntityType, "ns1:EntityType"))
				{	soap_flag_EntityType1--;
					continue;
				}
			if (soap_flag_displayName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:displayName", (char**)&a->_ns1__LectureModeParticipant::displayName, "xsd:string"))
				{	soap_flag_displayName1--;
					continue;
				}
			if (soap_flag_extension1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:extension", (char**)&a->_ns1__LectureModeParticipant::extension, "xsd:string"))
				{	soap_flag_extension1--;
					continue;
				}
			if (soap_flag_audio1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns1:audio", &a->_ns1__LectureModeParticipant::audio, "xsd:boolean"))
				{	soap_flag_audio1--;
					continue;
				}
			if (soap_flag_video1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns1:video", &a->_ns1__LectureModeParticipant::video, "xsd:boolean"))
				{	soap_flag_video1--;
					continue;
				}
			if (soap_flag_appshare1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns1:appshare", &a->_ns1__LectureModeParticipant::appshare, "xsd:boolean"))
				{	soap_flag_appshare1--;
					continue;
				}
			if (soap_flag_handRaised1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns1:handRaised", &a->_ns1__LectureModeParticipant::handRaised, "xsd:boolean"))
				{	soap_flag_handRaised1--;
					continue;
				}
			if (soap_flag_presenter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns1:presenter", &a->_ns1__LectureModeParticipant::presenter, "xsd:boolean"))
				{	soap_flag_presenter1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_entityID1 > 0 || soap_flag_participantID1 > 0 || soap_flag_EntityType1 > 0 || soap_flag_displayName1 > 0 || soap_flag_extension1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__LectureModeParticipant *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__LectureModeParticipant, SOAP_TYPE__ns1__LectureModeParticipant, sizeof(_ns1__LectureModeParticipant), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__LectureModeParticipant * SOAP_FMAC2 soap_instantiate__ns1__LectureModeParticipant(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__LectureModeParticipant(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__LectureModeParticipant *p;
	size_t k = sizeof(_ns1__LectureModeParticipant);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__LectureModeParticipant);
		if (p)
			((_ns1__LectureModeParticipant*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__LectureModeParticipant, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__LectureModeParticipant*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__LectureModeParticipant location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__LectureModeParticipant, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__LectureModeParticipant::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:LectureModeParticipant", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__LectureModeParticipant::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__LectureModeParticipant(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__LectureModeParticipant * SOAP_FMAC4 soap_get__ns1__LectureModeParticipant(struct soap *soap, _ns1__LectureModeParticipant *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__LectureModeParticipant(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__Entity::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EntityID(soap, &this->_ns1__Entity::entityID);
	soap_default_ns1__EntityID(soap, &this->_ns1__Entity::participantID);
	soap_default__ns1__EntityType(soap, &this->_ns1__Entity::EntityType);
	soap_default_ns1__EntityID(soap, &this->_ns1__Entity::ownerID);
	soap_default_string(soap, &this->_ns1__Entity::displayName);
	soap_default_string(soap, &this->_ns1__Entity::extension);
	soap_default_string(soap, &this->_ns1__Entity::emailAddress);
	soap_default_string(soap, &this->_ns1__Entity::tenant);
	soap_default_string(soap, &this->_ns1__Entity::description);
	this->_ns1__Entity::Language = NULL;
	this->_ns1__Entity::MemberStatus = NULL;
	this->_ns1__Entity::MemberMode = NULL;
	this->_ns1__Entity::canCallDirect = NULL;
	this->_ns1__Entity::canJoinMeeting = NULL;
	this->_ns1__Entity::canRecordMeeting = NULL;
	this->_ns1__Entity::isInMyContacts = NULL;
	this->_ns1__Entity::RoomStatus = NULL;
	this->_ns1__Entity::RoomMode = NULL;
	this->_ns1__Entity::canControl = NULL;
	this->_ns1__Entity::audio = NULL;
	this->_ns1__Entity::video = NULL;
	this->_ns1__Entity::appshare = NULL;
	/* transient soap skipped */
}

void _ns1__Entity::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__Entity::entityID);
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__Entity::participantID);
	soap_embedded(soap, &this->_ns1__Entity::EntityType, SOAP_TYPE__ns1__EntityType);
	soap_serialize_ns1__EntityID(soap, (char*const*)&this->_ns1__Entity::ownerID);
	soap_serialize_string(soap, (char*const*)&this->_ns1__Entity::displayName);
	soap_serialize_string(soap, (char*const*)&this->_ns1__Entity::extension);
	soap_serialize_string(soap, (char*const*)&this->_ns1__Entity::emailAddress);
	soap_serialize_string(soap, (char*const*)&this->_ns1__Entity::tenant);
	soap_serialize_string(soap, (char*const*)&this->_ns1__Entity::description);
	soap_serialize_PointerTo_ns1__Language(soap, &this->_ns1__Entity::Language);
	soap_serialize_PointerTo_ns1__MemberStatus(soap, &this->_ns1__Entity::MemberStatus);
	soap_serialize_PointerTo_ns1__MemberMode(soap, &this->_ns1__Entity::MemberMode);
	soap_serialize_PointerTobool(soap, &this->_ns1__Entity::canCallDirect);
	soap_serialize_PointerTobool(soap, &this->_ns1__Entity::canJoinMeeting);
	soap_serialize_PointerTobool(soap, &this->_ns1__Entity::canRecordMeeting);
	soap_serialize_PointerTobool(soap, &this->_ns1__Entity::isInMyContacts);
	soap_serialize_PointerTo_ns1__RoomStatus(soap, &this->_ns1__Entity::RoomStatus);
	soap_serialize_PointerTo_ns1__RoomMode(soap, &this->_ns1__Entity::RoomMode);
	soap_serialize_PointerTobool(soap, &this->_ns1__Entity::canControl);
	soap_serialize_PointerTobool(soap, &this->_ns1__Entity::audio);
	soap_serialize_PointerTobool(soap, &this->_ns1__Entity::video);
	soap_serialize_PointerTobool(soap, &this->_ns1__Entity::appshare);
#endif
}

int _ns1__Entity::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__Entity(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Entity(struct soap *soap, const char *tag, int id, const _ns1__Entity *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__Entity), type))
		return soap->error;
	if (!a->_ns1__Entity::entityID)
	{	if (soap_element_nil(soap, "ns1:entityID"))
			return soap->error;
	}
	else
	if (soap_out_ns1__EntityID(soap, "ns1:entityID", -1, (char*const*)&a->_ns1__Entity::entityID, ""))
		return soap->error;
	if (soap_out_ns1__EntityID(soap, "ns1:participantID", -1, (char*const*)&a->_ns1__Entity::participantID, ""))
		return soap->error;
	if (soap_out__ns1__EntityType(soap, "ns1:EntityType", -1, &a->_ns1__Entity::EntityType, ""))
		return soap->error;
	if (soap_out_ns1__EntityID(soap, "ns1:ownerID", -1, (char*const*)&a->_ns1__Entity::ownerID, ""))
		return soap->error;
	if (!a->_ns1__Entity::displayName)
	{	if (soap_element_nil(soap, "ns1:displayName"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:displayName", -1, (char*const*)&a->_ns1__Entity::displayName, ""))
		return soap->error;
	if (!a->_ns1__Entity::extension)
	{	if (soap_element_nil(soap, "ns1:extension"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:extension", -1, (char*const*)&a->_ns1__Entity::extension, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:emailAddress", -1, (char*const*)&a->_ns1__Entity::emailAddress, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:tenant", -1, (char*const*)&a->_ns1__Entity::tenant, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:description", -1, (char*const*)&a->_ns1__Entity::description, ""))
		return soap->error;
	if (soap_out_PointerTo_ns1__Language(soap, "ns1:Language", -1, &a->_ns1__Entity::Language, ""))
		return soap->error;
	if (soap_out_PointerTo_ns1__MemberStatus(soap, "ns1:MemberStatus", -1, &a->_ns1__Entity::MemberStatus, ""))
		return soap->error;
	if (soap_out_PointerTo_ns1__MemberMode(soap, "ns1:MemberMode", -1, &a->_ns1__Entity::MemberMode, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:canCallDirect", -1, &a->_ns1__Entity::canCallDirect, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:canJoinMeeting", -1, &a->_ns1__Entity::canJoinMeeting, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:canRecordMeeting", -1, &a->_ns1__Entity::canRecordMeeting, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:isInMyContacts", -1, &a->_ns1__Entity::isInMyContacts, ""))
		return soap->error;
	if (soap_out_PointerTo_ns1__RoomStatus(soap, "ns1:RoomStatus", -1, &a->_ns1__Entity::RoomStatus, ""))
		return soap->error;
	if (soap_out_PointerTo_ns1__RoomMode(soap, "ns1:RoomMode", -1, &a->_ns1__Entity::RoomMode, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:canControl", -1, &a->_ns1__Entity::canControl, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:audio", -1, &a->_ns1__Entity::audio, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:video", -1, &a->_ns1__Entity::video, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:appshare", -1, &a->_ns1__Entity::appshare, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__Entity::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__Entity(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__Entity * SOAP_FMAC4 soap_in__ns1__Entity(struct soap *soap, const char *tag, _ns1__Entity *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__Entity *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__Entity, sizeof(_ns1__Entity), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_entityID1 = 1;
	size_t soap_flag_participantID1 = 1;
	size_t soap_flag_EntityType1 = 1;
	size_t soap_flag_ownerID1 = 1;
	size_t soap_flag_displayName1 = 1;
	size_t soap_flag_extension1 = 1;
	size_t soap_flag_emailAddress1 = 1;
	size_t soap_flag_tenant1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_Language1 = 1;
	size_t soap_flag_MemberStatus1 = 1;
	size_t soap_flag_MemberMode1 = 1;
	size_t soap_flag_canCallDirect1 = 1;
	size_t soap_flag_canJoinMeeting1 = 1;
	size_t soap_flag_canRecordMeeting1 = 1;
	size_t soap_flag_isInMyContacts1 = 1;
	size_t soap_flag_RoomStatus1 = 1;
	size_t soap_flag_RoomMode1 = 1;
	size_t soap_flag_canControl1 = 1;
	size_t soap_flag_audio1 = 1;
	size_t soap_flag_video1 = 1;
	size_t soap_flag_appshare1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_entityID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:entityID", (char**)&a->_ns1__Entity::entityID, "ns1:EntityID"))
				{	soap_flag_entityID1--;
					continue;
				}
			if (soap_flag_participantID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:participantID", (char**)&a->_ns1__Entity::participantID, "ns1:EntityID"))
				{	soap_flag_participantID1--;
					continue;
				}
			if (soap_flag_EntityType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns1__EntityType(soap, "ns1:EntityType", &a->_ns1__Entity::EntityType, "ns1:EntityType"))
				{	soap_flag_EntityType1--;
					continue;
				}
			if (soap_flag_ownerID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns1__EntityID(soap, "ns1:ownerID", (char**)&a->_ns1__Entity::ownerID, "ns1:EntityID"))
				{	soap_flag_ownerID1--;
					continue;
				}
			if (soap_flag_displayName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:displayName", (char**)&a->_ns1__Entity::displayName, "xsd:string"))
				{	soap_flag_displayName1--;
					continue;
				}
			if (soap_flag_extension1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:extension", (char**)&a->_ns1__Entity::extension, "xsd:string"))
				{	soap_flag_extension1--;
					continue;
				}
			if (soap_flag_emailAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:emailAddress", (char**)&a->_ns1__Entity::emailAddress, "xsd:string"))
				{	soap_flag_emailAddress1--;
					continue;
				}
			if (soap_flag_tenant1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:tenant", (char**)&a->_ns1__Entity::tenant, "xsd:string"))
				{	soap_flag_tenant1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:description", (char**)&a->_ns1__Entity::description, "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_Language1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Language(soap, "ns1:Language", &a->_ns1__Entity::Language, "ns1:Language"))
				{	soap_flag_Language1--;
					continue;
				}
			if (soap_flag_MemberStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__MemberStatus(soap, "ns1:MemberStatus", &a->_ns1__Entity::MemberStatus, "ns1:MemberStatus"))
				{	soap_flag_MemberStatus1--;
					continue;
				}
			if (soap_flag_MemberMode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__MemberMode(soap, "ns1:MemberMode", &a->_ns1__Entity::MemberMode, "ns1:MemberMode"))
				{	soap_flag_MemberMode1--;
					continue;
				}
			if (soap_flag_canCallDirect1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns1:canCallDirect", &a->_ns1__Entity::canCallDirect, "xsd:boolean"))
				{	soap_flag_canCallDirect1--;
					continue;
				}
			if (soap_flag_canJoinMeeting1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns1:canJoinMeeting", &a->_ns1__Entity::canJoinMeeting, "xsd:boolean"))
				{	soap_flag_canJoinMeeting1--;
					continue;
				}
			if (soap_flag_canRecordMeeting1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns1:canRecordMeeting", &a->_ns1__Entity::canRecordMeeting, "xsd:boolean"))
				{	soap_flag_canRecordMeeting1--;
					continue;
				}
			if (soap_flag_isInMyContacts1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns1:isInMyContacts", &a->_ns1__Entity::isInMyContacts, "xsd:boolean"))
				{	soap_flag_isInMyContacts1--;
					continue;
				}
			if (soap_flag_RoomStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__RoomStatus(soap, "ns1:RoomStatus", &a->_ns1__Entity::RoomStatus, "ns1:RoomStatus"))
				{	soap_flag_RoomStatus1--;
					continue;
				}
			if (soap_flag_RoomMode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__RoomMode(soap, "ns1:RoomMode", &a->_ns1__Entity::RoomMode, ""))
				{	soap_flag_RoomMode1--;
					continue;
				}
			if (soap_flag_canControl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns1:canControl", &a->_ns1__Entity::canControl, "xsd:boolean"))
				{	soap_flag_canControl1--;
					continue;
				}
			if (soap_flag_audio1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns1:audio", &a->_ns1__Entity::audio, "xsd:boolean"))
				{	soap_flag_audio1--;
					continue;
				}
			if (soap_flag_video1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns1:video", &a->_ns1__Entity::video, "xsd:boolean"))
				{	soap_flag_video1--;
					continue;
				}
			if (soap_flag_appshare1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns1:appshare", &a->_ns1__Entity::appshare, "xsd:boolean"))
				{	soap_flag_appshare1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_entityID1 > 0 || soap_flag_EntityType1 > 0 || soap_flag_displayName1 > 0 || soap_flag_extension1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__Entity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__Entity, SOAP_TYPE__ns1__Entity, sizeof(_ns1__Entity), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__Entity * SOAP_FMAC2 soap_instantiate__ns1__Entity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__Entity(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__Entity *p;
	size_t k = sizeof(_ns1__Entity);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__Entity);
		if (p)
			((_ns1__Entity*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__Entity, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__Entity*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__Entity location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__Entity, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__Entity::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:Entity", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__Entity::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__Entity(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__Entity * SOAP_FMAC4 soap_get__ns1__Entity(struct soap *soap, _ns1__Entity *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Entity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__Filter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__Filter::start = NULL;
	this->_ns1__Filter::limit = NULL;
	soap_default_string(soap, &this->_ns1__Filter::sortBy);
	this->_ns1__Filter::dir = NULL;
	this->_ns1__Filter::EntityType = NULL;
	soap_default_string(soap, &this->_ns1__Filter::query);
	/* transient soap skipped */
}

void _ns1__Filter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &this->_ns1__Filter::start);
	soap_serialize_PointerToint(soap, &this->_ns1__Filter::limit);
	soap_serialize_string(soap, (char*const*)&this->_ns1__Filter::sortBy);
	soap_serialize_PointerTons1__sortDir(soap, &this->_ns1__Filter::dir);
	soap_serialize_PointerTo_ns1__EntityType(soap, &this->_ns1__Filter::EntityType);
	soap_serialize_string(soap, (char*const*)&this->_ns1__Filter::query);
#endif
}

int _ns1__Filter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__Filter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Filter(struct soap *soap, const char *tag, int id, const _ns1__Filter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__Filter), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:start", -1, &a->_ns1__Filter::start, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:limit", -1, &a->_ns1__Filter::limit, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:sortBy", -1, (char*const*)&a->_ns1__Filter::sortBy, ""))
		return soap->error;
	if (soap_out_PointerTons1__sortDir(soap, "ns1:dir", -1, &a->_ns1__Filter::dir, ""))
		return soap->error;
	if (soap_out_PointerTo_ns1__EntityType(soap, "ns1:EntityType", -1, &a->_ns1__Filter::EntityType, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:query", -1, (char*const*)&a->_ns1__Filter::query, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__Filter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__Filter(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__Filter * SOAP_FMAC4 soap_in__ns1__Filter(struct soap *soap, const char *tag, _ns1__Filter *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__Filter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__Filter, sizeof(_ns1__Filter), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_start1 = 1;
	size_t soap_flag_limit1 = 1;
	size_t soap_flag_sortBy1 = 1;
	size_t soap_flag_dir1 = 1;
	size_t soap_flag_EntityType1 = 1;
	size_t soap_flag_query1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_start1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:start", &a->_ns1__Filter::start, "xsd:int"))
				{	soap_flag_start1--;
					continue;
				}
			if (soap_flag_limit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:limit", &a->_ns1__Filter::limit, "xsd:int"))
				{	soap_flag_limit1--;
					continue;
				}
			if (soap_flag_sortBy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sortBy", (char**)&a->_ns1__Filter::sortBy, "xsd:string"))
				{	soap_flag_sortBy1--;
					continue;
				}
			if (soap_flag_dir1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__sortDir(soap, "ns1:dir", &a->_ns1__Filter::dir, "ns1:sortDir"))
				{	soap_flag_dir1--;
					continue;
				}
			if (soap_flag_EntityType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__EntityType(soap, "ns1:EntityType", &a->_ns1__Filter::EntityType, "ns1:EntityType"))
				{	soap_flag_EntityType1--;
					continue;
				}
			if (soap_flag_query1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:query", (char**)&a->_ns1__Filter::query, "xsd:string"))
				{	soap_flag_query1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__Filter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__Filter, SOAP_TYPE__ns1__Filter, sizeof(_ns1__Filter), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__Filter * SOAP_FMAC2 soap_instantiate__ns1__Filter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__Filter(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__Filter *p;
	size_t k = sizeof(_ns1__Filter);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__Filter);
		if (p)
			((_ns1__Filter*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__Filter, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__Filter*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__Filter location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__Filter, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__Filter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:Filter", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__Filter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__Filter(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__Filter * SOAP_FMAC4 soap_get__ns1__Filter(struct soap *soap, _ns1__Filter *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Filter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__RoomMode::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__RoomMode::roomURL);
	soap_default_bool(soap, &this->_ns1__RoomMode::isLocked);
	soap_default_bool(soap, &this->_ns1__RoomMode::hasPIN);
	soap_default_string(soap, &this->_ns1__RoomMode::roomPIN);
	this->_ns1__RoomMode::hasModeratorPIN = NULL;
	soap_default_string(soap, &this->_ns1__RoomMode::moderatorPIN);
	/* transient soap skipped */
}

void _ns1__RoomMode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__RoomMode::roomURL);
	soap_embedded(soap, &this->_ns1__RoomMode::isLocked, SOAP_TYPE_bool);
	soap_embedded(soap, &this->_ns1__RoomMode::hasPIN, SOAP_TYPE_bool);
	soap_serialize_string(soap, (char*const*)&this->_ns1__RoomMode::roomPIN);
	soap_serialize_PointerTobool(soap, &this->_ns1__RoomMode::hasModeratorPIN);
	soap_serialize_string(soap, (char*const*)&this->_ns1__RoomMode::moderatorPIN);
#endif
}

int _ns1__RoomMode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RoomMode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RoomMode(struct soap *soap, const char *tag, int id, const _ns1__RoomMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RoomMode), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:roomURL", -1, (char*const*)&a->_ns1__RoomMode::roomURL, ""))
		return soap->error;
	if (soap_out_bool(soap, "ns1:isLocked", -1, &a->_ns1__RoomMode::isLocked, ""))
		return soap->error;
	if (soap_out_bool(soap, "ns1:hasPIN", -1, &a->_ns1__RoomMode::hasPIN, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:roomPIN", -1, (char*const*)&a->_ns1__RoomMode::roomPIN, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:hasModeratorPIN", -1, &a->_ns1__RoomMode::hasModeratorPIN, ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:moderatorPIN", -1, (char*const*)&a->_ns1__RoomMode::moderatorPIN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__RoomMode::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RoomMode(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RoomMode * SOAP_FMAC4 soap_in__ns1__RoomMode(struct soap *soap, const char *tag, _ns1__RoomMode *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RoomMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RoomMode, sizeof(_ns1__RoomMode), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_roomURL1 = 1;
	size_t soap_flag_isLocked1 = 1;
	size_t soap_flag_hasPIN1 = 1;
	size_t soap_flag_roomPIN1 = 1;
	size_t soap_flag_hasModeratorPIN1 = 1;
	size_t soap_flag_moderatorPIN1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_roomURL1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:roomURL", (char**)&a->_ns1__RoomMode::roomURL, "xsd:string"))
				{	soap_flag_roomURL1--;
					continue;
				}
			if (soap_flag_isLocked1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:isLocked", &a->_ns1__RoomMode::isLocked, "xsd:boolean"))
				{	soap_flag_isLocked1--;
					continue;
				}
			if (soap_flag_hasPIN1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:hasPIN", &a->_ns1__RoomMode::hasPIN, "xsd:boolean"))
				{	soap_flag_hasPIN1--;
					continue;
				}
			if (soap_flag_roomPIN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:roomPIN", (char**)&a->_ns1__RoomMode::roomPIN, "xsd:string"))
				{	soap_flag_roomPIN1--;
					continue;
				}
			if (soap_flag_hasModeratorPIN1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns1:hasModeratorPIN", &a->_ns1__RoomMode::hasModeratorPIN, "xsd:boolean"))
				{	soap_flag_hasModeratorPIN1--;
					continue;
				}
			if (soap_flag_moderatorPIN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:moderatorPIN", (char**)&a->_ns1__RoomMode::moderatorPIN, "xsd:string"))
				{	soap_flag_moderatorPIN1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_isLocked1 > 0 || soap_flag_hasPIN1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__RoomMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RoomMode, SOAP_TYPE__ns1__RoomMode, sizeof(_ns1__RoomMode), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__RoomMode * SOAP_FMAC2 soap_instantiate__ns1__RoomMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RoomMode(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__RoomMode *p;
	size_t k = sizeof(_ns1__RoomMode);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__RoomMode);
		if (p)
			((_ns1__RoomMode*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__RoomMode, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__RoomMode*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__RoomMode location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__RoomMode, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__RoomMode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:RoomMode", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RoomMode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RoomMode(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RoomMode * SOAP_FMAC4 soap_get__ns1__RoomMode(struct soap *soap, _ns1__RoomMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RoomMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__RoomNotFoundFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__RoomNotFoundFault::ErrorMessage);
	/* transient soap skipped */
}

void _ns1__RoomNotFoundFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__RoomNotFoundFault::ErrorMessage);
#endif
}

int _ns1__RoomNotFoundFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RoomNotFoundFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RoomNotFoundFault(struct soap *soap, const char *tag, int id, const _ns1__RoomNotFoundFault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RoomNotFoundFault), type))
		return soap->error;
	if (!a->_ns1__RoomNotFoundFault::ErrorMessage)
	{	if (soap_element_nil(soap, "ns1:ErrorMessage"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:ErrorMessage", -1, (char*const*)&a->_ns1__RoomNotFoundFault::ErrorMessage, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__RoomNotFoundFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RoomNotFoundFault(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RoomNotFoundFault * SOAP_FMAC4 soap_in__ns1__RoomNotFoundFault(struct soap *soap, const char *tag, _ns1__RoomNotFoundFault *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RoomNotFoundFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RoomNotFoundFault, sizeof(_ns1__RoomNotFoundFault), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ErrorMessage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ErrorMessage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ErrorMessage", (char**)&a->_ns1__RoomNotFoundFault::ErrorMessage, "xsd:string"))
				{	soap_flag_ErrorMessage1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ErrorMessage1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__RoomNotFoundFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RoomNotFoundFault, SOAP_TYPE__ns1__RoomNotFoundFault, sizeof(_ns1__RoomNotFoundFault), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__RoomNotFoundFault * SOAP_FMAC2 soap_instantiate__ns1__RoomNotFoundFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RoomNotFoundFault(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__RoomNotFoundFault *p;
	size_t k = sizeof(_ns1__RoomNotFoundFault);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__RoomNotFoundFault);
		if (p)
			((_ns1__RoomNotFoundFault*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__RoomNotFoundFault, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__RoomNotFoundFault*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__RoomNotFoundFault location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__RoomNotFoundFault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__RoomNotFoundFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:RoomNotFoundFault", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RoomNotFoundFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RoomNotFoundFault(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RoomNotFoundFault * SOAP_FMAC4 soap_get__ns1__RoomNotFoundFault(struct soap *soap, _ns1__RoomNotFoundFault *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RoomNotFoundFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__VidyoReplayNotAvailableFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__VidyoReplayNotAvailableFault::ErrorMessage);
	/* transient soap skipped */
}

void _ns1__VidyoReplayNotAvailableFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__VidyoReplayNotAvailableFault::ErrorMessage);
#endif
}

int _ns1__VidyoReplayNotAvailableFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__VidyoReplayNotAvailableFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__VidyoReplayNotAvailableFault(struct soap *soap, const char *tag, int id, const _ns1__VidyoReplayNotAvailableFault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__VidyoReplayNotAvailableFault), type))
		return soap->error;
	if (!a->_ns1__VidyoReplayNotAvailableFault::ErrorMessage)
	{	if (soap_element_nil(soap, "ns1:ErrorMessage"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:ErrorMessage", -1, (char*const*)&a->_ns1__VidyoReplayNotAvailableFault::ErrorMessage, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__VidyoReplayNotAvailableFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__VidyoReplayNotAvailableFault(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__VidyoReplayNotAvailableFault * SOAP_FMAC4 soap_in__ns1__VidyoReplayNotAvailableFault(struct soap *soap, const char *tag, _ns1__VidyoReplayNotAvailableFault *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__VidyoReplayNotAvailableFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__VidyoReplayNotAvailableFault, sizeof(_ns1__VidyoReplayNotAvailableFault), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ErrorMessage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ErrorMessage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ErrorMessage", (char**)&a->_ns1__VidyoReplayNotAvailableFault::ErrorMessage, "xsd:string"))
				{	soap_flag_ErrorMessage1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ErrorMessage1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__VidyoReplayNotAvailableFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__VidyoReplayNotAvailableFault, SOAP_TYPE__ns1__VidyoReplayNotAvailableFault, sizeof(_ns1__VidyoReplayNotAvailableFault), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__VidyoReplayNotAvailableFault * SOAP_FMAC2 soap_instantiate__ns1__VidyoReplayNotAvailableFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__VidyoReplayNotAvailableFault(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__VidyoReplayNotAvailableFault *p;
	size_t k = sizeof(_ns1__VidyoReplayNotAvailableFault);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__VidyoReplayNotAvailableFault);
		if (p)
			((_ns1__VidyoReplayNotAvailableFault*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__VidyoReplayNotAvailableFault, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__VidyoReplayNotAvailableFault*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__VidyoReplayNotAvailableFault location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__VidyoReplayNotAvailableFault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__VidyoReplayNotAvailableFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:VidyoReplayNotAvailableFault", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__VidyoReplayNotAvailableFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__VidyoReplayNotAvailableFault(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__VidyoReplayNotAvailableFault * SOAP_FMAC4 soap_get__ns1__VidyoReplayNotAvailableFault(struct soap *soap, _ns1__VidyoReplayNotAvailableFault *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__VidyoReplayNotAvailableFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__FeatureNotAvailableFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__FeatureNotAvailableFault::ErrorMessage);
	/* transient soap skipped */
}

void _ns1__FeatureNotAvailableFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__FeatureNotAvailableFault::ErrorMessage);
#endif
}

int _ns1__FeatureNotAvailableFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__FeatureNotAvailableFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__FeatureNotAvailableFault(struct soap *soap, const char *tag, int id, const _ns1__FeatureNotAvailableFault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__FeatureNotAvailableFault), type))
		return soap->error;
	if (!a->_ns1__FeatureNotAvailableFault::ErrorMessage)
	{	if (soap_element_nil(soap, "ns1:ErrorMessage"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:ErrorMessage", -1, (char*const*)&a->_ns1__FeatureNotAvailableFault::ErrorMessage, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__FeatureNotAvailableFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__FeatureNotAvailableFault(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__FeatureNotAvailableFault * SOAP_FMAC4 soap_in__ns1__FeatureNotAvailableFault(struct soap *soap, const char *tag, _ns1__FeatureNotAvailableFault *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__FeatureNotAvailableFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__FeatureNotAvailableFault, sizeof(_ns1__FeatureNotAvailableFault), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ErrorMessage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ErrorMessage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ErrorMessage", (char**)&a->_ns1__FeatureNotAvailableFault::ErrorMessage, "xsd:string"))
				{	soap_flag_ErrorMessage1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ErrorMessage1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__FeatureNotAvailableFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__FeatureNotAvailableFault, SOAP_TYPE__ns1__FeatureNotAvailableFault, sizeof(_ns1__FeatureNotAvailableFault), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__FeatureNotAvailableFault * SOAP_FMAC2 soap_instantiate__ns1__FeatureNotAvailableFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__FeatureNotAvailableFault(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__FeatureNotAvailableFault *p;
	size_t k = sizeof(_ns1__FeatureNotAvailableFault);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__FeatureNotAvailableFault);
		if (p)
			((_ns1__FeatureNotAvailableFault*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__FeatureNotAvailableFault, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__FeatureNotAvailableFault*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__FeatureNotAvailableFault location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__FeatureNotAvailableFault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__FeatureNotAvailableFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:FeatureNotAvailableFault", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__FeatureNotAvailableFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__FeatureNotAvailableFault(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__FeatureNotAvailableFault * SOAP_FMAC4 soap_get__ns1__FeatureNotAvailableFault(struct soap *soap, _ns1__FeatureNotAvailableFault *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__FeatureNotAvailableFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__PrefixNotConfiguredException::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__PrefixNotConfiguredException::ErrorMessage);
	/* transient soap skipped */
}

void _ns1__PrefixNotConfiguredException::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__PrefixNotConfiguredException::ErrorMessage);
#endif
}

int _ns1__PrefixNotConfiguredException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__PrefixNotConfiguredException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__PrefixNotConfiguredException(struct soap *soap, const char *tag, int id, const _ns1__PrefixNotConfiguredException *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__PrefixNotConfiguredException), type))
		return soap->error;
	if (!a->_ns1__PrefixNotConfiguredException::ErrorMessage)
	{	if (soap_element_nil(soap, "ns1:ErrorMessage"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:ErrorMessage", -1, (char*const*)&a->_ns1__PrefixNotConfiguredException::ErrorMessage, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__PrefixNotConfiguredException::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__PrefixNotConfiguredException(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__PrefixNotConfiguredException * SOAP_FMAC4 soap_in__ns1__PrefixNotConfiguredException(struct soap *soap, const char *tag, _ns1__PrefixNotConfiguredException *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__PrefixNotConfiguredException *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__PrefixNotConfiguredException, sizeof(_ns1__PrefixNotConfiguredException), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ErrorMessage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ErrorMessage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ErrorMessage", (char**)&a->_ns1__PrefixNotConfiguredException::ErrorMessage, "xsd:string"))
				{	soap_flag_ErrorMessage1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ErrorMessage1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__PrefixNotConfiguredException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__PrefixNotConfiguredException, SOAP_TYPE__ns1__PrefixNotConfiguredException, sizeof(_ns1__PrefixNotConfiguredException), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__PrefixNotConfiguredException * SOAP_FMAC2 soap_instantiate__ns1__PrefixNotConfiguredException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__PrefixNotConfiguredException(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__PrefixNotConfiguredException *p;
	size_t k = sizeof(_ns1__PrefixNotConfiguredException);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__PrefixNotConfiguredException);
		if (p)
			((_ns1__PrefixNotConfiguredException*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__PrefixNotConfiguredException, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__PrefixNotConfiguredException*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__PrefixNotConfiguredException location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__PrefixNotConfiguredException, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__PrefixNotConfiguredException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:PrefixNotConfiguredException", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__PrefixNotConfiguredException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__PrefixNotConfiguredException(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__PrefixNotConfiguredException * SOAP_FMAC4 soap_get__ns1__PrefixNotConfiguredException(struct soap *soap, _ns1__PrefixNotConfiguredException *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__PrefixNotConfiguredException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InPointToPointCallFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__InPointToPointCallFault::ErrorMessage);
	/* transient soap skipped */
}

void _ns1__InPointToPointCallFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__InPointToPointCallFault::ErrorMessage);
#endif
}

int _ns1__InPointToPointCallFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InPointToPointCallFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InPointToPointCallFault(struct soap *soap, const char *tag, int id, const _ns1__InPointToPointCallFault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InPointToPointCallFault), type))
		return soap->error;
	if (!a->_ns1__InPointToPointCallFault::ErrorMessage)
	{	if (soap_element_nil(soap, "ns1:ErrorMessage"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:ErrorMessage", -1, (char*const*)&a->_ns1__InPointToPointCallFault::ErrorMessage, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InPointToPointCallFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InPointToPointCallFault(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InPointToPointCallFault * SOAP_FMAC4 soap_in__ns1__InPointToPointCallFault(struct soap *soap, const char *tag, _ns1__InPointToPointCallFault *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InPointToPointCallFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InPointToPointCallFault, sizeof(_ns1__InPointToPointCallFault), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ErrorMessage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ErrorMessage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ErrorMessage", (char**)&a->_ns1__InPointToPointCallFault::ErrorMessage, "xsd:string"))
				{	soap_flag_ErrorMessage1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ErrorMessage1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__InPointToPointCallFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InPointToPointCallFault, SOAP_TYPE__ns1__InPointToPointCallFault, sizeof(_ns1__InPointToPointCallFault), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InPointToPointCallFault * SOAP_FMAC2 soap_instantiate__ns1__InPointToPointCallFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InPointToPointCallFault(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InPointToPointCallFault *p;
	size_t k = sizeof(_ns1__InPointToPointCallFault);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InPointToPointCallFault);
		if (p)
			((_ns1__InPointToPointCallFault*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InPointToPointCallFault, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InPointToPointCallFault*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InPointToPointCallFault location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InPointToPointCallFault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InPointToPointCallFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:InPointToPointCallFault", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InPointToPointCallFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InPointToPointCallFault(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InPointToPointCallFault * SOAP_FMAC4 soap_get__ns1__InPointToPointCallFault(struct soap *soap, _ns1__InPointToPointCallFault *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InPointToPointCallFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__EndpointNotBoundFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__EndpointNotBoundFault::ErrorMessage);
	/* transient soap skipped */
}

void _ns1__EndpointNotBoundFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__EndpointNotBoundFault::ErrorMessage);
#endif
}

int _ns1__EndpointNotBoundFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__EndpointNotBoundFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__EndpointNotBoundFault(struct soap *soap, const char *tag, int id, const _ns1__EndpointNotBoundFault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__EndpointNotBoundFault), type))
		return soap->error;
	if (!a->_ns1__EndpointNotBoundFault::ErrorMessage)
	{	if (soap_element_nil(soap, "ns1:ErrorMessage"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:ErrorMessage", -1, (char*const*)&a->_ns1__EndpointNotBoundFault::ErrorMessage, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__EndpointNotBoundFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__EndpointNotBoundFault(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__EndpointNotBoundFault * SOAP_FMAC4 soap_in__ns1__EndpointNotBoundFault(struct soap *soap, const char *tag, _ns1__EndpointNotBoundFault *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__EndpointNotBoundFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__EndpointNotBoundFault, sizeof(_ns1__EndpointNotBoundFault), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ErrorMessage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ErrorMessage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ErrorMessage", (char**)&a->_ns1__EndpointNotBoundFault::ErrorMessage, "xsd:string"))
				{	soap_flag_ErrorMessage1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ErrorMessage1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__EndpointNotBoundFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__EndpointNotBoundFault, SOAP_TYPE__ns1__EndpointNotBoundFault, sizeof(_ns1__EndpointNotBoundFault), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__EndpointNotBoundFault * SOAP_FMAC2 soap_instantiate__ns1__EndpointNotBoundFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__EndpointNotBoundFault(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__EndpointNotBoundFault *p;
	size_t k = sizeof(_ns1__EndpointNotBoundFault);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__EndpointNotBoundFault);
		if (p)
			((_ns1__EndpointNotBoundFault*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__EndpointNotBoundFault, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__EndpointNotBoundFault*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__EndpointNotBoundFault location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__EndpointNotBoundFault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__EndpointNotBoundFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:EndpointNotBoundFault", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__EndpointNotBoundFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__EndpointNotBoundFault(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__EndpointNotBoundFault * SOAP_FMAC4 soap_get__ns1__EndpointNotBoundFault(struct soap *soap, _ns1__EndpointNotBoundFault *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__EndpointNotBoundFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ScheduledRoomCreationFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__ScheduledRoomCreationFault::ErrorMessage);
	/* transient soap skipped */
}

void _ns1__ScheduledRoomCreationFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__ScheduledRoomCreationFault::ErrorMessage);
#endif
}

int _ns1__ScheduledRoomCreationFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ScheduledRoomCreationFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ScheduledRoomCreationFault(struct soap *soap, const char *tag, int id, const _ns1__ScheduledRoomCreationFault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ScheduledRoomCreationFault), type))
		return soap->error;
	if (!a->_ns1__ScheduledRoomCreationFault::ErrorMessage)
	{	if (soap_element_nil(soap, "ns1:ErrorMessage"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:ErrorMessage", -1, (char*const*)&a->_ns1__ScheduledRoomCreationFault::ErrorMessage, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ScheduledRoomCreationFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ScheduledRoomCreationFault(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ScheduledRoomCreationFault * SOAP_FMAC4 soap_in__ns1__ScheduledRoomCreationFault(struct soap *soap, const char *tag, _ns1__ScheduledRoomCreationFault *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ScheduledRoomCreationFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ScheduledRoomCreationFault, sizeof(_ns1__ScheduledRoomCreationFault), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ErrorMessage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ErrorMessage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ErrorMessage", (char**)&a->_ns1__ScheduledRoomCreationFault::ErrorMessage, "xsd:string"))
				{	soap_flag_ErrorMessage1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ErrorMessage1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__ScheduledRoomCreationFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ScheduledRoomCreationFault, SOAP_TYPE__ns1__ScheduledRoomCreationFault, sizeof(_ns1__ScheduledRoomCreationFault), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ScheduledRoomCreationFault * SOAP_FMAC2 soap_instantiate__ns1__ScheduledRoomCreationFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ScheduledRoomCreationFault(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ScheduledRoomCreationFault *p;
	size_t k = sizeof(_ns1__ScheduledRoomCreationFault);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__ScheduledRoomCreationFault);
		if (p)
			((_ns1__ScheduledRoomCreationFault*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__ScheduledRoomCreationFault, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__ScheduledRoomCreationFault*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ScheduledRoomCreationFault location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__ScheduledRoomCreationFault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__ScheduledRoomCreationFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:ScheduledRoomCreationFault", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ScheduledRoomCreationFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ScheduledRoomCreationFault(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ScheduledRoomCreationFault * SOAP_FMAC4 soap_get__ns1__ScheduledRoomCreationFault(struct soap *soap, _ns1__ScheduledRoomCreationFault *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ScheduledRoomCreationFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ControlMeetingFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__ControlMeetingFault::ErrorMessage);
	/* transient soap skipped */
}

void _ns1__ControlMeetingFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__ControlMeetingFault::ErrorMessage);
#endif
}

int _ns1__ControlMeetingFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ControlMeetingFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ControlMeetingFault(struct soap *soap, const char *tag, int id, const _ns1__ControlMeetingFault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ControlMeetingFault), type))
		return soap->error;
	if (!a->_ns1__ControlMeetingFault::ErrorMessage)
	{	if (soap_element_nil(soap, "ns1:ErrorMessage"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:ErrorMessage", -1, (char*const*)&a->_ns1__ControlMeetingFault::ErrorMessage, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ControlMeetingFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ControlMeetingFault(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ControlMeetingFault * SOAP_FMAC4 soap_in__ns1__ControlMeetingFault(struct soap *soap, const char *tag, _ns1__ControlMeetingFault *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ControlMeetingFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ControlMeetingFault, sizeof(_ns1__ControlMeetingFault), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ErrorMessage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ErrorMessage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ErrorMessage", (char**)&a->_ns1__ControlMeetingFault::ErrorMessage, "xsd:string"))
				{	soap_flag_ErrorMessage1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ErrorMessage1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__ControlMeetingFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ControlMeetingFault, SOAP_TYPE__ns1__ControlMeetingFault, sizeof(_ns1__ControlMeetingFault), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ControlMeetingFault * SOAP_FMAC2 soap_instantiate__ns1__ControlMeetingFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ControlMeetingFault(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ControlMeetingFault *p;
	size_t k = sizeof(_ns1__ControlMeetingFault);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__ControlMeetingFault);
		if (p)
			((_ns1__ControlMeetingFault*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__ControlMeetingFault, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__ControlMeetingFault*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ControlMeetingFault location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__ControlMeetingFault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__ControlMeetingFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:ControlMeetingFault", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ControlMeetingFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ControlMeetingFault(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ControlMeetingFault * SOAP_FMAC4 soap_get__ns1__ControlMeetingFault(struct soap *soap, _ns1__ControlMeetingFault *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ControlMeetingFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InvalidModeratorPINFormatFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__InvalidModeratorPINFormatFault::ErrorMessage);
	/* transient soap skipped */
}

void _ns1__InvalidModeratorPINFormatFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__InvalidModeratorPINFormatFault::ErrorMessage);
#endif
}

int _ns1__InvalidModeratorPINFormatFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InvalidModeratorPINFormatFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InvalidModeratorPINFormatFault(struct soap *soap, const char *tag, int id, const _ns1__InvalidModeratorPINFormatFault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InvalidModeratorPINFormatFault), type))
		return soap->error;
	if (!a->_ns1__InvalidModeratorPINFormatFault::ErrorMessage)
	{	if (soap_element_nil(soap, "ns1:ErrorMessage"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:ErrorMessage", -1, (char*const*)&a->_ns1__InvalidModeratorPINFormatFault::ErrorMessage, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InvalidModeratorPINFormatFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InvalidModeratorPINFormatFault(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InvalidModeratorPINFormatFault * SOAP_FMAC4 soap_in__ns1__InvalidModeratorPINFormatFault(struct soap *soap, const char *tag, _ns1__InvalidModeratorPINFormatFault *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InvalidModeratorPINFormatFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InvalidModeratorPINFormatFault, sizeof(_ns1__InvalidModeratorPINFormatFault), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ErrorMessage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ErrorMessage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ErrorMessage", (char**)&a->_ns1__InvalidModeratorPINFormatFault::ErrorMessage, "xsd:string"))
				{	soap_flag_ErrorMessage1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ErrorMessage1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__InvalidModeratorPINFormatFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InvalidModeratorPINFormatFault, SOAP_TYPE__ns1__InvalidModeratorPINFormatFault, sizeof(_ns1__InvalidModeratorPINFormatFault), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InvalidModeratorPINFormatFault * SOAP_FMAC2 soap_instantiate__ns1__InvalidModeratorPINFormatFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InvalidModeratorPINFormatFault(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InvalidModeratorPINFormatFault *p;
	size_t k = sizeof(_ns1__InvalidModeratorPINFormatFault);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InvalidModeratorPINFormatFault);
		if (p)
			((_ns1__InvalidModeratorPINFormatFault*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InvalidModeratorPINFormatFault, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InvalidModeratorPINFormatFault*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InvalidModeratorPINFormatFault location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InvalidModeratorPINFormatFault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InvalidModeratorPINFormatFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:InvalidModeratorPINFormatFault", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InvalidModeratorPINFormatFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InvalidModeratorPINFormatFault(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InvalidModeratorPINFormatFault * SOAP_FMAC4 soap_get__ns1__InvalidModeratorPINFormatFault(struct soap *soap, _ns1__InvalidModeratorPINFormatFault *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InvalidModeratorPINFormatFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__AccessRestrictedFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__AccessRestrictedFault::ErrorMessage);
	/* transient soap skipped */
}

void _ns1__AccessRestrictedFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__AccessRestrictedFault::ErrorMessage);
#endif
}

int _ns1__AccessRestrictedFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__AccessRestrictedFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__AccessRestrictedFault(struct soap *soap, const char *tag, int id, const _ns1__AccessRestrictedFault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__AccessRestrictedFault), type))
		return soap->error;
	if (!a->_ns1__AccessRestrictedFault::ErrorMessage)
	{	if (soap_element_nil(soap, "ns1:ErrorMessage"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:ErrorMessage", -1, (char*const*)&a->_ns1__AccessRestrictedFault::ErrorMessage, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__AccessRestrictedFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__AccessRestrictedFault(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__AccessRestrictedFault * SOAP_FMAC4 soap_in__ns1__AccessRestrictedFault(struct soap *soap, const char *tag, _ns1__AccessRestrictedFault *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__AccessRestrictedFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__AccessRestrictedFault, sizeof(_ns1__AccessRestrictedFault), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ErrorMessage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ErrorMessage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ErrorMessage", (char**)&a->_ns1__AccessRestrictedFault::ErrorMessage, "xsd:string"))
				{	soap_flag_ErrorMessage1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ErrorMessage1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__AccessRestrictedFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__AccessRestrictedFault, SOAP_TYPE__ns1__AccessRestrictedFault, sizeof(_ns1__AccessRestrictedFault), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__AccessRestrictedFault * SOAP_FMAC2 soap_instantiate__ns1__AccessRestrictedFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__AccessRestrictedFault(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__AccessRestrictedFault *p;
	size_t k = sizeof(_ns1__AccessRestrictedFault);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__AccessRestrictedFault);
		if (p)
			((_ns1__AccessRestrictedFault*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__AccessRestrictedFault, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__AccessRestrictedFault*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__AccessRestrictedFault location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__AccessRestrictedFault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__AccessRestrictedFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:AccessRestrictedFault", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__AccessRestrictedFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__AccessRestrictedFault(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__AccessRestrictedFault * SOAP_FMAC4 soap_get__ns1__AccessRestrictedFault(struct soap *soap, _ns1__AccessRestrictedFault *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__AccessRestrictedFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ResourceNotAvailableFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__ResourceNotAvailableFault::ErrorMessage);
	/* transient soap skipped */
}

void _ns1__ResourceNotAvailableFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__ResourceNotAvailableFault::ErrorMessage);
#endif
}

int _ns1__ResourceNotAvailableFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ResourceNotAvailableFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ResourceNotAvailableFault(struct soap *soap, const char *tag, int id, const _ns1__ResourceNotAvailableFault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ResourceNotAvailableFault), type))
		return soap->error;
	if (!a->_ns1__ResourceNotAvailableFault::ErrorMessage)
	{	if (soap_element_nil(soap, "ns1:ErrorMessage"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:ErrorMessage", -1, (char*const*)&a->_ns1__ResourceNotAvailableFault::ErrorMessage, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ResourceNotAvailableFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ResourceNotAvailableFault(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ResourceNotAvailableFault * SOAP_FMAC4 soap_in__ns1__ResourceNotAvailableFault(struct soap *soap, const char *tag, _ns1__ResourceNotAvailableFault *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ResourceNotAvailableFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ResourceNotAvailableFault, sizeof(_ns1__ResourceNotAvailableFault), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ErrorMessage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ErrorMessage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ErrorMessage", (char**)&a->_ns1__ResourceNotAvailableFault::ErrorMessage, "xsd:string"))
				{	soap_flag_ErrorMessage1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ErrorMessage1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__ResourceNotAvailableFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ResourceNotAvailableFault, SOAP_TYPE__ns1__ResourceNotAvailableFault, sizeof(_ns1__ResourceNotAvailableFault), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ResourceNotAvailableFault * SOAP_FMAC2 soap_instantiate__ns1__ResourceNotAvailableFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ResourceNotAvailableFault(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ResourceNotAvailableFault *p;
	size_t k = sizeof(_ns1__ResourceNotAvailableFault);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__ResourceNotAvailableFault);
		if (p)
			((_ns1__ResourceNotAvailableFault*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__ResourceNotAvailableFault, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__ResourceNotAvailableFault*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ResourceNotAvailableFault location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__ResourceNotAvailableFault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__ResourceNotAvailableFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:ResourceNotAvailableFault", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ResourceNotAvailableFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ResourceNotAvailableFault(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ResourceNotAvailableFault * SOAP_FMAC4 soap_get__ns1__ResourceNotAvailableFault(struct soap *soap, _ns1__ResourceNotAvailableFault *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ResourceNotAvailableFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__NotLicensedFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__NotLicensedFault::ErrorMessage);
	/* transient soap skipped */
}

void _ns1__NotLicensedFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__NotLicensedFault::ErrorMessage);
#endif
}

int _ns1__NotLicensedFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__NotLicensedFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__NotLicensedFault(struct soap *soap, const char *tag, int id, const _ns1__NotLicensedFault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__NotLicensedFault), type))
		return soap->error;
	if (!a->_ns1__NotLicensedFault::ErrorMessage)
	{	if (soap_element_nil(soap, "ns1:ErrorMessage"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:ErrorMessage", -1, (char*const*)&a->_ns1__NotLicensedFault::ErrorMessage, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__NotLicensedFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__NotLicensedFault(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__NotLicensedFault * SOAP_FMAC4 soap_in__ns1__NotLicensedFault(struct soap *soap, const char *tag, _ns1__NotLicensedFault *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__NotLicensedFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__NotLicensedFault, sizeof(_ns1__NotLicensedFault), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ErrorMessage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ErrorMessage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ErrorMessage", (char**)&a->_ns1__NotLicensedFault::ErrorMessage, "xsd:string"))
				{	soap_flag_ErrorMessage1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ErrorMessage1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__NotLicensedFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__NotLicensedFault, SOAP_TYPE__ns1__NotLicensedFault, sizeof(_ns1__NotLicensedFault), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__NotLicensedFault * SOAP_FMAC2 soap_instantiate__ns1__NotLicensedFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__NotLicensedFault(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__NotLicensedFault *p;
	size_t k = sizeof(_ns1__NotLicensedFault);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__NotLicensedFault);
		if (p)
			((_ns1__NotLicensedFault*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__NotLicensedFault, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__NotLicensedFault*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__NotLicensedFault location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__NotLicensedFault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__NotLicensedFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:NotLicensedFault", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__NotLicensedFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__NotLicensedFault(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__NotLicensedFault * SOAP_FMAC4 soap_get__ns1__NotLicensedFault(struct soap *soap, _ns1__NotLicensedFault *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__NotLicensedFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ConferenceLockedFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__ConferenceLockedFault::ErrorMessage);
	/* transient soap skipped */
}

void _ns1__ConferenceLockedFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__ConferenceLockedFault::ErrorMessage);
#endif
}

int _ns1__ConferenceLockedFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ConferenceLockedFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ConferenceLockedFault(struct soap *soap, const char *tag, int id, const _ns1__ConferenceLockedFault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ConferenceLockedFault), type))
		return soap->error;
	if (!a->_ns1__ConferenceLockedFault::ErrorMessage)
	{	if (soap_element_nil(soap, "ns1:ErrorMessage"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:ErrorMessage", -1, (char*const*)&a->_ns1__ConferenceLockedFault::ErrorMessage, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ConferenceLockedFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ConferenceLockedFault(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ConferenceLockedFault * SOAP_FMAC4 soap_in__ns1__ConferenceLockedFault(struct soap *soap, const char *tag, _ns1__ConferenceLockedFault *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ConferenceLockedFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ConferenceLockedFault, sizeof(_ns1__ConferenceLockedFault), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ErrorMessage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ErrorMessage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ErrorMessage", (char**)&a->_ns1__ConferenceLockedFault::ErrorMessage, "xsd:string"))
				{	soap_flag_ErrorMessage1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ErrorMessage1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__ConferenceLockedFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ConferenceLockedFault, SOAP_TYPE__ns1__ConferenceLockedFault, sizeof(_ns1__ConferenceLockedFault), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ConferenceLockedFault * SOAP_FMAC2 soap_instantiate__ns1__ConferenceLockedFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ConferenceLockedFault(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ConferenceLockedFault *p;
	size_t k = sizeof(_ns1__ConferenceLockedFault);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__ConferenceLockedFault);
		if (p)
			((_ns1__ConferenceLockedFault*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__ConferenceLockedFault, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__ConferenceLockedFault*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ConferenceLockedFault location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__ConferenceLockedFault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__ConferenceLockedFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:ConferenceLockedFault", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ConferenceLockedFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ConferenceLockedFault(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ConferenceLockedFault * SOAP_FMAC4 soap_get__ns1__ConferenceLockedFault(struct soap *soap, _ns1__ConferenceLockedFault *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ConferenceLockedFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__WrongPINFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__WrongPINFault::ErrorMessage);
	/* transient soap skipped */
}

void _ns1__WrongPINFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__WrongPINFault::ErrorMessage);
#endif
}

int _ns1__WrongPINFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__WrongPINFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__WrongPINFault(struct soap *soap, const char *tag, int id, const _ns1__WrongPINFault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__WrongPINFault), type))
		return soap->error;
	if (!a->_ns1__WrongPINFault::ErrorMessage)
	{	if (soap_element_nil(soap, "ns1:ErrorMessage"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:ErrorMessage", -1, (char*const*)&a->_ns1__WrongPINFault::ErrorMessage, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__WrongPINFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__WrongPINFault(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__WrongPINFault * SOAP_FMAC4 soap_in__ns1__WrongPINFault(struct soap *soap, const char *tag, _ns1__WrongPINFault *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__WrongPINFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__WrongPINFault, sizeof(_ns1__WrongPINFault), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ErrorMessage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ErrorMessage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ErrorMessage", (char**)&a->_ns1__WrongPINFault::ErrorMessage, "xsd:string"))
				{	soap_flag_ErrorMessage1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ErrorMessage1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__WrongPINFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__WrongPINFault, SOAP_TYPE__ns1__WrongPINFault, sizeof(_ns1__WrongPINFault), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__WrongPINFault * SOAP_FMAC2 soap_instantiate__ns1__WrongPINFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__WrongPINFault(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__WrongPINFault *p;
	size_t k = sizeof(_ns1__WrongPINFault);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__WrongPINFault);
		if (p)
			((_ns1__WrongPINFault*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__WrongPINFault, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__WrongPINFault*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__WrongPINFault location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__WrongPINFault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__WrongPINFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:WrongPINFault", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__WrongPINFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__WrongPINFault(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__WrongPINFault * SOAP_FMAC4 soap_get__ns1__WrongPINFault(struct soap *soap, _ns1__WrongPINFault *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__WrongPINFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SeatLicenseExpiredFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__SeatLicenseExpiredFault::ErrorMessage);
	/* transient soap skipped */
}

void _ns1__SeatLicenseExpiredFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__SeatLicenseExpiredFault::ErrorMessage);
#endif
}

int _ns1__SeatLicenseExpiredFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SeatLicenseExpiredFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SeatLicenseExpiredFault(struct soap *soap, const char *tag, int id, const _ns1__SeatLicenseExpiredFault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SeatLicenseExpiredFault), type))
		return soap->error;
	if (!a->_ns1__SeatLicenseExpiredFault::ErrorMessage)
	{	if (soap_element_nil(soap, "ns1:ErrorMessage"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:ErrorMessage", -1, (char*const*)&a->_ns1__SeatLicenseExpiredFault::ErrorMessage, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SeatLicenseExpiredFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SeatLicenseExpiredFault(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SeatLicenseExpiredFault * SOAP_FMAC4 soap_in__ns1__SeatLicenseExpiredFault(struct soap *soap, const char *tag, _ns1__SeatLicenseExpiredFault *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SeatLicenseExpiredFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SeatLicenseExpiredFault, sizeof(_ns1__SeatLicenseExpiredFault), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ErrorMessage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ErrorMessage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ErrorMessage", (char**)&a->_ns1__SeatLicenseExpiredFault::ErrorMessage, "xsd:string"))
				{	soap_flag_ErrorMessage1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ErrorMessage1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__SeatLicenseExpiredFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SeatLicenseExpiredFault, SOAP_TYPE__ns1__SeatLicenseExpiredFault, sizeof(_ns1__SeatLicenseExpiredFault), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SeatLicenseExpiredFault * SOAP_FMAC2 soap_instantiate__ns1__SeatLicenseExpiredFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SeatLicenseExpiredFault(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SeatLicenseExpiredFault *p;
	size_t k = sizeof(_ns1__SeatLicenseExpiredFault);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__SeatLicenseExpiredFault);
		if (p)
			((_ns1__SeatLicenseExpiredFault*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__SeatLicenseExpiredFault, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__SeatLicenseExpiredFault*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SeatLicenseExpiredFault location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__SeatLicenseExpiredFault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__SeatLicenseExpiredFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:SeatLicenseExpiredFault", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SeatLicenseExpiredFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SeatLicenseExpiredFault(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SeatLicenseExpiredFault * SOAP_FMAC4 soap_get__ns1__SeatLicenseExpiredFault(struct soap *soap, _ns1__SeatLicenseExpiredFault *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SeatLicenseExpiredFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__InvalidArgumentFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__InvalidArgumentFault::ErrorMessage);
	/* transient soap skipped */
}

void _ns1__InvalidArgumentFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__InvalidArgumentFault::ErrorMessage);
#endif
}

int _ns1__InvalidArgumentFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InvalidArgumentFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InvalidArgumentFault(struct soap *soap, const char *tag, int id, const _ns1__InvalidArgumentFault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InvalidArgumentFault), type))
		return soap->error;
	if (!a->_ns1__InvalidArgumentFault::ErrorMessage)
	{	if (soap_element_nil(soap, "ns1:ErrorMessage"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:ErrorMessage", -1, (char*const*)&a->_ns1__InvalidArgumentFault::ErrorMessage, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__InvalidArgumentFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InvalidArgumentFault(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InvalidArgumentFault * SOAP_FMAC4 soap_in__ns1__InvalidArgumentFault(struct soap *soap, const char *tag, _ns1__InvalidArgumentFault *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InvalidArgumentFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InvalidArgumentFault, sizeof(_ns1__InvalidArgumentFault), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ErrorMessage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ErrorMessage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ErrorMessage", (char**)&a->_ns1__InvalidArgumentFault::ErrorMessage, "xsd:string"))
				{	soap_flag_ErrorMessage1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ErrorMessage1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__InvalidArgumentFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InvalidArgumentFault, SOAP_TYPE__ns1__InvalidArgumentFault, sizeof(_ns1__InvalidArgumentFault), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__InvalidArgumentFault * SOAP_FMAC2 soap_instantiate__ns1__InvalidArgumentFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InvalidArgumentFault(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__InvalidArgumentFault *p;
	size_t k = sizeof(_ns1__InvalidArgumentFault);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__InvalidArgumentFault);
		if (p)
			((_ns1__InvalidArgumentFault*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__InvalidArgumentFault, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__InvalidArgumentFault*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__InvalidArgumentFault location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__InvalidArgumentFault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__InvalidArgumentFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:InvalidArgumentFault", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InvalidArgumentFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InvalidArgumentFault(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InvalidArgumentFault * SOAP_FMAC4 soap_get__ns1__InvalidArgumentFault(struct soap *soap, _ns1__InvalidArgumentFault *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InvalidArgumentFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GeneralFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GeneralFault::ErrorMessage);
	/* transient soap skipped */
}

void _ns1__GeneralFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->_ns1__GeneralFault::ErrorMessage);
#endif
}

int _ns1__GeneralFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GeneralFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GeneralFault(struct soap *soap, const char *tag, int id, const _ns1__GeneralFault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GeneralFault), type))
		return soap->error;
	if (!a->_ns1__GeneralFault::ErrorMessage)
	{	if (soap_element_nil(soap, "ns1:ErrorMessage"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:ErrorMessage", -1, (char*const*)&a->_ns1__GeneralFault::ErrorMessage, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GeneralFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GeneralFault(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GeneralFault * SOAP_FMAC4 soap_in__ns1__GeneralFault(struct soap *soap, const char *tag, _ns1__GeneralFault *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GeneralFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GeneralFault, sizeof(_ns1__GeneralFault), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ErrorMessage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ErrorMessage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ErrorMessage", (char**)&a->_ns1__GeneralFault::ErrorMessage, "xsd:string"))
				{	soap_flag_ErrorMessage1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ErrorMessage1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GeneralFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GeneralFault, SOAP_TYPE__ns1__GeneralFault, sizeof(_ns1__GeneralFault), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GeneralFault * SOAP_FMAC2 soap_instantiate__ns1__GeneralFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GeneralFault(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GeneralFault *p;
	size_t k = sizeof(_ns1__GeneralFault);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GeneralFault);
		if (p)
			((_ns1__GeneralFault*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GeneralFault, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GeneralFault*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GeneralFault location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GeneralFault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GeneralFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:GeneralFault", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GeneralFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GeneralFault(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GeneralFault * SOAP_FMAC4 soap_get__ns1__GeneralFault(struct soap *soap, _ns1__GeneralFault *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GeneralFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__RoomProfile::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__RoomProfile::roomProfileName);
	soap_default_string(soap, &this->ns1__RoomProfile::description);
	/* transient soap skipped */
}

void ns1__RoomProfile::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->ns1__RoomProfile::roomProfileName);
	soap_serialize_string(soap, (char*const*)&this->ns1__RoomProfile::description);
#endif
}

int ns1__RoomProfile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RoomProfile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RoomProfile(struct soap *soap, const char *tag, int id, const ns1__RoomProfile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RoomProfile), type))
		return soap->error;
	if (!a->ns1__RoomProfile::roomProfileName)
	{	if (soap_element_nil(soap, "ns1:roomProfileName"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:roomProfileName", -1, (char*const*)&a->ns1__RoomProfile::roomProfileName, ""))
		return soap->error;
	if (!a->ns1__RoomProfile::description)
	{	if (soap_element_nil(soap, "ns1:description"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:description", -1, (char*const*)&a->ns1__RoomProfile::description, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RoomProfile::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__RoomProfile(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RoomProfile * SOAP_FMAC4 soap_in_ns1__RoomProfile(struct soap *soap, const char *tag, ns1__RoomProfile *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RoomProfile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RoomProfile, sizeof(ns1__RoomProfile), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_roomProfileName1 = 1;
	size_t soap_flag_description1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_roomProfileName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:roomProfileName", (char**)&a->ns1__RoomProfile::roomProfileName, "xsd:string"))
				{	soap_flag_roomProfileName1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:description", (char**)&a->ns1__RoomProfile::description, "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_roomProfileName1 > 0 || soap_flag_description1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__RoomProfile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RoomProfile, SOAP_TYPE_ns1__RoomProfile, sizeof(ns1__RoomProfile), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__RoomProfile * SOAP_FMAC2 soap_instantiate_ns1__RoomProfile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RoomProfile(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__RoomProfile *p;
	size_t k = sizeof(ns1__RoomProfile);
	if (n < 0)
	{	p = SOAP_NEW(ns1__RoomProfile);
		if (p)
			((ns1__RoomProfile*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__RoomProfile, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__RoomProfile*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__RoomProfile location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__RoomProfile, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__RoomProfile::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:RoomProfile", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RoomProfile::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RoomProfile(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RoomProfile * SOAP_FMAC4 soap_get_ns1__RoomProfile(struct soap *soap, ns1__RoomProfile *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RoomProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Recorder::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__Recorder::recorderPrefix);
	soap_default_string(soap, &this->ns1__Recorder::description);
	/* transient soap skipped */
}

void ns1__Recorder::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&this->ns1__Recorder::recorderPrefix);
	soap_serialize_string(soap, (char*const*)&this->ns1__Recorder::description);
#endif
}

int ns1__Recorder::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Recorder(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Recorder(struct soap *soap, const char *tag, int id, const ns1__Recorder *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Recorder), type))
		return soap->error;
	if (!a->ns1__Recorder::recorderPrefix)
	{	if (soap_element_nil(soap, "ns1:recorderPrefix"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:recorderPrefix", -1, (char*const*)&a->ns1__Recorder::recorderPrefix, ""))
		return soap->error;
	if (!a->ns1__Recorder::description)
	{	if (soap_element_nil(soap, "ns1:description"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns1:description", -1, (char*const*)&a->ns1__Recorder::description, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Recorder::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Recorder(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Recorder * SOAP_FMAC4 soap_in_ns1__Recorder(struct soap *soap, const char *tag, ns1__Recorder *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Recorder *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Recorder, sizeof(ns1__Recorder), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_recorderPrefix1 = 1;
	size_t soap_flag_description1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recorderPrefix1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:recorderPrefix", (char**)&a->ns1__Recorder::recorderPrefix, "xsd:string"))
				{	soap_flag_recorderPrefix1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:description", (char**)&a->ns1__Recorder::description, "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recorderPrefix1 > 0 || soap_flag_description1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__Recorder *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Recorder, SOAP_TYPE_ns1__Recorder, sizeof(ns1__Recorder), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Recorder * SOAP_FMAC2 soap_instantiate_ns1__Recorder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Recorder(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Recorder *p;
	size_t k = sizeof(ns1__Recorder);
	if (n < 0)
	{	p = SOAP_NEW(ns1__Recorder);
		if (p)
			((ns1__Recorder*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__Recorder, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__Recorder*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Recorder location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__Recorder, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__Recorder::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns1:Recorder", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Recorder::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Recorder(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Recorder * SOAP_FMAC4 soap_get_ns1__Recorder(struct soap *soap, ns1__Recorder *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Recorder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getChangePasswordHtmlUrlWithToken(struct soap *soap, struct __ns1__getChangePasswordHtmlUrlWithToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetChangePasswordHtmlUrlWithTokenRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getChangePasswordHtmlUrlWithToken(struct soap *soap, const struct __ns1__getChangePasswordHtmlUrlWithToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetChangePasswordHtmlUrlWithTokenRequest(soap, &a->ns1__GetChangePasswordHtmlUrlWithTokenRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getChangePasswordHtmlUrlWithToken(struct soap *soap, const char *tag, int id, const struct __ns1__getChangePasswordHtmlUrlWithToken *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetChangePasswordHtmlUrlWithTokenRequest(soap, "ns1:GetChangePasswordHtmlUrlWithTokenRequest", -1, &a->ns1__GetChangePasswordHtmlUrlWithTokenRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getChangePasswordHtmlUrlWithToken * SOAP_FMAC4 soap_in___ns1__getChangePasswordHtmlUrlWithToken(struct soap *soap, const char *tag, struct __ns1__getChangePasswordHtmlUrlWithToken *a, const char *type)
{
	size_t soap_flag_ns1__GetChangePasswordHtmlUrlWithTokenRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getChangePasswordHtmlUrlWithToken *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getChangePasswordHtmlUrlWithToken, sizeof(struct __ns1__getChangePasswordHtmlUrlWithToken), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getChangePasswordHtmlUrlWithToken(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetChangePasswordHtmlUrlWithTokenRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetChangePasswordHtmlUrlWithTokenRequest(soap, "ns1:GetChangePasswordHtmlUrlWithTokenRequest", &a->ns1__GetChangePasswordHtmlUrlWithTokenRequest, ""))
				{	soap_flag_ns1__GetChangePasswordHtmlUrlWithTokenRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getChangePasswordHtmlUrlWithToken * SOAP_FMAC2 soap_instantiate___ns1__getChangePasswordHtmlUrlWithToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getChangePasswordHtmlUrlWithToken(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getChangePasswordHtmlUrlWithToken *p;
	size_t k = sizeof(struct __ns1__getChangePasswordHtmlUrlWithToken);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getChangePasswordHtmlUrlWithToken);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getChangePasswordHtmlUrlWithToken, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getChangePasswordHtmlUrlWithToken location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getChangePasswordHtmlUrlWithToken, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getChangePasswordHtmlUrlWithToken(struct soap *soap, const struct __ns1__getChangePasswordHtmlUrlWithToken *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getChangePasswordHtmlUrlWithToken(soap, tag?tag:"-ns1:getChangePasswordHtmlUrlWithToken", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getChangePasswordHtmlUrlWithToken * SOAP_FMAC4 soap_get___ns1__getChangePasswordHtmlUrlWithToken(struct soap *soap, struct __ns1__getChangePasswordHtmlUrlWithToken *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getChangePasswordHtmlUrlWithToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__whatIsMyIPAddress(struct soap *soap, struct __ns1__whatIsMyIPAddress *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__WhatIsMyIPAddressRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__whatIsMyIPAddress(struct soap *soap, const struct __ns1__whatIsMyIPAddress *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__WhatIsMyIPAddressRequest(soap, &a->ns1__WhatIsMyIPAddressRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__whatIsMyIPAddress(struct soap *soap, const char *tag, int id, const struct __ns1__whatIsMyIPAddress *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__WhatIsMyIPAddressRequest(soap, "ns1:WhatIsMyIPAddressRequest", -1, &a->ns1__WhatIsMyIPAddressRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__whatIsMyIPAddress * SOAP_FMAC4 soap_in___ns1__whatIsMyIPAddress(struct soap *soap, const char *tag, struct __ns1__whatIsMyIPAddress *a, const char *type)
{
	size_t soap_flag_ns1__WhatIsMyIPAddressRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__whatIsMyIPAddress *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__whatIsMyIPAddress, sizeof(struct __ns1__whatIsMyIPAddress), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__whatIsMyIPAddress(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__WhatIsMyIPAddressRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__WhatIsMyIPAddressRequest(soap, "ns1:WhatIsMyIPAddressRequest", &a->ns1__WhatIsMyIPAddressRequest, ""))
				{	soap_flag_ns1__WhatIsMyIPAddressRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__whatIsMyIPAddress * SOAP_FMAC2 soap_instantiate___ns1__whatIsMyIPAddress(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__whatIsMyIPAddress(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__whatIsMyIPAddress *p;
	size_t k = sizeof(struct __ns1__whatIsMyIPAddress);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__whatIsMyIPAddress);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__whatIsMyIPAddress, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__whatIsMyIPAddress location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__whatIsMyIPAddress, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__whatIsMyIPAddress(struct soap *soap, const struct __ns1__whatIsMyIPAddress *a, const char *tag, const char *type)
{
	if (soap_out___ns1__whatIsMyIPAddress(soap, tag?tag:"-ns1:whatIsMyIPAddress", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__whatIsMyIPAddress * SOAP_FMAC4 soap_get___ns1__whatIsMyIPAddress(struct soap *soap, struct __ns1__whatIsMyIPAddress *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__whatIsMyIPAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getVidyoReplayLibrary(struct soap *soap, struct __ns1__getVidyoReplayLibrary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetVidyoReplayLibraryRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getVidyoReplayLibrary(struct soap *soap, const struct __ns1__getVidyoReplayLibrary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetVidyoReplayLibraryRequest(soap, &a->ns1__GetVidyoReplayLibraryRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getVidyoReplayLibrary(struct soap *soap, const char *tag, int id, const struct __ns1__getVidyoReplayLibrary *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetVidyoReplayLibraryRequest(soap, "ns1:GetVidyoReplayLibraryRequest", -1, &a->ns1__GetVidyoReplayLibraryRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getVidyoReplayLibrary * SOAP_FMAC4 soap_in___ns1__getVidyoReplayLibrary(struct soap *soap, const char *tag, struct __ns1__getVidyoReplayLibrary *a, const char *type)
{
	size_t soap_flag_ns1__GetVidyoReplayLibraryRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getVidyoReplayLibrary *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getVidyoReplayLibrary, sizeof(struct __ns1__getVidyoReplayLibrary), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getVidyoReplayLibrary(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetVidyoReplayLibraryRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetVidyoReplayLibraryRequest(soap, "ns1:GetVidyoReplayLibraryRequest", &a->ns1__GetVidyoReplayLibraryRequest, ""))
				{	soap_flag_ns1__GetVidyoReplayLibraryRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getVidyoReplayLibrary * SOAP_FMAC2 soap_instantiate___ns1__getVidyoReplayLibrary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getVidyoReplayLibrary(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getVidyoReplayLibrary *p;
	size_t k = sizeof(struct __ns1__getVidyoReplayLibrary);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getVidyoReplayLibrary);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getVidyoReplayLibrary, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getVidyoReplayLibrary location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getVidyoReplayLibrary, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getVidyoReplayLibrary(struct soap *soap, const struct __ns1__getVidyoReplayLibrary *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getVidyoReplayLibrary(soap, tag?tag:"-ns1:getVidyoReplayLibrary", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getVidyoReplayLibrary * SOAP_FMAC4 soap_get___ns1__getVidyoReplayLibrary(struct soap *soap, struct __ns1__getVidyoReplayLibrary *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getVidyoReplayLibrary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removePresenter(struct soap *soap, struct __ns1__removePresenter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RemovePresenterRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removePresenter(struct soap *soap, const struct __ns1__removePresenter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__RemovePresenterRequest(soap, &a->ns1__RemovePresenterRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removePresenter(struct soap *soap, const char *tag, int id, const struct __ns1__removePresenter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__RemovePresenterRequest(soap, "ns1:RemovePresenterRequest", -1, &a->ns1__RemovePresenterRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removePresenter * SOAP_FMAC4 soap_in___ns1__removePresenter(struct soap *soap, const char *tag, struct __ns1__removePresenter *a, const char *type)
{
	size_t soap_flag_ns1__RemovePresenterRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__removePresenter *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removePresenter, sizeof(struct __ns1__removePresenter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removePresenter(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RemovePresenterRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__RemovePresenterRequest(soap, "ns1:RemovePresenterRequest", &a->ns1__RemovePresenterRequest, ""))
				{	soap_flag_ns1__RemovePresenterRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__removePresenter * SOAP_FMAC2 soap_instantiate___ns1__removePresenter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removePresenter(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__removePresenter *p;
	size_t k = sizeof(struct __ns1__removePresenter);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__removePresenter);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__removePresenter, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__removePresenter location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__removePresenter, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removePresenter(struct soap *soap, const struct __ns1__removePresenter *a, const char *tag, const char *type)
{
	if (soap_out___ns1__removePresenter(soap, tag?tag:"-ns1:removePresenter", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removePresenter * SOAP_FMAC4 soap_get___ns1__removePresenter(struct soap *soap, struct __ns1__removePresenter *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removePresenter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setPresenter(struct soap *soap, struct __ns1__setPresenter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SetPresenterRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setPresenter(struct soap *soap, const struct __ns1__setPresenter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SetPresenterRequest(soap, &a->ns1__SetPresenterRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setPresenter(struct soap *soap, const char *tag, int id, const struct __ns1__setPresenter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SetPresenterRequest(soap, "ns1:SetPresenterRequest", -1, &a->ns1__SetPresenterRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setPresenter * SOAP_FMAC4 soap_in___ns1__setPresenter(struct soap *soap, const char *tag, struct __ns1__setPresenter *a, const char *type)
{
	size_t soap_flag_ns1__SetPresenterRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__setPresenter *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setPresenter, sizeof(struct __ns1__setPresenter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setPresenter(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SetPresenterRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SetPresenterRequest(soap, "ns1:SetPresenterRequest", &a->ns1__SetPresenterRequest, ""))
				{	soap_flag_ns1__SetPresenterRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__setPresenter * SOAP_FMAC2 soap_instantiate___ns1__setPresenter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__setPresenter(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__setPresenter *p;
	size_t k = sizeof(struct __ns1__setPresenter);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__setPresenter);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__setPresenter, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__setPresenter location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__setPresenter, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setPresenter(struct soap *soap, const struct __ns1__setPresenter *a, const char *tag, const char *type)
{
	if (soap_out___ns1__setPresenter(soap, tag?tag:"-ns1:setPresenter", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setPresenter * SOAP_FMAC4 soap_get___ns1__setPresenter(struct soap *soap, struct __ns1__setPresenter *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setPresenter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__dismissAllRaisedHand(struct soap *soap, struct __ns1__dismissAllRaisedHand *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DismissAllRaisedHandRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__dismissAllRaisedHand(struct soap *soap, const struct __ns1__dismissAllRaisedHand *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__DismissAllRaisedHandRequest(soap, &a->ns1__DismissAllRaisedHandRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__dismissAllRaisedHand(struct soap *soap, const char *tag, int id, const struct __ns1__dismissAllRaisedHand *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__DismissAllRaisedHandRequest(soap, "ns1:DismissAllRaisedHandRequest", -1, &a->ns1__DismissAllRaisedHandRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__dismissAllRaisedHand * SOAP_FMAC4 soap_in___ns1__dismissAllRaisedHand(struct soap *soap, const char *tag, struct __ns1__dismissAllRaisedHand *a, const char *type)
{
	size_t soap_flag_ns1__DismissAllRaisedHandRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__dismissAllRaisedHand *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__dismissAllRaisedHand, sizeof(struct __ns1__dismissAllRaisedHand), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__dismissAllRaisedHand(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DismissAllRaisedHandRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__DismissAllRaisedHandRequest(soap, "ns1:DismissAllRaisedHandRequest", &a->ns1__DismissAllRaisedHandRequest, ""))
				{	soap_flag_ns1__DismissAllRaisedHandRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__dismissAllRaisedHand * SOAP_FMAC2 soap_instantiate___ns1__dismissAllRaisedHand(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__dismissAllRaisedHand(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__dismissAllRaisedHand *p;
	size_t k = sizeof(struct __ns1__dismissAllRaisedHand);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__dismissAllRaisedHand);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__dismissAllRaisedHand, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__dismissAllRaisedHand location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__dismissAllRaisedHand, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__dismissAllRaisedHand(struct soap *soap, const struct __ns1__dismissAllRaisedHand *a, const char *tag, const char *type)
{
	if (soap_out___ns1__dismissAllRaisedHand(soap, tag?tag:"-ns1:dismissAllRaisedHand", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__dismissAllRaisedHand * SOAP_FMAC4 soap_get___ns1__dismissAllRaisedHand(struct soap *soap, struct __ns1__dismissAllRaisedHand *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__dismissAllRaisedHand(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__dismissRaisedHand(struct soap *soap, struct __ns1__dismissRaisedHand *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DismissRaisedHandRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__dismissRaisedHand(struct soap *soap, const struct __ns1__dismissRaisedHand *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__DismissRaisedHandRequest(soap, &a->ns1__DismissRaisedHandRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__dismissRaisedHand(struct soap *soap, const char *tag, int id, const struct __ns1__dismissRaisedHand *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__DismissRaisedHandRequest(soap, "ns1:DismissRaisedHandRequest", -1, &a->ns1__DismissRaisedHandRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__dismissRaisedHand * SOAP_FMAC4 soap_in___ns1__dismissRaisedHand(struct soap *soap, const char *tag, struct __ns1__dismissRaisedHand *a, const char *type)
{
	size_t soap_flag_ns1__DismissRaisedHandRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__dismissRaisedHand *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__dismissRaisedHand, sizeof(struct __ns1__dismissRaisedHand), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__dismissRaisedHand(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DismissRaisedHandRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__DismissRaisedHandRequest(soap, "ns1:DismissRaisedHandRequest", &a->ns1__DismissRaisedHandRequest, ""))
				{	soap_flag_ns1__DismissRaisedHandRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__dismissRaisedHand * SOAP_FMAC2 soap_instantiate___ns1__dismissRaisedHand(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__dismissRaisedHand(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__dismissRaisedHand *p;
	size_t k = sizeof(struct __ns1__dismissRaisedHand);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__dismissRaisedHand);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__dismissRaisedHand, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__dismissRaisedHand location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__dismissRaisedHand, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__dismissRaisedHand(struct soap *soap, const struct __ns1__dismissRaisedHand *a, const char *tag, const char *type)
{
	if (soap_out___ns1__dismissRaisedHand(soap, tag?tag:"-ns1:dismissRaisedHand", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__dismissRaisedHand * SOAP_FMAC4 soap_get___ns1__dismissRaisedHand(struct soap *soap, struct __ns1__dismissRaisedHand *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__dismissRaisedHand(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__unraiseHand(struct soap *soap, struct __ns1__unraiseHand *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UnraiseHandRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__unraiseHand(struct soap *soap, const struct __ns1__unraiseHand *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__unraiseHand(struct soap *soap, const char *tag, int id, const struct __ns1__unraiseHand *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	soap_outliteral(soap, "ns1:UnraiseHandRequest", (char*const*)&a->ns1__UnraiseHandRequest, NULL);
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__unraiseHand * SOAP_FMAC4 soap_in___ns1__unraiseHand(struct soap *soap, const char *tag, struct __ns1__unraiseHand *a, const char *type)
{
	size_t soap_flag_ns1__UnraiseHandRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__unraiseHand *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__unraiseHand, sizeof(struct __ns1__unraiseHand), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__unraiseHand(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UnraiseHandRequest && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "ns1:UnraiseHandRequest", (char**)&a->ns1__UnraiseHandRequest))
				{	soap_flag_ns1__UnraiseHandRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__unraiseHand * SOAP_FMAC2 soap_instantiate___ns1__unraiseHand(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__unraiseHand(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__unraiseHand *p;
	size_t k = sizeof(struct __ns1__unraiseHand);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__unraiseHand);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__unraiseHand, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__unraiseHand location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__unraiseHand, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__unraiseHand(struct soap *soap, const struct __ns1__unraiseHand *a, const char *tag, const char *type)
{
	if (soap_out___ns1__unraiseHand(soap, tag?tag:"-ns1:unraiseHand", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__unraiseHand * SOAP_FMAC4 soap_get___ns1__unraiseHand(struct soap *soap, struct __ns1__unraiseHand *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__unraiseHand(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__raiseHand(struct soap *soap, struct __ns1__raiseHand *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RaiseHandRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__raiseHand(struct soap *soap, const struct __ns1__raiseHand *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__raiseHand(struct soap *soap, const char *tag, int id, const struct __ns1__raiseHand *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	soap_outliteral(soap, "ns1:RaiseHandRequest", (char*const*)&a->ns1__RaiseHandRequest, NULL);
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__raiseHand * SOAP_FMAC4 soap_in___ns1__raiseHand(struct soap *soap, const char *tag, struct __ns1__raiseHand *a, const char *type)
{
	size_t soap_flag_ns1__RaiseHandRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__raiseHand *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__raiseHand, sizeof(struct __ns1__raiseHand), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__raiseHand(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RaiseHandRequest && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "ns1:RaiseHandRequest", (char**)&a->ns1__RaiseHandRequest))
				{	soap_flag_ns1__RaiseHandRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__raiseHand * SOAP_FMAC2 soap_instantiate___ns1__raiseHand(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__raiseHand(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__raiseHand *p;
	size_t k = sizeof(struct __ns1__raiseHand);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__raiseHand);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__raiseHand, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__raiseHand location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__raiseHand, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__raiseHand(struct soap *soap, const struct __ns1__raiseHand *a, const char *tag, const char *type)
{
	if (soap_out___ns1__raiseHand(soap, tag?tag:"-ns1:raiseHand", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__raiseHand * SOAP_FMAC4 soap_get___ns1__raiseHand(struct soap *soap, struct __ns1__raiseHand *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__raiseHand(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__stopLectureMode(struct soap *soap, struct __ns1__stopLectureMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__StopLectureModeRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__stopLectureMode(struct soap *soap, const struct __ns1__stopLectureMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__StopLectureModeRequest(soap, &a->ns1__StopLectureModeRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__stopLectureMode(struct soap *soap, const char *tag, int id, const struct __ns1__stopLectureMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__StopLectureModeRequest(soap, "ns1:StopLectureModeRequest", -1, &a->ns1__StopLectureModeRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__stopLectureMode * SOAP_FMAC4 soap_in___ns1__stopLectureMode(struct soap *soap, const char *tag, struct __ns1__stopLectureMode *a, const char *type)
{
	size_t soap_flag_ns1__StopLectureModeRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__stopLectureMode *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__stopLectureMode, sizeof(struct __ns1__stopLectureMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__stopLectureMode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__StopLectureModeRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__StopLectureModeRequest(soap, "ns1:StopLectureModeRequest", &a->ns1__StopLectureModeRequest, ""))
				{	soap_flag_ns1__StopLectureModeRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__stopLectureMode * SOAP_FMAC2 soap_instantiate___ns1__stopLectureMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__stopLectureMode(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__stopLectureMode *p;
	size_t k = sizeof(struct __ns1__stopLectureMode);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__stopLectureMode);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__stopLectureMode, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__stopLectureMode location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__stopLectureMode, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__stopLectureMode(struct soap *soap, const struct __ns1__stopLectureMode *a, const char *tag, const char *type)
{
	if (soap_out___ns1__stopLectureMode(soap, tag?tag:"-ns1:stopLectureMode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__stopLectureMode * SOAP_FMAC4 soap_get___ns1__stopLectureMode(struct soap *soap, struct __ns1__stopLectureMode *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__stopLectureMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__startLectureMode(struct soap *soap, struct __ns1__startLectureMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__StartLectureModeRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__startLectureMode(struct soap *soap, const struct __ns1__startLectureMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__StartLectureModeRequest(soap, &a->ns1__StartLectureModeRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__startLectureMode(struct soap *soap, const char *tag, int id, const struct __ns1__startLectureMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__StartLectureModeRequest(soap, "ns1:StartLectureModeRequest", -1, &a->ns1__StartLectureModeRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__startLectureMode * SOAP_FMAC4 soap_in___ns1__startLectureMode(struct soap *soap, const char *tag, struct __ns1__startLectureMode *a, const char *type)
{
	size_t soap_flag_ns1__StartLectureModeRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__startLectureMode *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__startLectureMode, sizeof(struct __ns1__startLectureMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__startLectureMode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__StartLectureModeRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__StartLectureModeRequest(soap, "ns1:StartLectureModeRequest", &a->ns1__StartLectureModeRequest, ""))
				{	soap_flag_ns1__StartLectureModeRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__startLectureMode * SOAP_FMAC2 soap_instantiate___ns1__startLectureMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__startLectureMode(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__startLectureMode *p;
	size_t k = sizeof(struct __ns1__startLectureMode);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__startLectureMode);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__startLectureMode, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__startLectureMode location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__startLectureMode, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__startLectureMode(struct soap *soap, const struct __ns1__startLectureMode *a, const char *tag, const char *type)
{
	if (soap_out___ns1__startLectureMode(soap, tag?tag:"-ns1:startLectureMode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__startLectureMode * SOAP_FMAC4 soap_get___ns1__startLectureMode(struct soap *soap, struct __ns1__startLectureMode *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__startLectureMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getUserAccountType(struct soap *soap, struct __ns1__getUserAccountType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getUserAccountTypeRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getUserAccountType(struct soap *soap, const struct __ns1__getUserAccountType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__getUserAccountTypeRequest(soap, &a->ns1__getUserAccountTypeRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getUserAccountType(struct soap *soap, const char *tag, int id, const struct __ns1__getUserAccountType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__getUserAccountTypeRequest(soap, "ns1:getUserAccountTypeRequest", -1, &a->ns1__getUserAccountTypeRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getUserAccountType * SOAP_FMAC4 soap_in___ns1__getUserAccountType(struct soap *soap, const char *tag, struct __ns1__getUserAccountType *a, const char *type)
{
	size_t soap_flag_ns1__getUserAccountTypeRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getUserAccountType *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getUserAccountType, sizeof(struct __ns1__getUserAccountType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getUserAccountType(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getUserAccountTypeRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getUserAccountTypeRequest(soap, "ns1:getUserAccountTypeRequest", &a->ns1__getUserAccountTypeRequest, ""))
				{	soap_flag_ns1__getUserAccountTypeRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getUserAccountType * SOAP_FMAC2 soap_instantiate___ns1__getUserAccountType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getUserAccountType(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getUserAccountType *p;
	size_t k = sizeof(struct __ns1__getUserAccountType);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getUserAccountType);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getUserAccountType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getUserAccountType location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getUserAccountType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getUserAccountType(struct soap *soap, const struct __ns1__getUserAccountType *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getUserAccountType(soap, tag?tag:"-ns1:getUserAccountType", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getUserAccountType * SOAP_FMAC4 soap_get___ns1__getUserAccountType(struct soap *soap, struct __ns1__getUserAccountType *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getUserAccountType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getLoginAndWelcomeBanner(struct soap *soap, struct __ns1__getLoginAndWelcomeBanner *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getLoginAndWelcomeBannerRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getLoginAndWelcomeBanner(struct soap *soap, const struct __ns1__getLoginAndWelcomeBanner *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__getLoginAndWelcomeBannerRequest(soap, &a->ns1__getLoginAndWelcomeBannerRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getLoginAndWelcomeBanner(struct soap *soap, const char *tag, int id, const struct __ns1__getLoginAndWelcomeBanner *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__getLoginAndWelcomeBannerRequest(soap, "ns1:getLoginAndWelcomeBannerRequest", -1, &a->ns1__getLoginAndWelcomeBannerRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getLoginAndWelcomeBanner * SOAP_FMAC4 soap_in___ns1__getLoginAndWelcomeBanner(struct soap *soap, const char *tag, struct __ns1__getLoginAndWelcomeBanner *a, const char *type)
{
	size_t soap_flag_ns1__getLoginAndWelcomeBannerRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getLoginAndWelcomeBanner *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getLoginAndWelcomeBanner, sizeof(struct __ns1__getLoginAndWelcomeBanner), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getLoginAndWelcomeBanner(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getLoginAndWelcomeBannerRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__getLoginAndWelcomeBannerRequest(soap, "ns1:getLoginAndWelcomeBannerRequest", &a->ns1__getLoginAndWelcomeBannerRequest, ""))
				{	soap_flag_ns1__getLoginAndWelcomeBannerRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getLoginAndWelcomeBanner * SOAP_FMAC2 soap_instantiate___ns1__getLoginAndWelcomeBanner(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getLoginAndWelcomeBanner(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getLoginAndWelcomeBanner *p;
	size_t k = sizeof(struct __ns1__getLoginAndWelcomeBanner);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getLoginAndWelcomeBanner);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getLoginAndWelcomeBanner, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getLoginAndWelcomeBanner location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getLoginAndWelcomeBanner, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getLoginAndWelcomeBanner(struct soap *soap, const struct __ns1__getLoginAndWelcomeBanner *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getLoginAndWelcomeBanner(soap, tag?tag:"-ns1:getLoginAndWelcomeBanner", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getLoginAndWelcomeBanner * SOAP_FMAC4 soap_get___ns1__getLoginAndWelcomeBanner(struct soap *soap, struct __ns1__getLoginAndWelcomeBanner *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getLoginAndWelcomeBanner(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getPortalPrefix(struct soap *soap, struct __ns1__getPortalPrefix *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__PortalPrefixRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getPortalPrefix(struct soap *soap, const struct __ns1__getPortalPrefix *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getPortalPrefix(struct soap *soap, const char *tag, int id, const struct __ns1__getPortalPrefix *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	soap_outliteral(soap, "ns1:PortalPrefixRequest", (char*const*)&a->ns1__PortalPrefixRequest, NULL);
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPortalPrefix * SOAP_FMAC4 soap_in___ns1__getPortalPrefix(struct soap *soap, const char *tag, struct __ns1__getPortalPrefix *a, const char *type)
{
	size_t soap_flag_ns1__PortalPrefixRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getPortalPrefix *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getPortalPrefix, sizeof(struct __ns1__getPortalPrefix), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getPortalPrefix(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__PortalPrefixRequest && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "ns1:PortalPrefixRequest", (char**)&a->ns1__PortalPrefixRequest))
				{	soap_flag_ns1__PortalPrefixRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getPortalPrefix * SOAP_FMAC2 soap_instantiate___ns1__getPortalPrefix(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getPortalPrefix(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getPortalPrefix *p;
	size_t k = sizeof(struct __ns1__getPortalPrefix);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getPortalPrefix);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getPortalPrefix, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getPortalPrefix location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getPortalPrefix, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getPortalPrefix(struct soap *soap, const struct __ns1__getPortalPrefix *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getPortalPrefix(soap, tag?tag:"-ns1:getPortalPrefix", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPortalPrefix * SOAP_FMAC4 soap_get___ns1__getPortalPrefix(struct soap *soap, struct __ns1__getPortalPrefix *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getPortalPrefix(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getRoomAccessOptions(struct soap *soap, struct __ns1__getRoomAccessOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RoomAccessOptionsRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getRoomAccessOptions(struct soap *soap, const struct __ns1__getRoomAccessOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__RoomAccessOptionsRequest(soap, &a->ns1__RoomAccessOptionsRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getRoomAccessOptions(struct soap *soap, const char *tag, int id, const struct __ns1__getRoomAccessOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__RoomAccessOptionsRequest(soap, "ns1:RoomAccessOptionsRequest", -1, &a->ns1__RoomAccessOptionsRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getRoomAccessOptions * SOAP_FMAC4 soap_in___ns1__getRoomAccessOptions(struct soap *soap, const char *tag, struct __ns1__getRoomAccessOptions *a, const char *type)
{
	size_t soap_flag_ns1__RoomAccessOptionsRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getRoomAccessOptions *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getRoomAccessOptions, sizeof(struct __ns1__getRoomAccessOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getRoomAccessOptions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RoomAccessOptionsRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__RoomAccessOptionsRequest(soap, "ns1:RoomAccessOptionsRequest", &a->ns1__RoomAccessOptionsRequest, ""))
				{	soap_flag_ns1__RoomAccessOptionsRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getRoomAccessOptions * SOAP_FMAC2 soap_instantiate___ns1__getRoomAccessOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getRoomAccessOptions(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getRoomAccessOptions *p;
	size_t k = sizeof(struct __ns1__getRoomAccessOptions);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getRoomAccessOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getRoomAccessOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getRoomAccessOptions location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getRoomAccessOptions, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getRoomAccessOptions(struct soap *soap, const struct __ns1__getRoomAccessOptions *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getRoomAccessOptions(soap, tag?tag:"-ns1:getRoomAccessOptions", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getRoomAccessOptions * SOAP_FMAC4 soap_get___ns1__getRoomAccessOptions(struct soap *soap, struct __ns1__getRoomAccessOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getRoomAccessOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getOnetimeAccessUrl(struct soap *soap, struct __ns1__getOnetimeAccessUrl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__OnetimeAccessRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getOnetimeAccessUrl(struct soap *soap, const struct __ns1__getOnetimeAccessUrl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getOnetimeAccessUrl(struct soap *soap, const char *tag, int id, const struct __ns1__getOnetimeAccessUrl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	soap_outliteral(soap, "ns1:OnetimeAccessRequest", (char*const*)&a->ns1__OnetimeAccessRequest, NULL);
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getOnetimeAccessUrl * SOAP_FMAC4 soap_in___ns1__getOnetimeAccessUrl(struct soap *soap, const char *tag, struct __ns1__getOnetimeAccessUrl *a, const char *type)
{
	size_t soap_flag_ns1__OnetimeAccessRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getOnetimeAccessUrl *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getOnetimeAccessUrl, sizeof(struct __ns1__getOnetimeAccessUrl), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getOnetimeAccessUrl(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__OnetimeAccessRequest && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "ns1:OnetimeAccessRequest", (char**)&a->ns1__OnetimeAccessRequest))
				{	soap_flag_ns1__OnetimeAccessRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getOnetimeAccessUrl * SOAP_FMAC2 soap_instantiate___ns1__getOnetimeAccessUrl(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getOnetimeAccessUrl(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getOnetimeAccessUrl *p;
	size_t k = sizeof(struct __ns1__getOnetimeAccessUrl);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getOnetimeAccessUrl);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getOnetimeAccessUrl, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getOnetimeAccessUrl location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getOnetimeAccessUrl, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getOnetimeAccessUrl(struct soap *soap, const struct __ns1__getOnetimeAccessUrl *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getOnetimeAccessUrl(soap, tag?tag:"-ns1:getOnetimeAccessUrl", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getOnetimeAccessUrl * SOAP_FMAC4 soap_get___ns1__getOnetimeAccessUrl(struct soap *soap, struct __ns1__getOnetimeAccessUrl *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getOnetimeAccessUrl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__muteVideoClientAll(struct soap *soap, struct __ns1__muteVideoClientAll *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__muteVideoClientAllRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__muteVideoClientAll(struct soap *soap, const struct __ns1__muteVideoClientAll *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__muteVideoClientAllRequest(soap, &a->ns1__muteVideoClientAllRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__muteVideoClientAll(struct soap *soap, const char *tag, int id, const struct __ns1__muteVideoClientAll *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__muteVideoClientAllRequest(soap, "ns1:muteVideoClientAllRequest", -1, &a->ns1__muteVideoClientAllRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__muteVideoClientAll * SOAP_FMAC4 soap_in___ns1__muteVideoClientAll(struct soap *soap, const char *tag, struct __ns1__muteVideoClientAll *a, const char *type)
{
	size_t soap_flag_ns1__muteVideoClientAllRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__muteVideoClientAll *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__muteVideoClientAll, sizeof(struct __ns1__muteVideoClientAll), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__muteVideoClientAll(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__muteVideoClientAllRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__muteVideoClientAllRequest(soap, "ns1:muteVideoClientAllRequest", &a->ns1__muteVideoClientAllRequest, ""))
				{	soap_flag_ns1__muteVideoClientAllRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__muteVideoClientAll * SOAP_FMAC2 soap_instantiate___ns1__muteVideoClientAll(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__muteVideoClientAll(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__muteVideoClientAll *p;
	size_t k = sizeof(struct __ns1__muteVideoClientAll);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__muteVideoClientAll);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__muteVideoClientAll, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__muteVideoClientAll location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__muteVideoClientAll, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__muteVideoClientAll(struct soap *soap, const struct __ns1__muteVideoClientAll *a, const char *tag, const char *type)
{
	if (soap_out___ns1__muteVideoClientAll(soap, tag?tag:"-ns1:muteVideoClientAll", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__muteVideoClientAll * SOAP_FMAC4 soap_get___ns1__muteVideoClientAll(struct soap *soap, struct __ns1__muteVideoClientAll *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__muteVideoClientAll(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__muteVideoServerAll(struct soap *soap, struct __ns1__muteVideoServerAll *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__muteVideoServerAllRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__muteVideoServerAll(struct soap *soap, const struct __ns1__muteVideoServerAll *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__muteVideoServerAllRequest(soap, &a->ns1__muteVideoServerAllRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__muteVideoServerAll(struct soap *soap, const char *tag, int id, const struct __ns1__muteVideoServerAll *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__muteVideoServerAllRequest(soap, "ns1:muteVideoServerAllRequest", -1, &a->ns1__muteVideoServerAllRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__muteVideoServerAll * SOAP_FMAC4 soap_in___ns1__muteVideoServerAll(struct soap *soap, const char *tag, struct __ns1__muteVideoServerAll *a, const char *type)
{
	size_t soap_flag_ns1__muteVideoServerAllRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__muteVideoServerAll *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__muteVideoServerAll, sizeof(struct __ns1__muteVideoServerAll), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__muteVideoServerAll(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__muteVideoServerAllRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__muteVideoServerAllRequest(soap, "ns1:muteVideoServerAllRequest", &a->ns1__muteVideoServerAllRequest, ""))
				{	soap_flag_ns1__muteVideoServerAllRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__muteVideoServerAll * SOAP_FMAC2 soap_instantiate___ns1__muteVideoServerAll(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__muteVideoServerAll(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__muteVideoServerAll *p;
	size_t k = sizeof(struct __ns1__muteVideoServerAll);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__muteVideoServerAll);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__muteVideoServerAll, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__muteVideoServerAll location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__muteVideoServerAll, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__muteVideoServerAll(struct soap *soap, const struct __ns1__muteVideoServerAll *a, const char *tag, const char *type)
{
	if (soap_out___ns1__muteVideoServerAll(soap, tag?tag:"-ns1:muteVideoServerAll", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__muteVideoServerAll * SOAP_FMAC4 soap_get___ns1__muteVideoServerAll(struct soap *soap, struct __ns1__muteVideoServerAll *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__muteVideoServerAll(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__muteAudioClientAll(struct soap *soap, struct __ns1__muteAudioClientAll *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__muteAudioClientAllRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__muteAudioClientAll(struct soap *soap, const struct __ns1__muteAudioClientAll *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__muteAudioClientAllRequest(soap, &a->ns1__muteAudioClientAllRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__muteAudioClientAll(struct soap *soap, const char *tag, int id, const struct __ns1__muteAudioClientAll *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__muteAudioClientAllRequest(soap, "ns1:muteAudioClientAllRequest", -1, &a->ns1__muteAudioClientAllRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__muteAudioClientAll * SOAP_FMAC4 soap_in___ns1__muteAudioClientAll(struct soap *soap, const char *tag, struct __ns1__muteAudioClientAll *a, const char *type)
{
	size_t soap_flag_ns1__muteAudioClientAllRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__muteAudioClientAll *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__muteAudioClientAll, sizeof(struct __ns1__muteAudioClientAll), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__muteAudioClientAll(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__muteAudioClientAllRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__muteAudioClientAllRequest(soap, "ns1:muteAudioClientAllRequest", &a->ns1__muteAudioClientAllRequest, ""))
				{	soap_flag_ns1__muteAudioClientAllRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__muteAudioClientAll * SOAP_FMAC2 soap_instantiate___ns1__muteAudioClientAll(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__muteAudioClientAll(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__muteAudioClientAll *p;
	size_t k = sizeof(struct __ns1__muteAudioClientAll);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__muteAudioClientAll);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__muteAudioClientAll, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__muteAudioClientAll location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__muteAudioClientAll, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__muteAudioClientAll(struct soap *soap, const struct __ns1__muteAudioClientAll *a, const char *tag, const char *type)
{
	if (soap_out___ns1__muteAudioClientAll(soap, tag?tag:"-ns1:muteAudioClientAll", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__muteAudioClientAll * SOAP_FMAC4 soap_get___ns1__muteAudioClientAll(struct soap *soap, struct __ns1__muteAudioClientAll *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__muteAudioClientAll(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__muteAudioServerAll(struct soap *soap, struct __ns1__muteAudioServerAll *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__muteAudioServerAllRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__muteAudioServerAll(struct soap *soap, const struct __ns1__muteAudioServerAll *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__muteAudioServerAllRequest(soap, &a->ns1__muteAudioServerAllRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__muteAudioServerAll(struct soap *soap, const char *tag, int id, const struct __ns1__muteAudioServerAll *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__muteAudioServerAllRequest(soap, "ns1:muteAudioServerAllRequest", -1, &a->ns1__muteAudioServerAllRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__muteAudioServerAll * SOAP_FMAC4 soap_in___ns1__muteAudioServerAll(struct soap *soap, const char *tag, struct __ns1__muteAudioServerAll *a, const char *type)
{
	size_t soap_flag_ns1__muteAudioServerAllRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__muteAudioServerAll *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__muteAudioServerAll, sizeof(struct __ns1__muteAudioServerAll), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__muteAudioServerAll(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__muteAudioServerAllRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__muteAudioServerAllRequest(soap, "ns1:muteAudioServerAllRequest", &a->ns1__muteAudioServerAllRequest, ""))
				{	soap_flag_ns1__muteAudioServerAllRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__muteAudioServerAll * SOAP_FMAC2 soap_instantiate___ns1__muteAudioServerAll(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__muteAudioServerAll(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__muteAudioServerAll *p;
	size_t k = sizeof(struct __ns1__muteAudioServerAll);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__muteAudioServerAll);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__muteAudioServerAll, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__muteAudioServerAll location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__muteAudioServerAll, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__muteAudioServerAll(struct soap *soap, const struct __ns1__muteAudioServerAll *a, const char *tag, const char *type)
{
	if (soap_out___ns1__muteAudioServerAll(soap, tag?tag:"-ns1:muteAudioServerAll", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__muteAudioServerAll * SOAP_FMAC4 soap_get___ns1__muteAudioServerAll(struct soap *soap, struct __ns1__muteAudioServerAll *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__muteAudioServerAll(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__disconnectConferenceAll(struct soap *soap, struct __ns1__disconnectConferenceAll *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__disconnectConferenceAllRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__disconnectConferenceAll(struct soap *soap, const struct __ns1__disconnectConferenceAll *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__disconnectConferenceAllRequest(soap, &a->ns1__disconnectConferenceAllRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__disconnectConferenceAll(struct soap *soap, const char *tag, int id, const struct __ns1__disconnectConferenceAll *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__disconnectConferenceAllRequest(soap, "ns1:disconnectConferenceAllRequest", -1, &a->ns1__disconnectConferenceAllRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__disconnectConferenceAll * SOAP_FMAC4 soap_in___ns1__disconnectConferenceAll(struct soap *soap, const char *tag, struct __ns1__disconnectConferenceAll *a, const char *type)
{
	size_t soap_flag_ns1__disconnectConferenceAllRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__disconnectConferenceAll *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__disconnectConferenceAll, sizeof(struct __ns1__disconnectConferenceAll), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__disconnectConferenceAll(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__disconnectConferenceAllRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__disconnectConferenceAllRequest(soap, "ns1:disconnectConferenceAllRequest", &a->ns1__disconnectConferenceAllRequest, ""))
				{	soap_flag_ns1__disconnectConferenceAllRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__disconnectConferenceAll * SOAP_FMAC2 soap_instantiate___ns1__disconnectConferenceAll(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__disconnectConferenceAll(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__disconnectConferenceAll *p;
	size_t k = sizeof(struct __ns1__disconnectConferenceAll);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__disconnectConferenceAll);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__disconnectConferenceAll, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__disconnectConferenceAll location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__disconnectConferenceAll, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__disconnectConferenceAll(struct soap *soap, const struct __ns1__disconnectConferenceAll *a, const char *tag, const char *type)
{
	if (soap_out___ns1__disconnectConferenceAll(soap, tag?tag:"-ns1:disconnectConferenceAll", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__disconnectConferenceAll * SOAP_FMAC4 soap_get___ns1__disconnectConferenceAll(struct soap *soap, struct __ns1__disconnectConferenceAll *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__disconnectConferenceAll(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__logoutAllOtherSessions(struct soap *soap, struct __ns1__logoutAllOtherSessions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__LogoutAllOtherSessionsRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__logoutAllOtherSessions(struct soap *soap, const struct __ns1__logoutAllOtherSessions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__logoutAllOtherSessions(struct soap *soap, const char *tag, int id, const struct __ns1__logoutAllOtherSessions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	soap_outliteral(soap, "ns1:LogoutAllOtherSessionsRequest", (char*const*)&a->ns1__LogoutAllOtherSessionsRequest, NULL);
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__logoutAllOtherSessions * SOAP_FMAC4 soap_in___ns1__logoutAllOtherSessions(struct soap *soap, const char *tag, struct __ns1__logoutAllOtherSessions *a, const char *type)
{
	size_t soap_flag_ns1__LogoutAllOtherSessionsRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__logoutAllOtherSessions *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__logoutAllOtherSessions, sizeof(struct __ns1__logoutAllOtherSessions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__logoutAllOtherSessions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__LogoutAllOtherSessionsRequest && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "ns1:LogoutAllOtherSessionsRequest", (char**)&a->ns1__LogoutAllOtherSessionsRequest))
				{	soap_flag_ns1__LogoutAllOtherSessionsRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__logoutAllOtherSessions * SOAP_FMAC2 soap_instantiate___ns1__logoutAllOtherSessions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__logoutAllOtherSessions(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__logoutAllOtherSessions *p;
	size_t k = sizeof(struct __ns1__logoutAllOtherSessions);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__logoutAllOtherSessions);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__logoutAllOtherSessions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__logoutAllOtherSessions location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__logoutAllOtherSessions, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__logoutAllOtherSessions(struct soap *soap, const struct __ns1__logoutAllOtherSessions *a, const char *tag, const char *type)
{
	if (soap_out___ns1__logoutAllOtherSessions(soap, tag?tag:"-ns1:logoutAllOtherSessions", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__logoutAllOtherSessions * SOAP_FMAC4 soap_get___ns1__logoutAllOtherSessions(struct soap *soap, struct __ns1__logoutAllOtherSessions *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__logoutAllOtherSessions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getActiveSessions(struct soap *soap, struct __ns1__getActiveSessions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetActiveSessionsRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getActiveSessions(struct soap *soap, const struct __ns1__getActiveSessions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getActiveSessions(struct soap *soap, const char *tag, int id, const struct __ns1__getActiveSessions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	soap_outliteral(soap, "ns1:GetActiveSessionsRequest", (char*const*)&a->ns1__GetActiveSessionsRequest, NULL);
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getActiveSessions * SOAP_FMAC4 soap_in___ns1__getActiveSessions(struct soap *soap, const char *tag, struct __ns1__getActiveSessions *a, const char *type)
{
	size_t soap_flag_ns1__GetActiveSessionsRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getActiveSessions *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getActiveSessions, sizeof(struct __ns1__getActiveSessions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getActiveSessions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetActiveSessionsRequest && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "ns1:GetActiveSessionsRequest", (char**)&a->ns1__GetActiveSessionsRequest))
				{	soap_flag_ns1__GetActiveSessionsRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getActiveSessions * SOAP_FMAC2 soap_instantiate___ns1__getActiveSessions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getActiveSessions(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getActiveSessions *p;
	size_t k = sizeof(struct __ns1__getActiveSessions);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getActiveSessions);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getActiveSessions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getActiveSessions location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getActiveSessions, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getActiveSessions(struct soap *soap, const struct __ns1__getActiveSessions *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getActiveSessions(soap, tag?tag:"-ns1:getActiveSessions", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getActiveSessions * SOAP_FMAC4 soap_get___ns1__getActiveSessions(struct soap *soap, struct __ns1__getActiveSessions *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getActiveSessions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setEndpointDetails(struct soap *soap, struct __ns1__setEndpointDetails *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SetEndpointDetailsRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setEndpointDetails(struct soap *soap, const struct __ns1__setEndpointDetails *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SetEndpointDetailsRequest(soap, &a->ns1__SetEndpointDetailsRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setEndpointDetails(struct soap *soap, const char *tag, int id, const struct __ns1__setEndpointDetails *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SetEndpointDetailsRequest(soap, "ns1:SetEndpointDetailsRequest", -1, &a->ns1__SetEndpointDetailsRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setEndpointDetails * SOAP_FMAC4 soap_in___ns1__setEndpointDetails(struct soap *soap, const char *tag, struct __ns1__setEndpointDetails *a, const char *type)
{
	size_t soap_flag_ns1__SetEndpointDetailsRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__setEndpointDetails *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setEndpointDetails, sizeof(struct __ns1__setEndpointDetails), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setEndpointDetails(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SetEndpointDetailsRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SetEndpointDetailsRequest(soap, "ns1:SetEndpointDetailsRequest", &a->ns1__SetEndpointDetailsRequest, ""))
				{	soap_flag_ns1__SetEndpointDetailsRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__setEndpointDetails * SOAP_FMAC2 soap_instantiate___ns1__setEndpointDetails(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__setEndpointDetails(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__setEndpointDetails *p;
	size_t k = sizeof(struct __ns1__setEndpointDetails);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__setEndpointDetails);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__setEndpointDetails, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__setEndpointDetails location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__setEndpointDetails, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setEndpointDetails(struct soap *soap, const struct __ns1__setEndpointDetails *a, const char *tag, const char *type)
{
	if (soap_out___ns1__setEndpointDetails(soap, tag?tag:"-ns1:setEndpointDetails", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setEndpointDetails * SOAP_FMAC4 soap_get___ns1__setEndpointDetails(struct soap *soap, struct __ns1__setEndpointDetails *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setEndpointDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getPortalFeatures(struct soap *soap, struct __ns1__getPortalFeatures *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPortalFeaturesRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getPortalFeatures(struct soap *soap, const struct __ns1__getPortalFeatures *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getPortalFeatures(struct soap *soap, const char *tag, int id, const struct __ns1__getPortalFeatures *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	soap_outliteral(soap, "ns1:GetPortalFeaturesRequest", (char*const*)&a->ns1__GetPortalFeaturesRequest, NULL);
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPortalFeatures * SOAP_FMAC4 soap_in___ns1__getPortalFeatures(struct soap *soap, const char *tag, struct __ns1__getPortalFeatures *a, const char *type)
{
	size_t soap_flag_ns1__GetPortalFeaturesRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getPortalFeatures *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getPortalFeatures, sizeof(struct __ns1__getPortalFeatures), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getPortalFeatures(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPortalFeaturesRequest && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "ns1:GetPortalFeaturesRequest", (char**)&a->ns1__GetPortalFeaturesRequest))
				{	soap_flag_ns1__GetPortalFeaturesRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getPortalFeatures * SOAP_FMAC2 soap_instantiate___ns1__getPortalFeatures(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getPortalFeatures(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getPortalFeatures *p;
	size_t k = sizeof(struct __ns1__getPortalFeatures);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getPortalFeatures);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getPortalFeatures, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getPortalFeatures location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getPortalFeatures, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getPortalFeatures(struct soap *soap, const struct __ns1__getPortalFeatures *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getPortalFeatures(soap, tag?tag:"-ns1:getPortalFeatures", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPortalFeatures * SOAP_FMAC4 soap_get___ns1__getPortalFeatures(struct soap *soap, struct __ns1__getPortalFeatures *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getPortalFeatures(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deleteScheduledRoom(struct soap *soap, struct __ns1__deleteScheduledRoom *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DeleteScheduledRoomRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deleteScheduledRoom(struct soap *soap, const struct __ns1__deleteScheduledRoom *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__DeleteScheduledRoomRequest(soap, &a->ns1__DeleteScheduledRoomRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deleteScheduledRoom(struct soap *soap, const char *tag, int id, const struct __ns1__deleteScheduledRoom *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__DeleteScheduledRoomRequest(soap, "ns1:DeleteScheduledRoomRequest", -1, &a->ns1__DeleteScheduledRoomRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteScheduledRoom * SOAP_FMAC4 soap_in___ns1__deleteScheduledRoom(struct soap *soap, const char *tag, struct __ns1__deleteScheduledRoom *a, const char *type)
{
	size_t soap_flag_ns1__DeleteScheduledRoomRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__deleteScheduledRoom *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__deleteScheduledRoom, sizeof(struct __ns1__deleteScheduledRoom), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__deleteScheduledRoom(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DeleteScheduledRoomRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__DeleteScheduledRoomRequest(soap, "ns1:DeleteScheduledRoomRequest", &a->ns1__DeleteScheduledRoomRequest, ""))
				{	soap_flag_ns1__DeleteScheduledRoomRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__deleteScheduledRoom * SOAP_FMAC2 soap_instantiate___ns1__deleteScheduledRoom(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__deleteScheduledRoom(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__deleteScheduledRoom *p;
	size_t k = sizeof(struct __ns1__deleteScheduledRoom);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__deleteScheduledRoom);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__deleteScheduledRoom, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__deleteScheduledRoom location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__deleteScheduledRoom, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deleteScheduledRoom(struct soap *soap, const struct __ns1__deleteScheduledRoom *a, const char *tag, const char *type)
{
	if (soap_out___ns1__deleteScheduledRoom(soap, tag?tag:"-ns1:deleteScheduledRoom", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteScheduledRoom * SOAP_FMAC4 soap_get___ns1__deleteScheduledRoom(struct soap *soap, struct __ns1__deleteScheduledRoom *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__deleteScheduledRoom(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__createScheduledRoom(struct soap *soap, struct __ns1__createScheduledRoom *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CreateScheduledRoomRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__createScheduledRoom(struct soap *soap, const struct __ns1__createScheduledRoom *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CreateScheduledRoomRequest(soap, &a->ns1__CreateScheduledRoomRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__createScheduledRoom(struct soap *soap, const char *tag, int id, const struct __ns1__createScheduledRoom *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CreateScheduledRoomRequest(soap, "ns1:CreateScheduledRoomRequest", -1, &a->ns1__CreateScheduledRoomRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createScheduledRoom * SOAP_FMAC4 soap_in___ns1__createScheduledRoom(struct soap *soap, const char *tag, struct __ns1__createScheduledRoom *a, const char *type)
{
	size_t soap_flag_ns1__CreateScheduledRoomRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__createScheduledRoom *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__createScheduledRoom, sizeof(struct __ns1__createScheduledRoom), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__createScheduledRoom(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CreateScheduledRoomRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__CreateScheduledRoomRequest(soap, "ns1:CreateScheduledRoomRequest", &a->ns1__CreateScheduledRoomRequest, ""))
				{	soap_flag_ns1__CreateScheduledRoomRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__createScheduledRoom * SOAP_FMAC2 soap_instantiate___ns1__createScheduledRoom(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__createScheduledRoom(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__createScheduledRoom *p;
	size_t k = sizeof(struct __ns1__createScheduledRoom);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__createScheduledRoom);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__createScheduledRoom, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__createScheduledRoom location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__createScheduledRoom, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__createScheduledRoom(struct soap *soap, const struct __ns1__createScheduledRoom *a, const char *tag, const char *type)
{
	if (soap_out___ns1__createScheduledRoom(soap, tag?tag:"-ns1:createScheduledRoom", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createScheduledRoom * SOAP_FMAC4 soap_get___ns1__createScheduledRoom(struct soap *soap, struct __ns1__createScheduledRoom *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__createScheduledRoom(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__generateAuthToken(struct soap *soap, struct __ns1__generateAuthToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GenerateAuthTokenRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__generateAuthToken(struct soap *soap, const struct __ns1__generateAuthToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GenerateAuthTokenRequest(soap, &a->ns1__GenerateAuthTokenRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__generateAuthToken(struct soap *soap, const char *tag, int id, const struct __ns1__generateAuthToken *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GenerateAuthTokenRequest(soap, "ns1:GenerateAuthTokenRequest", -1, &a->ns1__GenerateAuthTokenRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__generateAuthToken * SOAP_FMAC4 soap_in___ns1__generateAuthToken(struct soap *soap, const char *tag, struct __ns1__generateAuthToken *a, const char *type)
{
	size_t soap_flag_ns1__GenerateAuthTokenRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__generateAuthToken *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__generateAuthToken, sizeof(struct __ns1__generateAuthToken), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__generateAuthToken(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GenerateAuthTokenRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GenerateAuthTokenRequest(soap, "ns1:GenerateAuthTokenRequest", &a->ns1__GenerateAuthTokenRequest, ""))
				{	soap_flag_ns1__GenerateAuthTokenRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__generateAuthToken * SOAP_FMAC2 soap_instantiate___ns1__generateAuthToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__generateAuthToken(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__generateAuthToken *p;
	size_t k = sizeof(struct __ns1__generateAuthToken);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__generateAuthToken);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__generateAuthToken, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__generateAuthToken location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__generateAuthToken, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__generateAuthToken(struct soap *soap, const struct __ns1__generateAuthToken *a, const char *tag, const char *type)
{
	if (soap_out___ns1__generateAuthToken(soap, tag?tag:"-ns1:generateAuthToken", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__generateAuthToken * SOAP_FMAC4 soap_get___ns1__generateAuthToken(struct soap *soap, struct __ns1__generateAuthToken *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__generateAuthToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getConferenceID(struct soap *soap, struct __ns1__getConferenceID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetConferenceIDRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getConferenceID(struct soap *soap, const struct __ns1__getConferenceID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetConferenceIDRequest(soap, &a->ns1__GetConferenceIDRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getConferenceID(struct soap *soap, const char *tag, int id, const struct __ns1__getConferenceID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetConferenceIDRequest(soap, "ns1:GetConferenceIDRequest", -1, &a->ns1__GetConferenceIDRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getConferenceID * SOAP_FMAC4 soap_in___ns1__getConferenceID(struct soap *soap, const char *tag, struct __ns1__getConferenceID *a, const char *type)
{
	size_t soap_flag_ns1__GetConferenceIDRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getConferenceID *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getConferenceID, sizeof(struct __ns1__getConferenceID), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getConferenceID(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetConferenceIDRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetConferenceIDRequest(soap, "ns1:GetConferenceIDRequest", &a->ns1__GetConferenceIDRequest, ""))
				{	soap_flag_ns1__GetConferenceIDRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getConferenceID * SOAP_FMAC2 soap_instantiate___ns1__getConferenceID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getConferenceID(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getConferenceID *p;
	size_t k = sizeof(struct __ns1__getConferenceID);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getConferenceID);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getConferenceID, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getConferenceID location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getConferenceID, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getConferenceID(struct soap *soap, const struct __ns1__getConferenceID *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getConferenceID(soap, tag?tag:"-ns1:getConferenceID", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getConferenceID * SOAP_FMAC4 soap_get___ns1__getConferenceID(struct soap *soap, struct __ns1__getConferenceID *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getConferenceID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeModeratorPIN(struct soap *soap, struct __ns1__removeModeratorPIN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RemoveModeratorPINRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeModeratorPIN(struct soap *soap, const struct __ns1__removeModeratorPIN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__RemoveModeratorPINRequest(soap, &a->ns1__RemoveModeratorPINRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeModeratorPIN(struct soap *soap, const char *tag, int id, const struct __ns1__removeModeratorPIN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__RemoveModeratorPINRequest(soap, "ns1:RemoveModeratorPINRequest", -1, &a->ns1__RemoveModeratorPINRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeModeratorPIN * SOAP_FMAC4 soap_in___ns1__removeModeratorPIN(struct soap *soap, const char *tag, struct __ns1__removeModeratorPIN *a, const char *type)
{
	size_t soap_flag_ns1__RemoveModeratorPINRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__removeModeratorPIN *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeModeratorPIN, sizeof(struct __ns1__removeModeratorPIN), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeModeratorPIN(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RemoveModeratorPINRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__RemoveModeratorPINRequest(soap, "ns1:RemoveModeratorPINRequest", &a->ns1__RemoveModeratorPINRequest, ""))
				{	soap_flag_ns1__RemoveModeratorPINRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__removeModeratorPIN * SOAP_FMAC2 soap_instantiate___ns1__removeModeratorPIN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeModeratorPIN(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__removeModeratorPIN *p;
	size_t k = sizeof(struct __ns1__removeModeratorPIN);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__removeModeratorPIN);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__removeModeratorPIN, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__removeModeratorPIN location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__removeModeratorPIN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeModeratorPIN(struct soap *soap, const struct __ns1__removeModeratorPIN *a, const char *tag, const char *type)
{
	if (soap_out___ns1__removeModeratorPIN(soap, tag?tag:"-ns1:removeModeratorPIN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeModeratorPIN * SOAP_FMAC4 soap_get___ns1__removeModeratorPIN(struct soap *soap, struct __ns1__removeModeratorPIN *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeModeratorPIN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__createModeratorPIN(struct soap *soap, struct __ns1__createModeratorPIN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CreateModeratorPINRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__createModeratorPIN(struct soap *soap, const struct __ns1__createModeratorPIN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CreateModeratorPINRequest(soap, &a->ns1__CreateModeratorPINRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__createModeratorPIN(struct soap *soap, const char *tag, int id, const struct __ns1__createModeratorPIN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CreateModeratorPINRequest(soap, "ns1:CreateModeratorPINRequest", -1, &a->ns1__CreateModeratorPINRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createModeratorPIN * SOAP_FMAC4 soap_in___ns1__createModeratorPIN(struct soap *soap, const char *tag, struct __ns1__createModeratorPIN *a, const char *type)
{
	size_t soap_flag_ns1__CreateModeratorPINRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__createModeratorPIN *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__createModeratorPIN, sizeof(struct __ns1__createModeratorPIN), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__createModeratorPIN(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CreateModeratorPINRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__CreateModeratorPINRequest(soap, "ns1:CreateModeratorPINRequest", &a->ns1__CreateModeratorPINRequest, ""))
				{	soap_flag_ns1__CreateModeratorPINRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__createModeratorPIN * SOAP_FMAC2 soap_instantiate___ns1__createModeratorPIN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__createModeratorPIN(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__createModeratorPIN *p;
	size_t k = sizeof(struct __ns1__createModeratorPIN);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__createModeratorPIN);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__createModeratorPIN, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__createModeratorPIN location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__createModeratorPIN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__createModeratorPIN(struct soap *soap, const struct __ns1__createModeratorPIN *a, const char *tag, const char *type)
{
	if (soap_out___ns1__createModeratorPIN(soap, tag?tag:"-ns1:createModeratorPIN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createModeratorPIN * SOAP_FMAC4 soap_get___ns1__createModeratorPIN(struct soap *soap, struct __ns1__createModeratorPIN *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__createModeratorPIN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getModeratorURLWithToken(struct soap *soap, struct __ns1__getModeratorURLWithToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetModeratorURLWithTokenRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getModeratorURLWithToken(struct soap *soap, const struct __ns1__getModeratorURLWithToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetModeratorURLWithTokenRequest(soap, &a->ns1__GetModeratorURLWithTokenRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getModeratorURLWithToken(struct soap *soap, const char *tag, int id, const struct __ns1__getModeratorURLWithToken *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetModeratorURLWithTokenRequest(soap, "ns1:GetModeratorURLWithTokenRequest", -1, &a->ns1__GetModeratorURLWithTokenRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getModeratorURLWithToken * SOAP_FMAC4 soap_in___ns1__getModeratorURLWithToken(struct soap *soap, const char *tag, struct __ns1__getModeratorURLWithToken *a, const char *type)
{
	size_t soap_flag_ns1__GetModeratorURLWithTokenRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getModeratorURLWithToken *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getModeratorURLWithToken, sizeof(struct __ns1__getModeratorURLWithToken), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getModeratorURLWithToken(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetModeratorURLWithTokenRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetModeratorURLWithTokenRequest(soap, "ns1:GetModeratorURLWithTokenRequest", &a->ns1__GetModeratorURLWithTokenRequest, ""))
				{	soap_flag_ns1__GetModeratorURLWithTokenRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getModeratorURLWithToken * SOAP_FMAC2 soap_instantiate___ns1__getModeratorURLWithToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getModeratorURLWithToken(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getModeratorURLWithToken *p;
	size_t k = sizeof(struct __ns1__getModeratorURLWithToken);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getModeratorURLWithToken);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getModeratorURLWithToken, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getModeratorURLWithToken location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getModeratorURLWithToken, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getModeratorURLWithToken(struct soap *soap, const struct __ns1__getModeratorURLWithToken *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getModeratorURLWithToken(soap, tag?tag:"-ns1:getModeratorURLWithToken", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getModeratorURLWithToken * SOAP_FMAC4 soap_get___ns1__getModeratorURLWithToken(struct soap *soap, struct __ns1__getModeratorURLWithToken *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getModeratorURLWithToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getModeratorURL(struct soap *soap, struct __ns1__getModeratorURL *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetModeratorURLRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getModeratorURL(struct soap *soap, const struct __ns1__getModeratorURL *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetModeratorURLRequest(soap, &a->ns1__GetModeratorURLRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getModeratorURL(struct soap *soap, const char *tag, int id, const struct __ns1__getModeratorURL *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetModeratorURLRequest(soap, "ns1:GetModeratorURLRequest", -1, &a->ns1__GetModeratorURLRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getModeratorURL * SOAP_FMAC4 soap_in___ns1__getModeratorURL(struct soap *soap, const char *tag, struct __ns1__getModeratorURL *a, const char *type)
{
	size_t soap_flag_ns1__GetModeratorURLRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getModeratorURL *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getModeratorURL, sizeof(struct __ns1__getModeratorURL), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getModeratorURL(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetModeratorURLRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetModeratorURLRequest(soap, "ns1:GetModeratorURLRequest", &a->ns1__GetModeratorURLRequest, ""))
				{	soap_flag_ns1__GetModeratorURLRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getModeratorURL * SOAP_FMAC2 soap_instantiate___ns1__getModeratorURL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getModeratorURL(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getModeratorURL *p;
	size_t k = sizeof(struct __ns1__getModeratorURL);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getModeratorURL);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getModeratorURL, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getModeratorURL location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getModeratorURL, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getModeratorURL(struct soap *soap, const struct __ns1__getModeratorURL *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getModeratorURL(soap, tag?tag:"-ns1:getModeratorURL", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getModeratorURL * SOAP_FMAC4 soap_get___ns1__getModeratorURL(struct soap *soap, struct __ns1__getModeratorURL *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getModeratorURL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeModeratorURL(struct soap *soap, struct __ns1__removeModeratorURL *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RemoveModeratorURLRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeModeratorURL(struct soap *soap, const struct __ns1__removeModeratorURL *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__RemoveModeratorURLRequest(soap, &a->ns1__RemoveModeratorURLRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeModeratorURL(struct soap *soap, const char *tag, int id, const struct __ns1__removeModeratorURL *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__RemoveModeratorURLRequest(soap, "ns1:RemoveModeratorURLRequest", -1, &a->ns1__RemoveModeratorURLRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeModeratorURL * SOAP_FMAC4 soap_in___ns1__removeModeratorURL(struct soap *soap, const char *tag, struct __ns1__removeModeratorURL *a, const char *type)
{
	size_t soap_flag_ns1__RemoveModeratorURLRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__removeModeratorURL *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeModeratorURL, sizeof(struct __ns1__removeModeratorURL), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeModeratorURL(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RemoveModeratorURLRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__RemoveModeratorURLRequest(soap, "ns1:RemoveModeratorURLRequest", &a->ns1__RemoveModeratorURLRequest, ""))
				{	soap_flag_ns1__RemoveModeratorURLRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__removeModeratorURL * SOAP_FMAC2 soap_instantiate___ns1__removeModeratorURL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeModeratorURL(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__removeModeratorURL *p;
	size_t k = sizeof(struct __ns1__removeModeratorURL);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__removeModeratorURL);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__removeModeratorURL, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__removeModeratorURL location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__removeModeratorURL, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeModeratorURL(struct soap *soap, const struct __ns1__removeModeratorURL *a, const char *tag, const char *type)
{
	if (soap_out___ns1__removeModeratorURL(soap, tag?tag:"-ns1:removeModeratorURL", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeModeratorURL * SOAP_FMAC4 soap_get___ns1__removeModeratorURL(struct soap *soap, struct __ns1__removeModeratorURL *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeModeratorURL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__createModeratorURL(struct soap *soap, struct __ns1__createModeratorURL *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CreateModeratorURLRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__createModeratorURL(struct soap *soap, const struct __ns1__createModeratorURL *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CreateModeratorURLRequest(soap, &a->ns1__CreateModeratorURLRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__createModeratorURL(struct soap *soap, const char *tag, int id, const struct __ns1__createModeratorURL *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CreateModeratorURLRequest(soap, "ns1:CreateModeratorURLRequest", -1, &a->ns1__CreateModeratorURLRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createModeratorURL * SOAP_FMAC4 soap_in___ns1__createModeratorURL(struct soap *soap, const char *tag, struct __ns1__createModeratorURL *a, const char *type)
{
	size_t soap_flag_ns1__CreateModeratorURLRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__createModeratorURL *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__createModeratorURL, sizeof(struct __ns1__createModeratorURL), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__createModeratorURL(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CreateModeratorURLRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__CreateModeratorURLRequest(soap, "ns1:CreateModeratorURLRequest", &a->ns1__CreateModeratorURLRequest, ""))
				{	soap_flag_ns1__CreateModeratorURLRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__createModeratorURL * SOAP_FMAC2 soap_instantiate___ns1__createModeratorURL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__createModeratorURL(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__createModeratorURL *p;
	size_t k = sizeof(struct __ns1__createModeratorURL);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__createModeratorURL);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__createModeratorURL, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__createModeratorURL location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__createModeratorURL, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__createModeratorURL(struct soap *soap, const struct __ns1__createModeratorURL *a, const char *tag, const char *type)
{
	if (soap_out___ns1__createModeratorURL(soap, tag?tag:"-ns1:createModeratorURL", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createModeratorURL * SOAP_FMAC4 soap_get___ns1__createModeratorURL(struct soap *soap, struct __ns1__createModeratorURL *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__createModeratorURL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeRoomProfile(struct soap *soap, struct __ns1__removeRoomProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RemoveRoomProfileRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeRoomProfile(struct soap *soap, const struct __ns1__removeRoomProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__RemoveRoomProfileRequest(soap, &a->ns1__RemoveRoomProfileRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeRoomProfile(struct soap *soap, const char *tag, int id, const struct __ns1__removeRoomProfile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__RemoveRoomProfileRequest(soap, "ns1:RemoveRoomProfileRequest", -1, &a->ns1__RemoveRoomProfileRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeRoomProfile * SOAP_FMAC4 soap_in___ns1__removeRoomProfile(struct soap *soap, const char *tag, struct __ns1__removeRoomProfile *a, const char *type)
{
	size_t soap_flag_ns1__RemoveRoomProfileRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__removeRoomProfile *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeRoomProfile, sizeof(struct __ns1__removeRoomProfile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeRoomProfile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RemoveRoomProfileRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__RemoveRoomProfileRequest(soap, "ns1:RemoveRoomProfileRequest", &a->ns1__RemoveRoomProfileRequest, ""))
				{	soap_flag_ns1__RemoveRoomProfileRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__removeRoomProfile * SOAP_FMAC2 soap_instantiate___ns1__removeRoomProfile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeRoomProfile(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__removeRoomProfile *p;
	size_t k = sizeof(struct __ns1__removeRoomProfile);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__removeRoomProfile);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__removeRoomProfile, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__removeRoomProfile location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__removeRoomProfile, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeRoomProfile(struct soap *soap, const struct __ns1__removeRoomProfile *a, const char *tag, const char *type)
{
	if (soap_out___ns1__removeRoomProfile(soap, tag?tag:"-ns1:removeRoomProfile", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeRoomProfile * SOAP_FMAC4 soap_get___ns1__removeRoomProfile(struct soap *soap, struct __ns1__removeRoomProfile *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeRoomProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setRoomProfile(struct soap *soap, struct __ns1__setRoomProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SetRoomProfileRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setRoomProfile(struct soap *soap, const struct __ns1__setRoomProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SetRoomProfileRequest(soap, &a->ns1__SetRoomProfileRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setRoomProfile(struct soap *soap, const char *tag, int id, const struct __ns1__setRoomProfile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SetRoomProfileRequest(soap, "ns1:SetRoomProfileRequest", -1, &a->ns1__SetRoomProfileRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setRoomProfile * SOAP_FMAC4 soap_in___ns1__setRoomProfile(struct soap *soap, const char *tag, struct __ns1__setRoomProfile *a, const char *type)
{
	size_t soap_flag_ns1__SetRoomProfileRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__setRoomProfile *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setRoomProfile, sizeof(struct __ns1__setRoomProfile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setRoomProfile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SetRoomProfileRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SetRoomProfileRequest(soap, "ns1:SetRoomProfileRequest", &a->ns1__SetRoomProfileRequest, ""))
				{	soap_flag_ns1__SetRoomProfileRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__setRoomProfile * SOAP_FMAC2 soap_instantiate___ns1__setRoomProfile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__setRoomProfile(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__setRoomProfile *p;
	size_t k = sizeof(struct __ns1__setRoomProfile);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__setRoomProfile);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__setRoomProfile, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__setRoomProfile location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__setRoomProfile, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setRoomProfile(struct soap *soap, const struct __ns1__setRoomProfile *a, const char *tag, const char *type)
{
	if (soap_out___ns1__setRoomProfile(soap, tag?tag:"-ns1:setRoomProfile", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setRoomProfile * SOAP_FMAC4 soap_get___ns1__setRoomProfile(struct soap *soap, struct __ns1__setRoomProfile *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setRoomProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getRoomProfile(struct soap *soap, struct __ns1__getRoomProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetRoomProfileRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getRoomProfile(struct soap *soap, const struct __ns1__getRoomProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetRoomProfileRequest(soap, &a->ns1__GetRoomProfileRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getRoomProfile(struct soap *soap, const char *tag, int id, const struct __ns1__getRoomProfile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetRoomProfileRequest(soap, "ns1:GetRoomProfileRequest", -1, &a->ns1__GetRoomProfileRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getRoomProfile * SOAP_FMAC4 soap_in___ns1__getRoomProfile(struct soap *soap, const char *tag, struct __ns1__getRoomProfile *a, const char *type)
{
	size_t soap_flag_ns1__GetRoomProfileRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getRoomProfile *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getRoomProfile, sizeof(struct __ns1__getRoomProfile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getRoomProfile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetRoomProfileRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetRoomProfileRequest(soap, "ns1:GetRoomProfileRequest", &a->ns1__GetRoomProfileRequest, ""))
				{	soap_flag_ns1__GetRoomProfileRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getRoomProfile * SOAP_FMAC2 soap_instantiate___ns1__getRoomProfile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getRoomProfile(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getRoomProfile *p;
	size_t k = sizeof(struct __ns1__getRoomProfile);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getRoomProfile);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getRoomProfile, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getRoomProfile location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getRoomProfile, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getRoomProfile(struct soap *soap, const struct __ns1__getRoomProfile *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getRoomProfile(soap, tag?tag:"-ns1:getRoomProfile", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getRoomProfile * SOAP_FMAC4 soap_get___ns1__getRoomProfile(struct soap *soap, struct __ns1__getRoomProfile *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getRoomProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getRoomProfiles(struct soap *soap, struct __ns1__getRoomProfiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetRoomProfilesRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getRoomProfiles(struct soap *soap, const struct __ns1__getRoomProfiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getRoomProfiles(struct soap *soap, const char *tag, int id, const struct __ns1__getRoomProfiles *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	soap_outliteral(soap, "ns1:GetRoomProfilesRequest", (char*const*)&a->ns1__GetRoomProfilesRequest, NULL);
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getRoomProfiles * SOAP_FMAC4 soap_in___ns1__getRoomProfiles(struct soap *soap, const char *tag, struct __ns1__getRoomProfiles *a, const char *type)
{
	size_t soap_flag_ns1__GetRoomProfilesRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getRoomProfiles *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getRoomProfiles, sizeof(struct __ns1__getRoomProfiles), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getRoomProfiles(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetRoomProfilesRequest && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "ns1:GetRoomProfilesRequest", (char**)&a->ns1__GetRoomProfilesRequest))
				{	soap_flag_ns1__GetRoomProfilesRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getRoomProfiles * SOAP_FMAC2 soap_instantiate___ns1__getRoomProfiles(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getRoomProfiles(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getRoomProfiles *p;
	size_t k = sizeof(struct __ns1__getRoomProfiles);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getRoomProfiles);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getRoomProfiles, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getRoomProfiles location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getRoomProfiles, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getRoomProfiles(struct soap *soap, const struct __ns1__getRoomProfiles *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getRoomProfiles(soap, tag?tag:"-ns1:getRoomProfiles", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getRoomProfiles * SOAP_FMAC4 soap_get___ns1__getRoomProfiles(struct soap *soap, struct __ns1__getRoomProfiles *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getRoomProfiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getInviteContent(struct soap *soap, struct __ns1__getInviteContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetInviteContentRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getInviteContent(struct soap *soap, const struct __ns1__getInviteContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetInviteContentRequest(soap, &a->ns1__GetInviteContentRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getInviteContent(struct soap *soap, const char *tag, int id, const struct __ns1__getInviteContent *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetInviteContentRequest(soap, "ns1:GetInviteContentRequest", -1, &a->ns1__GetInviteContentRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getInviteContent * SOAP_FMAC4 soap_in___ns1__getInviteContent(struct soap *soap, const char *tag, struct __ns1__getInviteContent *a, const char *type)
{
	size_t soap_flag_ns1__GetInviteContentRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getInviteContent *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getInviteContent, sizeof(struct __ns1__getInviteContent), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getInviteContent(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetInviteContentRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetInviteContentRequest(soap, "ns1:GetInviteContentRequest", &a->ns1__GetInviteContentRequest, ""))
				{	soap_flag_ns1__GetInviteContentRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getInviteContent * SOAP_FMAC2 soap_instantiate___ns1__getInviteContent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getInviteContent(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getInviteContent *p;
	size_t k = sizeof(struct __ns1__getInviteContent);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getInviteContent);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getInviteContent, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getInviteContent location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getInviteContent, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getInviteContent(struct soap *soap, const struct __ns1__getInviteContent *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getInviteContent(soap, tag?tag:"-ns1:getInviteContent", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getInviteContent * SOAP_FMAC4 soap_get___ns1__getInviteContent(struct soap *soap, struct __ns1__getInviteContent *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getInviteContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getEntityByRoomKey(struct soap *soap, struct __ns1__getEntityByRoomKey *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetEntityByRoomKeyRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getEntityByRoomKey(struct soap *soap, const struct __ns1__getEntityByRoomKey *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetEntityByRoomKeyRequest(soap, &a->ns1__GetEntityByRoomKeyRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getEntityByRoomKey(struct soap *soap, const char *tag, int id, const struct __ns1__getEntityByRoomKey *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetEntityByRoomKeyRequest(soap, "ns1:GetEntityByRoomKeyRequest", -1, &a->ns1__GetEntityByRoomKeyRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getEntityByRoomKey * SOAP_FMAC4 soap_in___ns1__getEntityByRoomKey(struct soap *soap, const char *tag, struct __ns1__getEntityByRoomKey *a, const char *type)
{
	size_t soap_flag_ns1__GetEntityByRoomKeyRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getEntityByRoomKey *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getEntityByRoomKey, sizeof(struct __ns1__getEntityByRoomKey), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getEntityByRoomKey(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetEntityByRoomKeyRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetEntityByRoomKeyRequest(soap, "ns1:GetEntityByRoomKeyRequest", &a->ns1__GetEntityByRoomKeyRequest, ""))
				{	soap_flag_ns1__GetEntityByRoomKeyRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getEntityByRoomKey * SOAP_FMAC2 soap_instantiate___ns1__getEntityByRoomKey(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getEntityByRoomKey(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getEntityByRoomKey *p;
	size_t k = sizeof(struct __ns1__getEntityByRoomKey);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getEntityByRoomKey);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getEntityByRoomKey, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getEntityByRoomKey location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getEntityByRoomKey, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getEntityByRoomKey(struct soap *soap, const struct __ns1__getEntityByRoomKey *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getEntityByRoomKey(soap, tag?tag:"-ns1:getEntityByRoomKey", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getEntityByRoomKey * SOAP_FMAC4 soap_get___ns1__getEntityByRoomKey(struct soap *soap, struct __ns1__getEntityByRoomKey *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getEntityByRoomKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getUserName(struct soap *soap, struct __ns1__getUserName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetUserNameRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getUserName(struct soap *soap, const struct __ns1__getUserName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetUserNameRequest(soap, &a->ns1__GetUserNameRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getUserName(struct soap *soap, const char *tag, int id, const struct __ns1__getUserName *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetUserNameRequest(soap, "ns1:GetUserNameRequest", -1, &a->ns1__GetUserNameRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getUserName * SOAP_FMAC4 soap_in___ns1__getUserName(struct soap *soap, const char *tag, struct __ns1__getUserName *a, const char *type)
{
	size_t soap_flag_ns1__GetUserNameRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getUserName *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getUserName, sizeof(struct __ns1__getUserName), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getUserName(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetUserNameRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetUserNameRequest(soap, "ns1:GetUserNameRequest", &a->ns1__GetUserNameRequest, ""))
				{	soap_flag_ns1__GetUserNameRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getUserName * SOAP_FMAC2 soap_instantiate___ns1__getUserName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getUserName(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getUserName *p;
	size_t k = sizeof(struct __ns1__getUserName);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getUserName);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getUserName, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getUserName location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getUserName, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getUserName(struct soap *soap, const struct __ns1__getUserName *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getUserName(soap, tag?tag:"-ns1:getUserName", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getUserName * SOAP_FMAC4 soap_get___ns1__getUserName(struct soap *soap, struct __ns1__getUserName *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getUserName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getWebcastURL(struct soap *soap, struct __ns1__getWebcastURL *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetWebcastURLRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getWebcastURL(struct soap *soap, const struct __ns1__getWebcastURL *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetWebcastURLRequest(soap, &a->ns1__GetWebcastURLRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getWebcastURL(struct soap *soap, const char *tag, int id, const struct __ns1__getWebcastURL *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetWebcastURLRequest(soap, "ns1:GetWebcastURLRequest", -1, &a->ns1__GetWebcastURLRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getWebcastURL * SOAP_FMAC4 soap_in___ns1__getWebcastURL(struct soap *soap, const char *tag, struct __ns1__getWebcastURL *a, const char *type)
{
	size_t soap_flag_ns1__GetWebcastURLRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getWebcastURL *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getWebcastURL, sizeof(struct __ns1__getWebcastURL), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getWebcastURL(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetWebcastURLRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetWebcastURLRequest(soap, "ns1:GetWebcastURLRequest", &a->ns1__GetWebcastURLRequest, ""))
				{	soap_flag_ns1__GetWebcastURLRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getWebcastURL * SOAP_FMAC2 soap_instantiate___ns1__getWebcastURL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getWebcastURL(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getWebcastURL *p;
	size_t k = sizeof(struct __ns1__getWebcastURL);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getWebcastURL);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getWebcastURL, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getWebcastURL location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getWebcastURL, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getWebcastURL(struct soap *soap, const struct __ns1__getWebcastURL *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getWebcastURL(soap, tag?tag:"-ns1:getWebcastURL", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getWebcastURL * SOAP_FMAC4 soap_get___ns1__getWebcastURL(struct soap *soap, struct __ns1__getWebcastURL *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getWebcastURL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeWebcastPIN(struct soap *soap, struct __ns1__removeWebcastPIN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RemoveWebcastPINRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeWebcastPIN(struct soap *soap, const struct __ns1__removeWebcastPIN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__RemoveWebcastPINRequest(soap, &a->ns1__RemoveWebcastPINRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeWebcastPIN(struct soap *soap, const char *tag, int id, const struct __ns1__removeWebcastPIN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__RemoveWebcastPINRequest(soap, "ns1:RemoveWebcastPINRequest", -1, &a->ns1__RemoveWebcastPINRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeWebcastPIN * SOAP_FMAC4 soap_in___ns1__removeWebcastPIN(struct soap *soap, const char *tag, struct __ns1__removeWebcastPIN *a, const char *type)
{
	size_t soap_flag_ns1__RemoveWebcastPINRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__removeWebcastPIN *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeWebcastPIN, sizeof(struct __ns1__removeWebcastPIN), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeWebcastPIN(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RemoveWebcastPINRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__RemoveWebcastPINRequest(soap, "ns1:RemoveWebcastPINRequest", &a->ns1__RemoveWebcastPINRequest, ""))
				{	soap_flag_ns1__RemoveWebcastPINRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__removeWebcastPIN * SOAP_FMAC2 soap_instantiate___ns1__removeWebcastPIN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeWebcastPIN(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__removeWebcastPIN *p;
	size_t k = sizeof(struct __ns1__removeWebcastPIN);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__removeWebcastPIN);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__removeWebcastPIN, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__removeWebcastPIN location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__removeWebcastPIN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeWebcastPIN(struct soap *soap, const struct __ns1__removeWebcastPIN *a, const char *tag, const char *type)
{
	if (soap_out___ns1__removeWebcastPIN(soap, tag?tag:"-ns1:removeWebcastPIN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeWebcastPIN * SOAP_FMAC4 soap_get___ns1__removeWebcastPIN(struct soap *soap, struct __ns1__removeWebcastPIN *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeWebcastPIN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeWebcastURL(struct soap *soap, struct __ns1__removeWebcastURL *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RemoveWebcastURLRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeWebcastURL(struct soap *soap, const struct __ns1__removeWebcastURL *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__RemoveWebcastURLRequest(soap, &a->ns1__RemoveWebcastURLRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeWebcastURL(struct soap *soap, const char *tag, int id, const struct __ns1__removeWebcastURL *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__RemoveWebcastURLRequest(soap, "ns1:RemoveWebcastURLRequest", -1, &a->ns1__RemoveWebcastURLRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeWebcastURL * SOAP_FMAC4 soap_in___ns1__removeWebcastURL(struct soap *soap, const char *tag, struct __ns1__removeWebcastURL *a, const char *type)
{
	size_t soap_flag_ns1__RemoveWebcastURLRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__removeWebcastURL *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeWebcastURL, sizeof(struct __ns1__removeWebcastURL), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeWebcastURL(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RemoveWebcastURLRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__RemoveWebcastURLRequest(soap, "ns1:RemoveWebcastURLRequest", &a->ns1__RemoveWebcastURLRequest, ""))
				{	soap_flag_ns1__RemoveWebcastURLRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__removeWebcastURL * SOAP_FMAC2 soap_instantiate___ns1__removeWebcastURL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeWebcastURL(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__removeWebcastURL *p;
	size_t k = sizeof(struct __ns1__removeWebcastURL);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__removeWebcastURL);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__removeWebcastURL, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__removeWebcastURL location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__removeWebcastURL, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeWebcastURL(struct soap *soap, const struct __ns1__removeWebcastURL *a, const char *tag, const char *type)
{
	if (soap_out___ns1__removeWebcastURL(soap, tag?tag:"-ns1:removeWebcastURL", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeWebcastURL * SOAP_FMAC4 soap_get___ns1__removeWebcastURL(struct soap *soap, struct __ns1__removeWebcastURL *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeWebcastURL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__createWebcastPIN(struct soap *soap, struct __ns1__createWebcastPIN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CreateWebcastPINRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__createWebcastPIN(struct soap *soap, const struct __ns1__createWebcastPIN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CreateWebcastPINRequest(soap, &a->ns1__CreateWebcastPINRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__createWebcastPIN(struct soap *soap, const char *tag, int id, const struct __ns1__createWebcastPIN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CreateWebcastPINRequest(soap, "ns1:CreateWebcastPINRequest", -1, &a->ns1__CreateWebcastPINRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createWebcastPIN * SOAP_FMAC4 soap_in___ns1__createWebcastPIN(struct soap *soap, const char *tag, struct __ns1__createWebcastPIN *a, const char *type)
{
	size_t soap_flag_ns1__CreateWebcastPINRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__createWebcastPIN *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__createWebcastPIN, sizeof(struct __ns1__createWebcastPIN), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__createWebcastPIN(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CreateWebcastPINRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__CreateWebcastPINRequest(soap, "ns1:CreateWebcastPINRequest", &a->ns1__CreateWebcastPINRequest, ""))
				{	soap_flag_ns1__CreateWebcastPINRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__createWebcastPIN * SOAP_FMAC2 soap_instantiate___ns1__createWebcastPIN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__createWebcastPIN(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__createWebcastPIN *p;
	size_t k = sizeof(struct __ns1__createWebcastPIN);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__createWebcastPIN);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__createWebcastPIN, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__createWebcastPIN location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__createWebcastPIN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__createWebcastPIN(struct soap *soap, const struct __ns1__createWebcastPIN *a, const char *tag, const char *type)
{
	if (soap_out___ns1__createWebcastPIN(soap, tag?tag:"-ns1:createWebcastPIN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createWebcastPIN * SOAP_FMAC4 soap_get___ns1__createWebcastPIN(struct soap *soap, struct __ns1__createWebcastPIN *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__createWebcastPIN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__createWebcastURL(struct soap *soap, struct __ns1__createWebcastURL *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CreateWebcastURLRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__createWebcastURL(struct soap *soap, const struct __ns1__createWebcastURL *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CreateWebcastURLRequest(soap, &a->ns1__CreateWebcastURLRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__createWebcastURL(struct soap *soap, const char *tag, int id, const struct __ns1__createWebcastURL *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CreateWebcastURLRequest(soap, "ns1:CreateWebcastURLRequest", -1, &a->ns1__CreateWebcastURLRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createWebcastURL * SOAP_FMAC4 soap_in___ns1__createWebcastURL(struct soap *soap, const char *tag, struct __ns1__createWebcastURL *a, const char *type)
{
	size_t soap_flag_ns1__CreateWebcastURLRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__createWebcastURL *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__createWebcastURL, sizeof(struct __ns1__createWebcastURL), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__createWebcastURL(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CreateWebcastURLRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__CreateWebcastURLRequest(soap, "ns1:CreateWebcastURLRequest", &a->ns1__CreateWebcastURLRequest, ""))
				{	soap_flag_ns1__CreateWebcastURLRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__createWebcastURL * SOAP_FMAC2 soap_instantiate___ns1__createWebcastURL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__createWebcastURL(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__createWebcastURL *p;
	size_t k = sizeof(struct __ns1__createWebcastURL);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__createWebcastURL);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__createWebcastURL, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__createWebcastURL location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__createWebcastURL, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__createWebcastURL(struct soap *soap, const struct __ns1__createWebcastURL *a, const char *tag, const char *type)
{
	if (soap_out___ns1__createWebcastURL(soap, tag?tag:"-ns1:createWebcastURL", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createWebcastURL * SOAP_FMAC4 soap_get___ns1__createWebcastURL(struct soap *soap, struct __ns1__createWebcastURL *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__createWebcastURL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__stopRecording(struct soap *soap, struct __ns1__stopRecording *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__StopRecordingRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__stopRecording(struct soap *soap, const struct __ns1__stopRecording *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__StopRecordingRequest(soap, &a->ns1__StopRecordingRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__stopRecording(struct soap *soap, const char *tag, int id, const struct __ns1__stopRecording *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__StopRecordingRequest(soap, "ns1:StopRecordingRequest", -1, &a->ns1__StopRecordingRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__stopRecording * SOAP_FMAC4 soap_in___ns1__stopRecording(struct soap *soap, const char *tag, struct __ns1__stopRecording *a, const char *type)
{
	size_t soap_flag_ns1__StopRecordingRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__stopRecording *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__stopRecording, sizeof(struct __ns1__stopRecording), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__stopRecording(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__StopRecordingRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__StopRecordingRequest(soap, "ns1:StopRecordingRequest", &a->ns1__StopRecordingRequest, ""))
				{	soap_flag_ns1__StopRecordingRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__stopRecording * SOAP_FMAC2 soap_instantiate___ns1__stopRecording(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__stopRecording(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__stopRecording *p;
	size_t k = sizeof(struct __ns1__stopRecording);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__stopRecording);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__stopRecording, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__stopRecording location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__stopRecording, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__stopRecording(struct soap *soap, const struct __ns1__stopRecording *a, const char *tag, const char *type)
{
	if (soap_out___ns1__stopRecording(soap, tag?tag:"-ns1:stopRecording", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__stopRecording * SOAP_FMAC4 soap_get___ns1__stopRecording(struct soap *soap, struct __ns1__stopRecording *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__stopRecording(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__resumeRecording(struct soap *soap, struct __ns1__resumeRecording *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ResumeRecordingRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__resumeRecording(struct soap *soap, const struct __ns1__resumeRecording *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ResumeRecordingRequest(soap, &a->ns1__ResumeRecordingRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__resumeRecording(struct soap *soap, const char *tag, int id, const struct __ns1__resumeRecording *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ResumeRecordingRequest(soap, "ns1:ResumeRecordingRequest", -1, &a->ns1__ResumeRecordingRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__resumeRecording * SOAP_FMAC4 soap_in___ns1__resumeRecording(struct soap *soap, const char *tag, struct __ns1__resumeRecording *a, const char *type)
{
	size_t soap_flag_ns1__ResumeRecordingRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__resumeRecording *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__resumeRecording, sizeof(struct __ns1__resumeRecording), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__resumeRecording(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ResumeRecordingRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__ResumeRecordingRequest(soap, "ns1:ResumeRecordingRequest", &a->ns1__ResumeRecordingRequest, ""))
				{	soap_flag_ns1__ResumeRecordingRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__resumeRecording * SOAP_FMAC2 soap_instantiate___ns1__resumeRecording(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__resumeRecording(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__resumeRecording *p;
	size_t k = sizeof(struct __ns1__resumeRecording);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__resumeRecording);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__resumeRecording, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__resumeRecording location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__resumeRecording, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__resumeRecording(struct soap *soap, const struct __ns1__resumeRecording *a, const char *tag, const char *type)
{
	if (soap_out___ns1__resumeRecording(soap, tag?tag:"-ns1:resumeRecording", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__resumeRecording * SOAP_FMAC4 soap_get___ns1__resumeRecording(struct soap *soap, struct __ns1__resumeRecording *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__resumeRecording(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__pauseRecording(struct soap *soap, struct __ns1__pauseRecording *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__PauseRecordingRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__pauseRecording(struct soap *soap, const struct __ns1__pauseRecording *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__PauseRecordingRequest(soap, &a->ns1__PauseRecordingRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__pauseRecording(struct soap *soap, const char *tag, int id, const struct __ns1__pauseRecording *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__PauseRecordingRequest(soap, "ns1:PauseRecordingRequest", -1, &a->ns1__PauseRecordingRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__pauseRecording * SOAP_FMAC4 soap_in___ns1__pauseRecording(struct soap *soap, const char *tag, struct __ns1__pauseRecording *a, const char *type)
{
	size_t soap_flag_ns1__PauseRecordingRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__pauseRecording *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__pauseRecording, sizeof(struct __ns1__pauseRecording), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__pauseRecording(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__PauseRecordingRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__PauseRecordingRequest(soap, "ns1:PauseRecordingRequest", &a->ns1__PauseRecordingRequest, ""))
				{	soap_flag_ns1__PauseRecordingRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__pauseRecording * SOAP_FMAC2 soap_instantiate___ns1__pauseRecording(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__pauseRecording(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__pauseRecording *p;
	size_t k = sizeof(struct __ns1__pauseRecording);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__pauseRecording);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__pauseRecording, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__pauseRecording location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__pauseRecording, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__pauseRecording(struct soap *soap, const struct __ns1__pauseRecording *a, const char *tag, const char *type)
{
	if (soap_out___ns1__pauseRecording(soap, tag?tag:"-ns1:pauseRecording", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__pauseRecording * SOAP_FMAC4 soap_get___ns1__pauseRecording(struct soap *soap, struct __ns1__pauseRecording *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__pauseRecording(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getPortalVersion(struct soap *soap, struct __ns1__getPortalVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPortalVersionRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getPortalVersion(struct soap *soap, const struct __ns1__getPortalVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetPortalVersionRequest(soap, &a->ns1__GetPortalVersionRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getPortalVersion(struct soap *soap, const char *tag, int id, const struct __ns1__getPortalVersion *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetPortalVersionRequest(soap, "ns1:GetPortalVersionRequest", -1, &a->ns1__GetPortalVersionRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPortalVersion * SOAP_FMAC4 soap_in___ns1__getPortalVersion(struct soap *soap, const char *tag, struct __ns1__getPortalVersion *a, const char *type)
{
	size_t soap_flag_ns1__GetPortalVersionRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getPortalVersion *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getPortalVersion, sizeof(struct __ns1__getPortalVersion), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getPortalVersion(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPortalVersionRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPortalVersionRequest(soap, "ns1:GetPortalVersionRequest", &a->ns1__GetPortalVersionRequest, ""))
				{	soap_flag_ns1__GetPortalVersionRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getPortalVersion * SOAP_FMAC2 soap_instantiate___ns1__getPortalVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getPortalVersion(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getPortalVersion *p;
	size_t k = sizeof(struct __ns1__getPortalVersion);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getPortalVersion);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getPortalVersion, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getPortalVersion location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getPortalVersion, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getPortalVersion(struct soap *soap, const struct __ns1__getPortalVersion *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getPortalVersion(soap, tag?tag:"-ns1:getPortalVersion", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPortalVersion * SOAP_FMAC4 soap_get___ns1__getPortalVersion(struct soap *soap, struct __ns1__getPortalVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getPortalVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__startRecording(struct soap *soap, struct __ns1__startRecording *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__StartRecordingRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__startRecording(struct soap *soap, const struct __ns1__startRecording *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__StartRecordingRequest(soap, &a->ns1__StartRecordingRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__startRecording(struct soap *soap, const char *tag, int id, const struct __ns1__startRecording *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__StartRecordingRequest(soap, "ns1:StartRecordingRequest", -1, &a->ns1__StartRecordingRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__startRecording * SOAP_FMAC4 soap_in___ns1__startRecording(struct soap *soap, const char *tag, struct __ns1__startRecording *a, const char *type)
{
	size_t soap_flag_ns1__StartRecordingRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__startRecording *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__startRecording, sizeof(struct __ns1__startRecording), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__startRecording(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__StartRecordingRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__StartRecordingRequest(soap, "ns1:StartRecordingRequest", &a->ns1__StartRecordingRequest, ""))
				{	soap_flag_ns1__StartRecordingRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__startRecording * SOAP_FMAC2 soap_instantiate___ns1__startRecording(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__startRecording(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__startRecording *p;
	size_t k = sizeof(struct __ns1__startRecording);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__startRecording);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__startRecording, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__startRecording location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__startRecording, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__startRecording(struct soap *soap, const struct __ns1__startRecording *a, const char *tag, const char *type)
{
	if (soap_out___ns1__startRecording(soap, tag?tag:"-ns1:startRecording", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__startRecording * SOAP_FMAC4 soap_get___ns1__startRecording(struct soap *soap, struct __ns1__startRecording *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__startRecording(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getRecordingProfiles(struct soap *soap, struct __ns1__getRecordingProfiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetRecordingProfilesRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getRecordingProfiles(struct soap *soap, const struct __ns1__getRecordingProfiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetRecordingProfilesRequest(soap, &a->ns1__GetRecordingProfilesRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getRecordingProfiles(struct soap *soap, const char *tag, int id, const struct __ns1__getRecordingProfiles *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetRecordingProfilesRequest(soap, "ns1:GetRecordingProfilesRequest", -1, &a->ns1__GetRecordingProfilesRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getRecordingProfiles * SOAP_FMAC4 soap_in___ns1__getRecordingProfiles(struct soap *soap, const char *tag, struct __ns1__getRecordingProfiles *a, const char *type)
{
	size_t soap_flag_ns1__GetRecordingProfilesRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getRecordingProfiles *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getRecordingProfiles, sizeof(struct __ns1__getRecordingProfiles), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getRecordingProfiles(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetRecordingProfilesRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetRecordingProfilesRequest(soap, "ns1:GetRecordingProfilesRequest", &a->ns1__GetRecordingProfilesRequest, ""))
				{	soap_flag_ns1__GetRecordingProfilesRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getRecordingProfiles * SOAP_FMAC2 soap_instantiate___ns1__getRecordingProfiles(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getRecordingProfiles(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getRecordingProfiles *p;
	size_t k = sizeof(struct __ns1__getRecordingProfiles);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getRecordingProfiles);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getRecordingProfiles, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getRecordingProfiles location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getRecordingProfiles, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getRecordingProfiles(struct soap *soap, const struct __ns1__getRecordingProfiles *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getRecordingProfiles(soap, tag?tag:"-ns1:getRecordingProfiles", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getRecordingProfiles * SOAP_FMAC4 soap_get___ns1__getRecordingProfiles(struct soap *soap, struct __ns1__getRecordingProfiles *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getRecordingProfiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setMemberMode(struct soap *soap, struct __ns1__setMemberMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SetMemberModeRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setMemberMode(struct soap *soap, const struct __ns1__setMemberMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SetMemberModeRequest(soap, &a->ns1__SetMemberModeRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setMemberMode(struct soap *soap, const char *tag, int id, const struct __ns1__setMemberMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SetMemberModeRequest(soap, "ns1:SetMemberModeRequest", -1, &a->ns1__SetMemberModeRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setMemberMode * SOAP_FMAC4 soap_in___ns1__setMemberMode(struct soap *soap, const char *tag, struct __ns1__setMemberMode *a, const char *type)
{
	size_t soap_flag_ns1__SetMemberModeRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__setMemberMode *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setMemberMode, sizeof(struct __ns1__setMemberMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setMemberMode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SetMemberModeRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SetMemberModeRequest(soap, "ns1:SetMemberModeRequest", &a->ns1__SetMemberModeRequest, ""))
				{	soap_flag_ns1__SetMemberModeRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__setMemberMode * SOAP_FMAC2 soap_instantiate___ns1__setMemberMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__setMemberMode(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__setMemberMode *p;
	size_t k = sizeof(struct __ns1__setMemberMode);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__setMemberMode);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__setMemberMode, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__setMemberMode location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__setMemberMode, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setMemberMode(struct soap *soap, const struct __ns1__setMemberMode *a, const char *tag, const char *type)
{
	if (soap_out___ns1__setMemberMode(soap, tag?tag:"-ns1:setMemberMode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setMemberMode * SOAP_FMAC4 soap_get___ns1__setMemberMode(struct soap *soap, struct __ns1__setMemberMode *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setMemberMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__unlockRoom(struct soap *soap, struct __ns1__unlockRoom *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UnlockRoomRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__unlockRoom(struct soap *soap, const struct __ns1__unlockRoom *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__UnlockRoomRequest(soap, &a->ns1__UnlockRoomRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__unlockRoom(struct soap *soap, const char *tag, int id, const struct __ns1__unlockRoom *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__UnlockRoomRequest(soap, "ns1:UnlockRoomRequest", -1, &a->ns1__UnlockRoomRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__unlockRoom * SOAP_FMAC4 soap_in___ns1__unlockRoom(struct soap *soap, const char *tag, struct __ns1__unlockRoom *a, const char *type)
{
	size_t soap_flag_ns1__UnlockRoomRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__unlockRoom *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__unlockRoom, sizeof(struct __ns1__unlockRoom), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__unlockRoom(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UnlockRoomRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UnlockRoomRequest(soap, "ns1:UnlockRoomRequest", &a->ns1__UnlockRoomRequest, ""))
				{	soap_flag_ns1__UnlockRoomRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__unlockRoom * SOAP_FMAC2 soap_instantiate___ns1__unlockRoom(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__unlockRoom(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__unlockRoom *p;
	size_t k = sizeof(struct __ns1__unlockRoom);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__unlockRoom);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__unlockRoom, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__unlockRoom location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__unlockRoom, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__unlockRoom(struct soap *soap, const struct __ns1__unlockRoom *a, const char *tag, const char *type)
{
	if (soap_out___ns1__unlockRoom(soap, tag?tag:"-ns1:unlockRoom", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__unlockRoom * SOAP_FMAC4 soap_get___ns1__unlockRoom(struct soap *soap, struct __ns1__unlockRoom *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__unlockRoom(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__lockRoom(struct soap *soap, struct __ns1__lockRoom *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__LockRoomRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__lockRoom(struct soap *soap, const struct __ns1__lockRoom *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__LockRoomRequest(soap, &a->ns1__LockRoomRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__lockRoom(struct soap *soap, const char *tag, int id, const struct __ns1__lockRoom *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__LockRoomRequest(soap, "ns1:LockRoomRequest", -1, &a->ns1__LockRoomRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__lockRoom * SOAP_FMAC4 soap_in___ns1__lockRoom(struct soap *soap, const char *tag, struct __ns1__lockRoom *a, const char *type)
{
	size_t soap_flag_ns1__LockRoomRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__lockRoom *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__lockRoom, sizeof(struct __ns1__lockRoom), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__lockRoom(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__LockRoomRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__LockRoomRequest(soap, "ns1:LockRoomRequest", &a->ns1__LockRoomRequest, ""))
				{	soap_flag_ns1__LockRoomRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__lockRoom * SOAP_FMAC2 soap_instantiate___ns1__lockRoom(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__lockRoom(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__lockRoom *p;
	size_t k = sizeof(struct __ns1__lockRoom);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__lockRoom);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__lockRoom, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__lockRoom location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__lockRoom, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__lockRoom(struct soap *soap, const struct __ns1__lockRoom *a, const char *tag, const char *type)
{
	if (soap_out___ns1__lockRoom(soap, tag?tag:"-ns1:lockRoom", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__lockRoom * SOAP_FMAC4 soap_get___ns1__lockRoom(struct soap *soap, struct __ns1__lockRoom *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__lockRoom(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__updateLanguage(struct soap *soap, struct __ns1__updateLanguage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdateLanguageRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__updateLanguage(struct soap *soap, const struct __ns1__updateLanguage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__UpdateLanguageRequest(soap, &a->ns1__UpdateLanguageRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__updateLanguage(struct soap *soap, const char *tag, int id, const struct __ns1__updateLanguage *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__UpdateLanguageRequest(soap, "ns1:UpdateLanguageRequest", -1, &a->ns1__UpdateLanguageRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateLanguage * SOAP_FMAC4 soap_in___ns1__updateLanguage(struct soap *soap, const char *tag, struct __ns1__updateLanguage *a, const char *type)
{
	size_t soap_flag_ns1__UpdateLanguageRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__updateLanguage *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__updateLanguage, sizeof(struct __ns1__updateLanguage), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__updateLanguage(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdateLanguageRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UpdateLanguageRequest(soap, "ns1:UpdateLanguageRequest", &a->ns1__UpdateLanguageRequest, ""))
				{	soap_flag_ns1__UpdateLanguageRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__updateLanguage * SOAP_FMAC2 soap_instantiate___ns1__updateLanguage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__updateLanguage(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__updateLanguage *p;
	size_t k = sizeof(struct __ns1__updateLanguage);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__updateLanguage);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__updateLanguage, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__updateLanguage location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__updateLanguage, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__updateLanguage(struct soap *soap, const struct __ns1__updateLanguage *a, const char *tag, const char *type)
{
	if (soap_out___ns1__updateLanguage(soap, tag?tag:"-ns1:updateLanguage", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateLanguage * SOAP_FMAC4 soap_get___ns1__updateLanguage(struct soap *soap, struct __ns1__updateLanguage *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__updateLanguage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__updatePassword(struct soap *soap, struct __ns1__updatePassword *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdatePasswordRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__updatePassword(struct soap *soap, const struct __ns1__updatePassword *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__UpdatePasswordRequest(soap, &a->ns1__UpdatePasswordRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__updatePassword(struct soap *soap, const char *tag, int id, const struct __ns1__updatePassword *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__UpdatePasswordRequest(soap, "ns1:UpdatePasswordRequest", -1, &a->ns1__UpdatePasswordRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updatePassword * SOAP_FMAC4 soap_in___ns1__updatePassword(struct soap *soap, const char *tag, struct __ns1__updatePassword *a, const char *type)
{
	size_t soap_flag_ns1__UpdatePasswordRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__updatePassword *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__updatePassword, sizeof(struct __ns1__updatePassword), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__updatePassword(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdatePasswordRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UpdatePasswordRequest(soap, "ns1:UpdatePasswordRequest", &a->ns1__UpdatePasswordRequest, ""))
				{	soap_flag_ns1__UpdatePasswordRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__updatePassword * SOAP_FMAC2 soap_instantiate___ns1__updatePassword(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__updatePassword(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__updatePassword *p;
	size_t k = sizeof(struct __ns1__updatePassword);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__updatePassword);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__updatePassword, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__updatePassword location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__updatePassword, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__updatePassword(struct soap *soap, const struct __ns1__updatePassword *a, const char *tag, const char *type)
{
	if (soap_out___ns1__updatePassword(soap, tag?tag:"-ns1:updatePassword", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updatePassword * SOAP_FMAC4 soap_get___ns1__updatePassword(struct soap *soap, struct __ns1__updatePassword *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__updatePassword(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deleteRoom(struct soap *soap, struct __ns1__deleteRoom *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DeleteRoomRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deleteRoom(struct soap *soap, const struct __ns1__deleteRoom *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__DeleteRoomRequest(soap, &a->ns1__DeleteRoomRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deleteRoom(struct soap *soap, const char *tag, int id, const struct __ns1__deleteRoom *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__DeleteRoomRequest(soap, "ns1:DeleteRoomRequest", -1, &a->ns1__DeleteRoomRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteRoom * SOAP_FMAC4 soap_in___ns1__deleteRoom(struct soap *soap, const char *tag, struct __ns1__deleteRoom *a, const char *type)
{
	size_t soap_flag_ns1__DeleteRoomRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__deleteRoom *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__deleteRoom, sizeof(struct __ns1__deleteRoom), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__deleteRoom(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DeleteRoomRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__DeleteRoomRequest(soap, "ns1:DeleteRoomRequest", &a->ns1__DeleteRoomRequest, ""))
				{	soap_flag_ns1__DeleteRoomRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__deleteRoom * SOAP_FMAC2 soap_instantiate___ns1__deleteRoom(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__deleteRoom(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__deleteRoom *p;
	size_t k = sizeof(struct __ns1__deleteRoom);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__deleteRoom);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__deleteRoom, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__deleteRoom location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__deleteRoom, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deleteRoom(struct soap *soap, const struct __ns1__deleteRoom *a, const char *tag, const char *type)
{
	if (soap_out___ns1__deleteRoom(soap, tag?tag:"-ns1:deleteRoom", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteRoom * SOAP_FMAC4 soap_get___ns1__deleteRoom(struct soap *soap, struct __ns1__deleteRoom *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__deleteRoom(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__createRoom(struct soap *soap, struct __ns1__createRoom *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CreateRoomRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__createRoom(struct soap *soap, const struct __ns1__createRoom *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CreateRoomRequest(soap, &a->ns1__CreateRoomRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__createRoom(struct soap *soap, const char *tag, int id, const struct __ns1__createRoom *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CreateRoomRequest(soap, "ns1:CreateRoomRequest", -1, &a->ns1__CreateRoomRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createRoom * SOAP_FMAC4 soap_in___ns1__createRoom(struct soap *soap, const char *tag, struct __ns1__createRoom *a, const char *type)
{
	size_t soap_flag_ns1__CreateRoomRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__createRoom *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__createRoom, sizeof(struct __ns1__createRoom), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__createRoom(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CreateRoomRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__CreateRoomRequest(soap, "ns1:CreateRoomRequest", &a->ns1__CreateRoomRequest, ""))
				{	soap_flag_ns1__CreateRoomRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__createRoom * SOAP_FMAC2 soap_instantiate___ns1__createRoom(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__createRoom(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__createRoom *p;
	size_t k = sizeof(struct __ns1__createRoom);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__createRoom);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__createRoom, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__createRoom location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__createRoom, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__createRoom(struct soap *soap, const struct __ns1__createRoom *a, const char *tag, const char *type)
{
	if (soap_out___ns1__createRoom(soap, tag?tag:"-ns1:createRoom", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createRoom * SOAP_FMAC4 soap_get___ns1__createRoom(struct soap *soap, struct __ns1__createRoom *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__createRoom(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeRoomPIN(struct soap *soap, struct __ns1__removeRoomPIN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RemoveRoomPINRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeRoomPIN(struct soap *soap, const struct __ns1__removeRoomPIN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__RemoveRoomPINRequest(soap, &a->ns1__RemoveRoomPINRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeRoomPIN(struct soap *soap, const char *tag, int id, const struct __ns1__removeRoomPIN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__RemoveRoomPINRequest(soap, "ns1:RemoveRoomPINRequest", -1, &a->ns1__RemoveRoomPINRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeRoomPIN * SOAP_FMAC4 soap_in___ns1__removeRoomPIN(struct soap *soap, const char *tag, struct __ns1__removeRoomPIN *a, const char *type)
{
	size_t soap_flag_ns1__RemoveRoomPINRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__removeRoomPIN *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeRoomPIN, sizeof(struct __ns1__removeRoomPIN), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeRoomPIN(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RemoveRoomPINRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__RemoveRoomPINRequest(soap, "ns1:RemoveRoomPINRequest", &a->ns1__RemoveRoomPINRequest, ""))
				{	soap_flag_ns1__RemoveRoomPINRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__removeRoomPIN * SOAP_FMAC2 soap_instantiate___ns1__removeRoomPIN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeRoomPIN(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__removeRoomPIN *p;
	size_t k = sizeof(struct __ns1__removeRoomPIN);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__removeRoomPIN);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__removeRoomPIN, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__removeRoomPIN location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__removeRoomPIN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeRoomPIN(struct soap *soap, const struct __ns1__removeRoomPIN *a, const char *tag, const char *type)
{
	if (soap_out___ns1__removeRoomPIN(soap, tag?tag:"-ns1:removeRoomPIN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeRoomPIN * SOAP_FMAC4 soap_get___ns1__removeRoomPIN(struct soap *soap, struct __ns1__removeRoomPIN *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeRoomPIN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__createRoomPIN(struct soap *soap, struct __ns1__createRoomPIN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CreateRoomPINRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__createRoomPIN(struct soap *soap, const struct __ns1__createRoomPIN *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CreateRoomPINRequest(soap, &a->ns1__CreateRoomPINRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__createRoomPIN(struct soap *soap, const char *tag, int id, const struct __ns1__createRoomPIN *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CreateRoomPINRequest(soap, "ns1:CreateRoomPINRequest", -1, &a->ns1__CreateRoomPINRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createRoomPIN * SOAP_FMAC4 soap_in___ns1__createRoomPIN(struct soap *soap, const char *tag, struct __ns1__createRoomPIN *a, const char *type)
{
	size_t soap_flag_ns1__CreateRoomPINRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__createRoomPIN *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__createRoomPIN, sizeof(struct __ns1__createRoomPIN), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__createRoomPIN(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CreateRoomPINRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__CreateRoomPINRequest(soap, "ns1:CreateRoomPINRequest", &a->ns1__CreateRoomPINRequest, ""))
				{	soap_flag_ns1__CreateRoomPINRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__createRoomPIN * SOAP_FMAC2 soap_instantiate___ns1__createRoomPIN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__createRoomPIN(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__createRoomPIN *p;
	size_t k = sizeof(struct __ns1__createRoomPIN);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__createRoomPIN);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__createRoomPIN, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__createRoomPIN location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__createRoomPIN, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__createRoomPIN(struct soap *soap, const struct __ns1__createRoomPIN *a, const char *tag, const char *type)
{
	if (soap_out___ns1__createRoomPIN(soap, tag?tag:"-ns1:createRoomPIN", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createRoomPIN * SOAP_FMAC4 soap_get___ns1__createRoomPIN(struct soap *soap, struct __ns1__createRoomPIN *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__createRoomPIN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeRoomURL(struct soap *soap, struct __ns1__removeRoomURL *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RemoveRoomURLRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeRoomURL(struct soap *soap, const struct __ns1__removeRoomURL *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__RemoveRoomURLRequest(soap, &a->ns1__RemoveRoomURLRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeRoomURL(struct soap *soap, const char *tag, int id, const struct __ns1__removeRoomURL *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__RemoveRoomURLRequest(soap, "ns1:RemoveRoomURLRequest", -1, &a->ns1__RemoveRoomURLRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeRoomURL * SOAP_FMAC4 soap_in___ns1__removeRoomURL(struct soap *soap, const char *tag, struct __ns1__removeRoomURL *a, const char *type)
{
	size_t soap_flag_ns1__RemoveRoomURLRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__removeRoomURL *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeRoomURL, sizeof(struct __ns1__removeRoomURL), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeRoomURL(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RemoveRoomURLRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__RemoveRoomURLRequest(soap, "ns1:RemoveRoomURLRequest", &a->ns1__RemoveRoomURLRequest, ""))
				{	soap_flag_ns1__RemoveRoomURLRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__removeRoomURL * SOAP_FMAC2 soap_instantiate___ns1__removeRoomURL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeRoomURL(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__removeRoomURL *p;
	size_t k = sizeof(struct __ns1__removeRoomURL);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__removeRoomURL);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__removeRoomURL, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__removeRoomURL location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__removeRoomURL, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeRoomURL(struct soap *soap, const struct __ns1__removeRoomURL *a, const char *tag, const char *type)
{
	if (soap_out___ns1__removeRoomURL(soap, tag?tag:"-ns1:removeRoomURL", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeRoomURL * SOAP_FMAC4 soap_get___ns1__removeRoomURL(struct soap *soap, struct __ns1__removeRoomURL *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeRoomURL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__createRoomURL(struct soap *soap, struct __ns1__createRoomURL *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CreateRoomURLRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__createRoomURL(struct soap *soap, const struct __ns1__createRoomURL *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CreateRoomURLRequest(soap, &a->ns1__CreateRoomURLRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__createRoomURL(struct soap *soap, const char *tag, int id, const struct __ns1__createRoomURL *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CreateRoomURLRequest(soap, "ns1:CreateRoomURLRequest", -1, &a->ns1__CreateRoomURLRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createRoomURL * SOAP_FMAC4 soap_in___ns1__createRoomURL(struct soap *soap, const char *tag, struct __ns1__createRoomURL *a, const char *type)
{
	size_t soap_flag_ns1__CreateRoomURLRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__createRoomURL *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__createRoomURL, sizeof(struct __ns1__createRoomURL), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__createRoomURL(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CreateRoomURLRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__CreateRoomURLRequest(soap, "ns1:CreateRoomURLRequest", &a->ns1__CreateRoomURLRequest, ""))
				{	soap_flag_ns1__CreateRoomURLRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__createRoomURL * SOAP_FMAC2 soap_instantiate___ns1__createRoomURL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__createRoomURL(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__createRoomURL *p;
	size_t k = sizeof(struct __ns1__createRoomURL);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__createRoomURL);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__createRoomURL, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__createRoomURL location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__createRoomURL, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__createRoomURL(struct soap *soap, const struct __ns1__createRoomURL *a, const char *tag, const char *type)
{
	if (soap_out___ns1__createRoomURL(soap, tag?tag:"-ns1:createRoomURL", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createRoomURL * SOAP_FMAC4 soap_get___ns1__createRoomURL(struct soap *soap, struct __ns1__createRoomURL *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__createRoomURL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__myAccount(struct soap *soap, struct __ns1__myAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__MyAccountRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__myAccount(struct soap *soap, const struct __ns1__myAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__MyAccountRequest(soap, &a->ns1__MyAccountRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__myAccount(struct soap *soap, const char *tag, int id, const struct __ns1__myAccount *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__MyAccountRequest(soap, "ns1:MyAccountRequest", -1, &a->ns1__MyAccountRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__myAccount * SOAP_FMAC4 soap_in___ns1__myAccount(struct soap *soap, const char *tag, struct __ns1__myAccount *a, const char *type)
{
	size_t soap_flag_ns1__MyAccountRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__myAccount *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__myAccount, sizeof(struct __ns1__myAccount), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__myAccount(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__MyAccountRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__MyAccountRequest(soap, "ns1:MyAccountRequest", &a->ns1__MyAccountRequest, ""))
				{	soap_flag_ns1__MyAccountRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__myAccount * SOAP_FMAC2 soap_instantiate___ns1__myAccount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__myAccount(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__myAccount *p;
	size_t k = sizeof(struct __ns1__myAccount);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__myAccount);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__myAccount, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__myAccount location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__myAccount, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__myAccount(struct soap *soap, const struct __ns1__myAccount *a, const char *tag, const char *type)
{
	if (soap_out___ns1__myAccount(soap, tag?tag:"-ns1:myAccount", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__myAccount * SOAP_FMAC4 soap_get___ns1__myAccount(struct soap *soap, struct __ns1__myAccount *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__myAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__stopVideo(struct soap *soap, struct __ns1__stopVideo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__StopVideoRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__stopVideo(struct soap *soap, const struct __ns1__stopVideo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__StopVideoRequest(soap, &a->ns1__StopVideoRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__stopVideo(struct soap *soap, const char *tag, int id, const struct __ns1__stopVideo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__StopVideoRequest(soap, "ns1:StopVideoRequest", -1, &a->ns1__StopVideoRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__stopVideo * SOAP_FMAC4 soap_in___ns1__stopVideo(struct soap *soap, const char *tag, struct __ns1__stopVideo *a, const char *type)
{
	size_t soap_flag_ns1__StopVideoRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__stopVideo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__stopVideo, sizeof(struct __ns1__stopVideo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__stopVideo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__StopVideoRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__StopVideoRequest(soap, "ns1:StopVideoRequest", &a->ns1__StopVideoRequest, ""))
				{	soap_flag_ns1__StopVideoRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__stopVideo * SOAP_FMAC2 soap_instantiate___ns1__stopVideo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__stopVideo(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__stopVideo *p;
	size_t k = sizeof(struct __ns1__stopVideo);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__stopVideo);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__stopVideo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__stopVideo location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__stopVideo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__stopVideo(struct soap *soap, const struct __ns1__stopVideo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__stopVideo(soap, tag?tag:"-ns1:stopVideo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__stopVideo * SOAP_FMAC4 soap_get___ns1__stopVideo(struct soap *soap, struct __ns1__stopVideo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__stopVideo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__startVideo(struct soap *soap, struct __ns1__startVideo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__StartVideoRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__startVideo(struct soap *soap, const struct __ns1__startVideo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__StartVideoRequest(soap, &a->ns1__StartVideoRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__startVideo(struct soap *soap, const char *tag, int id, const struct __ns1__startVideo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__StartVideoRequest(soap, "ns1:StartVideoRequest", -1, &a->ns1__StartVideoRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__startVideo * SOAP_FMAC4 soap_in___ns1__startVideo(struct soap *soap, const char *tag, struct __ns1__startVideo *a, const char *type)
{
	size_t soap_flag_ns1__StartVideoRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__startVideo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__startVideo, sizeof(struct __ns1__startVideo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__startVideo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__StartVideoRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__StartVideoRequest(soap, "ns1:StartVideoRequest", &a->ns1__StartVideoRequest, ""))
				{	soap_flag_ns1__StartVideoRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__startVideo * SOAP_FMAC2 soap_instantiate___ns1__startVideo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__startVideo(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__startVideo *p;
	size_t k = sizeof(struct __ns1__startVideo);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__startVideo);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__startVideo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__startVideo location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__startVideo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__startVideo(struct soap *soap, const struct __ns1__startVideo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__startVideo(soap, tag?tag:"-ns1:startVideo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__startVideo * SOAP_FMAC4 soap_get___ns1__startVideo(struct soap *soap, struct __ns1__startVideo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__startVideo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__unmuteAudio(struct soap *soap, struct __ns1__unmuteAudio *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UnmuteAudioRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__unmuteAudio(struct soap *soap, const struct __ns1__unmuteAudio *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__UnmuteAudioRequest(soap, &a->ns1__UnmuteAudioRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__unmuteAudio(struct soap *soap, const char *tag, int id, const struct __ns1__unmuteAudio *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__UnmuteAudioRequest(soap, "ns1:UnmuteAudioRequest", -1, &a->ns1__UnmuteAudioRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__unmuteAudio * SOAP_FMAC4 soap_in___ns1__unmuteAudio(struct soap *soap, const char *tag, struct __ns1__unmuteAudio *a, const char *type)
{
	size_t soap_flag_ns1__UnmuteAudioRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__unmuteAudio *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__unmuteAudio, sizeof(struct __ns1__unmuteAudio), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__unmuteAudio(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UnmuteAudioRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UnmuteAudioRequest(soap, "ns1:UnmuteAudioRequest", &a->ns1__UnmuteAudioRequest, ""))
				{	soap_flag_ns1__UnmuteAudioRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__unmuteAudio * SOAP_FMAC2 soap_instantiate___ns1__unmuteAudio(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__unmuteAudio(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__unmuteAudio *p;
	size_t k = sizeof(struct __ns1__unmuteAudio);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__unmuteAudio);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__unmuteAudio, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__unmuteAudio location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__unmuteAudio, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__unmuteAudio(struct soap *soap, const struct __ns1__unmuteAudio *a, const char *tag, const char *type)
{
	if (soap_out___ns1__unmuteAudio(soap, tag?tag:"-ns1:unmuteAudio", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__unmuteAudio * SOAP_FMAC4 soap_get___ns1__unmuteAudio(struct soap *soap, struct __ns1__unmuteAudio *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__unmuteAudio(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__muteAudio(struct soap *soap, struct __ns1__muteAudio *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__MuteAudioRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__muteAudio(struct soap *soap, const struct __ns1__muteAudio *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__MuteAudioRequest(soap, &a->ns1__MuteAudioRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__muteAudio(struct soap *soap, const char *tag, int id, const struct __ns1__muteAudio *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__MuteAudioRequest(soap, "ns1:MuteAudioRequest", -1, &a->ns1__MuteAudioRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__muteAudio * SOAP_FMAC4 soap_in___ns1__muteAudio(struct soap *soap, const char *tag, struct __ns1__muteAudio *a, const char *type)
{
	size_t soap_flag_ns1__MuteAudioRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__muteAudio *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__muteAudio, sizeof(struct __ns1__muteAudio), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__muteAudio(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__MuteAudioRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__MuteAudioRequest(soap, "ns1:MuteAudioRequest", &a->ns1__MuteAudioRequest, ""))
				{	soap_flag_ns1__MuteAudioRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__muteAudio * SOAP_FMAC2 soap_instantiate___ns1__muteAudio(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__muteAudio(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__muteAudio *p;
	size_t k = sizeof(struct __ns1__muteAudio);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__muteAudio);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__muteAudio, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__muteAudio location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__muteAudio, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__muteAudio(struct soap *soap, const struct __ns1__muteAudio *a, const char *tag, const char *type)
{
	if (soap_out___ns1__muteAudio(soap, tag?tag:"-ns1:muteAudio", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__muteAudio * SOAP_FMAC4 soap_get___ns1__muteAudio(struct soap *soap, struct __ns1__muteAudio *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__muteAudio(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__leaveConference(struct soap *soap, struct __ns1__leaveConference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__LeaveConferenceRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__leaveConference(struct soap *soap, const struct __ns1__leaveConference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__LeaveConferenceRequest(soap, &a->ns1__LeaveConferenceRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__leaveConference(struct soap *soap, const char *tag, int id, const struct __ns1__leaveConference *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__LeaveConferenceRequest(soap, "ns1:LeaveConferenceRequest", -1, &a->ns1__LeaveConferenceRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__leaveConference * SOAP_FMAC4 soap_in___ns1__leaveConference(struct soap *soap, const char *tag, struct __ns1__leaveConference *a, const char *type)
{
	size_t soap_flag_ns1__LeaveConferenceRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__leaveConference *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__leaveConference, sizeof(struct __ns1__leaveConference), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__leaveConference(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__LeaveConferenceRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__LeaveConferenceRequest(soap, "ns1:LeaveConferenceRequest", &a->ns1__LeaveConferenceRequest, ""))
				{	soap_flag_ns1__LeaveConferenceRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__leaveConference * SOAP_FMAC2 soap_instantiate___ns1__leaveConference(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__leaveConference(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__leaveConference *p;
	size_t k = sizeof(struct __ns1__leaveConference);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__leaveConference);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__leaveConference, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__leaveConference location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__leaveConference, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__leaveConference(struct soap *soap, const struct __ns1__leaveConference *a, const char *tag, const char *type)
{
	if (soap_out___ns1__leaveConference(soap, tag?tag:"-ns1:leaveConference", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__leaveConference * SOAP_FMAC4 soap_get___ns1__leaveConference(struct soap *soap, struct __ns1__leaveConference *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__leaveConference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getLectureModeParticipants(struct soap *soap, struct __ns1__getLectureModeParticipants *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetLectureModeParticipantsRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getLectureModeParticipants(struct soap *soap, const struct __ns1__getLectureModeParticipants *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetLectureModeParticipantsRequest(soap, &a->ns1__GetLectureModeParticipantsRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getLectureModeParticipants(struct soap *soap, const char *tag, int id, const struct __ns1__getLectureModeParticipants *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetLectureModeParticipantsRequest(soap, "ns1:GetLectureModeParticipantsRequest", -1, &a->ns1__GetLectureModeParticipantsRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getLectureModeParticipants * SOAP_FMAC4 soap_in___ns1__getLectureModeParticipants(struct soap *soap, const char *tag, struct __ns1__getLectureModeParticipants *a, const char *type)
{
	size_t soap_flag_ns1__GetLectureModeParticipantsRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getLectureModeParticipants *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getLectureModeParticipants, sizeof(struct __ns1__getLectureModeParticipants), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getLectureModeParticipants(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetLectureModeParticipantsRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetLectureModeParticipantsRequest(soap, "ns1:GetLectureModeParticipantsRequest", &a->ns1__GetLectureModeParticipantsRequest, ""))
				{	soap_flag_ns1__GetLectureModeParticipantsRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getLectureModeParticipants * SOAP_FMAC2 soap_instantiate___ns1__getLectureModeParticipants(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getLectureModeParticipants(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getLectureModeParticipants *p;
	size_t k = sizeof(struct __ns1__getLectureModeParticipants);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getLectureModeParticipants);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getLectureModeParticipants, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getLectureModeParticipants location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getLectureModeParticipants, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getLectureModeParticipants(struct soap *soap, const struct __ns1__getLectureModeParticipants *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getLectureModeParticipants(soap, tag?tag:"-ns1:getLectureModeParticipants", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getLectureModeParticipants * SOAP_FMAC4 soap_get___ns1__getLectureModeParticipants(struct soap *soap, struct __ns1__getLectureModeParticipants *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getLectureModeParticipants(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getParticipants(struct soap *soap, struct __ns1__getParticipants *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetParticipantsRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getParticipants(struct soap *soap, const struct __ns1__getParticipants *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetParticipantsRequest(soap, &a->ns1__GetParticipantsRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getParticipants(struct soap *soap, const char *tag, int id, const struct __ns1__getParticipants *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetParticipantsRequest(soap, "ns1:GetParticipantsRequest", -1, &a->ns1__GetParticipantsRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getParticipants * SOAP_FMAC4 soap_in___ns1__getParticipants(struct soap *soap, const char *tag, struct __ns1__getParticipants *a, const char *type)
{
	size_t soap_flag_ns1__GetParticipantsRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getParticipants *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getParticipants, sizeof(struct __ns1__getParticipants), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getParticipants(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetParticipantsRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetParticipantsRequest(soap, "ns1:GetParticipantsRequest", &a->ns1__GetParticipantsRequest, ""))
				{	soap_flag_ns1__GetParticipantsRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getParticipants * SOAP_FMAC2 soap_instantiate___ns1__getParticipants(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getParticipants(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getParticipants *p;
	size_t k = sizeof(struct __ns1__getParticipants);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getParticipants);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getParticipants, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getParticipants location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getParticipants, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getParticipants(struct soap *soap, const struct __ns1__getParticipants *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getParticipants(soap, tag?tag:"-ns1:getParticipants", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getParticipants * SOAP_FMAC4 soap_get___ns1__getParticipants(struct soap *soap, struct __ns1__getParticipants *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getParticipants(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__directCall(struct soap *soap, struct __ns1__directCall *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DirectCallRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__directCall(struct soap *soap, const struct __ns1__directCall *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__DirectCallRequest(soap, &a->ns1__DirectCallRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__directCall(struct soap *soap, const char *tag, int id, const struct __ns1__directCall *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__DirectCallRequest(soap, "ns1:DirectCallRequest", -1, &a->ns1__DirectCallRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__directCall * SOAP_FMAC4 soap_in___ns1__directCall(struct soap *soap, const char *tag, struct __ns1__directCall *a, const char *type)
{
	size_t soap_flag_ns1__DirectCallRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__directCall *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__directCall, sizeof(struct __ns1__directCall), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__directCall(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DirectCallRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__DirectCallRequest(soap, "ns1:DirectCallRequest", &a->ns1__DirectCallRequest, ""))
				{	soap_flag_ns1__DirectCallRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__directCall * SOAP_FMAC2 soap_instantiate___ns1__directCall(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__directCall(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__directCall *p;
	size_t k = sizeof(struct __ns1__directCall);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__directCall);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__directCall, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__directCall location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__directCall, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__directCall(struct soap *soap, const struct __ns1__directCall *a, const char *tag, const char *type)
{
	if (soap_out___ns1__directCall(soap, tag?tag:"-ns1:directCall", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__directCall * SOAP_FMAC4 soap_get___ns1__directCall(struct soap *soap, struct __ns1__directCall *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__directCall(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__joinIPCConference(struct soap *soap, struct __ns1__joinIPCConference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__JoinIPCConferenceRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__joinIPCConference(struct soap *soap, const struct __ns1__joinIPCConference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__JoinIPCConferenceRequest(soap, &a->ns1__JoinIPCConferenceRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__joinIPCConference(struct soap *soap, const char *tag, int id, const struct __ns1__joinIPCConference *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__JoinIPCConferenceRequest(soap, "ns1:JoinIPCConferenceRequest", -1, &a->ns1__JoinIPCConferenceRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__joinIPCConference * SOAP_FMAC4 soap_in___ns1__joinIPCConference(struct soap *soap, const char *tag, struct __ns1__joinIPCConference *a, const char *type)
{
	size_t soap_flag_ns1__JoinIPCConferenceRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__joinIPCConference *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__joinIPCConference, sizeof(struct __ns1__joinIPCConference), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__joinIPCConference(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__JoinIPCConferenceRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__JoinIPCConferenceRequest(soap, "ns1:JoinIPCConferenceRequest", &a->ns1__JoinIPCConferenceRequest, ""))
				{	soap_flag_ns1__JoinIPCConferenceRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__joinIPCConference * SOAP_FMAC2 soap_instantiate___ns1__joinIPCConference(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__joinIPCConference(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__joinIPCConference *p;
	size_t k = sizeof(struct __ns1__joinIPCConference);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__joinIPCConference);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__joinIPCConference, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__joinIPCConference location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__joinIPCConference, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__joinIPCConference(struct soap *soap, const struct __ns1__joinIPCConference *a, const char *tag, const char *type)
{
	if (soap_out___ns1__joinIPCConference(soap, tag?tag:"-ns1:joinIPCConference", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__joinIPCConference * SOAP_FMAC4 soap_get___ns1__joinIPCConference(struct soap *soap, struct __ns1__joinIPCConference *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__joinIPCConference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__joinConference(struct soap *soap, struct __ns1__joinConference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__JoinConferenceRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__joinConference(struct soap *soap, const struct __ns1__joinConference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__JoinConferenceRequest(soap, &a->ns1__JoinConferenceRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__joinConference(struct soap *soap, const char *tag, int id, const struct __ns1__joinConference *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__JoinConferenceRequest(soap, "ns1:JoinConferenceRequest", -1, &a->ns1__JoinConferenceRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__joinConference * SOAP_FMAC4 soap_in___ns1__joinConference(struct soap *soap, const char *tag, struct __ns1__joinConference *a, const char *type)
{
	size_t soap_flag_ns1__JoinConferenceRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__joinConference *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__joinConference, sizeof(struct __ns1__joinConference), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__joinConference(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__JoinConferenceRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__JoinConferenceRequest(soap, "ns1:JoinConferenceRequest", &a->ns1__JoinConferenceRequest, ""))
				{	soap_flag_ns1__JoinConferenceRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__joinConference * SOAP_FMAC2 soap_instantiate___ns1__joinConference(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__joinConference(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__joinConference *p;
	size_t k = sizeof(struct __ns1__joinConference);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__joinConference);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__joinConference, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__joinConference location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__joinConference, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__joinConference(struct soap *soap, const struct __ns1__joinConference *a, const char *tag, const char *type)
{
	if (soap_out___ns1__joinConference(soap, tag?tag:"-ns1:joinConference", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__joinConference * SOAP_FMAC4 soap_get___ns1__joinConference(struct soap *soap, struct __ns1__joinConference *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__joinConference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__cancelOutboundCall(struct soap *soap, struct __ns1__cancelOutboundCall *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CancelOutboundCallRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__cancelOutboundCall(struct soap *soap, const struct __ns1__cancelOutboundCall *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CancelOutboundCallRequest(soap, &a->ns1__CancelOutboundCallRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__cancelOutboundCall(struct soap *soap, const char *tag, int id, const struct __ns1__cancelOutboundCall *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CancelOutboundCallRequest(soap, "ns1:CancelOutboundCallRequest", -1, &a->ns1__CancelOutboundCallRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__cancelOutboundCall * SOAP_FMAC4 soap_in___ns1__cancelOutboundCall(struct soap *soap, const char *tag, struct __ns1__cancelOutboundCall *a, const char *type)
{
	size_t soap_flag_ns1__CancelOutboundCallRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__cancelOutboundCall *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__cancelOutboundCall, sizeof(struct __ns1__cancelOutboundCall), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__cancelOutboundCall(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CancelOutboundCallRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__CancelOutboundCallRequest(soap, "ns1:CancelOutboundCallRequest", &a->ns1__CancelOutboundCallRequest, ""))
				{	soap_flag_ns1__CancelOutboundCallRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__cancelOutboundCall * SOAP_FMAC2 soap_instantiate___ns1__cancelOutboundCall(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__cancelOutboundCall(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__cancelOutboundCall *p;
	size_t k = sizeof(struct __ns1__cancelOutboundCall);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__cancelOutboundCall);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__cancelOutboundCall, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__cancelOutboundCall location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__cancelOutboundCall, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__cancelOutboundCall(struct soap *soap, const struct __ns1__cancelOutboundCall *a, const char *tag, const char *type)
{
	if (soap_out___ns1__cancelOutboundCall(soap, tag?tag:"-ns1:cancelOutboundCall", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__cancelOutboundCall * SOAP_FMAC4 soap_get___ns1__cancelOutboundCall(struct soap *soap, struct __ns1__cancelOutboundCall *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__cancelOutboundCall(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__inviteToConference(struct soap *soap, struct __ns1__inviteToConference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InviteToConferenceRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__inviteToConference(struct soap *soap, const struct __ns1__inviteToConference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__InviteToConferenceRequest(soap, &a->ns1__InviteToConferenceRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__inviteToConference(struct soap *soap, const char *tag, int id, const struct __ns1__inviteToConference *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__InviteToConferenceRequest(soap, "ns1:InviteToConferenceRequest", -1, &a->ns1__InviteToConferenceRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__inviteToConference * SOAP_FMAC4 soap_in___ns1__inviteToConference(struct soap *soap, const char *tag, struct __ns1__inviteToConference *a, const char *type)
{
	size_t soap_flag_ns1__InviteToConferenceRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__inviteToConference *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__inviteToConference, sizeof(struct __ns1__inviteToConference), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__inviteToConference(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InviteToConferenceRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__InviteToConferenceRequest(soap, "ns1:InviteToConferenceRequest", &a->ns1__InviteToConferenceRequest, ""))
				{	soap_flag_ns1__InviteToConferenceRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__inviteToConference * SOAP_FMAC2 soap_instantiate___ns1__inviteToConference(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__inviteToConference(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__inviteToConference *p;
	size_t k = sizeof(struct __ns1__inviteToConference);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__inviteToConference);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__inviteToConference, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__inviteToConference location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__inviteToConference, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__inviteToConference(struct soap *soap, const struct __ns1__inviteToConference *a, const char *tag, const char *type)
{
	if (soap_out___ns1__inviteToConference(soap, tag?tag:"-ns1:inviteToConference", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__inviteToConference * SOAP_FMAC4 soap_get___ns1__inviteToConference(struct soap *soap, struct __ns1__inviteToConference *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__inviteToConference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getEntityByEntityID(struct soap *soap, struct __ns1__getEntityByEntityID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetEntityByEntityIDRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getEntityByEntityID(struct soap *soap, const struct __ns1__getEntityByEntityID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetEntityByEntityIDRequest(soap, &a->ns1__GetEntityByEntityIDRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getEntityByEntityID(struct soap *soap, const char *tag, int id, const struct __ns1__getEntityByEntityID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetEntityByEntityIDRequest(soap, "ns1:GetEntityByEntityIDRequest", -1, &a->ns1__GetEntityByEntityIDRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getEntityByEntityID * SOAP_FMAC4 soap_in___ns1__getEntityByEntityID(struct soap *soap, const char *tag, struct __ns1__getEntityByEntityID *a, const char *type)
{
	size_t soap_flag_ns1__GetEntityByEntityIDRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__getEntityByEntityID *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getEntityByEntityID, sizeof(struct __ns1__getEntityByEntityID), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getEntityByEntityID(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetEntityByEntityIDRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetEntityByEntityIDRequest(soap, "ns1:GetEntityByEntityIDRequest", &a->ns1__GetEntityByEntityIDRequest, ""))
				{	soap_flag_ns1__GetEntityByEntityIDRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__getEntityByEntityID * SOAP_FMAC2 soap_instantiate___ns1__getEntityByEntityID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getEntityByEntityID(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__getEntityByEntityID *p;
	size_t k = sizeof(struct __ns1__getEntityByEntityID);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__getEntityByEntityID);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__getEntityByEntityID, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__getEntityByEntityID location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__getEntityByEntityID, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getEntityByEntityID(struct soap *soap, const struct __ns1__getEntityByEntityID *a, const char *tag, const char *type)
{
	if (soap_out___ns1__getEntityByEntityID(soap, tag?tag:"-ns1:getEntityByEntityID", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getEntityByEntityID * SOAP_FMAC4 soap_get___ns1__getEntityByEntityID(struct soap *soap, struct __ns1__getEntityByEntityID *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getEntityByEntityID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__searchByEmail(struct soap *soap, struct __ns1__searchByEmail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SearchByEmailRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__searchByEmail(struct soap *soap, const struct __ns1__searchByEmail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SearchByEmailRequest(soap, &a->ns1__SearchByEmailRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__searchByEmail(struct soap *soap, const char *tag, int id, const struct __ns1__searchByEmail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SearchByEmailRequest(soap, "ns1:SearchByEmailRequest", -1, &a->ns1__SearchByEmailRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__searchByEmail * SOAP_FMAC4 soap_in___ns1__searchByEmail(struct soap *soap, const char *tag, struct __ns1__searchByEmail *a, const char *type)
{
	size_t soap_flag_ns1__SearchByEmailRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__searchByEmail *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__searchByEmail, sizeof(struct __ns1__searchByEmail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__searchByEmail(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SearchByEmailRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SearchByEmailRequest(soap, "ns1:SearchByEmailRequest", &a->ns1__SearchByEmailRequest, ""))
				{	soap_flag_ns1__SearchByEmailRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__searchByEmail * SOAP_FMAC2 soap_instantiate___ns1__searchByEmail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__searchByEmail(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__searchByEmail *p;
	size_t k = sizeof(struct __ns1__searchByEmail);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__searchByEmail);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__searchByEmail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__searchByEmail location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__searchByEmail, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__searchByEmail(struct soap *soap, const struct __ns1__searchByEmail *a, const char *tag, const char *type)
{
	if (soap_out___ns1__searchByEmail(soap, tag?tag:"-ns1:searchByEmail", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__searchByEmail * SOAP_FMAC4 soap_get___ns1__searchByEmail(struct soap *soap, struct __ns1__searchByEmail *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__searchByEmail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__searchByEntityID(struct soap *soap, struct __ns1__searchByEntityID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SearchByEntityIDRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__searchByEntityID(struct soap *soap, const struct __ns1__searchByEntityID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SearchByEntityIDRequest(soap, &a->ns1__SearchByEntityIDRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__searchByEntityID(struct soap *soap, const char *tag, int id, const struct __ns1__searchByEntityID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SearchByEntityIDRequest(soap, "ns1:SearchByEntityIDRequest", -1, &a->ns1__SearchByEntityIDRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__searchByEntityID * SOAP_FMAC4 soap_in___ns1__searchByEntityID(struct soap *soap, const char *tag, struct __ns1__searchByEntityID *a, const char *type)
{
	size_t soap_flag_ns1__SearchByEntityIDRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__searchByEntityID *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__searchByEntityID, sizeof(struct __ns1__searchByEntityID), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__searchByEntityID(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SearchByEntityIDRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SearchByEntityIDRequest(soap, "ns1:SearchByEntityIDRequest", &a->ns1__SearchByEntityIDRequest, ""))
				{	soap_flag_ns1__SearchByEntityIDRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__searchByEntityID * SOAP_FMAC2 soap_instantiate___ns1__searchByEntityID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__searchByEntityID(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__searchByEntityID *p;
	size_t k = sizeof(struct __ns1__searchByEntityID);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__searchByEntityID);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__searchByEntityID, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__searchByEntityID location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__searchByEntityID, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__searchByEntityID(struct soap *soap, const struct __ns1__searchByEntityID *a, const char *tag, const char *type)
{
	if (soap_out___ns1__searchByEntityID(soap, tag?tag:"-ns1:searchByEntityID", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__searchByEntityID * SOAP_FMAC4 soap_get___ns1__searchByEntityID(struct soap *soap, struct __ns1__searchByEntityID *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__searchByEntityID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__search(struct soap *soap, struct __ns1__search *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SearchRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__search(struct soap *soap, const struct __ns1__search *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SearchRequest(soap, &a->ns1__SearchRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__search(struct soap *soap, const char *tag, int id, const struct __ns1__search *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SearchRequest(soap, "ns1:SearchRequest", -1, &a->ns1__SearchRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__search * SOAP_FMAC4 soap_in___ns1__search(struct soap *soap, const char *tag, struct __ns1__search *a, const char *type)
{
	size_t soap_flag_ns1__SearchRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__search *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__search, sizeof(struct __ns1__search), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__search(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SearchRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SearchRequest(soap, "ns1:SearchRequest", &a->ns1__SearchRequest, ""))
				{	soap_flag_ns1__SearchRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__search * SOAP_FMAC2 soap_instantiate___ns1__search(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__search(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__search *p;
	size_t k = sizeof(struct __ns1__search);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__search);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__search, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__search location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__search, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__search(struct soap *soap, const struct __ns1__search *a, const char *tag, const char *type)
{
	if (soap_out___ns1__search(soap, tag?tag:"-ns1:search", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__search * SOAP_FMAC4 soap_get___ns1__search(struct soap *soap, struct __ns1__search *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__search(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeFromMyContacts(struct soap *soap, struct __ns1__removeFromMyContacts *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RemoveFromMyContactsRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeFromMyContacts(struct soap *soap, const struct __ns1__removeFromMyContacts *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__RemoveFromMyContactsRequest(soap, &a->ns1__RemoveFromMyContactsRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeFromMyContacts(struct soap *soap, const char *tag, int id, const struct __ns1__removeFromMyContacts *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__RemoveFromMyContactsRequest(soap, "ns1:RemoveFromMyContactsRequest", -1, &a->ns1__RemoveFromMyContactsRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeFromMyContacts * SOAP_FMAC4 soap_in___ns1__removeFromMyContacts(struct soap *soap, const char *tag, struct __ns1__removeFromMyContacts *a, const char *type)
{
	size_t soap_flag_ns1__RemoveFromMyContactsRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__removeFromMyContacts *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeFromMyContacts, sizeof(struct __ns1__removeFromMyContacts), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeFromMyContacts(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RemoveFromMyContactsRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__RemoveFromMyContactsRequest(soap, "ns1:RemoveFromMyContactsRequest", &a->ns1__RemoveFromMyContactsRequest, ""))
				{	soap_flag_ns1__RemoveFromMyContactsRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__removeFromMyContacts * SOAP_FMAC2 soap_instantiate___ns1__removeFromMyContacts(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeFromMyContacts(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__removeFromMyContacts *p;
	size_t k = sizeof(struct __ns1__removeFromMyContacts);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__removeFromMyContacts);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__removeFromMyContacts, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__removeFromMyContacts location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__removeFromMyContacts, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeFromMyContacts(struct soap *soap, const struct __ns1__removeFromMyContacts *a, const char *tag, const char *type)
{
	if (soap_out___ns1__removeFromMyContacts(soap, tag?tag:"-ns1:removeFromMyContacts", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeFromMyContacts * SOAP_FMAC4 soap_get___ns1__removeFromMyContacts(struct soap *soap, struct __ns1__removeFromMyContacts *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeFromMyContacts(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__addToMyContacts(struct soap *soap, struct __ns1__addToMyContacts *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__AddToMyContactsRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__addToMyContacts(struct soap *soap, const struct __ns1__addToMyContacts *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__AddToMyContactsRequest(soap, &a->ns1__AddToMyContactsRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__addToMyContacts(struct soap *soap, const char *tag, int id, const struct __ns1__addToMyContacts *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__AddToMyContactsRequest(soap, "ns1:AddToMyContactsRequest", -1, &a->ns1__AddToMyContactsRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addToMyContacts * SOAP_FMAC4 soap_in___ns1__addToMyContacts(struct soap *soap, const char *tag, struct __ns1__addToMyContacts *a, const char *type)
{
	size_t soap_flag_ns1__AddToMyContactsRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__addToMyContacts *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__addToMyContacts, sizeof(struct __ns1__addToMyContacts), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__addToMyContacts(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__AddToMyContactsRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__AddToMyContactsRequest(soap, "ns1:AddToMyContactsRequest", &a->ns1__AddToMyContactsRequest, ""))
				{	soap_flag_ns1__AddToMyContactsRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__addToMyContacts * SOAP_FMAC2 soap_instantiate___ns1__addToMyContacts(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__addToMyContacts(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__addToMyContacts *p;
	size_t k = sizeof(struct __ns1__addToMyContacts);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__addToMyContacts);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__addToMyContacts, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__addToMyContacts location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__addToMyContacts, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__addToMyContacts(struct soap *soap, const struct __ns1__addToMyContacts *a, const char *tag, const char *type)
{
	if (soap_out___ns1__addToMyContacts(soap, tag?tag:"-ns1:addToMyContacts", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addToMyContacts * SOAP_FMAC4 soap_get___ns1__addToMyContacts(struct soap *soap, struct __ns1__addToMyContacts *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__addToMyContacts(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__searchMyContacts(struct soap *soap, struct __ns1__searchMyContacts *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SearchMyContactsRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__searchMyContacts(struct soap *soap, const struct __ns1__searchMyContacts *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SearchMyContactsRequest(soap, &a->ns1__SearchMyContactsRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__searchMyContacts(struct soap *soap, const char *tag, int id, const struct __ns1__searchMyContacts *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SearchMyContactsRequest(soap, "ns1:SearchMyContactsRequest", -1, &a->ns1__SearchMyContactsRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__searchMyContacts * SOAP_FMAC4 soap_in___ns1__searchMyContacts(struct soap *soap, const char *tag, struct __ns1__searchMyContacts *a, const char *type)
{
	size_t soap_flag_ns1__SearchMyContactsRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__searchMyContacts *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__searchMyContacts, sizeof(struct __ns1__searchMyContacts), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__searchMyContacts(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SearchMyContactsRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SearchMyContactsRequest(soap, "ns1:SearchMyContactsRequest", &a->ns1__SearchMyContactsRequest, ""))
				{	soap_flag_ns1__SearchMyContactsRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__searchMyContacts * SOAP_FMAC2 soap_instantiate___ns1__searchMyContacts(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__searchMyContacts(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__searchMyContacts *p;
	size_t k = sizeof(struct __ns1__searchMyContacts);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__searchMyContacts);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__searchMyContacts, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__searchMyContacts location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__searchMyContacts, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__searchMyContacts(struct soap *soap, const struct __ns1__searchMyContacts *a, const char *tag, const char *type)
{
	if (soap_out___ns1__searchMyContacts(soap, tag?tag:"-ns1:searchMyContacts", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__searchMyContacts * SOAP_FMAC4 soap_get___ns1__searchMyContacts(struct soap *soap, struct __ns1__searchMyContacts *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__searchMyContacts(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__myEndpointStatus(struct soap *soap, struct __ns1__myEndpointStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__MyEndpointStatusRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__myEndpointStatus(struct soap *soap, const struct __ns1__myEndpointStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__MyEndpointStatusRequest(soap, &a->ns1__MyEndpointStatusRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__myEndpointStatus(struct soap *soap, const char *tag, int id, const struct __ns1__myEndpointStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__MyEndpointStatusRequest(soap, "ns1:MyEndpointStatusRequest", -1, &a->ns1__MyEndpointStatusRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__myEndpointStatus * SOAP_FMAC4 soap_in___ns1__myEndpointStatus(struct soap *soap, const char *tag, struct __ns1__myEndpointStatus *a, const char *type)
{
	size_t soap_flag_ns1__MyEndpointStatusRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__myEndpointStatus *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__myEndpointStatus, sizeof(struct __ns1__myEndpointStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__myEndpointStatus(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__MyEndpointStatusRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__MyEndpointStatusRequest(soap, "ns1:MyEndpointStatusRequest", &a->ns1__MyEndpointStatusRequest, ""))
				{	soap_flag_ns1__MyEndpointStatusRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__myEndpointStatus * SOAP_FMAC2 soap_instantiate___ns1__myEndpointStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__myEndpointStatus(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__myEndpointStatus *p;
	size_t k = sizeof(struct __ns1__myEndpointStatus);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__myEndpointStatus);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__myEndpointStatus, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__myEndpointStatus location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__myEndpointStatus, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__myEndpointStatus(struct soap *soap, const struct __ns1__myEndpointStatus *a, const char *tag, const char *type)
{
	if (soap_out___ns1__myEndpointStatus(soap, tag?tag:"-ns1:myEndpointStatus", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__myEndpointStatus * SOAP_FMAC4 soap_get___ns1__myEndpointStatus(struct soap *soap, struct __ns1__myEndpointStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__myEndpointStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__logOut(struct soap *soap, struct __ns1__logOut *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__LogOutRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__logOut(struct soap *soap, const struct __ns1__logOut *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__LogOutRequest(soap, &a->ns1__LogOutRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__logOut(struct soap *soap, const char *tag, int id, const struct __ns1__logOut *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__LogOutRequest(soap, "ns1:LogOutRequest", -1, &a->ns1__LogOutRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__logOut * SOAP_FMAC4 soap_in___ns1__logOut(struct soap *soap, const char *tag, struct __ns1__logOut *a, const char *type)
{
	size_t soap_flag_ns1__LogOutRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__logOut *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__logOut, sizeof(struct __ns1__logOut), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__logOut(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__LogOutRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__LogOutRequest(soap, "ns1:LogOutRequest", &a->ns1__LogOutRequest, ""))
				{	soap_flag_ns1__LogOutRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__logOut * SOAP_FMAC2 soap_instantiate___ns1__logOut(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__logOut(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__logOut *p;
	size_t k = sizeof(struct __ns1__logOut);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__logOut);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__logOut, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__logOut location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__logOut, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__logOut(struct soap *soap, const struct __ns1__logOut *a, const char *tag, const char *type)
{
	if (soap_out___ns1__logOut(soap, tag?tag:"-ns1:logOut", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__logOut * SOAP_FMAC4 soap_get___ns1__logOut(struct soap *soap, struct __ns1__logOut *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__logOut(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__linkEndpoint(struct soap *soap, struct __ns1__linkEndpoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__LinkEndpointRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__linkEndpoint(struct soap *soap, const struct __ns1__linkEndpoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__LinkEndpointRequest(soap, &a->ns1__LinkEndpointRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__linkEndpoint(struct soap *soap, const char *tag, int id, const struct __ns1__linkEndpoint *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__LinkEndpointRequest(soap, "ns1:LinkEndpointRequest", -1, &a->ns1__LinkEndpointRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__linkEndpoint * SOAP_FMAC4 soap_in___ns1__linkEndpoint(struct soap *soap, const char *tag, struct __ns1__linkEndpoint *a, const char *type)
{
	size_t soap_flag_ns1__LinkEndpointRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__linkEndpoint *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__linkEndpoint, sizeof(struct __ns1__linkEndpoint), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__linkEndpoint(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__LinkEndpointRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__LinkEndpointRequest(soap, "ns1:LinkEndpointRequest", &a->ns1__LinkEndpointRequest, ""))
				{	soap_flag_ns1__LinkEndpointRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__linkEndpoint * SOAP_FMAC2 soap_instantiate___ns1__linkEndpoint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__linkEndpoint(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__linkEndpoint *p;
	size_t k = sizeof(struct __ns1__linkEndpoint);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__linkEndpoint);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__linkEndpoint, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__linkEndpoint location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__linkEndpoint, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__linkEndpoint(struct soap *soap, const struct __ns1__linkEndpoint *a, const char *tag, const char *type)
{
	if (soap_out___ns1__linkEndpoint(soap, tag?tag:"-ns1:linkEndpoint", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__linkEndpoint * SOAP_FMAC4 soap_get___ns1__linkEndpoint(struct soap *soap, struct __ns1__linkEndpoint *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__linkEndpoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__logIn(struct soap *soap, struct __ns1__logIn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__LogInRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__logIn(struct soap *soap, const struct __ns1__logIn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__LogInRequest(soap, &a->ns1__LogInRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__logIn(struct soap *soap, const char *tag, int id, const struct __ns1__logIn *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__LogInRequest(soap, "ns1:LogInRequest", -1, &a->ns1__LogInRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__logIn * SOAP_FMAC4 soap_in___ns1__logIn(struct soap *soap, const char *tag, struct __ns1__logIn *a, const char *type)
{
	size_t soap_flag_ns1__LogInRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__logIn *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__logIn, sizeof(struct __ns1__logIn), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__logIn(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__LogInRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__LogInRequest(soap, "ns1:LogInRequest", &a->ns1__LogInRequest, ""))
				{	soap_flag_ns1__LogInRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__logIn * SOAP_FMAC2 soap_instantiate___ns1__logIn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__logIn(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__logIn *p;
	size_t k = sizeof(struct __ns1__logIn);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__logIn);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__logIn, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__logIn location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__logIn, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__logIn(struct soap *soap, const struct __ns1__logIn *a, const char *tag, const char *type)
{
	if (soap_out___ns1__logIn(soap, tag?tag:"-ns1:logIn", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__logIn * SOAP_FMAC4 soap_get___ns1__logIn(struct soap *soap, struct __ns1__logIn *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__logIn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__AccessRestrictedFault = NULL;
	a->ns1__ConferenceLockedFault = NULL;
	a->ns1__ControlMeetingFault = NULL;
	a->ns1__EndpointNotBoundFault = NULL;
	a->ns1__FeatureNotAvailableFault = NULL;
	a->ns1__GeneralFault = NULL;
	a->ns1__InPointToPointCallFault = NULL;
	a->ns1__InvalidArgumentFault = NULL;
	a->ns1__InvalidModeratorPINFormatFault = NULL;
	a->ns1__NotLicensedFault = NULL;
	a->ns1__PrefixNotConfiguredFault = NULL;
	a->ns1__ResourceNotAvailableFault = NULL;
	a->ns1__RoomNotFoundFault = NULL;
	a->ns1__ScheduledRoomCreationFault = NULL;
	a->ns1__SeatLicenseExpiredFault = NULL;
	a->ns1__VidyoReplayNotAvailableFault = NULL;
	a->ns1__WrongPINFault = NULL;
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__AccessRestrictedFault(soap, &a->ns1__AccessRestrictedFault);
	soap_serialize_PointerTo_ns1__ConferenceLockedFault(soap, &a->ns1__ConferenceLockedFault);
	soap_serialize_PointerTo_ns1__ControlMeetingFault(soap, &a->ns1__ControlMeetingFault);
	soap_serialize_PointerTo_ns1__EndpointNotBoundFault(soap, &a->ns1__EndpointNotBoundFault);
	soap_serialize_PointerTo_ns1__FeatureNotAvailableFault(soap, &a->ns1__FeatureNotAvailableFault);
	soap_serialize_PointerTo_ns1__GeneralFault(soap, &a->ns1__GeneralFault);
	soap_serialize_PointerTo_ns1__InPointToPointCallFault(soap, &a->ns1__InPointToPointCallFault);
	soap_serialize_PointerTo_ns1__InvalidArgumentFault(soap, &a->ns1__InvalidArgumentFault);
	soap_serialize_PointerTo_ns1__InvalidModeratorPINFormatFault(soap, &a->ns1__InvalidModeratorPINFormatFault);
	soap_serialize_PointerTo_ns1__NotLicensedFault(soap, &a->ns1__NotLicensedFault);
	soap_serialize_PointerTo_ns1__PrefixNotConfiguredFault(soap, &a->ns1__PrefixNotConfiguredFault);
	soap_serialize_PointerTo_ns1__ResourceNotAvailableFault(soap, &a->ns1__ResourceNotAvailableFault);
	soap_serialize_PointerTo_ns1__RoomNotFoundFault(soap, &a->ns1__RoomNotFoundFault);
	soap_serialize_PointerTo_ns1__ScheduledRoomCreationFault(soap, &a->ns1__ScheduledRoomCreationFault);
	soap_serialize_PointerTo_ns1__SeatLicenseExpiredFault(soap, &a->ns1__SeatLicenseExpiredFault);
	soap_serialize_PointerTo_ns1__VidyoReplayNotAvailableFault(soap, &a->ns1__VidyoReplayNotAvailableFault);
	soap_serialize_PointerTo_ns1__WrongPINFault(soap, &a->ns1__WrongPINFault);
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_out_PointerTo_ns1__AccessRestrictedFault(soap, "ns1:AccessRestrictedFault", -1, &a->ns1__AccessRestrictedFault, ""))
		return soap->error;
	if (soap_out_PointerTo_ns1__ConferenceLockedFault(soap, "ns1:ConferenceLockedFault", -1, &a->ns1__ConferenceLockedFault, ""))
		return soap->error;
	if (soap_out_PointerTo_ns1__ControlMeetingFault(soap, "ns1:ControlMeetingFault", -1, &a->ns1__ControlMeetingFault, ""))
		return soap->error;
	if (soap_out_PointerTo_ns1__EndpointNotBoundFault(soap, "ns1:EndpointNotBoundFault", -1, &a->ns1__EndpointNotBoundFault, ""))
		return soap->error;
	if (soap_out_PointerTo_ns1__FeatureNotAvailableFault(soap, "ns1:FeatureNotAvailableFault", -1, &a->ns1__FeatureNotAvailableFault, ""))
		return soap->error;
	if (soap_out_PointerTo_ns1__GeneralFault(soap, "ns1:GeneralFault", -1, &a->ns1__GeneralFault, ""))
		return soap->error;
	if (soap_out_PointerTo_ns1__InPointToPointCallFault(soap, "ns1:InPointToPointCallFault", -1, &a->ns1__InPointToPointCallFault, ""))
		return soap->error;
	if (soap_out_PointerTo_ns1__InvalidArgumentFault(soap, "ns1:InvalidArgumentFault", -1, &a->ns1__InvalidArgumentFault, ""))
		return soap->error;
	if (soap_out_PointerTo_ns1__InvalidModeratorPINFormatFault(soap, "ns1:InvalidModeratorPINFormatFault", -1, &a->ns1__InvalidModeratorPINFormatFault, ""))
		return soap->error;
	if (soap_out_PointerTo_ns1__NotLicensedFault(soap, "ns1:NotLicensedFault", -1, &a->ns1__NotLicensedFault, ""))
		return soap->error;
	if (soap_out_PointerTo_ns1__PrefixNotConfiguredFault(soap, "ns1:PrefixNotConfiguredFault", -1, &a->ns1__PrefixNotConfiguredFault, ""))
		return soap->error;
	if (soap_out_PointerTo_ns1__ResourceNotAvailableFault(soap, "ns1:ResourceNotAvailableFault", -1, &a->ns1__ResourceNotAvailableFault, ""))
		return soap->error;
	if (soap_out_PointerTo_ns1__RoomNotFoundFault(soap, "ns1:RoomNotFoundFault", -1, &a->ns1__RoomNotFoundFault, ""))
		return soap->error;
	if (soap_out_PointerTo_ns1__ScheduledRoomCreationFault(soap, "ns1:ScheduledRoomCreationFault", -1, &a->ns1__ScheduledRoomCreationFault, ""))
		return soap->error;
	if (soap_out_PointerTo_ns1__SeatLicenseExpiredFault(soap, "ns1:SeatLicenseExpiredFault", -1, &a->ns1__SeatLicenseExpiredFault, ""))
		return soap->error;
	if (soap_out_PointerTo_ns1__VidyoReplayNotAvailableFault(soap, "ns1:VidyoReplayNotAvailableFault", -1, &a->ns1__VidyoReplayNotAvailableFault, ""))
		return soap->error;
	if (soap_out_PointerTo_ns1__WrongPINFault(soap, "ns1:WrongPINFault", -1, &a->ns1__WrongPINFault, ""))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_ns1__AccessRestrictedFault = 1;
	size_t soap_flag_ns1__ConferenceLockedFault = 1;
	size_t soap_flag_ns1__ControlMeetingFault = 1;
	size_t soap_flag_ns1__EndpointNotBoundFault = 1;
	size_t soap_flag_ns1__FeatureNotAvailableFault = 1;
	size_t soap_flag_ns1__GeneralFault = 1;
	size_t soap_flag_ns1__InPointToPointCallFault = 1;
	size_t soap_flag_ns1__InvalidArgumentFault = 1;
	size_t soap_flag_ns1__InvalidModeratorPINFormatFault = 1;
	size_t soap_flag_ns1__NotLicensedFault = 1;
	size_t soap_flag_ns1__PrefixNotConfiguredFault = 1;
	size_t soap_flag_ns1__ResourceNotAvailableFault = 1;
	size_t soap_flag_ns1__RoomNotFoundFault = 1;
	size_t soap_flag_ns1__ScheduledRoomCreationFault = 1;
	size_t soap_flag_ns1__SeatLicenseExpiredFault = 1;
	size_t soap_flag_ns1__VidyoReplayNotAvailableFault = 1;
	size_t soap_flag_ns1__WrongPINFault = 1;
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__AccessRestrictedFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__AccessRestrictedFault(soap, "ns1:AccessRestrictedFault", &a->ns1__AccessRestrictedFault, ""))
				{	soap_flag_ns1__AccessRestrictedFault--;
					continue;
				}
			if (soap_flag_ns1__ConferenceLockedFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__ConferenceLockedFault(soap, "ns1:ConferenceLockedFault", &a->ns1__ConferenceLockedFault, ""))
				{	soap_flag_ns1__ConferenceLockedFault--;
					continue;
				}
			if (soap_flag_ns1__ControlMeetingFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__ControlMeetingFault(soap, "ns1:ControlMeetingFault", &a->ns1__ControlMeetingFault, ""))
				{	soap_flag_ns1__ControlMeetingFault--;
					continue;
				}
			if (soap_flag_ns1__EndpointNotBoundFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__EndpointNotBoundFault(soap, "ns1:EndpointNotBoundFault", &a->ns1__EndpointNotBoundFault, ""))
				{	soap_flag_ns1__EndpointNotBoundFault--;
					continue;
				}
			if (soap_flag_ns1__FeatureNotAvailableFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__FeatureNotAvailableFault(soap, "ns1:FeatureNotAvailableFault", &a->ns1__FeatureNotAvailableFault, ""))
				{	soap_flag_ns1__FeatureNotAvailableFault--;
					continue;
				}
			if (soap_flag_ns1__GeneralFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GeneralFault(soap, "ns1:GeneralFault", &a->ns1__GeneralFault, ""))
				{	soap_flag_ns1__GeneralFault--;
					continue;
				}
			if (soap_flag_ns1__InPointToPointCallFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__InPointToPointCallFault(soap, "ns1:InPointToPointCallFault", &a->ns1__InPointToPointCallFault, ""))
				{	soap_flag_ns1__InPointToPointCallFault--;
					continue;
				}
			if (soap_flag_ns1__InvalidArgumentFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__InvalidArgumentFault(soap, "ns1:InvalidArgumentFault", &a->ns1__InvalidArgumentFault, ""))
				{	soap_flag_ns1__InvalidArgumentFault--;
					continue;
				}
			if (soap_flag_ns1__InvalidModeratorPINFormatFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__InvalidModeratorPINFormatFault(soap, "ns1:InvalidModeratorPINFormatFault", &a->ns1__InvalidModeratorPINFormatFault, ""))
				{	soap_flag_ns1__InvalidModeratorPINFormatFault--;
					continue;
				}
			if (soap_flag_ns1__NotLicensedFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__NotLicensedFault(soap, "ns1:NotLicensedFault", &a->ns1__NotLicensedFault, ""))
				{	soap_flag_ns1__NotLicensedFault--;
					continue;
				}
			if (soap_flag_ns1__PrefixNotConfiguredFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__PrefixNotConfiguredFault(soap, "ns1:PrefixNotConfiguredFault", &a->ns1__PrefixNotConfiguredFault, ""))
				{	soap_flag_ns1__PrefixNotConfiguredFault--;
					continue;
				}
			if (soap_flag_ns1__ResourceNotAvailableFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__ResourceNotAvailableFault(soap, "ns1:ResourceNotAvailableFault", &a->ns1__ResourceNotAvailableFault, ""))
				{	soap_flag_ns1__ResourceNotAvailableFault--;
					continue;
				}
			if (soap_flag_ns1__RoomNotFoundFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__RoomNotFoundFault(soap, "ns1:RoomNotFoundFault", &a->ns1__RoomNotFoundFault, ""))
				{	soap_flag_ns1__RoomNotFoundFault--;
					continue;
				}
			if (soap_flag_ns1__ScheduledRoomCreationFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__ScheduledRoomCreationFault(soap, "ns1:ScheduledRoomCreationFault", &a->ns1__ScheduledRoomCreationFault, ""))
				{	soap_flag_ns1__ScheduledRoomCreationFault--;
					continue;
				}
			if (soap_flag_ns1__SeatLicenseExpiredFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SeatLicenseExpiredFault(soap, "ns1:SeatLicenseExpiredFault", &a->ns1__SeatLicenseExpiredFault, ""))
				{	soap_flag_ns1__SeatLicenseExpiredFault--;
					continue;
				}
			if (soap_flag_ns1__VidyoReplayNotAvailableFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__VidyoReplayNotAvailableFault(soap, "ns1:VidyoReplayNotAvailableFault", &a->ns1__VidyoReplayNotAvailableFault, ""))
				{	soap_flag_ns1__VidyoReplayNotAvailableFault--;
					continue;
				}
			if (soap_flag_ns1__WrongPINFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__WrongPINFault(soap, "ns1:WrongPINFault", &a->ns1__WrongPINFault, ""))
				{	soap_flag_ns1__WrongPINFault--;
					continue;
				}
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fault > 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__union_DirectCallRequest(struct soap *soap, int choice, const union _ns1__union_DirectCallRequest *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__ns1__union_DirectCallRequest_entityID:
		soap_serialize_ns1__EntityID(soap, &a->entityID);
		break;
	case SOAP_UNION__ns1__union_DirectCallRequest_invite:
		soap_serialize_string(soap, &a->invite);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__union_DirectCallRequest(struct soap *soap, int choice, const union _ns1__union_DirectCallRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns1__union_DirectCallRequest_entityID:
		return soap_out_ns1__EntityID(soap, "ns1:entityID", -1, (char*const*)&a->entityID, "");
	case SOAP_UNION__ns1__union_DirectCallRequest_invite:
		return soap_out_string(soap, "ns1:invite", -1, (char*const*)&a->invite, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns1__union_DirectCallRequest * SOAP_FMAC4 soap_in__ns1__union_DirectCallRequest(struct soap *soap, int *choice, union _ns1__union_DirectCallRequest *a)
{
	(void)a; /* appease -Wall -Werror */	soap->error = SOAP_TAG_MISMATCH;
	a->entityID = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_ns1__EntityID(soap, "ns1:entityID", &a->entityID, "ns1:EntityID"))
	{	*choice = SOAP_UNION__ns1__union_DirectCallRequest_entityID;
		return a;
	}
	a->invite = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_string(soap, "ns1:invite", &a->invite, "xsd:string"))
	{	*choice = SOAP_UNION__ns1__union_DirectCallRequest_invite;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__union_JoinConferenceRequest(struct soap *soap, int choice, const union _ns1__union_JoinConferenceRequest *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__ns1__union_JoinConferenceRequest_conferenceID:
		soap_serialize_ns1__EntityID(soap, &a->conferenceID);
		break;
	case SOAP_UNION__ns1__union_JoinConferenceRequest_extension:
		soap_serialize_string(soap, &a->extension);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__union_JoinConferenceRequest(struct soap *soap, int choice, const union _ns1__union_JoinConferenceRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns1__union_JoinConferenceRequest_conferenceID:
		return soap_out_ns1__EntityID(soap, "ns1:conferenceID", -1, (char*const*)&a->conferenceID, "");
	case SOAP_UNION__ns1__union_JoinConferenceRequest_extension:
		return soap_out_string(soap, "ns1:extension", -1, (char*const*)&a->extension, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns1__union_JoinConferenceRequest * SOAP_FMAC4 soap_in__ns1__union_JoinConferenceRequest(struct soap *soap, int *choice, union _ns1__union_JoinConferenceRequest *a)
{
	(void)a; /* appease -Wall -Werror */	soap->error = SOAP_TAG_MISMATCH;
	a->conferenceID = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_ns1__EntityID(soap, "ns1:conferenceID", &a->conferenceID, "ns1:EntityID"))
	{	*choice = SOAP_UNION__ns1__union_JoinConferenceRequest_conferenceID;
		return a;
	}
	a->extension = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_string(soap, "ns1:extension", &a->extension, "xsd:string"))
	{	*choice = SOAP_UNION__ns1__union_JoinConferenceRequest_extension;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__union_InviteToConferenceRequest(struct soap *soap, int choice, const union _ns1__union_InviteToConferenceRequest *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__ns1__union_InviteToConferenceRequest_entityID:
		soap_serialize_ns1__EntityID(soap, &a->entityID);
		break;
	case SOAP_UNION__ns1__union_InviteToConferenceRequest_invite:
		soap_serialize_string(soap, &a->invite);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__union_InviteToConferenceRequest(struct soap *soap, int choice, const union _ns1__union_InviteToConferenceRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns1__union_InviteToConferenceRequest_entityID:
		return soap_out_ns1__EntityID(soap, "ns1:entityID", -1, (char*const*)&a->entityID, "");
	case SOAP_UNION__ns1__union_InviteToConferenceRequest_invite:
		return soap_out_string(soap, "ns1:invite", -1, (char*const*)&a->invite, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns1__union_InviteToConferenceRequest * SOAP_FMAC4 soap_in__ns1__union_InviteToConferenceRequest(struct soap *soap, int *choice, union _ns1__union_InviteToConferenceRequest *a)
{
	(void)a; /* appease -Wall -Werror */	soap->error = SOAP_TAG_MISMATCH;
	a->entityID = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_ns1__EntityID(soap, "ns1:entityID", &a->entityID, "ns1:EntityID"))
	{	*choice = SOAP_UNION__ns1__union_InviteToConferenceRequest_entityID;
		return a;
	}
	a->invite = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_string(soap, "ns1:invite", &a->invite, "xsd:string"))
	{	*choice = SOAP_UNION__ns1__union_InviteToConferenceRequest_invite;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetChangePasswordHtmlUrlWithTokenRequest(struct soap *soap, _ns1__GetChangePasswordHtmlUrlWithTokenRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetChangePasswordHtmlUrlWithTokenRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetChangePasswordHtmlUrlWithTokenRequest(struct soap *soap, const char *tag, int id, _ns1__GetChangePasswordHtmlUrlWithTokenRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetChangePasswordHtmlUrlWithTokenRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetChangePasswordHtmlUrlWithTokenRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetChangePasswordHtmlUrlWithTokenRequest(struct soap *soap, const char *tag, _ns1__GetChangePasswordHtmlUrlWithTokenRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetChangePasswordHtmlUrlWithTokenRequest **)soap_malloc(soap, sizeof(_ns1__GetChangePasswordHtmlUrlWithTokenRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetChangePasswordHtmlUrlWithTokenRequest *)soap_instantiate__ns1__GetChangePasswordHtmlUrlWithTokenRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetChangePasswordHtmlUrlWithTokenRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetChangePasswordHtmlUrlWithTokenRequest, sizeof(_ns1__GetChangePasswordHtmlUrlWithTokenRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetChangePasswordHtmlUrlWithTokenRequest(struct soap *soap, _ns1__GetChangePasswordHtmlUrlWithTokenRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetChangePasswordHtmlUrlWithTokenRequest(soap, tag?tag:"ns1:GetChangePasswordHtmlUrlWithTokenRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetChangePasswordHtmlUrlWithTokenRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetChangePasswordHtmlUrlWithTokenRequest(struct soap *soap, _ns1__GetChangePasswordHtmlUrlWithTokenRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetChangePasswordHtmlUrlWithTokenRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__WhatIsMyIPAddressRequest(struct soap *soap, _ns1__WhatIsMyIPAddressRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__WhatIsMyIPAddressRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__WhatIsMyIPAddressRequest(struct soap *soap, const char *tag, int id, _ns1__WhatIsMyIPAddressRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__WhatIsMyIPAddressRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__WhatIsMyIPAddressRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__WhatIsMyIPAddressRequest(struct soap *soap, const char *tag, _ns1__WhatIsMyIPAddressRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__WhatIsMyIPAddressRequest **)soap_malloc(soap, sizeof(_ns1__WhatIsMyIPAddressRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__WhatIsMyIPAddressRequest *)soap_instantiate__ns1__WhatIsMyIPAddressRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__WhatIsMyIPAddressRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__WhatIsMyIPAddressRequest, sizeof(_ns1__WhatIsMyIPAddressRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__WhatIsMyIPAddressRequest(struct soap *soap, _ns1__WhatIsMyIPAddressRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__WhatIsMyIPAddressRequest(soap, tag?tag:"ns1:WhatIsMyIPAddressRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__WhatIsMyIPAddressRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__WhatIsMyIPAddressRequest(struct soap *soap, _ns1__WhatIsMyIPAddressRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__WhatIsMyIPAddressRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetVidyoReplayLibraryRequest(struct soap *soap, _ns1__GetVidyoReplayLibraryRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetVidyoReplayLibraryRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetVidyoReplayLibraryRequest(struct soap *soap, const char *tag, int id, _ns1__GetVidyoReplayLibraryRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetVidyoReplayLibraryRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetVidyoReplayLibraryRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetVidyoReplayLibraryRequest(struct soap *soap, const char *tag, _ns1__GetVidyoReplayLibraryRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetVidyoReplayLibraryRequest **)soap_malloc(soap, sizeof(_ns1__GetVidyoReplayLibraryRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetVidyoReplayLibraryRequest *)soap_instantiate__ns1__GetVidyoReplayLibraryRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetVidyoReplayLibraryRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetVidyoReplayLibraryRequest, sizeof(_ns1__GetVidyoReplayLibraryRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetVidyoReplayLibraryRequest(struct soap *soap, _ns1__GetVidyoReplayLibraryRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetVidyoReplayLibraryRequest(soap, tag?tag:"ns1:GetVidyoReplayLibraryRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetVidyoReplayLibraryRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetVidyoReplayLibraryRequest(struct soap *soap, _ns1__GetVidyoReplayLibraryRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetVidyoReplayLibraryRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__RemovePresenterRequest(struct soap *soap, _ns1__RemovePresenterRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__RemovePresenterRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__RemovePresenterRequest(struct soap *soap, const char *tag, int id, _ns1__RemovePresenterRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__RemovePresenterRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__RemovePresenterRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__RemovePresenterRequest(struct soap *soap, const char *tag, _ns1__RemovePresenterRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__RemovePresenterRequest **)soap_malloc(soap, sizeof(_ns1__RemovePresenterRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__RemovePresenterRequest *)soap_instantiate__ns1__RemovePresenterRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__RemovePresenterRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__RemovePresenterRequest, sizeof(_ns1__RemovePresenterRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__RemovePresenterRequest(struct soap *soap, _ns1__RemovePresenterRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__RemovePresenterRequest(soap, tag?tag:"ns1:RemovePresenterRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__RemovePresenterRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__RemovePresenterRequest(struct soap *soap, _ns1__RemovePresenterRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__RemovePresenterRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SetPresenterRequest(struct soap *soap, _ns1__SetPresenterRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SetPresenterRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SetPresenterRequest(struct soap *soap, const char *tag, int id, _ns1__SetPresenterRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SetPresenterRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SetPresenterRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__SetPresenterRequest(struct soap *soap, const char *tag, _ns1__SetPresenterRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SetPresenterRequest **)soap_malloc(soap, sizeof(_ns1__SetPresenterRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SetPresenterRequest *)soap_instantiate__ns1__SetPresenterRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SetPresenterRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SetPresenterRequest, sizeof(_ns1__SetPresenterRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SetPresenterRequest(struct soap *soap, _ns1__SetPresenterRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SetPresenterRequest(soap, tag?tag:"ns1:SetPresenterRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SetPresenterRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__SetPresenterRequest(struct soap *soap, _ns1__SetPresenterRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SetPresenterRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DismissAllRaisedHandRequest(struct soap *soap, _ns1__DismissAllRaisedHandRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__DismissAllRaisedHandRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DismissAllRaisedHandRequest(struct soap *soap, const char *tag, int id, _ns1__DismissAllRaisedHandRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__DismissAllRaisedHandRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__DismissAllRaisedHandRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__DismissAllRaisedHandRequest(struct soap *soap, const char *tag, _ns1__DismissAllRaisedHandRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__DismissAllRaisedHandRequest **)soap_malloc(soap, sizeof(_ns1__DismissAllRaisedHandRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__DismissAllRaisedHandRequest *)soap_instantiate__ns1__DismissAllRaisedHandRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__DismissAllRaisedHandRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DismissAllRaisedHandRequest, sizeof(_ns1__DismissAllRaisedHandRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DismissAllRaisedHandRequest(struct soap *soap, _ns1__DismissAllRaisedHandRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__DismissAllRaisedHandRequest(soap, tag?tag:"ns1:DismissAllRaisedHandRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__DismissAllRaisedHandRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__DismissAllRaisedHandRequest(struct soap *soap, _ns1__DismissAllRaisedHandRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DismissAllRaisedHandRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DismissRaisedHandRequest(struct soap *soap, _ns1__DismissRaisedHandRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__DismissRaisedHandRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DismissRaisedHandRequest(struct soap *soap, const char *tag, int id, _ns1__DismissRaisedHandRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__DismissRaisedHandRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__DismissRaisedHandRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__DismissRaisedHandRequest(struct soap *soap, const char *tag, _ns1__DismissRaisedHandRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__DismissRaisedHandRequest **)soap_malloc(soap, sizeof(_ns1__DismissRaisedHandRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__DismissRaisedHandRequest *)soap_instantiate__ns1__DismissRaisedHandRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__DismissRaisedHandRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DismissRaisedHandRequest, sizeof(_ns1__DismissRaisedHandRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DismissRaisedHandRequest(struct soap *soap, _ns1__DismissRaisedHandRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__DismissRaisedHandRequest(soap, tag?tag:"ns1:DismissRaisedHandRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__DismissRaisedHandRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__DismissRaisedHandRequest(struct soap *soap, _ns1__DismissRaisedHandRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DismissRaisedHandRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__StopLectureModeRequest(struct soap *soap, _ns1__StopLectureModeRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__StopLectureModeRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__StopLectureModeRequest(struct soap *soap, const char *tag, int id, _ns1__StopLectureModeRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__StopLectureModeRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__StopLectureModeRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__StopLectureModeRequest(struct soap *soap, const char *tag, _ns1__StopLectureModeRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__StopLectureModeRequest **)soap_malloc(soap, sizeof(_ns1__StopLectureModeRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__StopLectureModeRequest *)soap_instantiate__ns1__StopLectureModeRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__StopLectureModeRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__StopLectureModeRequest, sizeof(_ns1__StopLectureModeRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__StopLectureModeRequest(struct soap *soap, _ns1__StopLectureModeRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__StopLectureModeRequest(soap, tag?tag:"ns1:StopLectureModeRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__StopLectureModeRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__StopLectureModeRequest(struct soap *soap, _ns1__StopLectureModeRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__StopLectureModeRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__StartLectureModeRequest(struct soap *soap, _ns1__StartLectureModeRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__StartLectureModeRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__StartLectureModeRequest(struct soap *soap, const char *tag, int id, _ns1__StartLectureModeRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__StartLectureModeRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__StartLectureModeRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__StartLectureModeRequest(struct soap *soap, const char *tag, _ns1__StartLectureModeRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__StartLectureModeRequest **)soap_malloc(soap, sizeof(_ns1__StartLectureModeRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__StartLectureModeRequest *)soap_instantiate__ns1__StartLectureModeRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__StartLectureModeRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__StartLectureModeRequest, sizeof(_ns1__StartLectureModeRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__StartLectureModeRequest(struct soap *soap, _ns1__StartLectureModeRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__StartLectureModeRequest(soap, tag?tag:"ns1:StartLectureModeRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__StartLectureModeRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__StartLectureModeRequest(struct soap *soap, _ns1__StartLectureModeRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__StartLectureModeRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getUserAccountTypeRequest(struct soap *soap, _ns1__getUserAccountTypeRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getUserAccountTypeRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getUserAccountTypeRequest(struct soap *soap, const char *tag, int id, _ns1__getUserAccountTypeRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getUserAccountTypeRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getUserAccountTypeRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__getUserAccountTypeRequest(struct soap *soap, const char *tag, _ns1__getUserAccountTypeRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getUserAccountTypeRequest **)soap_malloc(soap, sizeof(_ns1__getUserAccountTypeRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getUserAccountTypeRequest *)soap_instantiate__ns1__getUserAccountTypeRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__getUserAccountTypeRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getUserAccountTypeRequest, sizeof(_ns1__getUserAccountTypeRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getUserAccountTypeRequest(struct soap *soap, _ns1__getUserAccountTypeRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__getUserAccountTypeRequest(soap, tag?tag:"ns1:getUserAccountTypeRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getUserAccountTypeRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__getUserAccountTypeRequest(struct soap *soap, _ns1__getUserAccountTypeRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getUserAccountTypeRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getLoginAndWelcomeBannerRequest(struct soap *soap, _ns1__getLoginAndWelcomeBannerRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__getLoginAndWelcomeBannerRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getLoginAndWelcomeBannerRequest(struct soap *soap, const char *tag, int id, _ns1__getLoginAndWelcomeBannerRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__getLoginAndWelcomeBannerRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__getLoginAndWelcomeBannerRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__getLoginAndWelcomeBannerRequest(struct soap *soap, const char *tag, _ns1__getLoginAndWelcomeBannerRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__getLoginAndWelcomeBannerRequest **)soap_malloc(soap, sizeof(_ns1__getLoginAndWelcomeBannerRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__getLoginAndWelcomeBannerRequest *)soap_instantiate__ns1__getLoginAndWelcomeBannerRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__getLoginAndWelcomeBannerRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__getLoginAndWelcomeBannerRequest, sizeof(_ns1__getLoginAndWelcomeBannerRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getLoginAndWelcomeBannerRequest(struct soap *soap, _ns1__getLoginAndWelcomeBannerRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__getLoginAndWelcomeBannerRequest(soap, tag?tag:"ns1:getLoginAndWelcomeBannerRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__getLoginAndWelcomeBannerRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__getLoginAndWelcomeBannerRequest(struct soap *soap, _ns1__getLoginAndWelcomeBannerRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__getLoginAndWelcomeBannerRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__RoomAccessOptionsRequest(struct soap *soap, _ns1__RoomAccessOptionsRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__RoomAccessOptionsRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__RoomAccessOptionsRequest(struct soap *soap, const char *tag, int id, _ns1__RoomAccessOptionsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__RoomAccessOptionsRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__RoomAccessOptionsRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__RoomAccessOptionsRequest(struct soap *soap, const char *tag, _ns1__RoomAccessOptionsRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__RoomAccessOptionsRequest **)soap_malloc(soap, sizeof(_ns1__RoomAccessOptionsRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__RoomAccessOptionsRequest *)soap_instantiate__ns1__RoomAccessOptionsRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__RoomAccessOptionsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__RoomAccessOptionsRequest, sizeof(_ns1__RoomAccessOptionsRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__RoomAccessOptionsRequest(struct soap *soap, _ns1__RoomAccessOptionsRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__RoomAccessOptionsRequest(soap, tag?tag:"ns1:RoomAccessOptionsRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__RoomAccessOptionsRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__RoomAccessOptionsRequest(struct soap *soap, _ns1__RoomAccessOptionsRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__RoomAccessOptionsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__muteVideoClientAllRequest(struct soap *soap, _ns1__muteVideoClientAllRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__muteVideoClientAllRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__muteVideoClientAllRequest(struct soap *soap, const char *tag, int id, _ns1__muteVideoClientAllRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__muteVideoClientAllRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__muteVideoClientAllRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__muteVideoClientAllRequest(struct soap *soap, const char *tag, _ns1__muteVideoClientAllRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__muteVideoClientAllRequest **)soap_malloc(soap, sizeof(_ns1__muteVideoClientAllRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__muteVideoClientAllRequest *)soap_instantiate__ns1__muteVideoClientAllRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__muteVideoClientAllRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__muteVideoClientAllRequest, sizeof(_ns1__muteVideoClientAllRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__muteVideoClientAllRequest(struct soap *soap, _ns1__muteVideoClientAllRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__muteVideoClientAllRequest(soap, tag?tag:"ns1:muteVideoClientAllRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__muteVideoClientAllRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__muteVideoClientAllRequest(struct soap *soap, _ns1__muteVideoClientAllRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__muteVideoClientAllRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__muteVideoServerAllRequest(struct soap *soap, _ns1__muteVideoServerAllRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__muteVideoServerAllRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__muteVideoServerAllRequest(struct soap *soap, const char *tag, int id, _ns1__muteVideoServerAllRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__muteVideoServerAllRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__muteVideoServerAllRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__muteVideoServerAllRequest(struct soap *soap, const char *tag, _ns1__muteVideoServerAllRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__muteVideoServerAllRequest **)soap_malloc(soap, sizeof(_ns1__muteVideoServerAllRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__muteVideoServerAllRequest *)soap_instantiate__ns1__muteVideoServerAllRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__muteVideoServerAllRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__muteVideoServerAllRequest, sizeof(_ns1__muteVideoServerAllRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__muteVideoServerAllRequest(struct soap *soap, _ns1__muteVideoServerAllRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__muteVideoServerAllRequest(soap, tag?tag:"ns1:muteVideoServerAllRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__muteVideoServerAllRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__muteVideoServerAllRequest(struct soap *soap, _ns1__muteVideoServerAllRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__muteVideoServerAllRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__muteAudioClientAllRequest(struct soap *soap, _ns1__muteAudioClientAllRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__muteAudioClientAllRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__muteAudioClientAllRequest(struct soap *soap, const char *tag, int id, _ns1__muteAudioClientAllRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__muteAudioClientAllRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__muteAudioClientAllRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__muteAudioClientAllRequest(struct soap *soap, const char *tag, _ns1__muteAudioClientAllRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__muteAudioClientAllRequest **)soap_malloc(soap, sizeof(_ns1__muteAudioClientAllRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__muteAudioClientAllRequest *)soap_instantiate__ns1__muteAudioClientAllRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__muteAudioClientAllRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__muteAudioClientAllRequest, sizeof(_ns1__muteAudioClientAllRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__muteAudioClientAllRequest(struct soap *soap, _ns1__muteAudioClientAllRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__muteAudioClientAllRequest(soap, tag?tag:"ns1:muteAudioClientAllRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__muteAudioClientAllRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__muteAudioClientAllRequest(struct soap *soap, _ns1__muteAudioClientAllRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__muteAudioClientAllRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__muteAudioServerAllRequest(struct soap *soap, _ns1__muteAudioServerAllRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__muteAudioServerAllRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__muteAudioServerAllRequest(struct soap *soap, const char *tag, int id, _ns1__muteAudioServerAllRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__muteAudioServerAllRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__muteAudioServerAllRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__muteAudioServerAllRequest(struct soap *soap, const char *tag, _ns1__muteAudioServerAllRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__muteAudioServerAllRequest **)soap_malloc(soap, sizeof(_ns1__muteAudioServerAllRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__muteAudioServerAllRequest *)soap_instantiate__ns1__muteAudioServerAllRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__muteAudioServerAllRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__muteAudioServerAllRequest, sizeof(_ns1__muteAudioServerAllRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__muteAudioServerAllRequest(struct soap *soap, _ns1__muteAudioServerAllRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__muteAudioServerAllRequest(soap, tag?tag:"ns1:muteAudioServerAllRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__muteAudioServerAllRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__muteAudioServerAllRequest(struct soap *soap, _ns1__muteAudioServerAllRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__muteAudioServerAllRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__disconnectConferenceAllRequest(struct soap *soap, _ns1__disconnectConferenceAllRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__disconnectConferenceAllRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__disconnectConferenceAllRequest(struct soap *soap, const char *tag, int id, _ns1__disconnectConferenceAllRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__disconnectConferenceAllRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__disconnectConferenceAllRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__disconnectConferenceAllRequest(struct soap *soap, const char *tag, _ns1__disconnectConferenceAllRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__disconnectConferenceAllRequest **)soap_malloc(soap, sizeof(_ns1__disconnectConferenceAllRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__disconnectConferenceAllRequest *)soap_instantiate__ns1__disconnectConferenceAllRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__disconnectConferenceAllRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__disconnectConferenceAllRequest, sizeof(_ns1__disconnectConferenceAllRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__disconnectConferenceAllRequest(struct soap *soap, _ns1__disconnectConferenceAllRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__disconnectConferenceAllRequest(soap, tag?tag:"ns1:disconnectConferenceAllRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__disconnectConferenceAllRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__disconnectConferenceAllRequest(struct soap *soap, _ns1__disconnectConferenceAllRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__disconnectConferenceAllRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SetEndpointDetailsRequest(struct soap *soap, _ns1__SetEndpointDetailsRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SetEndpointDetailsRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SetEndpointDetailsRequest(struct soap *soap, const char *tag, int id, _ns1__SetEndpointDetailsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SetEndpointDetailsRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SetEndpointDetailsRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__SetEndpointDetailsRequest(struct soap *soap, const char *tag, _ns1__SetEndpointDetailsRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SetEndpointDetailsRequest **)soap_malloc(soap, sizeof(_ns1__SetEndpointDetailsRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SetEndpointDetailsRequest *)soap_instantiate__ns1__SetEndpointDetailsRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SetEndpointDetailsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SetEndpointDetailsRequest, sizeof(_ns1__SetEndpointDetailsRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SetEndpointDetailsRequest(struct soap *soap, _ns1__SetEndpointDetailsRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SetEndpointDetailsRequest(soap, tag?tag:"ns1:SetEndpointDetailsRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SetEndpointDetailsRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__SetEndpointDetailsRequest(struct soap *soap, _ns1__SetEndpointDetailsRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SetEndpointDetailsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DeleteScheduledRoomRequest(struct soap *soap, _ns1__DeleteScheduledRoomRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__DeleteScheduledRoomRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DeleteScheduledRoomRequest(struct soap *soap, const char *tag, int id, _ns1__DeleteScheduledRoomRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__DeleteScheduledRoomRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__DeleteScheduledRoomRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__DeleteScheduledRoomRequest(struct soap *soap, const char *tag, _ns1__DeleteScheduledRoomRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__DeleteScheduledRoomRequest **)soap_malloc(soap, sizeof(_ns1__DeleteScheduledRoomRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__DeleteScheduledRoomRequest *)soap_instantiate__ns1__DeleteScheduledRoomRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__DeleteScheduledRoomRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DeleteScheduledRoomRequest, sizeof(_ns1__DeleteScheduledRoomRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DeleteScheduledRoomRequest(struct soap *soap, _ns1__DeleteScheduledRoomRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__DeleteScheduledRoomRequest(soap, tag?tag:"ns1:DeleteScheduledRoomRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__DeleteScheduledRoomRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__DeleteScheduledRoomRequest(struct soap *soap, _ns1__DeleteScheduledRoomRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DeleteScheduledRoomRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CreateScheduledRoomRequest(struct soap *soap, _ns1__CreateScheduledRoomRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CreateScheduledRoomRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CreateScheduledRoomRequest(struct soap *soap, const char *tag, int id, _ns1__CreateScheduledRoomRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CreateScheduledRoomRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__CreateScheduledRoomRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__CreateScheduledRoomRequest(struct soap *soap, const char *tag, _ns1__CreateScheduledRoomRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CreateScheduledRoomRequest **)soap_malloc(soap, sizeof(_ns1__CreateScheduledRoomRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CreateScheduledRoomRequest *)soap_instantiate__ns1__CreateScheduledRoomRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__CreateScheduledRoomRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CreateScheduledRoomRequest, sizeof(_ns1__CreateScheduledRoomRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CreateScheduledRoomRequest(struct soap *soap, _ns1__CreateScheduledRoomRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__CreateScheduledRoomRequest(soap, tag?tag:"ns1:CreateScheduledRoomRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__CreateScheduledRoomRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__CreateScheduledRoomRequest(struct soap *soap, _ns1__CreateScheduledRoomRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CreateScheduledRoomRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GenerateAuthTokenRequest(struct soap *soap, _ns1__GenerateAuthTokenRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GenerateAuthTokenRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GenerateAuthTokenRequest(struct soap *soap, const char *tag, int id, _ns1__GenerateAuthTokenRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GenerateAuthTokenRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GenerateAuthTokenRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__GenerateAuthTokenRequest(struct soap *soap, const char *tag, _ns1__GenerateAuthTokenRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GenerateAuthTokenRequest **)soap_malloc(soap, sizeof(_ns1__GenerateAuthTokenRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GenerateAuthTokenRequest *)soap_instantiate__ns1__GenerateAuthTokenRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GenerateAuthTokenRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GenerateAuthTokenRequest, sizeof(_ns1__GenerateAuthTokenRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GenerateAuthTokenRequest(struct soap *soap, _ns1__GenerateAuthTokenRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GenerateAuthTokenRequest(soap, tag?tag:"ns1:GenerateAuthTokenRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GenerateAuthTokenRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__GenerateAuthTokenRequest(struct soap *soap, _ns1__GenerateAuthTokenRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GenerateAuthTokenRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetConferenceIDRequest(struct soap *soap, _ns1__GetConferenceIDRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetConferenceIDRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetConferenceIDRequest(struct soap *soap, const char *tag, int id, _ns1__GetConferenceIDRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetConferenceIDRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetConferenceIDRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetConferenceIDRequest(struct soap *soap, const char *tag, _ns1__GetConferenceIDRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetConferenceIDRequest **)soap_malloc(soap, sizeof(_ns1__GetConferenceIDRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetConferenceIDRequest *)soap_instantiate__ns1__GetConferenceIDRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetConferenceIDRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetConferenceIDRequest, sizeof(_ns1__GetConferenceIDRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetConferenceIDRequest(struct soap *soap, _ns1__GetConferenceIDRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetConferenceIDRequest(soap, tag?tag:"ns1:GetConferenceIDRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetConferenceIDRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetConferenceIDRequest(struct soap *soap, _ns1__GetConferenceIDRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetConferenceIDRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__RemoveModeratorPINRequest(struct soap *soap, _ns1__RemoveModeratorPINRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__RemoveModeratorPINRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__RemoveModeratorPINRequest(struct soap *soap, const char *tag, int id, _ns1__RemoveModeratorPINRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__RemoveModeratorPINRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__RemoveModeratorPINRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__RemoveModeratorPINRequest(struct soap *soap, const char *tag, _ns1__RemoveModeratorPINRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__RemoveModeratorPINRequest **)soap_malloc(soap, sizeof(_ns1__RemoveModeratorPINRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__RemoveModeratorPINRequest *)soap_instantiate__ns1__RemoveModeratorPINRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__RemoveModeratorPINRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__RemoveModeratorPINRequest, sizeof(_ns1__RemoveModeratorPINRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__RemoveModeratorPINRequest(struct soap *soap, _ns1__RemoveModeratorPINRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__RemoveModeratorPINRequest(soap, tag?tag:"ns1:RemoveModeratorPINRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__RemoveModeratorPINRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__RemoveModeratorPINRequest(struct soap *soap, _ns1__RemoveModeratorPINRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__RemoveModeratorPINRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CreateModeratorPINRequest(struct soap *soap, _ns1__CreateModeratorPINRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CreateModeratorPINRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CreateModeratorPINRequest(struct soap *soap, const char *tag, int id, _ns1__CreateModeratorPINRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CreateModeratorPINRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__CreateModeratorPINRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__CreateModeratorPINRequest(struct soap *soap, const char *tag, _ns1__CreateModeratorPINRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CreateModeratorPINRequest **)soap_malloc(soap, sizeof(_ns1__CreateModeratorPINRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CreateModeratorPINRequest *)soap_instantiate__ns1__CreateModeratorPINRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__CreateModeratorPINRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CreateModeratorPINRequest, sizeof(_ns1__CreateModeratorPINRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CreateModeratorPINRequest(struct soap *soap, _ns1__CreateModeratorPINRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__CreateModeratorPINRequest(soap, tag?tag:"ns1:CreateModeratorPINRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__CreateModeratorPINRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__CreateModeratorPINRequest(struct soap *soap, _ns1__CreateModeratorPINRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CreateModeratorPINRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetModeratorURLWithTokenRequest(struct soap *soap, _ns1__GetModeratorURLWithTokenRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetModeratorURLWithTokenRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetModeratorURLWithTokenRequest(struct soap *soap, const char *tag, int id, _ns1__GetModeratorURLWithTokenRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetModeratorURLWithTokenRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetModeratorURLWithTokenRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetModeratorURLWithTokenRequest(struct soap *soap, const char *tag, _ns1__GetModeratorURLWithTokenRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetModeratorURLWithTokenRequest **)soap_malloc(soap, sizeof(_ns1__GetModeratorURLWithTokenRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetModeratorURLWithTokenRequest *)soap_instantiate__ns1__GetModeratorURLWithTokenRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetModeratorURLWithTokenRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetModeratorURLWithTokenRequest, sizeof(_ns1__GetModeratorURLWithTokenRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetModeratorURLWithTokenRequest(struct soap *soap, _ns1__GetModeratorURLWithTokenRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetModeratorURLWithTokenRequest(soap, tag?tag:"ns1:GetModeratorURLWithTokenRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetModeratorURLWithTokenRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetModeratorURLWithTokenRequest(struct soap *soap, _ns1__GetModeratorURLWithTokenRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetModeratorURLWithTokenRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetModeratorURLRequest(struct soap *soap, _ns1__GetModeratorURLRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetModeratorURLRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetModeratorURLRequest(struct soap *soap, const char *tag, int id, _ns1__GetModeratorURLRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetModeratorURLRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetModeratorURLRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetModeratorURLRequest(struct soap *soap, const char *tag, _ns1__GetModeratorURLRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetModeratorURLRequest **)soap_malloc(soap, sizeof(_ns1__GetModeratorURLRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetModeratorURLRequest *)soap_instantiate__ns1__GetModeratorURLRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetModeratorURLRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetModeratorURLRequest, sizeof(_ns1__GetModeratorURLRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetModeratorURLRequest(struct soap *soap, _ns1__GetModeratorURLRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetModeratorURLRequest(soap, tag?tag:"ns1:GetModeratorURLRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetModeratorURLRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetModeratorURLRequest(struct soap *soap, _ns1__GetModeratorURLRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetModeratorURLRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__RemoveModeratorURLRequest(struct soap *soap, _ns1__RemoveModeratorURLRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__RemoveModeratorURLRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__RemoveModeratorURLRequest(struct soap *soap, const char *tag, int id, _ns1__RemoveModeratorURLRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__RemoveModeratorURLRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__RemoveModeratorURLRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__RemoveModeratorURLRequest(struct soap *soap, const char *tag, _ns1__RemoveModeratorURLRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__RemoveModeratorURLRequest **)soap_malloc(soap, sizeof(_ns1__RemoveModeratorURLRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__RemoveModeratorURLRequest *)soap_instantiate__ns1__RemoveModeratorURLRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__RemoveModeratorURLRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__RemoveModeratorURLRequest, sizeof(_ns1__RemoveModeratorURLRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__RemoveModeratorURLRequest(struct soap *soap, _ns1__RemoveModeratorURLRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__RemoveModeratorURLRequest(soap, tag?tag:"ns1:RemoveModeratorURLRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__RemoveModeratorURLRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__RemoveModeratorURLRequest(struct soap *soap, _ns1__RemoveModeratorURLRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__RemoveModeratorURLRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CreateModeratorURLRequest(struct soap *soap, _ns1__CreateModeratorURLRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CreateModeratorURLRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CreateModeratorURLRequest(struct soap *soap, const char *tag, int id, _ns1__CreateModeratorURLRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CreateModeratorURLRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__CreateModeratorURLRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__CreateModeratorURLRequest(struct soap *soap, const char *tag, _ns1__CreateModeratorURLRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CreateModeratorURLRequest **)soap_malloc(soap, sizeof(_ns1__CreateModeratorURLRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CreateModeratorURLRequest *)soap_instantiate__ns1__CreateModeratorURLRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__CreateModeratorURLRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CreateModeratorURLRequest, sizeof(_ns1__CreateModeratorURLRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CreateModeratorURLRequest(struct soap *soap, _ns1__CreateModeratorURLRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__CreateModeratorURLRequest(soap, tag?tag:"ns1:CreateModeratorURLRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__CreateModeratorURLRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__CreateModeratorURLRequest(struct soap *soap, _ns1__CreateModeratorURLRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CreateModeratorURLRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__RemoveRoomProfileRequest(struct soap *soap, _ns1__RemoveRoomProfileRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__RemoveRoomProfileRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__RemoveRoomProfileRequest(struct soap *soap, const char *tag, int id, _ns1__RemoveRoomProfileRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__RemoveRoomProfileRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__RemoveRoomProfileRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__RemoveRoomProfileRequest(struct soap *soap, const char *tag, _ns1__RemoveRoomProfileRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__RemoveRoomProfileRequest **)soap_malloc(soap, sizeof(_ns1__RemoveRoomProfileRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__RemoveRoomProfileRequest *)soap_instantiate__ns1__RemoveRoomProfileRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__RemoveRoomProfileRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__RemoveRoomProfileRequest, sizeof(_ns1__RemoveRoomProfileRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__RemoveRoomProfileRequest(struct soap *soap, _ns1__RemoveRoomProfileRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__RemoveRoomProfileRequest(soap, tag?tag:"ns1:RemoveRoomProfileRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__RemoveRoomProfileRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__RemoveRoomProfileRequest(struct soap *soap, _ns1__RemoveRoomProfileRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__RemoveRoomProfileRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SetRoomProfileRequest(struct soap *soap, _ns1__SetRoomProfileRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SetRoomProfileRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SetRoomProfileRequest(struct soap *soap, const char *tag, int id, _ns1__SetRoomProfileRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SetRoomProfileRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SetRoomProfileRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__SetRoomProfileRequest(struct soap *soap, const char *tag, _ns1__SetRoomProfileRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SetRoomProfileRequest **)soap_malloc(soap, sizeof(_ns1__SetRoomProfileRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SetRoomProfileRequest *)soap_instantiate__ns1__SetRoomProfileRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SetRoomProfileRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SetRoomProfileRequest, sizeof(_ns1__SetRoomProfileRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SetRoomProfileRequest(struct soap *soap, _ns1__SetRoomProfileRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SetRoomProfileRequest(soap, tag?tag:"ns1:SetRoomProfileRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SetRoomProfileRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__SetRoomProfileRequest(struct soap *soap, _ns1__SetRoomProfileRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SetRoomProfileRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetRoomProfileRequest(struct soap *soap, _ns1__GetRoomProfileRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetRoomProfileRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetRoomProfileRequest(struct soap *soap, const char *tag, int id, _ns1__GetRoomProfileRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetRoomProfileRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetRoomProfileRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetRoomProfileRequest(struct soap *soap, const char *tag, _ns1__GetRoomProfileRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetRoomProfileRequest **)soap_malloc(soap, sizeof(_ns1__GetRoomProfileRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetRoomProfileRequest *)soap_instantiate__ns1__GetRoomProfileRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetRoomProfileRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetRoomProfileRequest, sizeof(_ns1__GetRoomProfileRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetRoomProfileRequest(struct soap *soap, _ns1__GetRoomProfileRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetRoomProfileRequest(soap, tag?tag:"ns1:GetRoomProfileRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetRoomProfileRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetRoomProfileRequest(struct soap *soap, _ns1__GetRoomProfileRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetRoomProfileRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetInviteContentRequest(struct soap *soap, _ns1__GetInviteContentRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetInviteContentRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetInviteContentRequest(struct soap *soap, const char *tag, int id, _ns1__GetInviteContentRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetInviteContentRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetInviteContentRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetInviteContentRequest(struct soap *soap, const char *tag, _ns1__GetInviteContentRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetInviteContentRequest **)soap_malloc(soap, sizeof(_ns1__GetInviteContentRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetInviteContentRequest *)soap_instantiate__ns1__GetInviteContentRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetInviteContentRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetInviteContentRequest, sizeof(_ns1__GetInviteContentRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetInviteContentRequest(struct soap *soap, _ns1__GetInviteContentRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetInviteContentRequest(soap, tag?tag:"ns1:GetInviteContentRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetInviteContentRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetInviteContentRequest(struct soap *soap, _ns1__GetInviteContentRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetInviteContentRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetEntityByRoomKeyRequest(struct soap *soap, _ns1__GetEntityByRoomKeyRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetEntityByRoomKeyRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetEntityByRoomKeyRequest(struct soap *soap, const char *tag, int id, _ns1__GetEntityByRoomKeyRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetEntityByRoomKeyRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetEntityByRoomKeyRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetEntityByRoomKeyRequest(struct soap *soap, const char *tag, _ns1__GetEntityByRoomKeyRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetEntityByRoomKeyRequest **)soap_malloc(soap, sizeof(_ns1__GetEntityByRoomKeyRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetEntityByRoomKeyRequest *)soap_instantiate__ns1__GetEntityByRoomKeyRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetEntityByRoomKeyRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetEntityByRoomKeyRequest, sizeof(_ns1__GetEntityByRoomKeyRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetEntityByRoomKeyRequest(struct soap *soap, _ns1__GetEntityByRoomKeyRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetEntityByRoomKeyRequest(soap, tag?tag:"ns1:GetEntityByRoomKeyRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetEntityByRoomKeyRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetEntityByRoomKeyRequest(struct soap *soap, _ns1__GetEntityByRoomKeyRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetEntityByRoomKeyRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetUserNameRequest(struct soap *soap, _ns1__GetUserNameRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetUserNameRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetUserNameRequest(struct soap *soap, const char *tag, int id, _ns1__GetUserNameRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetUserNameRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetUserNameRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetUserNameRequest(struct soap *soap, const char *tag, _ns1__GetUserNameRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetUserNameRequest **)soap_malloc(soap, sizeof(_ns1__GetUserNameRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetUserNameRequest *)soap_instantiate__ns1__GetUserNameRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetUserNameRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetUserNameRequest, sizeof(_ns1__GetUserNameRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetUserNameRequest(struct soap *soap, _ns1__GetUserNameRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetUserNameRequest(soap, tag?tag:"ns1:GetUserNameRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetUserNameRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetUserNameRequest(struct soap *soap, _ns1__GetUserNameRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetUserNameRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetWebcastURLRequest(struct soap *soap, _ns1__GetWebcastURLRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetWebcastURLRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetWebcastURLRequest(struct soap *soap, const char *tag, int id, _ns1__GetWebcastURLRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetWebcastURLRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetWebcastURLRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetWebcastURLRequest(struct soap *soap, const char *tag, _ns1__GetWebcastURLRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetWebcastURLRequest **)soap_malloc(soap, sizeof(_ns1__GetWebcastURLRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetWebcastURLRequest *)soap_instantiate__ns1__GetWebcastURLRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetWebcastURLRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetWebcastURLRequest, sizeof(_ns1__GetWebcastURLRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetWebcastURLRequest(struct soap *soap, _ns1__GetWebcastURLRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetWebcastURLRequest(soap, tag?tag:"ns1:GetWebcastURLRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetWebcastURLRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetWebcastURLRequest(struct soap *soap, _ns1__GetWebcastURLRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetWebcastURLRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__RemoveWebcastPINRequest(struct soap *soap, _ns1__RemoveWebcastPINRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__RemoveWebcastPINRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__RemoveWebcastPINRequest(struct soap *soap, const char *tag, int id, _ns1__RemoveWebcastPINRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__RemoveWebcastPINRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__RemoveWebcastPINRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__RemoveWebcastPINRequest(struct soap *soap, const char *tag, _ns1__RemoveWebcastPINRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__RemoveWebcastPINRequest **)soap_malloc(soap, sizeof(_ns1__RemoveWebcastPINRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__RemoveWebcastPINRequest *)soap_instantiate__ns1__RemoveWebcastPINRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__RemoveWebcastPINRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__RemoveWebcastPINRequest, sizeof(_ns1__RemoveWebcastPINRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__RemoveWebcastPINRequest(struct soap *soap, _ns1__RemoveWebcastPINRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__RemoveWebcastPINRequest(soap, tag?tag:"ns1:RemoveWebcastPINRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__RemoveWebcastPINRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__RemoveWebcastPINRequest(struct soap *soap, _ns1__RemoveWebcastPINRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__RemoveWebcastPINRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__RemoveWebcastURLRequest(struct soap *soap, _ns1__RemoveWebcastURLRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__RemoveWebcastURLRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__RemoveWebcastURLRequest(struct soap *soap, const char *tag, int id, _ns1__RemoveWebcastURLRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__RemoveWebcastURLRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__RemoveWebcastURLRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__RemoveWebcastURLRequest(struct soap *soap, const char *tag, _ns1__RemoveWebcastURLRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__RemoveWebcastURLRequest **)soap_malloc(soap, sizeof(_ns1__RemoveWebcastURLRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__RemoveWebcastURLRequest *)soap_instantiate__ns1__RemoveWebcastURLRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__RemoveWebcastURLRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__RemoveWebcastURLRequest, sizeof(_ns1__RemoveWebcastURLRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__RemoveWebcastURLRequest(struct soap *soap, _ns1__RemoveWebcastURLRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__RemoveWebcastURLRequest(soap, tag?tag:"ns1:RemoveWebcastURLRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__RemoveWebcastURLRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__RemoveWebcastURLRequest(struct soap *soap, _ns1__RemoveWebcastURLRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__RemoveWebcastURLRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CreateWebcastPINRequest(struct soap *soap, _ns1__CreateWebcastPINRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CreateWebcastPINRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CreateWebcastPINRequest(struct soap *soap, const char *tag, int id, _ns1__CreateWebcastPINRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CreateWebcastPINRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__CreateWebcastPINRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__CreateWebcastPINRequest(struct soap *soap, const char *tag, _ns1__CreateWebcastPINRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CreateWebcastPINRequest **)soap_malloc(soap, sizeof(_ns1__CreateWebcastPINRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CreateWebcastPINRequest *)soap_instantiate__ns1__CreateWebcastPINRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__CreateWebcastPINRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CreateWebcastPINRequest, sizeof(_ns1__CreateWebcastPINRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CreateWebcastPINRequest(struct soap *soap, _ns1__CreateWebcastPINRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__CreateWebcastPINRequest(soap, tag?tag:"ns1:CreateWebcastPINRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__CreateWebcastPINRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__CreateWebcastPINRequest(struct soap *soap, _ns1__CreateWebcastPINRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CreateWebcastPINRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CreateWebcastURLRequest(struct soap *soap, _ns1__CreateWebcastURLRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CreateWebcastURLRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CreateWebcastURLRequest(struct soap *soap, const char *tag, int id, _ns1__CreateWebcastURLRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CreateWebcastURLRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__CreateWebcastURLRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__CreateWebcastURLRequest(struct soap *soap, const char *tag, _ns1__CreateWebcastURLRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CreateWebcastURLRequest **)soap_malloc(soap, sizeof(_ns1__CreateWebcastURLRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CreateWebcastURLRequest *)soap_instantiate__ns1__CreateWebcastURLRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__CreateWebcastURLRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CreateWebcastURLRequest, sizeof(_ns1__CreateWebcastURLRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CreateWebcastURLRequest(struct soap *soap, _ns1__CreateWebcastURLRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__CreateWebcastURLRequest(soap, tag?tag:"ns1:CreateWebcastURLRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__CreateWebcastURLRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__CreateWebcastURLRequest(struct soap *soap, _ns1__CreateWebcastURLRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CreateWebcastURLRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__StopRecordingRequest(struct soap *soap, _ns1__StopRecordingRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__StopRecordingRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__StopRecordingRequest(struct soap *soap, const char *tag, int id, _ns1__StopRecordingRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__StopRecordingRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__StopRecordingRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__StopRecordingRequest(struct soap *soap, const char *tag, _ns1__StopRecordingRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__StopRecordingRequest **)soap_malloc(soap, sizeof(_ns1__StopRecordingRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__StopRecordingRequest *)soap_instantiate__ns1__StopRecordingRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__StopRecordingRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__StopRecordingRequest, sizeof(_ns1__StopRecordingRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__StopRecordingRequest(struct soap *soap, _ns1__StopRecordingRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__StopRecordingRequest(soap, tag?tag:"ns1:StopRecordingRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__StopRecordingRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__StopRecordingRequest(struct soap *soap, _ns1__StopRecordingRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__StopRecordingRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ResumeRecordingRequest(struct soap *soap, _ns1__ResumeRecordingRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ResumeRecordingRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ResumeRecordingRequest(struct soap *soap, const char *tag, int id, _ns1__ResumeRecordingRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ResumeRecordingRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__ResumeRecordingRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__ResumeRecordingRequest(struct soap *soap, const char *tag, _ns1__ResumeRecordingRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ResumeRecordingRequest **)soap_malloc(soap, sizeof(_ns1__ResumeRecordingRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ResumeRecordingRequest *)soap_instantiate__ns1__ResumeRecordingRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__ResumeRecordingRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ResumeRecordingRequest, sizeof(_ns1__ResumeRecordingRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ResumeRecordingRequest(struct soap *soap, _ns1__ResumeRecordingRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__ResumeRecordingRequest(soap, tag?tag:"ns1:ResumeRecordingRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__ResumeRecordingRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__ResumeRecordingRequest(struct soap *soap, _ns1__ResumeRecordingRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ResumeRecordingRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__PauseRecordingRequest(struct soap *soap, _ns1__PauseRecordingRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__PauseRecordingRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__PauseRecordingRequest(struct soap *soap, const char *tag, int id, _ns1__PauseRecordingRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__PauseRecordingRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__PauseRecordingRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__PauseRecordingRequest(struct soap *soap, const char *tag, _ns1__PauseRecordingRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__PauseRecordingRequest **)soap_malloc(soap, sizeof(_ns1__PauseRecordingRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__PauseRecordingRequest *)soap_instantiate__ns1__PauseRecordingRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__PauseRecordingRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__PauseRecordingRequest, sizeof(_ns1__PauseRecordingRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__PauseRecordingRequest(struct soap *soap, _ns1__PauseRecordingRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__PauseRecordingRequest(soap, tag?tag:"ns1:PauseRecordingRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__PauseRecordingRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__PauseRecordingRequest(struct soap *soap, _ns1__PauseRecordingRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__PauseRecordingRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPortalVersionRequest(struct soap *soap, _ns1__GetPortalVersionRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPortalVersionRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPortalVersionRequest(struct soap *soap, const char *tag, int id, _ns1__GetPortalVersionRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPortalVersionRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPortalVersionRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPortalVersionRequest(struct soap *soap, const char *tag, _ns1__GetPortalVersionRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPortalVersionRequest **)soap_malloc(soap, sizeof(_ns1__GetPortalVersionRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPortalVersionRequest *)soap_instantiate__ns1__GetPortalVersionRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetPortalVersionRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPortalVersionRequest, sizeof(_ns1__GetPortalVersionRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPortalVersionRequest(struct soap *soap, _ns1__GetPortalVersionRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetPortalVersionRequest(soap, tag?tag:"ns1:GetPortalVersionRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPortalVersionRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPortalVersionRequest(struct soap *soap, _ns1__GetPortalVersionRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPortalVersionRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__StartRecordingRequest(struct soap *soap, _ns1__StartRecordingRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__StartRecordingRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__StartRecordingRequest(struct soap *soap, const char *tag, int id, _ns1__StartRecordingRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__StartRecordingRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__StartRecordingRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__StartRecordingRequest(struct soap *soap, const char *tag, _ns1__StartRecordingRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__StartRecordingRequest **)soap_malloc(soap, sizeof(_ns1__StartRecordingRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__StartRecordingRequest *)soap_instantiate__ns1__StartRecordingRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__StartRecordingRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__StartRecordingRequest, sizeof(_ns1__StartRecordingRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__StartRecordingRequest(struct soap *soap, _ns1__StartRecordingRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__StartRecordingRequest(soap, tag?tag:"ns1:StartRecordingRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__StartRecordingRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__StartRecordingRequest(struct soap *soap, _ns1__StartRecordingRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__StartRecordingRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetRecordingProfilesRequest(struct soap *soap, _ns1__GetRecordingProfilesRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetRecordingProfilesRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetRecordingProfilesRequest(struct soap *soap, const char *tag, int id, _ns1__GetRecordingProfilesRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetRecordingProfilesRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetRecordingProfilesRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetRecordingProfilesRequest(struct soap *soap, const char *tag, _ns1__GetRecordingProfilesRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetRecordingProfilesRequest **)soap_malloc(soap, sizeof(_ns1__GetRecordingProfilesRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetRecordingProfilesRequest *)soap_instantiate__ns1__GetRecordingProfilesRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetRecordingProfilesRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetRecordingProfilesRequest, sizeof(_ns1__GetRecordingProfilesRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetRecordingProfilesRequest(struct soap *soap, _ns1__GetRecordingProfilesRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetRecordingProfilesRequest(soap, tag?tag:"ns1:GetRecordingProfilesRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetRecordingProfilesRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetRecordingProfilesRequest(struct soap *soap, _ns1__GetRecordingProfilesRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetRecordingProfilesRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SetMemberModeRequest(struct soap *soap, _ns1__SetMemberModeRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SetMemberModeRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SetMemberModeRequest(struct soap *soap, const char *tag, int id, _ns1__SetMemberModeRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SetMemberModeRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SetMemberModeRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__SetMemberModeRequest(struct soap *soap, const char *tag, _ns1__SetMemberModeRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SetMemberModeRequest **)soap_malloc(soap, sizeof(_ns1__SetMemberModeRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SetMemberModeRequest *)soap_instantiate__ns1__SetMemberModeRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SetMemberModeRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SetMemberModeRequest, sizeof(_ns1__SetMemberModeRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SetMemberModeRequest(struct soap *soap, _ns1__SetMemberModeRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SetMemberModeRequest(soap, tag?tag:"ns1:SetMemberModeRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SetMemberModeRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__SetMemberModeRequest(struct soap *soap, _ns1__SetMemberModeRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SetMemberModeRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UnlockRoomRequest(struct soap *soap, _ns1__UnlockRoomRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UnlockRoomRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UnlockRoomRequest(struct soap *soap, const char *tag, int id, _ns1__UnlockRoomRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UnlockRoomRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UnlockRoomRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__UnlockRoomRequest(struct soap *soap, const char *tag, _ns1__UnlockRoomRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UnlockRoomRequest **)soap_malloc(soap, sizeof(_ns1__UnlockRoomRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UnlockRoomRequest *)soap_instantiate__ns1__UnlockRoomRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__UnlockRoomRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UnlockRoomRequest, sizeof(_ns1__UnlockRoomRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UnlockRoomRequest(struct soap *soap, _ns1__UnlockRoomRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__UnlockRoomRequest(soap, tag?tag:"ns1:UnlockRoomRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UnlockRoomRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__UnlockRoomRequest(struct soap *soap, _ns1__UnlockRoomRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UnlockRoomRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__LockRoomRequest(struct soap *soap, _ns1__LockRoomRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__LockRoomRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__LockRoomRequest(struct soap *soap, const char *tag, int id, _ns1__LockRoomRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__LockRoomRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__LockRoomRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__LockRoomRequest(struct soap *soap, const char *tag, _ns1__LockRoomRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__LockRoomRequest **)soap_malloc(soap, sizeof(_ns1__LockRoomRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__LockRoomRequest *)soap_instantiate__ns1__LockRoomRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__LockRoomRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__LockRoomRequest, sizeof(_ns1__LockRoomRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__LockRoomRequest(struct soap *soap, _ns1__LockRoomRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__LockRoomRequest(soap, tag?tag:"ns1:LockRoomRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__LockRoomRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__LockRoomRequest(struct soap *soap, _ns1__LockRoomRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__LockRoomRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UpdateLanguageRequest(struct soap *soap, _ns1__UpdateLanguageRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UpdateLanguageRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UpdateLanguageRequest(struct soap *soap, const char *tag, int id, _ns1__UpdateLanguageRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UpdateLanguageRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UpdateLanguageRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__UpdateLanguageRequest(struct soap *soap, const char *tag, _ns1__UpdateLanguageRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UpdateLanguageRequest **)soap_malloc(soap, sizeof(_ns1__UpdateLanguageRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UpdateLanguageRequest *)soap_instantiate__ns1__UpdateLanguageRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__UpdateLanguageRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UpdateLanguageRequest, sizeof(_ns1__UpdateLanguageRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UpdateLanguageRequest(struct soap *soap, _ns1__UpdateLanguageRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__UpdateLanguageRequest(soap, tag?tag:"ns1:UpdateLanguageRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UpdateLanguageRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__UpdateLanguageRequest(struct soap *soap, _ns1__UpdateLanguageRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UpdateLanguageRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UpdatePasswordRequest(struct soap *soap, _ns1__UpdatePasswordRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UpdatePasswordRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UpdatePasswordRequest(struct soap *soap, const char *tag, int id, _ns1__UpdatePasswordRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UpdatePasswordRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UpdatePasswordRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__UpdatePasswordRequest(struct soap *soap, const char *tag, _ns1__UpdatePasswordRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UpdatePasswordRequest **)soap_malloc(soap, sizeof(_ns1__UpdatePasswordRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UpdatePasswordRequest *)soap_instantiate__ns1__UpdatePasswordRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__UpdatePasswordRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UpdatePasswordRequest, sizeof(_ns1__UpdatePasswordRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UpdatePasswordRequest(struct soap *soap, _ns1__UpdatePasswordRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__UpdatePasswordRequest(soap, tag?tag:"ns1:UpdatePasswordRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UpdatePasswordRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__UpdatePasswordRequest(struct soap *soap, _ns1__UpdatePasswordRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UpdatePasswordRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DeleteRoomRequest(struct soap *soap, _ns1__DeleteRoomRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__DeleteRoomRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DeleteRoomRequest(struct soap *soap, const char *tag, int id, _ns1__DeleteRoomRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__DeleteRoomRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__DeleteRoomRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__DeleteRoomRequest(struct soap *soap, const char *tag, _ns1__DeleteRoomRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__DeleteRoomRequest **)soap_malloc(soap, sizeof(_ns1__DeleteRoomRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__DeleteRoomRequest *)soap_instantiate__ns1__DeleteRoomRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__DeleteRoomRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DeleteRoomRequest, sizeof(_ns1__DeleteRoomRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DeleteRoomRequest(struct soap *soap, _ns1__DeleteRoomRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__DeleteRoomRequest(soap, tag?tag:"ns1:DeleteRoomRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__DeleteRoomRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__DeleteRoomRequest(struct soap *soap, _ns1__DeleteRoomRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DeleteRoomRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CreateRoomRequest(struct soap *soap, _ns1__CreateRoomRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CreateRoomRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CreateRoomRequest(struct soap *soap, const char *tag, int id, _ns1__CreateRoomRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CreateRoomRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__CreateRoomRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__CreateRoomRequest(struct soap *soap, const char *tag, _ns1__CreateRoomRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CreateRoomRequest **)soap_malloc(soap, sizeof(_ns1__CreateRoomRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CreateRoomRequest *)soap_instantiate__ns1__CreateRoomRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__CreateRoomRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CreateRoomRequest, sizeof(_ns1__CreateRoomRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CreateRoomRequest(struct soap *soap, _ns1__CreateRoomRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__CreateRoomRequest(soap, tag?tag:"ns1:CreateRoomRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__CreateRoomRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__CreateRoomRequest(struct soap *soap, _ns1__CreateRoomRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CreateRoomRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__RemoveRoomPINRequest(struct soap *soap, _ns1__RemoveRoomPINRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__RemoveRoomPINRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__RemoveRoomPINRequest(struct soap *soap, const char *tag, int id, _ns1__RemoveRoomPINRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__RemoveRoomPINRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__RemoveRoomPINRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__RemoveRoomPINRequest(struct soap *soap, const char *tag, _ns1__RemoveRoomPINRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__RemoveRoomPINRequest **)soap_malloc(soap, sizeof(_ns1__RemoveRoomPINRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__RemoveRoomPINRequest *)soap_instantiate__ns1__RemoveRoomPINRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__RemoveRoomPINRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__RemoveRoomPINRequest, sizeof(_ns1__RemoveRoomPINRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__RemoveRoomPINRequest(struct soap *soap, _ns1__RemoveRoomPINRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__RemoveRoomPINRequest(soap, tag?tag:"ns1:RemoveRoomPINRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__RemoveRoomPINRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__RemoveRoomPINRequest(struct soap *soap, _ns1__RemoveRoomPINRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__RemoveRoomPINRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CreateRoomPINRequest(struct soap *soap, _ns1__CreateRoomPINRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CreateRoomPINRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CreateRoomPINRequest(struct soap *soap, const char *tag, int id, _ns1__CreateRoomPINRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CreateRoomPINRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__CreateRoomPINRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__CreateRoomPINRequest(struct soap *soap, const char *tag, _ns1__CreateRoomPINRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CreateRoomPINRequest **)soap_malloc(soap, sizeof(_ns1__CreateRoomPINRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CreateRoomPINRequest *)soap_instantiate__ns1__CreateRoomPINRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__CreateRoomPINRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CreateRoomPINRequest, sizeof(_ns1__CreateRoomPINRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CreateRoomPINRequest(struct soap *soap, _ns1__CreateRoomPINRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__CreateRoomPINRequest(soap, tag?tag:"ns1:CreateRoomPINRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__CreateRoomPINRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__CreateRoomPINRequest(struct soap *soap, _ns1__CreateRoomPINRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CreateRoomPINRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__RemoveRoomURLRequest(struct soap *soap, _ns1__RemoveRoomURLRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__RemoveRoomURLRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__RemoveRoomURLRequest(struct soap *soap, const char *tag, int id, _ns1__RemoveRoomURLRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__RemoveRoomURLRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__RemoveRoomURLRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__RemoveRoomURLRequest(struct soap *soap, const char *tag, _ns1__RemoveRoomURLRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__RemoveRoomURLRequest **)soap_malloc(soap, sizeof(_ns1__RemoveRoomURLRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__RemoveRoomURLRequest *)soap_instantiate__ns1__RemoveRoomURLRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__RemoveRoomURLRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__RemoveRoomURLRequest, sizeof(_ns1__RemoveRoomURLRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__RemoveRoomURLRequest(struct soap *soap, _ns1__RemoveRoomURLRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__RemoveRoomURLRequest(soap, tag?tag:"ns1:RemoveRoomURLRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__RemoveRoomURLRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__RemoveRoomURLRequest(struct soap *soap, _ns1__RemoveRoomURLRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__RemoveRoomURLRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CreateRoomURLRequest(struct soap *soap, _ns1__CreateRoomURLRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CreateRoomURLRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CreateRoomURLRequest(struct soap *soap, const char *tag, int id, _ns1__CreateRoomURLRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CreateRoomURLRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__CreateRoomURLRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__CreateRoomURLRequest(struct soap *soap, const char *tag, _ns1__CreateRoomURLRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CreateRoomURLRequest **)soap_malloc(soap, sizeof(_ns1__CreateRoomURLRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CreateRoomURLRequest *)soap_instantiate__ns1__CreateRoomURLRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__CreateRoomURLRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CreateRoomURLRequest, sizeof(_ns1__CreateRoomURLRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CreateRoomURLRequest(struct soap *soap, _ns1__CreateRoomURLRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__CreateRoomURLRequest(soap, tag?tag:"ns1:CreateRoomURLRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__CreateRoomURLRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__CreateRoomURLRequest(struct soap *soap, _ns1__CreateRoomURLRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CreateRoomURLRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__MyAccountRequest(struct soap *soap, _ns1__MyAccountRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__MyAccountRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__MyAccountRequest(struct soap *soap, const char *tag, int id, _ns1__MyAccountRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__MyAccountRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__MyAccountRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__MyAccountRequest(struct soap *soap, const char *tag, _ns1__MyAccountRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__MyAccountRequest **)soap_malloc(soap, sizeof(_ns1__MyAccountRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__MyAccountRequest *)soap_instantiate__ns1__MyAccountRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__MyAccountRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__MyAccountRequest, sizeof(_ns1__MyAccountRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__MyAccountRequest(struct soap *soap, _ns1__MyAccountRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__MyAccountRequest(soap, tag?tag:"ns1:MyAccountRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__MyAccountRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__MyAccountRequest(struct soap *soap, _ns1__MyAccountRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__MyAccountRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__StopVideoRequest(struct soap *soap, _ns1__StopVideoRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__StopVideoRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__StopVideoRequest(struct soap *soap, const char *tag, int id, _ns1__StopVideoRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__StopVideoRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__StopVideoRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__StopVideoRequest(struct soap *soap, const char *tag, _ns1__StopVideoRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__StopVideoRequest **)soap_malloc(soap, sizeof(_ns1__StopVideoRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__StopVideoRequest *)soap_instantiate__ns1__StopVideoRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__StopVideoRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__StopVideoRequest, sizeof(_ns1__StopVideoRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__StopVideoRequest(struct soap *soap, _ns1__StopVideoRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__StopVideoRequest(soap, tag?tag:"ns1:StopVideoRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__StopVideoRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__StopVideoRequest(struct soap *soap, _ns1__StopVideoRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__StopVideoRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__StartVideoRequest(struct soap *soap, _ns1__StartVideoRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__StartVideoRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__StartVideoRequest(struct soap *soap, const char *tag, int id, _ns1__StartVideoRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__StartVideoRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__StartVideoRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__StartVideoRequest(struct soap *soap, const char *tag, _ns1__StartVideoRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__StartVideoRequest **)soap_malloc(soap, sizeof(_ns1__StartVideoRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__StartVideoRequest *)soap_instantiate__ns1__StartVideoRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__StartVideoRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__StartVideoRequest, sizeof(_ns1__StartVideoRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__StartVideoRequest(struct soap *soap, _ns1__StartVideoRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__StartVideoRequest(soap, tag?tag:"ns1:StartVideoRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__StartVideoRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__StartVideoRequest(struct soap *soap, _ns1__StartVideoRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__StartVideoRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UnmuteAudioRequest(struct soap *soap, _ns1__UnmuteAudioRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UnmuteAudioRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UnmuteAudioRequest(struct soap *soap, const char *tag, int id, _ns1__UnmuteAudioRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UnmuteAudioRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UnmuteAudioRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__UnmuteAudioRequest(struct soap *soap, const char *tag, _ns1__UnmuteAudioRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UnmuteAudioRequest **)soap_malloc(soap, sizeof(_ns1__UnmuteAudioRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UnmuteAudioRequest *)soap_instantiate__ns1__UnmuteAudioRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__UnmuteAudioRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UnmuteAudioRequest, sizeof(_ns1__UnmuteAudioRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UnmuteAudioRequest(struct soap *soap, _ns1__UnmuteAudioRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__UnmuteAudioRequest(soap, tag?tag:"ns1:UnmuteAudioRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UnmuteAudioRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__UnmuteAudioRequest(struct soap *soap, _ns1__UnmuteAudioRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UnmuteAudioRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__MuteAudioRequest(struct soap *soap, _ns1__MuteAudioRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__MuteAudioRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__MuteAudioRequest(struct soap *soap, const char *tag, int id, _ns1__MuteAudioRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__MuteAudioRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__MuteAudioRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__MuteAudioRequest(struct soap *soap, const char *tag, _ns1__MuteAudioRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__MuteAudioRequest **)soap_malloc(soap, sizeof(_ns1__MuteAudioRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__MuteAudioRequest *)soap_instantiate__ns1__MuteAudioRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__MuteAudioRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__MuteAudioRequest, sizeof(_ns1__MuteAudioRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__MuteAudioRequest(struct soap *soap, _ns1__MuteAudioRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__MuteAudioRequest(soap, tag?tag:"ns1:MuteAudioRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__MuteAudioRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__MuteAudioRequest(struct soap *soap, _ns1__MuteAudioRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__MuteAudioRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__LeaveConferenceRequest(struct soap *soap, _ns1__LeaveConferenceRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__LeaveConferenceRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__LeaveConferenceRequest(struct soap *soap, const char *tag, int id, _ns1__LeaveConferenceRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__LeaveConferenceRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__LeaveConferenceRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__LeaveConferenceRequest(struct soap *soap, const char *tag, _ns1__LeaveConferenceRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__LeaveConferenceRequest **)soap_malloc(soap, sizeof(_ns1__LeaveConferenceRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__LeaveConferenceRequest *)soap_instantiate__ns1__LeaveConferenceRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__LeaveConferenceRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__LeaveConferenceRequest, sizeof(_ns1__LeaveConferenceRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__LeaveConferenceRequest(struct soap *soap, _ns1__LeaveConferenceRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__LeaveConferenceRequest(soap, tag?tag:"ns1:LeaveConferenceRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__LeaveConferenceRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__LeaveConferenceRequest(struct soap *soap, _ns1__LeaveConferenceRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__LeaveConferenceRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetLectureModeParticipantsRequest(struct soap *soap, _ns1__GetLectureModeParticipantsRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetLectureModeParticipantsRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetLectureModeParticipantsRequest(struct soap *soap, const char *tag, int id, _ns1__GetLectureModeParticipantsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetLectureModeParticipantsRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetLectureModeParticipantsRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetLectureModeParticipantsRequest(struct soap *soap, const char *tag, _ns1__GetLectureModeParticipantsRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetLectureModeParticipantsRequest **)soap_malloc(soap, sizeof(_ns1__GetLectureModeParticipantsRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetLectureModeParticipantsRequest *)soap_instantiate__ns1__GetLectureModeParticipantsRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetLectureModeParticipantsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetLectureModeParticipantsRequest, sizeof(_ns1__GetLectureModeParticipantsRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetLectureModeParticipantsRequest(struct soap *soap, _ns1__GetLectureModeParticipantsRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetLectureModeParticipantsRequest(soap, tag?tag:"ns1:GetLectureModeParticipantsRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetLectureModeParticipantsRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetLectureModeParticipantsRequest(struct soap *soap, _ns1__GetLectureModeParticipantsRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetLectureModeParticipantsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetParticipantsRequest(struct soap *soap, _ns1__GetParticipantsRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetParticipantsRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetParticipantsRequest(struct soap *soap, const char *tag, int id, _ns1__GetParticipantsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetParticipantsRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetParticipantsRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetParticipantsRequest(struct soap *soap, const char *tag, _ns1__GetParticipantsRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetParticipantsRequest **)soap_malloc(soap, sizeof(_ns1__GetParticipantsRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetParticipantsRequest *)soap_instantiate__ns1__GetParticipantsRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetParticipantsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetParticipantsRequest, sizeof(_ns1__GetParticipantsRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetParticipantsRequest(struct soap *soap, _ns1__GetParticipantsRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetParticipantsRequest(soap, tag?tag:"ns1:GetParticipantsRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetParticipantsRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetParticipantsRequest(struct soap *soap, _ns1__GetParticipantsRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetParticipantsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DirectCallRequest(struct soap *soap, _ns1__DirectCallRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__DirectCallRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DirectCallRequest(struct soap *soap, const char *tag, int id, _ns1__DirectCallRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__DirectCallRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__DirectCallRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__DirectCallRequest(struct soap *soap, const char *tag, _ns1__DirectCallRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__DirectCallRequest **)soap_malloc(soap, sizeof(_ns1__DirectCallRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__DirectCallRequest *)soap_instantiate__ns1__DirectCallRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__DirectCallRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DirectCallRequest, sizeof(_ns1__DirectCallRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DirectCallRequest(struct soap *soap, _ns1__DirectCallRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__DirectCallRequest(soap, tag?tag:"ns1:DirectCallRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__DirectCallRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__DirectCallRequest(struct soap *soap, _ns1__DirectCallRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DirectCallRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__JoinIPCConferenceRequest(struct soap *soap, _ns1__JoinIPCConferenceRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__JoinIPCConferenceRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__JoinIPCConferenceRequest(struct soap *soap, const char *tag, int id, _ns1__JoinIPCConferenceRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__JoinIPCConferenceRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__JoinIPCConferenceRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__JoinIPCConferenceRequest(struct soap *soap, const char *tag, _ns1__JoinIPCConferenceRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__JoinIPCConferenceRequest **)soap_malloc(soap, sizeof(_ns1__JoinIPCConferenceRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__JoinIPCConferenceRequest *)soap_instantiate__ns1__JoinIPCConferenceRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__JoinIPCConferenceRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__JoinIPCConferenceRequest, sizeof(_ns1__JoinIPCConferenceRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__JoinIPCConferenceRequest(struct soap *soap, _ns1__JoinIPCConferenceRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__JoinIPCConferenceRequest(soap, tag?tag:"ns1:JoinIPCConferenceRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__JoinIPCConferenceRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__JoinIPCConferenceRequest(struct soap *soap, _ns1__JoinIPCConferenceRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__JoinIPCConferenceRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__JoinConferenceRequest(struct soap *soap, _ns1__JoinConferenceRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__JoinConferenceRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__JoinConferenceRequest(struct soap *soap, const char *tag, int id, _ns1__JoinConferenceRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__JoinConferenceRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__JoinConferenceRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__JoinConferenceRequest(struct soap *soap, const char *tag, _ns1__JoinConferenceRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__JoinConferenceRequest **)soap_malloc(soap, sizeof(_ns1__JoinConferenceRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__JoinConferenceRequest *)soap_instantiate__ns1__JoinConferenceRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__JoinConferenceRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__JoinConferenceRequest, sizeof(_ns1__JoinConferenceRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__JoinConferenceRequest(struct soap *soap, _ns1__JoinConferenceRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__JoinConferenceRequest(soap, tag?tag:"ns1:JoinConferenceRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__JoinConferenceRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__JoinConferenceRequest(struct soap *soap, _ns1__JoinConferenceRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__JoinConferenceRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CancelOutboundCallRequest(struct soap *soap, _ns1__CancelOutboundCallRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CancelOutboundCallRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CancelOutboundCallRequest(struct soap *soap, const char *tag, int id, _ns1__CancelOutboundCallRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CancelOutboundCallRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__CancelOutboundCallRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__CancelOutboundCallRequest(struct soap *soap, const char *tag, _ns1__CancelOutboundCallRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CancelOutboundCallRequest **)soap_malloc(soap, sizeof(_ns1__CancelOutboundCallRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CancelOutboundCallRequest *)soap_instantiate__ns1__CancelOutboundCallRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__CancelOutboundCallRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CancelOutboundCallRequest, sizeof(_ns1__CancelOutboundCallRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CancelOutboundCallRequest(struct soap *soap, _ns1__CancelOutboundCallRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__CancelOutboundCallRequest(soap, tag?tag:"ns1:CancelOutboundCallRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__CancelOutboundCallRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__CancelOutboundCallRequest(struct soap *soap, _ns1__CancelOutboundCallRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CancelOutboundCallRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InviteToConferenceRequest(struct soap *soap, _ns1__InviteToConferenceRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InviteToConferenceRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InviteToConferenceRequest(struct soap *soap, const char *tag, int id, _ns1__InviteToConferenceRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InviteToConferenceRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__InviteToConferenceRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__InviteToConferenceRequest(struct soap *soap, const char *tag, _ns1__InviteToConferenceRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InviteToConferenceRequest **)soap_malloc(soap, sizeof(_ns1__InviteToConferenceRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InviteToConferenceRequest *)soap_instantiate__ns1__InviteToConferenceRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__InviteToConferenceRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InviteToConferenceRequest, sizeof(_ns1__InviteToConferenceRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InviteToConferenceRequest(struct soap *soap, _ns1__InviteToConferenceRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__InviteToConferenceRequest(soap, tag?tag:"ns1:InviteToConferenceRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InviteToConferenceRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__InviteToConferenceRequest(struct soap *soap, _ns1__InviteToConferenceRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InviteToConferenceRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetEntityByEntityIDRequest(struct soap *soap, _ns1__GetEntityByEntityIDRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetEntityByEntityIDRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetEntityByEntityIDRequest(struct soap *soap, const char *tag, int id, _ns1__GetEntityByEntityIDRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetEntityByEntityIDRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetEntityByEntityIDRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetEntityByEntityIDRequest(struct soap *soap, const char *tag, _ns1__GetEntityByEntityIDRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetEntityByEntityIDRequest **)soap_malloc(soap, sizeof(_ns1__GetEntityByEntityIDRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetEntityByEntityIDRequest *)soap_instantiate__ns1__GetEntityByEntityIDRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetEntityByEntityIDRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetEntityByEntityIDRequest, sizeof(_ns1__GetEntityByEntityIDRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetEntityByEntityIDRequest(struct soap *soap, _ns1__GetEntityByEntityIDRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetEntityByEntityIDRequest(soap, tag?tag:"ns1:GetEntityByEntityIDRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetEntityByEntityIDRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetEntityByEntityIDRequest(struct soap *soap, _ns1__GetEntityByEntityIDRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetEntityByEntityIDRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SearchByEmailRequest(struct soap *soap, _ns1__SearchByEmailRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SearchByEmailRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SearchByEmailRequest(struct soap *soap, const char *tag, int id, _ns1__SearchByEmailRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SearchByEmailRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SearchByEmailRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__SearchByEmailRequest(struct soap *soap, const char *tag, _ns1__SearchByEmailRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SearchByEmailRequest **)soap_malloc(soap, sizeof(_ns1__SearchByEmailRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SearchByEmailRequest *)soap_instantiate__ns1__SearchByEmailRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SearchByEmailRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SearchByEmailRequest, sizeof(_ns1__SearchByEmailRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SearchByEmailRequest(struct soap *soap, _ns1__SearchByEmailRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SearchByEmailRequest(soap, tag?tag:"ns1:SearchByEmailRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SearchByEmailRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__SearchByEmailRequest(struct soap *soap, _ns1__SearchByEmailRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SearchByEmailRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SearchByEntityIDRequest(struct soap *soap, _ns1__SearchByEntityIDRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SearchByEntityIDRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SearchByEntityIDRequest(struct soap *soap, const char *tag, int id, _ns1__SearchByEntityIDRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SearchByEntityIDRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SearchByEntityIDRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__SearchByEntityIDRequest(struct soap *soap, const char *tag, _ns1__SearchByEntityIDRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SearchByEntityIDRequest **)soap_malloc(soap, sizeof(_ns1__SearchByEntityIDRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SearchByEntityIDRequest *)soap_instantiate__ns1__SearchByEntityIDRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SearchByEntityIDRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SearchByEntityIDRequest, sizeof(_ns1__SearchByEntityIDRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SearchByEntityIDRequest(struct soap *soap, _ns1__SearchByEntityIDRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SearchByEntityIDRequest(soap, tag?tag:"ns1:SearchByEntityIDRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SearchByEntityIDRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__SearchByEntityIDRequest(struct soap *soap, _ns1__SearchByEntityIDRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SearchByEntityIDRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SearchRequest(struct soap *soap, _ns1__SearchRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SearchRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SearchRequest(struct soap *soap, const char *tag, int id, _ns1__SearchRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SearchRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SearchRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__SearchRequest(struct soap *soap, const char *tag, _ns1__SearchRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SearchRequest **)soap_malloc(soap, sizeof(_ns1__SearchRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SearchRequest *)soap_instantiate__ns1__SearchRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SearchRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SearchRequest, sizeof(_ns1__SearchRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SearchRequest(struct soap *soap, _ns1__SearchRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SearchRequest(soap, tag?tag:"ns1:SearchRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SearchRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__SearchRequest(struct soap *soap, _ns1__SearchRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SearchRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__RemoveFromMyContactsRequest(struct soap *soap, _ns1__RemoveFromMyContactsRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__RemoveFromMyContactsRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__RemoveFromMyContactsRequest(struct soap *soap, const char *tag, int id, _ns1__RemoveFromMyContactsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__RemoveFromMyContactsRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__RemoveFromMyContactsRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__RemoveFromMyContactsRequest(struct soap *soap, const char *tag, _ns1__RemoveFromMyContactsRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__RemoveFromMyContactsRequest **)soap_malloc(soap, sizeof(_ns1__RemoveFromMyContactsRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__RemoveFromMyContactsRequest *)soap_instantiate__ns1__RemoveFromMyContactsRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__RemoveFromMyContactsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__RemoveFromMyContactsRequest, sizeof(_ns1__RemoveFromMyContactsRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__RemoveFromMyContactsRequest(struct soap *soap, _ns1__RemoveFromMyContactsRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__RemoveFromMyContactsRequest(soap, tag?tag:"ns1:RemoveFromMyContactsRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__RemoveFromMyContactsRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__RemoveFromMyContactsRequest(struct soap *soap, _ns1__RemoveFromMyContactsRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__RemoveFromMyContactsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__AddToMyContactsRequest(struct soap *soap, _ns1__AddToMyContactsRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__AddToMyContactsRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__AddToMyContactsRequest(struct soap *soap, const char *tag, int id, _ns1__AddToMyContactsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__AddToMyContactsRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__AddToMyContactsRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__AddToMyContactsRequest(struct soap *soap, const char *tag, _ns1__AddToMyContactsRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__AddToMyContactsRequest **)soap_malloc(soap, sizeof(_ns1__AddToMyContactsRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__AddToMyContactsRequest *)soap_instantiate__ns1__AddToMyContactsRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__AddToMyContactsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__AddToMyContactsRequest, sizeof(_ns1__AddToMyContactsRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__AddToMyContactsRequest(struct soap *soap, _ns1__AddToMyContactsRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__AddToMyContactsRequest(soap, tag?tag:"ns1:AddToMyContactsRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__AddToMyContactsRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__AddToMyContactsRequest(struct soap *soap, _ns1__AddToMyContactsRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__AddToMyContactsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SearchMyContactsRequest(struct soap *soap, _ns1__SearchMyContactsRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SearchMyContactsRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SearchMyContactsRequest(struct soap *soap, const char *tag, int id, _ns1__SearchMyContactsRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SearchMyContactsRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SearchMyContactsRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__SearchMyContactsRequest(struct soap *soap, const char *tag, _ns1__SearchMyContactsRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SearchMyContactsRequest **)soap_malloc(soap, sizeof(_ns1__SearchMyContactsRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SearchMyContactsRequest *)soap_instantiate__ns1__SearchMyContactsRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SearchMyContactsRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SearchMyContactsRequest, sizeof(_ns1__SearchMyContactsRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SearchMyContactsRequest(struct soap *soap, _ns1__SearchMyContactsRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SearchMyContactsRequest(soap, tag?tag:"ns1:SearchMyContactsRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SearchMyContactsRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__SearchMyContactsRequest(struct soap *soap, _ns1__SearchMyContactsRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SearchMyContactsRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__MyEndpointStatusRequest(struct soap *soap, _ns1__MyEndpointStatusRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__MyEndpointStatusRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__MyEndpointStatusRequest(struct soap *soap, const char *tag, int id, _ns1__MyEndpointStatusRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__MyEndpointStatusRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__MyEndpointStatusRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__MyEndpointStatusRequest(struct soap *soap, const char *tag, _ns1__MyEndpointStatusRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__MyEndpointStatusRequest **)soap_malloc(soap, sizeof(_ns1__MyEndpointStatusRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__MyEndpointStatusRequest *)soap_instantiate__ns1__MyEndpointStatusRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__MyEndpointStatusRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__MyEndpointStatusRequest, sizeof(_ns1__MyEndpointStatusRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__MyEndpointStatusRequest(struct soap *soap, _ns1__MyEndpointStatusRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__MyEndpointStatusRequest(soap, tag?tag:"ns1:MyEndpointStatusRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__MyEndpointStatusRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__MyEndpointStatusRequest(struct soap *soap, _ns1__MyEndpointStatusRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__MyEndpointStatusRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__LogOutRequest(struct soap *soap, _ns1__LogOutRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__LogOutRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__LogOutRequest(struct soap *soap, const char *tag, int id, _ns1__LogOutRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__LogOutRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__LogOutRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__LogOutRequest(struct soap *soap, const char *tag, _ns1__LogOutRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__LogOutRequest **)soap_malloc(soap, sizeof(_ns1__LogOutRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__LogOutRequest *)soap_instantiate__ns1__LogOutRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__LogOutRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__LogOutRequest, sizeof(_ns1__LogOutRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__LogOutRequest(struct soap *soap, _ns1__LogOutRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__LogOutRequest(soap, tag?tag:"ns1:LogOutRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__LogOutRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__LogOutRequest(struct soap *soap, _ns1__LogOutRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__LogOutRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__LinkEndpointRequest(struct soap *soap, _ns1__LinkEndpointRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__LinkEndpointRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__LinkEndpointRequest(struct soap *soap, const char *tag, int id, _ns1__LinkEndpointRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__LinkEndpointRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__LinkEndpointRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__LinkEndpointRequest(struct soap *soap, const char *tag, _ns1__LinkEndpointRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__LinkEndpointRequest **)soap_malloc(soap, sizeof(_ns1__LinkEndpointRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__LinkEndpointRequest *)soap_instantiate__ns1__LinkEndpointRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__LinkEndpointRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__LinkEndpointRequest, sizeof(_ns1__LinkEndpointRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__LinkEndpointRequest(struct soap *soap, _ns1__LinkEndpointRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__LinkEndpointRequest(soap, tag?tag:"ns1:LinkEndpointRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__LinkEndpointRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__LinkEndpointRequest(struct soap *soap, _ns1__LinkEndpointRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__LinkEndpointRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__LogInRequest(struct soap *soap, _ns1__LogInRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__LogInRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__LogInRequest(struct soap *soap, const char *tag, int id, _ns1__LogInRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__LogInRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__LogInRequest ** SOAP_FMAC4 soap_in_PointerTo_ns1__LogInRequest(struct soap *soap, const char *tag, _ns1__LogInRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__LogInRequest **)soap_malloc(soap, sizeof(_ns1__LogInRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__LogInRequest *)soap_instantiate__ns1__LogInRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__LogInRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__LogInRequest, sizeof(_ns1__LogInRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__LogInRequest(struct soap *soap, _ns1__LogInRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__LogInRequest(soap, tag?tag:"ns1:LogInRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__LogInRequest ** SOAP_FMAC4 soap_get_PointerTo_ns1__LogInRequest(struct soap *soap, _ns1__LogInRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__LogInRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__WrongPINFault(struct soap *soap, _ns1__WrongPINFault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__WrongPINFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__WrongPINFault(struct soap *soap, const char *tag, int id, _ns1__WrongPINFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__WrongPINFault, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__WrongPINFault ** SOAP_FMAC4 soap_in_PointerTo_ns1__WrongPINFault(struct soap *soap, const char *tag, _ns1__WrongPINFault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__WrongPINFault **)soap_malloc(soap, sizeof(_ns1__WrongPINFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__WrongPINFault *)soap_instantiate__ns1__WrongPINFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__WrongPINFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__WrongPINFault, sizeof(_ns1__WrongPINFault), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__WrongPINFault(struct soap *soap, _ns1__WrongPINFault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__WrongPINFault(soap, tag?tag:"ns1:WrongPINFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__WrongPINFault ** SOAP_FMAC4 soap_get_PointerTo_ns1__WrongPINFault(struct soap *soap, _ns1__WrongPINFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__WrongPINFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__VidyoReplayNotAvailableFault(struct soap *soap, _ns1__VidyoReplayNotAvailableFault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__VidyoReplayNotAvailableFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__VidyoReplayNotAvailableFault(struct soap *soap, const char *tag, int id, _ns1__VidyoReplayNotAvailableFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__VidyoReplayNotAvailableFault, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__VidyoReplayNotAvailableFault ** SOAP_FMAC4 soap_in_PointerTo_ns1__VidyoReplayNotAvailableFault(struct soap *soap, const char *tag, _ns1__VidyoReplayNotAvailableFault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__VidyoReplayNotAvailableFault **)soap_malloc(soap, sizeof(_ns1__VidyoReplayNotAvailableFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__VidyoReplayNotAvailableFault *)soap_instantiate__ns1__VidyoReplayNotAvailableFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__VidyoReplayNotAvailableFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__VidyoReplayNotAvailableFault, sizeof(_ns1__VidyoReplayNotAvailableFault), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__VidyoReplayNotAvailableFault(struct soap *soap, _ns1__VidyoReplayNotAvailableFault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__VidyoReplayNotAvailableFault(soap, tag?tag:"ns1:VidyoReplayNotAvailableFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__VidyoReplayNotAvailableFault ** SOAP_FMAC4 soap_get_PointerTo_ns1__VidyoReplayNotAvailableFault(struct soap *soap, _ns1__VidyoReplayNotAvailableFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__VidyoReplayNotAvailableFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SeatLicenseExpiredFault(struct soap *soap, _ns1__SeatLicenseExpiredFault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SeatLicenseExpiredFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SeatLicenseExpiredFault(struct soap *soap, const char *tag, int id, _ns1__SeatLicenseExpiredFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SeatLicenseExpiredFault, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SeatLicenseExpiredFault ** SOAP_FMAC4 soap_in_PointerTo_ns1__SeatLicenseExpiredFault(struct soap *soap, const char *tag, _ns1__SeatLicenseExpiredFault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SeatLicenseExpiredFault **)soap_malloc(soap, sizeof(_ns1__SeatLicenseExpiredFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SeatLicenseExpiredFault *)soap_instantiate__ns1__SeatLicenseExpiredFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SeatLicenseExpiredFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SeatLicenseExpiredFault, sizeof(_ns1__SeatLicenseExpiredFault), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SeatLicenseExpiredFault(struct soap *soap, _ns1__SeatLicenseExpiredFault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SeatLicenseExpiredFault(soap, tag?tag:"ns1:SeatLicenseExpiredFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SeatLicenseExpiredFault ** SOAP_FMAC4 soap_get_PointerTo_ns1__SeatLicenseExpiredFault(struct soap *soap, _ns1__SeatLicenseExpiredFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SeatLicenseExpiredFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ScheduledRoomCreationFault(struct soap *soap, _ns1__ScheduledRoomCreationFault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ScheduledRoomCreationFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ScheduledRoomCreationFault(struct soap *soap, const char *tag, int id, _ns1__ScheduledRoomCreationFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ScheduledRoomCreationFault, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__ScheduledRoomCreationFault ** SOAP_FMAC4 soap_in_PointerTo_ns1__ScheduledRoomCreationFault(struct soap *soap, const char *tag, _ns1__ScheduledRoomCreationFault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ScheduledRoomCreationFault **)soap_malloc(soap, sizeof(_ns1__ScheduledRoomCreationFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ScheduledRoomCreationFault *)soap_instantiate__ns1__ScheduledRoomCreationFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__ScheduledRoomCreationFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ScheduledRoomCreationFault, sizeof(_ns1__ScheduledRoomCreationFault), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ScheduledRoomCreationFault(struct soap *soap, _ns1__ScheduledRoomCreationFault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__ScheduledRoomCreationFault(soap, tag?tag:"ns1:ScheduledRoomCreationFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__ScheduledRoomCreationFault ** SOAP_FMAC4 soap_get_PointerTo_ns1__ScheduledRoomCreationFault(struct soap *soap, _ns1__ScheduledRoomCreationFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ScheduledRoomCreationFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__RoomNotFoundFault(struct soap *soap, _ns1__RoomNotFoundFault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__RoomNotFoundFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__RoomNotFoundFault(struct soap *soap, const char *tag, int id, _ns1__RoomNotFoundFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__RoomNotFoundFault, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__RoomNotFoundFault ** SOAP_FMAC4 soap_in_PointerTo_ns1__RoomNotFoundFault(struct soap *soap, const char *tag, _ns1__RoomNotFoundFault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__RoomNotFoundFault **)soap_malloc(soap, sizeof(_ns1__RoomNotFoundFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__RoomNotFoundFault *)soap_instantiate__ns1__RoomNotFoundFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__RoomNotFoundFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__RoomNotFoundFault, sizeof(_ns1__RoomNotFoundFault), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__RoomNotFoundFault(struct soap *soap, _ns1__RoomNotFoundFault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__RoomNotFoundFault(soap, tag?tag:"ns1:RoomNotFoundFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__RoomNotFoundFault ** SOAP_FMAC4 soap_get_PointerTo_ns1__RoomNotFoundFault(struct soap *soap, _ns1__RoomNotFoundFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__RoomNotFoundFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ResourceNotAvailableFault(struct soap *soap, _ns1__ResourceNotAvailableFault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ResourceNotAvailableFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ResourceNotAvailableFault(struct soap *soap, const char *tag, int id, _ns1__ResourceNotAvailableFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ResourceNotAvailableFault, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__ResourceNotAvailableFault ** SOAP_FMAC4 soap_in_PointerTo_ns1__ResourceNotAvailableFault(struct soap *soap, const char *tag, _ns1__ResourceNotAvailableFault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ResourceNotAvailableFault **)soap_malloc(soap, sizeof(_ns1__ResourceNotAvailableFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ResourceNotAvailableFault *)soap_instantiate__ns1__ResourceNotAvailableFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__ResourceNotAvailableFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ResourceNotAvailableFault, sizeof(_ns1__ResourceNotAvailableFault), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ResourceNotAvailableFault(struct soap *soap, _ns1__ResourceNotAvailableFault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__ResourceNotAvailableFault(soap, tag?tag:"ns1:ResourceNotAvailableFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__ResourceNotAvailableFault ** SOAP_FMAC4 soap_get_PointerTo_ns1__ResourceNotAvailableFault(struct soap *soap, _ns1__ResourceNotAvailableFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ResourceNotAvailableFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__PrefixNotConfiguredFault(struct soap *soap, _ns1__PrefixNotConfiguredFault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__PrefixNotConfiguredFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__PrefixNotConfiguredFault(struct soap *soap, const char *tag, int id, _ns1__PrefixNotConfiguredFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__PrefixNotConfiguredFault, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__PrefixNotConfiguredFault ** SOAP_FMAC4 soap_in_PointerTo_ns1__PrefixNotConfiguredFault(struct soap *soap, const char *tag, _ns1__PrefixNotConfiguredFault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__PrefixNotConfiguredFault **)soap_malloc(soap, sizeof(_ns1__PrefixNotConfiguredFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__PrefixNotConfiguredFault *)soap_instantiate__ns1__PrefixNotConfiguredFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__PrefixNotConfiguredFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__PrefixNotConfiguredFault, sizeof(_ns1__PrefixNotConfiguredFault), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__PrefixNotConfiguredFault(struct soap *soap, _ns1__PrefixNotConfiguredFault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__PrefixNotConfiguredFault(soap, tag?tag:"ns1:PrefixNotConfiguredFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__PrefixNotConfiguredFault ** SOAP_FMAC4 soap_get_PointerTo_ns1__PrefixNotConfiguredFault(struct soap *soap, _ns1__PrefixNotConfiguredFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__PrefixNotConfiguredFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__NotLicensedFault(struct soap *soap, _ns1__NotLicensedFault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__NotLicensedFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__NotLicensedFault(struct soap *soap, const char *tag, int id, _ns1__NotLicensedFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__NotLicensedFault, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__NotLicensedFault ** SOAP_FMAC4 soap_in_PointerTo_ns1__NotLicensedFault(struct soap *soap, const char *tag, _ns1__NotLicensedFault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__NotLicensedFault **)soap_malloc(soap, sizeof(_ns1__NotLicensedFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__NotLicensedFault *)soap_instantiate__ns1__NotLicensedFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__NotLicensedFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__NotLicensedFault, sizeof(_ns1__NotLicensedFault), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__NotLicensedFault(struct soap *soap, _ns1__NotLicensedFault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__NotLicensedFault(soap, tag?tag:"ns1:NotLicensedFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__NotLicensedFault ** SOAP_FMAC4 soap_get_PointerTo_ns1__NotLicensedFault(struct soap *soap, _ns1__NotLicensedFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__NotLicensedFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InvalidModeratorPINFormatFault(struct soap *soap, _ns1__InvalidModeratorPINFormatFault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InvalidModeratorPINFormatFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InvalidModeratorPINFormatFault(struct soap *soap, const char *tag, int id, _ns1__InvalidModeratorPINFormatFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InvalidModeratorPINFormatFault, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__InvalidModeratorPINFormatFault ** SOAP_FMAC4 soap_in_PointerTo_ns1__InvalidModeratorPINFormatFault(struct soap *soap, const char *tag, _ns1__InvalidModeratorPINFormatFault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InvalidModeratorPINFormatFault **)soap_malloc(soap, sizeof(_ns1__InvalidModeratorPINFormatFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InvalidModeratorPINFormatFault *)soap_instantiate__ns1__InvalidModeratorPINFormatFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__InvalidModeratorPINFormatFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InvalidModeratorPINFormatFault, sizeof(_ns1__InvalidModeratorPINFormatFault), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InvalidModeratorPINFormatFault(struct soap *soap, _ns1__InvalidModeratorPINFormatFault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__InvalidModeratorPINFormatFault(soap, tag?tag:"ns1:InvalidModeratorPINFormatFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InvalidModeratorPINFormatFault ** SOAP_FMAC4 soap_get_PointerTo_ns1__InvalidModeratorPINFormatFault(struct soap *soap, _ns1__InvalidModeratorPINFormatFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InvalidModeratorPINFormatFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InvalidArgumentFault(struct soap *soap, _ns1__InvalidArgumentFault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InvalidArgumentFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InvalidArgumentFault(struct soap *soap, const char *tag, int id, _ns1__InvalidArgumentFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InvalidArgumentFault, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__InvalidArgumentFault ** SOAP_FMAC4 soap_in_PointerTo_ns1__InvalidArgumentFault(struct soap *soap, const char *tag, _ns1__InvalidArgumentFault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InvalidArgumentFault **)soap_malloc(soap, sizeof(_ns1__InvalidArgumentFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InvalidArgumentFault *)soap_instantiate__ns1__InvalidArgumentFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__InvalidArgumentFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InvalidArgumentFault, sizeof(_ns1__InvalidArgumentFault), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InvalidArgumentFault(struct soap *soap, _ns1__InvalidArgumentFault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__InvalidArgumentFault(soap, tag?tag:"ns1:InvalidArgumentFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InvalidArgumentFault ** SOAP_FMAC4 soap_get_PointerTo_ns1__InvalidArgumentFault(struct soap *soap, _ns1__InvalidArgumentFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InvalidArgumentFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InPointToPointCallFault(struct soap *soap, _ns1__InPointToPointCallFault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InPointToPointCallFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InPointToPointCallFault(struct soap *soap, const char *tag, int id, _ns1__InPointToPointCallFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InPointToPointCallFault, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__InPointToPointCallFault ** SOAP_FMAC4 soap_in_PointerTo_ns1__InPointToPointCallFault(struct soap *soap, const char *tag, _ns1__InPointToPointCallFault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InPointToPointCallFault **)soap_malloc(soap, sizeof(_ns1__InPointToPointCallFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InPointToPointCallFault *)soap_instantiate__ns1__InPointToPointCallFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__InPointToPointCallFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InPointToPointCallFault, sizeof(_ns1__InPointToPointCallFault), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InPointToPointCallFault(struct soap *soap, _ns1__InPointToPointCallFault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__InPointToPointCallFault(soap, tag?tag:"ns1:InPointToPointCallFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InPointToPointCallFault ** SOAP_FMAC4 soap_get_PointerTo_ns1__InPointToPointCallFault(struct soap *soap, _ns1__InPointToPointCallFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InPointToPointCallFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GeneralFault(struct soap *soap, _ns1__GeneralFault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GeneralFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GeneralFault(struct soap *soap, const char *tag, int id, _ns1__GeneralFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GeneralFault, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GeneralFault ** SOAP_FMAC4 soap_in_PointerTo_ns1__GeneralFault(struct soap *soap, const char *tag, _ns1__GeneralFault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GeneralFault **)soap_malloc(soap, sizeof(_ns1__GeneralFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GeneralFault *)soap_instantiate__ns1__GeneralFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GeneralFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GeneralFault, sizeof(_ns1__GeneralFault), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GeneralFault(struct soap *soap, _ns1__GeneralFault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GeneralFault(soap, tag?tag:"ns1:GeneralFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GeneralFault ** SOAP_FMAC4 soap_get_PointerTo_ns1__GeneralFault(struct soap *soap, _ns1__GeneralFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GeneralFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__FeatureNotAvailableFault(struct soap *soap, _ns1__FeatureNotAvailableFault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__FeatureNotAvailableFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__FeatureNotAvailableFault(struct soap *soap, const char *tag, int id, _ns1__FeatureNotAvailableFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__FeatureNotAvailableFault, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__FeatureNotAvailableFault ** SOAP_FMAC4 soap_in_PointerTo_ns1__FeatureNotAvailableFault(struct soap *soap, const char *tag, _ns1__FeatureNotAvailableFault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__FeatureNotAvailableFault **)soap_malloc(soap, sizeof(_ns1__FeatureNotAvailableFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__FeatureNotAvailableFault *)soap_instantiate__ns1__FeatureNotAvailableFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__FeatureNotAvailableFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__FeatureNotAvailableFault, sizeof(_ns1__FeatureNotAvailableFault), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__FeatureNotAvailableFault(struct soap *soap, _ns1__FeatureNotAvailableFault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__FeatureNotAvailableFault(soap, tag?tag:"ns1:FeatureNotAvailableFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__FeatureNotAvailableFault ** SOAP_FMAC4 soap_get_PointerTo_ns1__FeatureNotAvailableFault(struct soap *soap, _ns1__FeatureNotAvailableFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__FeatureNotAvailableFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__EndpointNotBoundFault(struct soap *soap, _ns1__EndpointNotBoundFault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__EndpointNotBoundFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__EndpointNotBoundFault(struct soap *soap, const char *tag, int id, _ns1__EndpointNotBoundFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__EndpointNotBoundFault, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__EndpointNotBoundFault ** SOAP_FMAC4 soap_in_PointerTo_ns1__EndpointNotBoundFault(struct soap *soap, const char *tag, _ns1__EndpointNotBoundFault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__EndpointNotBoundFault **)soap_malloc(soap, sizeof(_ns1__EndpointNotBoundFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__EndpointNotBoundFault *)soap_instantiate__ns1__EndpointNotBoundFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__EndpointNotBoundFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__EndpointNotBoundFault, sizeof(_ns1__EndpointNotBoundFault), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__EndpointNotBoundFault(struct soap *soap, _ns1__EndpointNotBoundFault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__EndpointNotBoundFault(soap, tag?tag:"ns1:EndpointNotBoundFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__EndpointNotBoundFault ** SOAP_FMAC4 soap_get_PointerTo_ns1__EndpointNotBoundFault(struct soap *soap, _ns1__EndpointNotBoundFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__EndpointNotBoundFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ControlMeetingFault(struct soap *soap, _ns1__ControlMeetingFault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ControlMeetingFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ControlMeetingFault(struct soap *soap, const char *tag, int id, _ns1__ControlMeetingFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ControlMeetingFault, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__ControlMeetingFault ** SOAP_FMAC4 soap_in_PointerTo_ns1__ControlMeetingFault(struct soap *soap, const char *tag, _ns1__ControlMeetingFault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ControlMeetingFault **)soap_malloc(soap, sizeof(_ns1__ControlMeetingFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ControlMeetingFault *)soap_instantiate__ns1__ControlMeetingFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__ControlMeetingFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ControlMeetingFault, sizeof(_ns1__ControlMeetingFault), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ControlMeetingFault(struct soap *soap, _ns1__ControlMeetingFault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__ControlMeetingFault(soap, tag?tag:"ns1:ControlMeetingFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__ControlMeetingFault ** SOAP_FMAC4 soap_get_PointerTo_ns1__ControlMeetingFault(struct soap *soap, _ns1__ControlMeetingFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ControlMeetingFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ConferenceLockedFault(struct soap *soap, _ns1__ConferenceLockedFault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ConferenceLockedFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ConferenceLockedFault(struct soap *soap, const char *tag, int id, _ns1__ConferenceLockedFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ConferenceLockedFault, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__ConferenceLockedFault ** SOAP_FMAC4 soap_in_PointerTo_ns1__ConferenceLockedFault(struct soap *soap, const char *tag, _ns1__ConferenceLockedFault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ConferenceLockedFault **)soap_malloc(soap, sizeof(_ns1__ConferenceLockedFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ConferenceLockedFault *)soap_instantiate__ns1__ConferenceLockedFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__ConferenceLockedFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ConferenceLockedFault, sizeof(_ns1__ConferenceLockedFault), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ConferenceLockedFault(struct soap *soap, _ns1__ConferenceLockedFault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__ConferenceLockedFault(soap, tag?tag:"ns1:ConferenceLockedFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__ConferenceLockedFault ** SOAP_FMAC4 soap_get_PointerTo_ns1__ConferenceLockedFault(struct soap *soap, _ns1__ConferenceLockedFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ConferenceLockedFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__AccessRestrictedFault(struct soap *soap, _ns1__AccessRestrictedFault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__AccessRestrictedFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__AccessRestrictedFault(struct soap *soap, const char *tag, int id, _ns1__AccessRestrictedFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__AccessRestrictedFault, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__AccessRestrictedFault ** SOAP_FMAC4 soap_in_PointerTo_ns1__AccessRestrictedFault(struct soap *soap, const char *tag, _ns1__AccessRestrictedFault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__AccessRestrictedFault **)soap_malloc(soap, sizeof(_ns1__AccessRestrictedFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__AccessRestrictedFault *)soap_instantiate__ns1__AccessRestrictedFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__AccessRestrictedFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__AccessRestrictedFault, sizeof(_ns1__AccessRestrictedFault), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__AccessRestrictedFault(struct soap *soap, _ns1__AccessRestrictedFault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__AccessRestrictedFault(soap, tag?tag:"ns1:AccessRestrictedFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__AccessRestrictedFault ** SOAP_FMAC4 soap_get_PointerTo_ns1__AccessRestrictedFault(struct soap *soap, _ns1__AccessRestrictedFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__AccessRestrictedFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__WelcomeBannerContent(struct soap *soap, _ns1__WelcomeBannerContent *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__WelcomeBannerContent))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__WelcomeBannerContent(struct soap *soap, const char *tag, int id, _ns1__WelcomeBannerContent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__WelcomeBannerContent, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__WelcomeBannerContent ** SOAP_FMAC4 soap_in_PointerTo_ns1__WelcomeBannerContent(struct soap *soap, const char *tag, _ns1__WelcomeBannerContent **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__WelcomeBannerContent **)soap_malloc(soap, sizeof(_ns1__WelcomeBannerContent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__WelcomeBannerContent *)soap_instantiate__ns1__WelcomeBannerContent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__WelcomeBannerContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__WelcomeBannerContent, sizeof(_ns1__WelcomeBannerContent), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__WelcomeBannerContent(struct soap *soap, _ns1__WelcomeBannerContent *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__WelcomeBannerContent(soap, tag?tag:"ns1:WelcomeBannerContent", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__WelcomeBannerContent ** SOAP_FMAC4 soap_get_PointerTo_ns1__WelcomeBannerContent(struct soap *soap, _ns1__WelcomeBannerContent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__WelcomeBannerContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTo_ns1__RoomAccessOption(struct soap *soap, _ns1__RoomAccessOption **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTo_ns1__RoomAccessOption))
		soap_serialize_PointerTo_ns1__RoomAccessOption(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTo_ns1__RoomAccessOption(struct soap *soap, const char *tag, int id, _ns1__RoomAccessOption **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTo_ns1__RoomAccessOption, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTo_ns1__RoomAccessOption(soap, tag, id, *a, type);
}

SOAP_FMAC3 _ns1__RoomAccessOption *** SOAP_FMAC4 soap_in_PointerToPointerTo_ns1__RoomAccessOption(struct soap *soap, const char *tag, _ns1__RoomAccessOption ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__RoomAccessOption ***)soap_malloc(soap, sizeof(_ns1__RoomAccessOption **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTo_ns1__RoomAccessOption(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (_ns1__RoomAccessOption ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__RoomAccessOption, sizeof(_ns1__RoomAccessOption), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTo_ns1__RoomAccessOption(struct soap *soap, _ns1__RoomAccessOption **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTo_ns1__RoomAccessOption(soap, tag?tag:"ns1:RoomAccessOption", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__RoomAccessOption *** SOAP_FMAC4 soap_get_PointerToPointerTo_ns1__RoomAccessOption(struct soap *soap, _ns1__RoomAccessOption ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTo_ns1__RoomAccessOption(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__RoomAccessOption(struct soap *soap, _ns1__RoomAccessOption *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__RoomAccessOption))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__RoomAccessOption(struct soap *soap, const char *tag, int id, _ns1__RoomAccessOption *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__RoomAccessOption, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__RoomAccessOption ** SOAP_FMAC4 soap_in_PointerTo_ns1__RoomAccessOption(struct soap *soap, const char *tag, _ns1__RoomAccessOption **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__RoomAccessOption **)soap_malloc(soap, sizeof(_ns1__RoomAccessOption *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__RoomAccessOption *)soap_instantiate__ns1__RoomAccessOption(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__RoomAccessOption **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__RoomAccessOption, sizeof(_ns1__RoomAccessOption), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__RoomAccessOption(struct soap *soap, _ns1__RoomAccessOption *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__RoomAccessOption(soap, tag?tag:"ns1:RoomAccessOption", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__RoomAccessOption ** SOAP_FMAC4 soap_get_PointerTo_ns1__RoomAccessOption(struct soap *soap, _ns1__RoomAccessOption **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__RoomAccessOption(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTo_ns1__EndpointFeature(struct soap *soap, _ns1__EndpointFeature **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTo_ns1__EndpointFeature))
		soap_serialize_PointerTo_ns1__EndpointFeature(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTo_ns1__EndpointFeature(struct soap *soap, const char *tag, int id, _ns1__EndpointFeature **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTo_ns1__EndpointFeature, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTo_ns1__EndpointFeature(soap, tag, id, *a, type);
}

SOAP_FMAC3 _ns1__EndpointFeature *** SOAP_FMAC4 soap_in_PointerToPointerTo_ns1__EndpointFeature(struct soap *soap, const char *tag, _ns1__EndpointFeature ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__EndpointFeature ***)soap_malloc(soap, sizeof(_ns1__EndpointFeature **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTo_ns1__EndpointFeature(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (_ns1__EndpointFeature ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__EndpointFeature, sizeof(_ns1__EndpointFeature), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTo_ns1__EndpointFeature(struct soap *soap, _ns1__EndpointFeature **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTo_ns1__EndpointFeature(soap, tag?tag:"ns1:EndpointFeature", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__EndpointFeature *** SOAP_FMAC4 soap_get_PointerToPointerTo_ns1__EndpointFeature(struct soap *soap, _ns1__EndpointFeature ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTo_ns1__EndpointFeature(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__EndpointFeature(struct soap *soap, _ns1__EndpointFeature *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__EndpointFeature))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__EndpointFeature(struct soap *soap, const char *tag, int id, _ns1__EndpointFeature *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__EndpointFeature, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__EndpointFeature ** SOAP_FMAC4 soap_in_PointerTo_ns1__EndpointFeature(struct soap *soap, const char *tag, _ns1__EndpointFeature **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__EndpointFeature **)soap_malloc(soap, sizeof(_ns1__EndpointFeature *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__EndpointFeature *)soap_instantiate__ns1__EndpointFeature(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__EndpointFeature **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__EndpointFeature, sizeof(_ns1__EndpointFeature), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__EndpointFeature(struct soap *soap, _ns1__EndpointFeature *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__EndpointFeature(soap, tag?tag:"ns1:EndpointFeature", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__EndpointFeature ** SOAP_FMAC4 soap_get_PointerTo_ns1__EndpointFeature(struct soap *soap, _ns1__EndpointFeature **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__EndpointFeature(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTo_ns1__PortalFeature(struct soap *soap, _ns1__PortalFeature **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTo_ns1__PortalFeature))
		soap_serialize_PointerTo_ns1__PortalFeature(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTo_ns1__PortalFeature(struct soap *soap, const char *tag, int id, _ns1__PortalFeature **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTo_ns1__PortalFeature, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTo_ns1__PortalFeature(soap, tag, id, *a, type);
}

SOAP_FMAC3 _ns1__PortalFeature *** SOAP_FMAC4 soap_in_PointerToPointerTo_ns1__PortalFeature(struct soap *soap, const char *tag, _ns1__PortalFeature ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__PortalFeature ***)soap_malloc(soap, sizeof(_ns1__PortalFeature **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTo_ns1__PortalFeature(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (_ns1__PortalFeature ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__PortalFeature, sizeof(_ns1__PortalFeature), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTo_ns1__PortalFeature(struct soap *soap, _ns1__PortalFeature **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTo_ns1__PortalFeature(soap, tag?tag:"ns1:PortalFeature", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__PortalFeature *** SOAP_FMAC4 soap_get_PointerToPointerTo_ns1__PortalFeature(struct soap *soap, _ns1__PortalFeature ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTo_ns1__PortalFeature(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__PortalFeature(struct soap *soap, _ns1__PortalFeature *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__PortalFeature))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__PortalFeature(struct soap *soap, const char *tag, int id, _ns1__PortalFeature *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__PortalFeature, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__PortalFeature ** SOAP_FMAC4 soap_in_PointerTo_ns1__PortalFeature(struct soap *soap, const char *tag, _ns1__PortalFeature **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__PortalFeature **)soap_malloc(soap, sizeof(_ns1__PortalFeature *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__PortalFeature *)soap_instantiate__ns1__PortalFeature(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__PortalFeature **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__PortalFeature, sizeof(_ns1__PortalFeature), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__PortalFeature(struct soap *soap, _ns1__PortalFeature *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__PortalFeature(soap, tag?tag:"ns1:PortalFeature", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__PortalFeature ** SOAP_FMAC4 soap_get_PointerTo_ns1__PortalFeature(struct soap *soap, _ns1__PortalFeature **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__PortalFeature(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostring(soap, tag?tag:"string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__RoomProfile(struct soap *soap, ns1__RoomProfile **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__RoomProfile))
		soap_serialize_PointerTons1__RoomProfile(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__RoomProfile(struct soap *soap, const char *tag, int id, ns1__RoomProfile **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__RoomProfile, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__RoomProfile(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__RoomProfile *** SOAP_FMAC4 soap_in_PointerToPointerTons1__RoomProfile(struct soap *soap, const char *tag, ns1__RoomProfile ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__RoomProfile ***)soap_malloc(soap, sizeof(ns1__RoomProfile **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__RoomProfile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__RoomProfile ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RoomProfile, sizeof(ns1__RoomProfile), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__RoomProfile(struct soap *soap, ns1__RoomProfile **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons1__RoomProfile(soap, tag?tag:"ns1:RoomProfile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__RoomProfile *** SOAP_FMAC4 soap_get_PointerToPointerTons1__RoomProfile(struct soap *soap, ns1__RoomProfile ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__RoomProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RoomProfile(struct soap *soap, ns1__RoomProfile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RoomProfile))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RoomProfile(struct soap *soap, const char *tag, int id, ns1__RoomProfile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RoomProfile, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__RoomProfile ** SOAP_FMAC4 soap_in_PointerTons1__RoomProfile(struct soap *soap, const char *tag, ns1__RoomProfile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__RoomProfile **)soap_malloc(soap, sizeof(ns1__RoomProfile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__RoomProfile *)soap_instantiate_ns1__RoomProfile(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__RoomProfile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RoomProfile, sizeof(ns1__RoomProfile), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RoomProfile(struct soap *soap, ns1__RoomProfile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__RoomProfile(soap, tag?tag:"ns1:RoomProfile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__RoomProfile ** SOAP_FMAC4 soap_get_PointerTons1__RoomProfile(struct soap *soap, ns1__RoomProfile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RoomProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__Recorder(struct soap *soap, ns1__Recorder **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__Recorder))
		soap_serialize_PointerTons1__Recorder(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__Recorder(struct soap *soap, const char *tag, int id, ns1__Recorder **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__Recorder, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__Recorder(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__Recorder *** SOAP_FMAC4 soap_in_PointerToPointerTons1__Recorder(struct soap *soap, const char *tag, ns1__Recorder ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Recorder ***)soap_malloc(soap, sizeof(ns1__Recorder **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__Recorder(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__Recorder ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Recorder, sizeof(ns1__Recorder), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__Recorder(struct soap *soap, ns1__Recorder **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons1__Recorder(soap, tag?tag:"ns1:Recorder", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Recorder *** SOAP_FMAC4 soap_get_PointerToPointerTons1__Recorder(struct soap *soap, ns1__Recorder ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__Recorder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Recorder(struct soap *soap, ns1__Recorder *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Recorder))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Recorder(struct soap *soap, const char *tag, int id, ns1__Recorder *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Recorder, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Recorder ** SOAP_FMAC4 soap_in_PointerTons1__Recorder(struct soap *soap, const char *tag, ns1__Recorder **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Recorder **)soap_malloc(soap, sizeof(ns1__Recorder *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Recorder *)soap_instantiate_ns1__Recorder(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__Recorder **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Recorder, sizeof(ns1__Recorder), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Recorder(struct soap *soap, ns1__Recorder *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Recorder(soap, tag?tag:"ns1:Recorder", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Recorder ** SOAP_FMAC4 soap_get_PointerTons1__Recorder(struct soap *soap, ns1__Recorder **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Recorder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTo_ns1__LectureModeParticipant(struct soap *soap, _ns1__LectureModeParticipant **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTo_ns1__LectureModeParticipant))
		soap_serialize_PointerTo_ns1__LectureModeParticipant(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTo_ns1__LectureModeParticipant(struct soap *soap, const char *tag, int id, _ns1__LectureModeParticipant **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTo_ns1__LectureModeParticipant, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTo_ns1__LectureModeParticipant(soap, tag, id, *a, type);
}

SOAP_FMAC3 _ns1__LectureModeParticipant *** SOAP_FMAC4 soap_in_PointerToPointerTo_ns1__LectureModeParticipant(struct soap *soap, const char *tag, _ns1__LectureModeParticipant ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__LectureModeParticipant ***)soap_malloc(soap, sizeof(_ns1__LectureModeParticipant **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTo_ns1__LectureModeParticipant(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (_ns1__LectureModeParticipant ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__LectureModeParticipant, sizeof(_ns1__LectureModeParticipant), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTo_ns1__LectureModeParticipant(struct soap *soap, _ns1__LectureModeParticipant **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTo_ns1__LectureModeParticipant(soap, tag?tag:"ns1:LectureModeParticipant", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__LectureModeParticipant *** SOAP_FMAC4 soap_get_PointerToPointerTo_ns1__LectureModeParticipant(struct soap *soap, _ns1__LectureModeParticipant ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTo_ns1__LectureModeParticipant(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__LectureModeParticipant(struct soap *soap, _ns1__LectureModeParticipant *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__LectureModeParticipant))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__LectureModeParticipant(struct soap *soap, const char *tag, int id, _ns1__LectureModeParticipant *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__LectureModeParticipant, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__LectureModeParticipant ** SOAP_FMAC4 soap_in_PointerTo_ns1__LectureModeParticipant(struct soap *soap, const char *tag, _ns1__LectureModeParticipant **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__LectureModeParticipant **)soap_malloc(soap, sizeof(_ns1__LectureModeParticipant *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__LectureModeParticipant *)soap_instantiate__ns1__LectureModeParticipant(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__LectureModeParticipant **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__LectureModeParticipant, sizeof(_ns1__LectureModeParticipant), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__LectureModeParticipant(struct soap *soap, _ns1__LectureModeParticipant *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__LectureModeParticipant(soap, tag?tag:"ns1:LectureModeParticipant", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__LectureModeParticipant ** SOAP_FMAC4 soap_get_PointerTo_ns1__LectureModeParticipant(struct soap *soap, _ns1__LectureModeParticipant **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__LectureModeParticipant(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__EntityID(struct soap *soap, char **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__EntityID))
		soap_serialize_ns1__EntityID(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__EntityID(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__EntityID, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__EntityID(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTons1__EntityID(struct soap *soap, const char *tag, char ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__EntityID(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__EntityID, sizeof(char *), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__EntityID(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__EntityID(soap, tag?tag:"ns1:EntityID", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTons1__EntityID(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__EntityID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTo_ns1__Entity(struct soap *soap, _ns1__Entity **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTo_ns1__Entity))
		soap_serialize_PointerTo_ns1__Entity(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTo_ns1__Entity(struct soap *soap, const char *tag, int id, _ns1__Entity **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTo_ns1__Entity, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTo_ns1__Entity(soap, tag, id, *a, type);
}

SOAP_FMAC3 _ns1__Entity *** SOAP_FMAC4 soap_in_PointerToPointerTo_ns1__Entity(struct soap *soap, const char *tag, _ns1__Entity ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__Entity ***)soap_malloc(soap, sizeof(_ns1__Entity **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTo_ns1__Entity(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (_ns1__Entity ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__Entity, sizeof(_ns1__Entity), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTo_ns1__Entity(struct soap *soap, _ns1__Entity **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTo_ns1__Entity(soap, tag?tag:"ns1:Entity", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__Entity *** SOAP_FMAC4 soap_get_PointerToPointerTo_ns1__Entity(struct soap *soap, _ns1__Entity ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTo_ns1__Entity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__Filter(struct soap *soap, _ns1__Filter *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__Filter))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__Filter(struct soap *soap, const char *tag, int id, _ns1__Filter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__Filter, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__Filter ** SOAP_FMAC4 soap_in_PointerTo_ns1__Filter(struct soap *soap, const char *tag, _ns1__Filter **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__Filter **)soap_malloc(soap, sizeof(_ns1__Filter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__Filter *)soap_instantiate__ns1__Filter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__Filter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__Filter, sizeof(_ns1__Filter), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__Filter(struct soap *soap, _ns1__Filter *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__Filter(soap, tag?tag:"ns1:Filter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__Filter ** SOAP_FMAC4 soap_get_PointerTo_ns1__Filter(struct soap *soap, _ns1__Filter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__Filter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__Entity(struct soap *soap, _ns1__Entity *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__Entity))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__Entity(struct soap *soap, const char *tag, int id, _ns1__Entity *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__Entity, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__Entity ** SOAP_FMAC4 soap_in_PointerTo_ns1__Entity(struct soap *soap, const char *tag, _ns1__Entity **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__Entity **)soap_malloc(soap, sizeof(_ns1__Entity *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__Entity *)soap_instantiate__ns1__Entity(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__Entity **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__Entity, sizeof(_ns1__Entity), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__Entity(struct soap *soap, _ns1__Entity *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__Entity(soap, tag?tag:"ns1:Entity", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__Entity ** SOAP_FMAC4 soap_get_PointerTo_ns1__Entity(struct soap *soap, _ns1__Entity **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__Entity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ClientType(struct soap *soap, enum _ns1__ClientType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__ns1__ClientType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ClientType(struct soap *soap, const char *tag, int id, enum _ns1__ClientType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ClientType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__ClientType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum _ns1__ClientType ** SOAP_FMAC4 soap_in_PointerTo_ns1__ClientType(struct soap *soap, const char *tag, enum _ns1__ClientType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum _ns1__ClientType **)soap_malloc(soap, sizeof(enum _ns1__ClientType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__ClientType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum _ns1__ClientType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ClientType, sizeof(enum _ns1__ClientType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ClientType(struct soap *soap, enum _ns1__ClientType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__ClientType(soap, tag?tag:"ns1:ClientType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _ns1__ClientType ** SOAP_FMAC4 soap_get_PointerTo_ns1__ClientType(struct soap *soap, enum _ns1__ClientType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ClientType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodateTime(struct soap *soap, time_t *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_dateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodateTime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dateTime, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_dateTime(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTodateTime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_dateTime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dateTime, sizeof(time_t), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodateTime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTodateTime(soap, tag?tag:"dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTodateTime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTo_ns1__LoginAttempt(struct soap *soap, _ns1__LoginAttempt **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTo_ns1__LoginAttempt))
		soap_serialize_PointerTo_ns1__LoginAttempt(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTo_ns1__LoginAttempt(struct soap *soap, const char *tag, int id, _ns1__LoginAttempt **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTo_ns1__LoginAttempt, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTo_ns1__LoginAttempt(soap, tag, id, *a, type);
}

SOAP_FMAC3 _ns1__LoginAttempt *** SOAP_FMAC4 soap_in_PointerToPointerTo_ns1__LoginAttempt(struct soap *soap, const char *tag, _ns1__LoginAttempt ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__LoginAttempt ***)soap_malloc(soap, sizeof(_ns1__LoginAttempt **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTo_ns1__LoginAttempt(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (_ns1__LoginAttempt ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__LoginAttempt, sizeof(_ns1__LoginAttempt), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTo_ns1__LoginAttempt(struct soap *soap, _ns1__LoginAttempt **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTo_ns1__LoginAttempt(soap, tag?tag:"ns1:LoginAttempt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__LoginAttempt *** SOAP_FMAC4 soap_get_PointerToPointerTo_ns1__LoginAttempt(struct soap *soap, _ns1__LoginAttempt ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTo_ns1__LoginAttempt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__LoginAttempt(struct soap *soap, _ns1__LoginAttempt *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__LoginAttempt))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__LoginAttempt(struct soap *soap, const char *tag, int id, _ns1__LoginAttempt *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__LoginAttempt, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__LoginAttempt ** SOAP_FMAC4 soap_in_PointerTo_ns1__LoginAttempt(struct soap *soap, const char *tag, _ns1__LoginAttempt **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__LoginAttempt **)soap_malloc(soap, sizeof(_ns1__LoginAttempt *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__LoginAttempt *)soap_instantiate__ns1__LoginAttempt(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__LoginAttempt **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__LoginAttempt, sizeof(_ns1__LoginAttempt), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__LoginAttempt(struct soap *soap, _ns1__LoginAttempt *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__LoginAttempt(soap, tag?tag:"ns1:LoginAttempt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__LoginAttempt ** SOAP_FMAC4 soap_get_PointerTo_ns1__LoginAttempt(struct soap *soap, _ns1__LoginAttempt **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__LoginAttempt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__RoomMode(struct soap *soap, _ns1__RoomMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__RoomMode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__RoomMode(struct soap *soap, const char *tag, int id, _ns1__RoomMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__RoomMode, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__RoomMode ** SOAP_FMAC4 soap_in_PointerTo_ns1__RoomMode(struct soap *soap, const char *tag, _ns1__RoomMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__RoomMode **)soap_malloc(soap, sizeof(_ns1__RoomMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__RoomMode *)soap_instantiate__ns1__RoomMode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__RoomMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__RoomMode, sizeof(_ns1__RoomMode), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__RoomMode(struct soap *soap, _ns1__RoomMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__RoomMode(soap, tag?tag:"ns1:RoomMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__RoomMode ** SOAP_FMAC4 soap_get_PointerTo_ns1__RoomMode(struct soap *soap, _ns1__RoomMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__RoomMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__RoomStatus(struct soap *soap, enum _ns1__RoomStatus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__ns1__RoomStatus);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__RoomStatus(struct soap *soap, const char *tag, int id, enum _ns1__RoomStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__RoomStatus, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__RoomStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum _ns1__RoomStatus ** SOAP_FMAC4 soap_in_PointerTo_ns1__RoomStatus(struct soap *soap, const char *tag, enum _ns1__RoomStatus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum _ns1__RoomStatus **)soap_malloc(soap, sizeof(enum _ns1__RoomStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__RoomStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum _ns1__RoomStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__RoomStatus, sizeof(enum _ns1__RoomStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__RoomStatus(struct soap *soap, enum _ns1__RoomStatus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__RoomStatus(soap, tag?tag:"ns1:RoomStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _ns1__RoomStatus ** SOAP_FMAC4 soap_get_PointerTo_ns1__RoomStatus(struct soap *soap, enum _ns1__RoomStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__RoomStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__MemberMode(struct soap *soap, enum _ns1__MemberMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__ns1__MemberMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__MemberMode(struct soap *soap, const char *tag, int id, enum _ns1__MemberMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__MemberMode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__MemberMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum _ns1__MemberMode ** SOAP_FMAC4 soap_in_PointerTo_ns1__MemberMode(struct soap *soap, const char *tag, enum _ns1__MemberMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum _ns1__MemberMode **)soap_malloc(soap, sizeof(enum _ns1__MemberMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__MemberMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum _ns1__MemberMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__MemberMode, sizeof(enum _ns1__MemberMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__MemberMode(struct soap *soap, enum _ns1__MemberMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__MemberMode(soap, tag?tag:"ns1:MemberMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _ns1__MemberMode ** SOAP_FMAC4 soap_get_PointerTo_ns1__MemberMode(struct soap *soap, enum _ns1__MemberMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__MemberMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__MemberStatus(struct soap *soap, enum _ns1__MemberStatus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__ns1__MemberStatus);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__MemberStatus(struct soap *soap, const char *tag, int id, enum _ns1__MemberStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__MemberStatus, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__MemberStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum _ns1__MemberStatus ** SOAP_FMAC4 soap_in_PointerTo_ns1__MemberStatus(struct soap *soap, const char *tag, enum _ns1__MemberStatus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum _ns1__MemberStatus **)soap_malloc(soap, sizeof(enum _ns1__MemberStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__MemberStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum _ns1__MemberStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__MemberStatus, sizeof(enum _ns1__MemberStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__MemberStatus(struct soap *soap, enum _ns1__MemberStatus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__MemberStatus(soap, tag?tag:"ns1:MemberStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _ns1__MemberStatus ** SOAP_FMAC4 soap_get_PointerTo_ns1__MemberStatus(struct soap *soap, enum _ns1__MemberStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__MemberStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__Language(struct soap *soap, enum _ns1__Language *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__ns1__Language);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__Language(struct soap *soap, const char *tag, int id, enum _ns1__Language *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__Language, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__Language(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum _ns1__Language ** SOAP_FMAC4 soap_in_PointerTo_ns1__Language(struct soap *soap, const char *tag, enum _ns1__Language **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum _ns1__Language **)soap_malloc(soap, sizeof(enum _ns1__Language *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__Language(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum _ns1__Language **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__Language, sizeof(enum _ns1__Language), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__Language(struct soap *soap, enum _ns1__Language *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__Language(soap, tag?tag:"ns1:Language", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _ns1__Language ** SOAP_FMAC4 soap_get_PointerTo_ns1__Language(struct soap *soap, enum _ns1__Language **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__Language(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__EntityType(struct soap *soap, enum _ns1__EntityType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__ns1__EntityType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__EntityType(struct soap *soap, const char *tag, int id, enum _ns1__EntityType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__EntityType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__EntityType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum _ns1__EntityType ** SOAP_FMAC4 soap_in_PointerTo_ns1__EntityType(struct soap *soap, const char *tag, enum _ns1__EntityType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum _ns1__EntityType **)soap_malloc(soap, sizeof(enum _ns1__EntityType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__EntityType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum _ns1__EntityType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__EntityType, sizeof(enum _ns1__EntityType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__EntityType(struct soap *soap, enum _ns1__EntityType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__EntityType(soap, tag?tag:"ns1:EntityType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _ns1__EntityType ** SOAP_FMAC4 soap_get_PointerTo_ns1__EntityType(struct soap *soap, enum _ns1__EntityType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__EntityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__sortDir(struct soap *soap, enum ns1__sortDir *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_ns1__sortDir);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__sortDir(struct soap *soap, const char *tag, int id, enum ns1__sortDir *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__sortDir, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__sortDir(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__sortDir ** SOAP_FMAC4 soap_in_PointerTons1__sortDir(struct soap *soap, const char *tag, enum ns1__sortDir **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__sortDir **)soap_malloc(soap, sizeof(enum ns1__sortDir *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__sortDir(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__sortDir **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__sortDir, sizeof(enum ns1__sortDir), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__sortDir(struct soap *soap, enum ns1__sortDir *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__sortDir(soap, tag?tag:"ns1:sortDir", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__sortDir ** SOAP_FMAC4 soap_get_PointerTons1__sortDir(struct soap *soap, enum ns1__sortDir **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__sortDir(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToint(soap, tag?tag:"int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bool, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bool(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bool, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTobool(soap, tag?tag:"boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__EndpointFeatureName(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__EndpointFeatureName
	*a = SOAP_DEFAULT_ns1__EndpointFeatureName;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__EndpointFeatureName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_ns1__EndpointFeatureName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__EndpointFeatureName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns1__EndpointFeatureName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_ns1__EndpointFeatureName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_ns1__EndpointFeatureName, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__EndpointFeatureName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_ns1__EndpointFeatureName(soap, tag?tag:"ns1:EndpointFeatureName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns1__EndpointFeatureName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__EndpointFeatureName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__PortalFeatureName(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__PortalFeatureName
	*a = SOAP_DEFAULT_ns1__PortalFeatureName;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__PortalFeatureName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_ns1__PortalFeatureName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PortalFeatureName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns1__PortalFeatureName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_ns1__PortalFeatureName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_ns1__PortalFeatureName, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__PortalFeatureName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_ns1__PortalFeatureName(soap, tag?tag:"ns1:PortalFeatureName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns1__PortalFeatureName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PortalFeatureName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__EntityID(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__EntityID
	*a = SOAP_DEFAULT_ns1__EntityID;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__EntityID(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_ns1__EntityID);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__EntityID(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ns1__EntityID);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_ns1__EntityID(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_ns1__EntityID, 1, 0, -1, "[0-9]+");
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__EntityID(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_ns1__EntityID(soap, tag?tag:"ns1:EntityID", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_ns1__EntityID(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__EntityID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__anyURI(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_xsd__anyURI
	*a = SOAP_DEFAULT_xsd__anyURI;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anyURI(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_xsd__anyURI);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__anyURI);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__anyURI, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__anyURI(soap, tag?tag:"xsd:anyURI", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__QName
	*a = SOAP_DEFAULT__QName;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag?tag:"QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag?tag:"string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
